# 1 "<built-in>"
# 1 "ice.cpp"
#if 0 /* expanded by -frewrite-includes */
#include <algorithm>
#endif /* expanded by -frewrite-includes */
# 1 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 1 3
// algorithm standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#ifndef _ALGORITHM_
#define _ALGORITHM_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xmemory>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 1 3
// xmemory internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 3
#ifndef _XMEMORY_
#define _XMEMORY_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xmemory0>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 1 3
// xmemory0 internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
#ifndef _XMEMORY0_
#define _XMEMORY0_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <cstdint>	/* for uintptr_t */
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 1 3
// cstdint standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 3
#ifndef _CSTDINT_
#define _CSTDINT_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 1 3
// yvals.h internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#ifndef _YVALS
#define _YVALS
#ifndef RC_INVOKED

// _HAS_CXX17 directly controls:
// P0005R4 not_fn()
// P0024R2 Parallel Algorithms
//     (partially implemented)
// P0025R1 clamp()
// P0031R0 constexpr For <array> (Again) And <iterator>
// P0032R3 Homogeneous Interface For variant/any/optional
// P0040R3 Extending Memory Management Tools
// P0083R3 Splicing Maps And Sets
// P0084R2 Emplace Return Type
// P0088R3 <variant>
// P0152R1 atomic::is_always_lock_free
// P0154R1 hardware_destructive_interference_size, etc.
// P0156R2 scoped_lock
// P0163R0 shared_ptr::weak_type
// P0185R1 is_swappable, is_nothrow_swappable
// P0209R2 make_from_tuple()
// P0220R1 <any>, <memory_resource>, <optional>, <string_view>, apply(), sample(), Boyer-Moore search()
// P0253R1 Fixing Searcher Return Types
// P0254R2 Integrating string_view And std::string
// P0258R2 has_unique_object_representations
// P0272R1 Non-const basic_string::data()
// P0295R0 gcd(), lcm()
// P0307R2 Making Optional Greater Equal Again
// P0337R0 Deleting polymorphic_allocator Assignment
// P0358R1 Fixes For not_fn()
// P0393R3 Making Variant Greater Equal
// P0403R1 UDLs For <string_view> ("meow"sv, etc.)
// P0426R1 constexpr For char_traits
// P0433R2 Deduction Guides For The STL
// P0504R0 Revisiting in_place_t/in_place_type_t<T>/in_place_index_t<I>
// P0505R0 constexpr For <chrono> (Again)
// P0508R0 Clarifying insert_return_type
// P0510R0 Rejecting variants Of Nothing, Arrays, References, And Incomplete Types
// P0604R0 invoke_result, is_invocable, is_nothrow_invocable
// P0607R0 Inline Variables For The STL
// P0739R0 Improving Class Template Argument Deduction For The STL

// _HAS_CXX17 indirectly controls:
// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff
// P0003R5 Removing Dynamic Exception Specifications
// P0004R1 Removing Deprecated Iostreams Aliases
// P0298R3 std::byte
// P0302R1 Removing Allocator Support In std::function
// LWG 2385 function::assign allocator argument doesn't make sense
// LWG 2921 packaged_task and type-erased allocators
// LWG 2976 Dangling uses_allocator specialization for packaged_task
// The non-Standard std::tr1 namespace and TR1-only machinery
// The non-Standard std::identity struct
// The non-Standard std::tr2::sys namespace
// Enforcement of matching allocator value_types
// [[nodiscard]] attributes on STL functions

// _HAS_CXX17 and _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS control:
// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// P0618R0 Deprecating <codecvt>
// Other C++17 deprecation warnings

// Implemented unconditionally:
// N3911 void_t
// N4089 Safe Conversions In unique_ptr<T[]>
// N4169 invoke()
// N4258 noexcept Cleanups
// N4259 uncaught_exceptions()
// N4277 Trivially Copyable reference_wrapper
// N4279 insert_or_assign()/try_emplace() For map/unordered_map
// N4280 size(), empty(), data()
// N4366 Precisely Constraining unique_ptr Assignment
// N4387 Improving pair And tuple
// N4389 bool_constant
// N4508 shared_mutex (Untimed)
// N4510 Supporting Incomplete Types In vector/list/forward_list
// P0006R0 Variable Templates For Type Traits (is_same_v, etc.)
// P0007R1 as_const()
// P0013R1 Logical Operator Type Traits (conjunction, etc.)
// P0033R1 Rewording enable_shared_from_this
// P0063R3 C11 Standard Library
// P0074R0 owner_less<>
// P0092R1 <chrono> floor(), ceil(), round(), abs()
// P0414R2 shared_ptr<T[]>, shared_ptr<T[N]>
// P0418R2 atomic compare_exchange memory_order Requirements
// P0435R1 Overhauling common_type
// P0497R0 Fixing shared_ptr For Arrays
// P0513R0 Poisoning hash
// P0516R0 Marking shared_future Copying As noexcept
// P0517R0 Constructing future_error From future_errc
// P0548R1 Tweaking common_type And duration
// P0558R1 Resolving atomic<T> Named Base Class Inconsistencies
// P0599R1 noexcept hash

#ifndef _HAS_CXX17
 #ifdef _MSVC_LANG
  #if _MSVC_LANG > 201402
   #define _HAS_CXX17	1
  #else /* _MSVC_LANG > 201402 */
# 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _HAS_CXX17	0
  #endif /* _MSVC_LANG > 201402 */
# 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #else /* _MSVC_LANG */
# 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #if __cplusplus > 201402
   #define _HAS_CXX17	1
  #else /* __cplusplus > 201402 */
# 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _HAS_CXX17	0
  #endif /* __cplusplus > 201402 */
# 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif /* _MSVC_LANG */
# 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_CXX17 */
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <xkeycheck.h>	// _HAS_CXX17 must be defined before including this
#endif /* expanded by -frewrite-includes */
# 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 1 3
/* xkeycheck.h internal header */
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3
#ifndef _XKEYCHECK_H
#define _XKEYCHECK_H
#ifndef RC_INVOKED

#ifndef _ALLOW_KEYWORD_MACROS

 #if !defined(__cplusplus)

  #if defined(auto)	/* check C keywords */  \
	|| defined(break) \
	|| defined(case) \
	|| defined(char) \
	|| defined(const) \
	|| defined(continue) \
	|| defined(default) \
	|| defined(do) \
	|| defined(double) \
	|| defined(else) \
	|| defined(enum) \
	|| defined(extern) \
	|| defined(float) \
	|| defined(for) \
	|| defined(goto) \
	|| defined(if) \
	|| defined(inline) \
	|| defined(int) \
	|| defined(long) \
	|| defined(register) \
	|| defined(restrict) \
	|| defined(return) \
	|| defined(short) \
	|| defined(signed) \
	|| defined(sizeof) \
	|| defined(static) \
	|| defined(struct) \
	|| defined(switch) \
	|| defined(typedef) \
	|| defined(union) \
	|| defined(unsigned) \
	|| defined(void) \
	|| defined(volatile) \
	|| defined(while) \
	|| defined(_Bool) \
	|| defined(_Complex) \
	|| defined(_Imaginary)

   #define auto EMIT WARNING C4005
   #define break EMIT WARNING C4005
   #define case EMIT WARNING C4005
   #define char EMIT WARNING C4005
   #define const EMIT WARNING C4005
   #define continue EMIT WARNING C4005
   #define default EMIT WARNING C4005
   #define do EMIT WARNING C4005
   #define double EMIT WARNING C4005
   #define else EMIT WARNING C4005
   #define enum EMIT WARNING C4005
   #define extern EMIT WARNING C4005
   #define float EMIT WARNING C4005
   #define for EMIT WARNING C4005
   #define goto EMIT WARNING C4005
   #define if EMIT WARNING C4005
   #define inline EMIT WARNING C4005
   #define int EMIT WARNING C4005
   #define long EMIT WARNING C4005
   #define register EMIT WARNING C4005
   #define restrict EMIT WARNING C4005
   #define return EMIT WARNING C4005
   #define short EMIT WARNING C4005
   #define signed EMIT WARNING C4005
   #define sizeof EMIT WARNING C4005
   #define static EMIT WARNING C4005
   #define struct EMIT WARNING C4005
   #define switch EMIT WARNING C4005
   #define typedef EMIT WARNING C4005
   #define union EMIT WARNING C4005
   #define unsigned EMIT WARNING C4005
   #define void EMIT WARNING C4005
   #define volatile EMIT WARNING C4005
   #define while EMIT WARNING C4005
   #define _Bool EMIT WARNING C4005
   #define _Complex EMIT WARNING C4005
   #define _Imaginary EMIT WARNING C4005

   #error The C Standard Library forbids macroizing keywords. Enable warning C4005 to find the forbidden macro.
  #endif /* defined... */
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3

 #else /* __cplusplus is defined */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3

  #if defined(alignas)	/* check C++ keywords */ \
	|| defined(alignof) \
	|| defined(asm) \
	|| defined(auto) \
	|| defined(bool) \
	|| defined(break) \
	|| defined(case) \
	|| defined(catch) \
	|| defined(char) \
	|| defined(char16_t) \
	|| defined(char32_t) \
	|| defined(class) \
	|| defined(const) \
	|| defined(const_cast) \
	|| defined(constexpr) \
	|| defined(continue) \
	|| defined(decltype) \
	|| defined(default) \
	|| defined(delete) \
	|| defined(do) \
	|| defined(double) \
	|| defined(dynamic_cast) \
	|| defined(else) \
	|| defined(enum) \
	|| defined(explicit) \
	|| defined(export) \
	|| defined(extern) \
	|| defined(false) \
	|| defined(float) \
	|| defined(for) \
	|| defined(friend) \
	|| defined(goto) \
	|| defined(if) \
	|| defined(inline) \
	|| defined(int) \
	|| defined(long) \
	|| defined(mutable) \
	|| defined(namespace) \
	|| defined(new) && defined(_ENFORCE_BAN_OF_MACRO_NEW) \
	|| defined(noexcept) \
	|| defined(nullptr) \
	|| defined(operator) \
	|| defined(private) \
	|| defined(protected) \
	|| defined(public) \
	|| defined(register) \
	|| defined(reinterpret_cast) \
	|| defined(return) \
	|| defined(short) \
	|| defined(signed) \
	|| defined(sizeof) \
	|| defined(static) \
	|| defined(static_assert) \
	|| defined(static_cast) \
	|| defined(struct) \
	|| defined(switch) \
	|| defined(template) \
	|| defined(this) \
	|| defined(thread_local) \
	|| defined(throw) \
	|| defined(true) \
	|| defined(try) \
	|| defined(typedef) \
	|| defined(typeid) \
	|| defined(typename) \
	|| defined(union) \
	|| defined(unsigned) \
	|| defined(using) \
	|| defined(virtual) \
	|| defined(void) \
	|| defined(volatile) \
	|| defined(wchar_t) \
	|| defined(while) \
	|| defined(final)		/* check "identifiers with special meaning" */ \
	|| defined(override)	/* (also known as context-sensitive keywords) */ \
	|| defined(carries_dependency)	/* check attribute-tokens */ \
	|| defined(deprecated) && _HAS_CXX17 \
	|| defined(fallthrough) && _HAS_CXX17 \
	|| defined(maybe_unused) && _HAS_CXX17 \
	|| defined(nodiscard) && _HAS_CXX17 \
	|| defined(noreturn)

   #define alignas EMIT WARNING C4005
   #define alignof EMIT WARNING C4005
   #define asm EMIT WARNING C4005
   #define auto EMIT WARNING C4005
   #define bool EMIT WARNING C4005
   #define break EMIT WARNING C4005
   #define case EMIT WARNING C4005
   #define catch EMIT WARNING C4005
   #define char EMIT WARNING C4005
   #define char16_t EMIT WARNING C4005
   #define char32_t EMIT WARNING C4005
   #define class EMIT WARNING C4005
   #define const EMIT WARNING C4005
   #define const_cast EMIT WARNING C4005
   #define constexpr EMIT WARNING C4005
   #define continue EMIT WARNING C4005
   #define decltype EMIT WARNING C4005
   #define default EMIT WARNING C4005
   #define delete EMIT WARNING C4005
   #define do EMIT WARNING C4005
   #define double EMIT WARNING C4005
   #define dynamic_cast EMIT WARNING C4005
   #define else EMIT WARNING C4005
   #define enum EMIT WARNING C4005
   #define explicit EMIT WARNING C4005
   #define export EMIT WARNING C4005
   #define extern EMIT WARNING C4005
   #define false EMIT WARNING C4005
   #define float EMIT WARNING C4005
   #define for EMIT WARNING C4005
   #define friend EMIT WARNING C4005
   #define goto EMIT WARNING C4005
   #define if EMIT WARNING C4005
   #define inline EMIT WARNING C4005
   #define int EMIT WARNING C4005
   #define long EMIT WARNING C4005
   #define mutable EMIT WARNING C4005
   #define namespace EMIT WARNING C4005
   #ifdef _ENFORCE_BAN_OF_MACRO_NEW
    #define new EMIT WARNING C4005
   #endif /* _ENFORCE_BAN_OF_MACRO_NEW */
# 215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3
   #define noexcept EMIT WARNING C4005
   #define nullptr EMIT WARNING C4005
   #define operator EMIT WARNING C4005
   #define private EMIT WARNING C4005
   #define protected EMIT WARNING C4005
   #define public EMIT WARNING C4005
   #define register EMIT WARNING C4005
   #define reinterpret_cast EMIT WARNING C4005
   #define return EMIT WARNING C4005
   #define short EMIT WARNING C4005
   #define signed EMIT WARNING C4005
   #define sizeof EMIT WARNING C4005
   #define static EMIT WARNING C4005
   #define static_assert EMIT WARNING C4005
   #define static_cast EMIT WARNING C4005
   #define struct EMIT WARNING C4005
   #define switch EMIT WARNING C4005
   #define template EMIT WARNING C4005
   #define this EMIT WARNING C4005
   #define thread_local EMIT WARNING C4005
   #define throw EMIT WARNING C4005
   #define true EMIT WARNING C4005
   #define try EMIT WARNING C4005
   #define typedef EMIT WARNING C4005
   #define typeid EMIT WARNING C4005
   #define typename EMIT WARNING C4005
   #define union EMIT WARNING C4005
   #define unsigned EMIT WARNING C4005
   #define using EMIT WARNING C4005
   #define virtual EMIT WARNING C4005
   #define void EMIT WARNING C4005
   #define volatile EMIT WARNING C4005
   #define wchar_t EMIT WARNING C4005
   #define while EMIT WARNING C4005
   #define final EMIT WARNING C4005
   #define override EMIT WARNING C4005
   #define carries_dependency EMIT WARNING C4005
   #if _HAS_CXX17
    #define deprecated EMIT WARNING C4005
    #define fallthrough EMIT WARNING C4005
    #define maybe_unused EMIT WARNING C4005
    #define nodiscard EMIT WARNING C4005
   #endif /* _HAS_CXX17 */
# 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3
   #define noreturn EMIT WARNING C4005

   #error The C++ Standard Library forbids macroizing keywords. Enable warning C4005 to find the forbidden macro.
  #endif /* defined... */
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3
 #endif /* defined(__cplusplus) */
# 263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3

#endif /* _ALLOW_KEYWORD_MACROS */
# 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3

#endif /* RC_INVOKED */
# 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3
#endif /* _XKEYCHECK_H */
# 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xkeycheck.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <crtdefs.h>
#endif /* expanded by -frewrite-includes */
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 1 3
//
// crtdefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used across the Visual C++ Libraries.  The lack of #pragma once
// is deliberate.
//
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 1 3
/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indiates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*/

#define __ATTR_SAL

#ifndef _SAL_VERSION
#define _SAL_VERSION 20
#endif
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#ifndef __SAL_H_VERSION
#define __SAL_H_VERSION 180000000
#endif
# 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#ifdef _PREFAST_ // [

// choose attribute or __declspec implementation
#ifndef _USE_DECLSPECS_FOR_SAL // [
#define _USE_DECLSPECS_FOR_SAL 1
#endif // ]
# 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#if _USE_DECLSPECS_FOR_SAL // [
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#elif !defined(_USE_ATTRIBUTES_FOR_SAL) // ][
# 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define _USE_ATTRIBUTES_FOR_SAL 1
#endif // ]
# 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3


#if !_USE_DECLSPECS_FOR_SAL // [
#if !_USE_ATTRIBUTES_FOR_SAL // [
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 1
#endif // ]
# 176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#endif // ]
# 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#else
# 179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// Disable expansion of SAL macros in non-Prefast mode to
// improve compiler throughput.
#ifndef _USE_DECLSPECS_FOR_SAL // [
#define _USE_DECLSPECS_FOR_SAL 0
#endif // ]
# 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#ifndef _USE_ATTRIBUTES_FOR_SAL // [
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif // ]
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#endif // ]
# 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// safeguard for MIDL and RC builds
#if _USE_DECLSPECS_FOR_SAL && ( defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) || !defined(_PREFAST_) ) // [
#undef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL 0
#endif // ]
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#if _USE_ATTRIBUTES_FOR_SAL && ( !defined(_MSC_EXTENSIONS) || defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) ) // [
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif // ]
# 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#if _USE_DECLSPECS_FOR_SAL || _USE_ATTRIBUTES_FOR_SAL

// Special enum type for Y/N/M
enum __SAL_YesNo {_SAL_notpresent, _SAL_no, _SAL_maybe, _SAL_yes, _SAL_default};

#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#if defined(BUILD_WINDOWS) && !_USE_ATTRIBUTES_FOR_SAL
#define _SAL1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1") _GrouP_(annotes _SAL_nop_impl_)
#define _SAL1_1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.1") _GrouP_(annotes _SAL_nop_impl_)
#define _SAL1_2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.2") _GrouP_(annotes _SAL_nop_impl_)
#define _SAL2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _GrouP_(annotes _SAL_nop_impl_)

#ifndef _SAL_L_Source_
// Some annotations aren't officially SAL2 yet.
#define _SAL_L_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _GrouP_(annotes _SAL_nop_impl_)
#endif
# 218 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#else
# 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define _SAL1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1") _Group_(annotes _SAL_nop_impl_)
#define _SAL1_1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.1") _Group_(annotes _SAL_nop_impl_)
#define _SAL1_2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.2") _Group_(annotes _SAL_nop_impl_)
#define _SAL2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _Group_(annotes _SAL_nop_impl_)

#ifndef _SAL_L_Source_
// Some annotations aren't officially SAL2 yet.
#define _SAL_L_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _Group_(annotes _SAL_nop_impl_)
#endif
# 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#endif
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3


//============================================================================
//   Structural SAL:
//     These annotations modify the use of other annotations.  They may
//     express the annotation target (i.e. what parameter/field the annotation
//     applies to) or the condition under which the annotation is applicable.
//============================================================================

// _At_(target, annos) specifies that the annotations listed in 'annos' is to
// be applied to 'target' rather than to the identifier which is the current
// lexical target.
#define _At_(target, annos)            _At_impl_(target, annos _SAL_nop_impl_)

// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that
// target names a buffer, and each annotation in annos is applied to each
// element of target up to bound, with the variable named in iter usable
// by the annotations to refer to relevant offsets within target.
#define _At_buffer_(target, iter, bound, annos)  _At_buffer_impl_(target, iter, bound, annos _SAL_nop_impl_)

// _When_(expr, annos) specifies that the annotations listed in 'annos' only
// apply when 'expr' evaluates to non-zero.
#define _When_(expr, annos)            _When_impl_(expr, annos _SAL_nop_impl_)
#define _Group_(annos)                 _Group_impl_(annos _SAL_nop_impl_)
#define _GrouP_(annos)                 _GrouP_impl_(annos _SAL_nop_impl_)

// <expr> indicates whether normal post conditions apply to a function
#define _Success_(expr)                  _SAL2_Source_(_Success_, (expr), _Success_impl_(expr))

// <expr> indicates whether post conditions apply to a function returning
// the type that this annotation is applied to
#define _Return_type_success_(expr)      _SAL2_Source_(_Return_type_success_, (expr), _Success_impl_(expr))

// Establish postconditions that apply only if the function does not succeed
#define _On_failure_(annos)              _On_failure_impl_(annos _SAL_nop_impl_)

// Establish postconditions that apply in both success and failure cases.
// Only applicable with functions that have  _Success_ or _Return_type_succss_.
#define _Always_(annos)                  _Always_impl_(annos _SAL_nop_impl_)

// Usable on a function defintion. Asserts that a function declaration is
// in scope, and its annotations are to be used. There are no other annotations
// allowed on the function definition.
#define _Use_decl_annotations_         _Use_decl_anno_impl_

// _Notref_ may precede a _Deref_ or "real" annotation, and removes one
// level of dereference if the parameter is a C++ reference (&).  If the
// net deref on a "real" annotation is negative, it is simply discarded.
#define _Notref_                       _Notref_impl_

// Annotations for defensive programming styles.
#define _Pre_defensive_             _SA_annotes0(SAL_pre_defensive)
#define _Post_defensive_            _SA_annotes0(SAL_post_defensive)

#define _In_defensive_(annotes)     _Pre_defensive_ _Group_(annotes)
#define _Out_defensive_(annotes)    _Post_defensive_ _Group_(annotes)
#define _Inout_defensive_(annotes)  _Pre_defensive_ _Post_defensive_ _Group_(annotes)

//============================================================================
//   _In_/_Out_ Layer:
//============================================================================

// Reserved pointer parameters, must always be NULL.
#define _Reserved_                      _SAL2_Source_(_Reserved_, (), _Pre1_impl_(__null_impl))

// _Const_ allows specification that any namable memory location is considered
// readonly for a given call.
#define _Const_                         _SAL2_Source_(_Const_, (), _Pre1_impl_(__readaccess_impl_notref))


// Input parameters --------------------------

//   _In_ - Annotations for parameters where data is passed into the function, but not modified.
//          _In_ by itself can be used with non-pointer types (although it is redundant).

// e.g. void SetPoint( _In_ const POINT* pPT );
#define _In_                            _SAL2_Source_(_In_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_ _Deref_pre1_impl_(__readaccess_impl_notref))
#define _In_opt_                        _SAL2_Source_(_In_opt_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_ _Deref_pre_readonly_)

// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _In_z_                          _SAL2_Source_(_In_z_, (),     _In_     _Pre1_impl_(__zterm_impl))
#define _In_opt_z_                      _SAL2_Source_(_In_opt_z_, (), _In_opt_ _Pre1_impl_(__zterm_impl))


// 'input' buffers with given size

#define _In_reads_(size)               _SAL2_Source_(_In_reads_, (size), _Pre_count_(size)          _Deref_pre_readonly_)
#define _In_reads_opt_(size)           _SAL2_Source_(_In_reads_opt_, (size), _Pre_opt_count_(size)      _Deref_pre_readonly_)
#define _In_reads_bytes_(size)         _SAL2_Source_(_In_reads_bytes_, (size), _Pre_bytecount_(size)      _Deref_pre_readonly_)
#define _In_reads_bytes_opt_(size)     _SAL2_Source_(_In_reads_bytes_opt_, (size), _Pre_opt_bytecount_(size)  _Deref_pre_readonly_)
#define _In_reads_z_(size)             _SAL2_Source_(_In_reads_z_, (size), _In_reads_(size)     _Pre_z_)
#define _In_reads_opt_z_(size)         _SAL2_Source_(_In_reads_opt_z_, (size), _Pre_opt_count_(size)      _Deref_pre_readonly_     _Pre_opt_z_)
#define _In_reads_or_z_(size)          _SAL2_Source_(_In_reads_or_z_, (size), _In_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))
#define _In_reads_or_z_opt_(size)      _SAL2_Source_(_In_reads_or_z_opt_, (size), _In_opt_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))


// 'input' buffers valid to the given end pointer

#define _In_reads_to_ptr_(ptr)         _SAL2_Source_(_In_reads_to_ptr_, (ptr), _Pre_ptrdiff_count_(ptr)     _Deref_pre_readonly_)
#define _In_reads_to_ptr_opt_(ptr)     _SAL2_Source_(_In_reads_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_)
#define _In_reads_to_ptr_z_(ptr)       _SAL2_Source_(_In_reads_to_ptr_z_, (ptr), _In_reads_to_ptr_(ptr) _Pre_z_)
#define _In_reads_to_ptr_opt_z_(ptr)   _SAL2_Source_(_In_reads_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_  _Pre_opt_z_)



// Output parameters --------------------------

//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.
//           These are mostly used where the pointer/reference is to a non-pointer type.
//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.

// e.g. void GetPoint( _Out_ POINT* pPT );
#define _Out_                                  _SAL2_Source_(_Out_, (),     _Out_impl_)
#define _Out_opt_                              _SAL2_Source_(_Out_opt_, (), _Out_opt_impl_)

#define _Out_writes_(size)                     _SAL2_Source_(_Out_writes_, (size), _Pre_cap_(size)            _Post_valid_impl_)
#define _Out_writes_opt_(size)                 _SAL2_Source_(_Out_writes_opt_, (size), _Pre_opt_cap_(size)        _Post_valid_impl_)
#define _Out_writes_bytes_(size)               _SAL2_Source_(_Out_writes_bytes_, (size), _Pre_bytecap_(size)        _Post_valid_impl_)
#define _Out_writes_bytes_opt_(size)           _SAL2_Source_(_Out_writes_bytes_opt_, (size), _Pre_opt_bytecap_(size)    _Post_valid_impl_)
#define _Out_writes_z_(size)                   _SAL2_Source_(_Out_writes_z_, (size), _Pre_cap_(size)            _Post_valid_impl_ _Post_z_)
#define _Out_writes_opt_z_(size)               _SAL2_Source_(_Out_writes_opt_z_, (size), _Pre_opt_cap_(size)        _Post_valid_impl_ _Post_z_)

#define _Out_writes_to_(size,count)            _SAL2_Source_(_Out_writes_to_, (size,count), _Pre_cap_(size)            _Post_valid_impl_ _Post_count_(count))
#define _Out_writes_to_opt_(size,count)        _SAL2_Source_(_Out_writes_to_opt_, (size,count), _Pre_opt_cap_(size)        _Post_valid_impl_ _Post_count_(count))
#define _Out_writes_all_(size)                 _SAL2_Source_(_Out_writes_all_, (size), _Out_writes_to_(_Old_(size), _Old_(size)))
#define _Out_writes_all_opt_(size)             _SAL2_Source_(_Out_writes_all_opt_, (size), _Out_writes_to_opt_(_Old_(size), _Old_(size)))

#define _Out_writes_bytes_to_(size,count)      _SAL2_Source_(_Out_writes_bytes_to_, (size,count), _Pre_bytecap_(size)        _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_writes_bytes_to_opt_(size,count)  _SAL2_Source_(_Out_writes_bytes_to_opt_, (size,count), _Pre_opt_bytecap_(size) _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_writes_bytes_all_(size)           _SAL2_Source_(_Out_writes_bytes_all_, (size), _Out_writes_bytes_to_(_Old_(size), _Old_(size)))
#define _Out_writes_bytes_all_opt_(size)       _SAL2_Source_(_Out_writes_bytes_all_opt_, (size), _Out_writes_bytes_to_opt_(_Old_(size), _Old_(size)))

#define _Out_writes_to_ptr_(ptr)               _SAL2_Source_(_Out_writes_to_ptr_, (ptr), _Pre_ptrdiff_cap_(ptr)     _Post_valid_impl_)
#define _Out_writes_to_ptr_opt_(ptr)           _SAL2_Source_(_Out_writes_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_)
#define _Out_writes_to_ptr_z_(ptr)             _SAL2_Source_(_Out_writes_to_ptr_z_, (ptr), _Pre_ptrdiff_cap_(ptr)     _Post_valid_impl_ Post_z_)
#define _Out_writes_to_ptr_opt_z_(ptr)         _SAL2_Source_(_Out_writes_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_ Post_z_)


// Inout parameters ----------------------------

//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and
//        potentially modified.
//          void ModifyPoint( _Inout_ POINT* pPT );
//          void ModifyPointByRef( _Inout_ POINT& pPT );

#define _Inout_                                _SAL2_Source_(_Inout_, (), _Prepost_valid_)
#define _Inout_opt_                            _SAL2_Source_(_Inout_opt_, (), _Prepost_opt_valid_)

// For modifying string buffers
//   void toupper( _Inout_z_ char* sz );
#define _Inout_z_                              _SAL2_Source_(_Inout_z_, (), _Prepost_z_)
#define _Inout_opt_z_                          _SAL2_Source_(_Inout_opt_z_, (), _Prepost_opt_z_)

// For modifying buffers with explicit element size
#define _Inout_updates_(size)                  _SAL2_Source_(_Inout_updates_, (size), _Pre_cap_(size)         _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_opt_(size)              _SAL2_Source_(_Inout_updates_opt_, (size), _Pre_opt_cap_(size)     _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_z_(size)                _SAL2_Source_(_Inout_updates_z_, (size), _Pre_cap_(size)         _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))
#define _Inout_updates_opt_z_(size)            _SAL2_Source_(_Inout_updates_opt_z_, (size), _Pre_opt_cap_(size)     _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))

#define _Inout_updates_to_(size,count)         _SAL2_Source_(_Inout_updates_to_, (size,count), _Out_writes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))
#define _Inout_updates_to_opt_(size,count)     _SAL2_Source_(_Inout_updates_to_opt_, (size,count), _Out_writes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))

#define _Inout_updates_all_(size)              _SAL2_Source_(_Inout_updates_all_, (size), _Inout_updates_to_(_Old_(size), _Old_(size)))
#define _Inout_updates_all_opt_(size)          _SAL2_Source_(_Inout_updates_all_opt_, (size), _Inout_updates_to_opt_(_Old_(size), _Old_(size)))

// For modifying buffers with explicit byte size
#define _Inout_updates_bytes_(size)            _SAL2_Source_(_Inout_updates_bytes_, (size), _Pre_bytecap_(size)     _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_bytes_opt_(size)        _SAL2_Source_(_Inout_updates_bytes_opt_, (size), _Pre_opt_bytecap_(size) _Pre_valid_impl_ _Post_valid_impl_)

#define _Inout_updates_bytes_to_(size,count)       _SAL2_Source_(_Inout_updates_bytes_to_, (size,count), _Out_writes_bytes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))
#define _Inout_updates_bytes_to_opt_(size,count)   _SAL2_Source_(_Inout_updates_bytes_to_opt_, (size,count), _Out_writes_bytes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))

#define _Inout_updates_bytes_all_(size)        _SAL2_Source_(_Inout_updates_bytes_all_, (size), _Inout_updates_bytes_to_(_Old_(size), _Old_(size)))
#define _Inout_updates_bytes_all_opt_(size)    _SAL2_Source_(_Inout_updates_bytes_all_opt_, (size), _Inout_updates_bytes_to_opt_(_Old_(size), _Old_(size)))


// Pointer to pointer parameters -------------------------

//   _Outptr_ - Annotations for output params returning pointers
//      These describe parameters where the called function provides the buffer:
//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);
//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates
//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.
//
//    _Outptr_opt_ - describes parameters that are allowed to be NULL.
//    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.
//
//    Example:
//       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);
//    Callers:
//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL
//       MyFunc(&pData1, &pData2);     // ok: both non-NULL
//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call

#define _Outptr_                         _SAL2_Source_(_Outptr_, (),                      _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref,   __count_impl(1)))
#define _Outptr_result_maybenull_        _SAL2_Source_(_Outptr_result_maybenull_, (),     _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))
#define _Outptr_opt_                     _SAL2_Source_(_Outptr_opt_, (),                  _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref,   __count_impl(1)))
#define _Outptr_opt_result_maybenull_    _SAL2_Source_(_Outptr_opt_result_maybenull_, (), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))

// Annotations for _Outptr_ parameters returning pointers to null terminated strings.

#define _Outptr_result_z_                _SAL2_Source_(_Outptr_result_z_, (),               _Out_impl_     _Deref_post_z_)
#define _Outptr_opt_result_z_            _SAL2_Source_(_Outptr_opt_result_z_, (),           _Out_opt_impl_ _Deref_post_z_)
#define _Outptr_result_maybenull_z_      _SAL2_Source_(_Outptr_result_maybenull_z_, (),     _Out_impl_     _Deref_post_opt_z_)
#define _Outptr_opt_result_maybenull_z_  _SAL2_Source_(_Outptr_opt_result_maybenull_z_, (), _Out_opt_impl_ _Deref_post_opt_z_)

// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.

#define _Outptr_result_nullonfailure_       _SAL2_Source_(_Outptr_result_nullonfailure_, (),     _Outptr_      _On_failure_(_Deref_post_null_))
#define _Outptr_opt_result_nullonfailure_   _SAL2_Source_(_Outptr_opt_result_nullonfailure_, (), _Outptr_opt_  _On_failure_(_Deref_post_null_))

// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,
// following the COM convention of setting the output to NULL on failure.
// The current implementation is identical to _Outptr_result_nullonfailure_.
// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.

#define _COM_Outptr_                        _SAL2_Source_(_COM_Outptr_, (),                      _Outptr_                      _On_failure_(_Deref_post_null_))
#define _COM_Outptr_result_maybenull_       _SAL2_Source_(_COM_Outptr_result_maybenull_, (),     _Outptr_result_maybenull_     _On_failure_(_Deref_post_null_))
#define _COM_Outptr_opt_                    _SAL2_Source_(_COM_Outptr_opt_, (),                  _Outptr_opt_                  _On_failure_(_Deref_post_null_))
#define _COM_Outptr_opt_result_maybenull_   _SAL2_Source_(_COM_Outptr_opt_result_maybenull_, (), _Outptr_opt_result_maybenull_ _On_failure_(_Deref_post_null_))

// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes

#define _Outptr_result_buffer_(size)                      _SAL2_Source_(_Outptr_result_buffer_, (size),               _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))
#define _Outptr_opt_result_buffer_(size)                  _SAL2_Source_(_Outptr_opt_result_buffer_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))
#define _Outptr_result_buffer_to_(size, count)            _SAL2_Source_(_Outptr_result_buffer_to_, (size, count),     _Out_impl_     _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))
#define _Outptr_opt_result_buffer_to_(size, count)        _SAL2_Source_(_Outptr_opt_result_buffer_to_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))

#define _Outptr_result_buffer_all_(size)                  _SAL2_Source_(_Outptr_result_buffer_all_, (size),           _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))
#define _Outptr_opt_result_buffer_all_(size)              _SAL2_Source_(_Outptr_opt_result_buffer_all_, (size),       _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))

#define _Outptr_result_buffer_maybenull_(size)               _SAL2_Source_(_Outptr_result_buffer_maybenull_, (size),               _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))
#define _Outptr_opt_result_buffer_maybenull_(size)           _SAL2_Source_(_Outptr_opt_result_buffer_maybenull_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))
#define _Outptr_result_buffer_to_maybenull_(size, count)     _SAL2_Source_(_Outptr_result_buffer_to_maybenull_, (size, count),     _Out_impl_     _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))
#define _Outptr_opt_result_buffer_to_maybenull_(size, count) _SAL2_Source_(_Outptr_opt_result_buffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))

#define _Outptr_result_buffer_all_maybenull_(size)           _SAL2_Source_(_Outptr_result_buffer_all_maybenull_, (size),           _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))
#define _Outptr_opt_result_buffer_all_maybenull_(size)       _SAL2_Source_(_Outptr_opt_result_buffer_all_maybenull_, (size),       _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))

#define _Outptr_result_bytebuffer_(size)                     _SAL2_Source_(_Outptr_result_bytebuffer_, (size),                     _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))
#define _Outptr_opt_result_bytebuffer_(size)                 _SAL2_Source_(_Outptr_opt_result_bytebuffer_, (size),                 _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))
#define _Outptr_result_bytebuffer_to_(size, count)           _SAL2_Source_(_Outptr_result_bytebuffer_to_, (size, count),           _Out_impl_     _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))
#define _Outptr_opt_result_bytebuffer_to_(size, count)       _SAL2_Source_(_Outptr_opt_result_bytebuffer_to_, (size, count),       _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))

#define _Outptr_result_bytebuffer_all_(size)                 _SAL2_Source_(_Outptr_result_bytebuffer_all_, (size),                 _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))
#define _Outptr_opt_result_bytebuffer_all_(size)             _SAL2_Source_(_Outptr_opt_result_bytebuffer_all_, (size),             _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))

#define _Outptr_result_bytebuffer_maybenull_(size)                 _SAL2_Source_(_Outptr_result_bytebuffer_maybenull_, (size),               _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))
#define _Outptr_opt_result_bytebuffer_maybenull_(size)             _SAL2_Source_(_Outptr_opt_result_bytebuffer_maybenull_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))
#define _Outptr_result_bytebuffer_to_maybenull_(size, count)       _SAL2_Source_(_Outptr_result_bytebuffer_to_maybenull_, (size, count),     _Out_impl_     _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))
#define _Outptr_opt_result_bytebuffer_to_maybenull_(size, count)   _SAL2_Source_(_Outptr_opt_result_bytebuffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))

#define _Outptr_result_bytebuffer_all_maybenull_(size)         _SAL2_Source_(_Outptr_result_bytebuffer_all_maybenull_, (size),               _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))
#define _Outptr_opt_result_bytebuffer_all_maybenull_(size)     _SAL2_Source_(_Outptr_opt_result_bytebuffer_all_maybenull_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))

// Annotations for output reference to pointer parameters.

#define _Outref_                                               _SAL2_Source_(_Outref_, (),                  _Out_impl_ _Post_notnull_)
#define _Outref_result_maybenull_                              _SAL2_Source_(_Outref_result_maybenull_, (), _Pre2_impl_(__notnull_impl_notref, __cap_c_one_notref_impl) _Post_maybenull_ _Post_valid_impl_)

#define _Outref_result_buffer_(size)                           _SAL2_Source_(_Outref_result_buffer_, (size),                         _Outref_ _Post1_impl_(__cap_impl(size)))
#define _Outref_result_bytebuffer_(size)                       _SAL2_Source_(_Outref_result_bytebuffer_, (size),                     _Outref_ _Post1_impl_(__bytecap_impl(size)))
#define _Outref_result_buffer_to_(size, count)                 _SAL2_Source_(_Outref_result_buffer_to_, (size, count),               _Outref_result_buffer_(size) _Post1_impl_(__count_impl(count)))
#define _Outref_result_bytebuffer_to_(size, count)             _SAL2_Source_(_Outref_result_bytebuffer_to_, (size, count),           _Outref_result_bytebuffer_(size) _Post1_impl_(__bytecount_impl(count)))
#define _Outref_result_buffer_all_(size)                       _SAL2_Source_(_Outref_result_buffer_all_, (size),                     _Outref_result_buffer_to_(size, _Old_(size)))
#define _Outref_result_bytebuffer_all_(size)                   _SAL2_Source_(_Outref_result_bytebuffer_all_, (size),                 _Outref_result_bytebuffer_to_(size, _Old_(size)))

#define _Outref_result_buffer_maybenull_(size)                 _SAL2_Source_(_Outref_result_buffer_maybenull_, (size),               _Outref_result_maybenull_ _Post1_impl_(__cap_impl(size)))
#define _Outref_result_bytebuffer_maybenull_(size)             _SAL2_Source_(_Outref_result_bytebuffer_maybenull_, (size),           _Outref_result_maybenull_ _Post1_impl_(__bytecap_impl(size)))
#define _Outref_result_buffer_to_maybenull_(size, count)       _SAL2_Source_(_Outref_result_buffer_to_maybenull_, (size, count),     _Outref_result_buffer_maybenull_(size) _Post1_impl_(__count_impl(count)))
#define _Outref_result_bytebuffer_to_maybenull_(size, count)   _SAL2_Source_(_Outref_result_bytebuffer_to_maybenull_, (size, count), _Outref_result_bytebuffer_maybenull_(size) _Post1_impl_(__bytecount_impl(count)))
#define _Outref_result_buffer_all_maybenull_(size)             _SAL2_Source_(_Outref_result_buffer_all_maybenull_, (size),           _Outref_result_buffer_to_maybenull_(size, _Old_(size)))
#define _Outref_result_bytebuffer_all_maybenull_(size)         _SAL2_Source_(_Outref_result_bytebuffer_all_maybenull_, (size),       _Outref_result_bytebuffer_to_maybenull_(size, _Old_(size)))

// Annotations for output reference to pointer parameters that guarantee
// that the pointer is set to NULL on failure.
#define _Outref_result_nullonfailure_                          _SAL2_Source_(_Outref_result_nullonfailure_, (), _Outref_    _On_failure_(_Post_null_))

// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.
#define _Result_nullonfailure_                                 _SAL2_Source_(_Result_nullonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Post_null_))
#define _Result_zeroonfailure_                                 _SAL2_Source_(_Result_zeroonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Out_range_(==, 0)))


// return values -------------------------------

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const throw();
#define _Ret_z_                             _SAL2_Source_(_Ret_z_, (), _Ret2_impl_(__notnull_impl,  __zterm_impl) _Ret_valid_impl_)
#define _Ret_maybenull_z_                   _SAL2_Source_(_Ret_maybenull_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)

// used with allocated but not yet initialized objects
#define _Ret_notnull_                       _SAL2_Source_(_Ret_notnull_, (), _Ret1_impl_(__notnull_impl))
#define _Ret_maybenull_                     _SAL2_Source_(_Ret_maybenull_, (), _Ret1_impl_(__maybenull_impl))
#define _Ret_null_                          _SAL2_Source_(_Ret_null_, (), _Ret1_impl_(__null_impl))

// used with allocated and initialized objects
//    returns single valid object
#define _Ret_valid_                         _SAL2_Source_(_Ret_valid_, (), _Ret1_impl_(__notnull_impl_notref)   _Ret_valid_impl_)

//    returns pointer to initialized buffer of specified size
#define _Ret_writes_(size)                  _SAL2_Source_(_Ret_writes_, (size), _Ret2_impl_(__notnull_impl,  __count_impl(size))          _Ret_valid_impl_)
#define _Ret_writes_z_(size)                _SAL2_Source_(_Ret_writes_z_, (size), _Ret3_impl_(__notnull_impl,  __count_impl(size), __zterm_impl) _Ret_valid_impl_)
#define _Ret_writes_bytes_(size)            _SAL2_Source_(_Ret_writes_bytes_, (size), _Ret2_impl_(__notnull_impl,  __bytecount_impl(size))      _Ret_valid_impl_)
#define _Ret_writes_maybenull_(size)        _SAL2_Source_(_Ret_writes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__count_impl(size))          _Ret_valid_impl_)
#define _Ret_writes_maybenull_z_(size)      _SAL2_Source_(_Ret_writes_maybenull_z_, (size), _Ret3_impl_(__maybenull_impl,__count_impl(size),__zterm_impl)  _Ret_valid_impl_)
#define _Ret_writes_bytes_maybenull_(size)  _SAL2_Source_(_Ret_writes_bytes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__bytecount_impl(size))      _Ret_valid_impl_)

//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'
#define _Ret_writes_to_(size,count)                   _SAL2_Source_(_Ret_writes_to_, (size,count), _Ret3_impl_(__notnull_impl,  __cap_impl(size),     __count_impl(count))     _Ret_valid_impl_)
#define _Ret_writes_bytes_to_(size,count)             _SAL2_Source_(_Ret_writes_bytes_to_, (size,count), _Ret3_impl_(__notnull_impl,  __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)
#define _Ret_writes_to_maybenull_(size,count)         _SAL2_Source_(_Ret_writes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl,  __cap_impl(size),     __count_impl(count))     _Ret_valid_impl_)
#define _Ret_writes_bytes_to_maybenull_(size,count)   _SAL2_Source_(_Ret_writes_bytes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl,  __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)


// Annotations for strict type checking
#define _Points_to_data_        _SAL2_Source_(_Points_to_data_, (), _Pre_ _Points_to_data_impl_)
#define _Literal_               _SAL2_Source_(_Literal_, (), _Pre_ _Literal_impl_)
#define _Notliteral_            _SAL2_Source_(_Notliteral_, (), _Pre_ _Notliteral_impl_)

// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();
#define _Check_return_           _SAL2_Source_(_Check_return_, (), _Check_return_impl_)
#define _Must_inspect_result_    _SAL2_Source_(_Must_inspect_result_, (), _Must_inspect_impl_ _Check_return_impl_)

// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );
#define _Printf_format_string_  _SAL2_Source_(_Printf_format_string_, (), _Printf_format_string_impl_)
#define _Scanf_format_string_   _SAL2_Source_(_Scanf_format_string_, (), _Scanf_format_string_impl_)
#define _Scanf_s_format_string_  _SAL2_Source_(_Scanf_s_format_string_, (), _Scanf_s_format_string_impl_)

#define _Format_string_impl_(kind,where)  _SA_annotes2(SAL_IsFormatString2, kind, where)
#define _Printf_format_string_params_(x)  _SAL2_Source_(_Printf_format_string_params_, (x), _Format_string_impl_("printf", x))
#define _Scanf_format_string_params_(x)   _SAL2_Source_(_Scanf_format_string_params_, (x), _Format_string_impl_("scanf", x))
#define _Scanf_s_format_string_params_(x) _SAL2_Source_(_Scanf_s_format_string_params_, (x), _Format_string_impl_("scanf_s", x))

// annotations to express value of integral or pointer parameter
#define _In_range_(lb,ub)           _SAL2_Source_(_In_range_, (lb,ub), _In_range_impl_(lb,ub))
#define _Out_range_(lb,ub)          _SAL2_Source_(_Out_range_, (lb,ub), _Out_range_impl_(lb,ub))
#define _Ret_range_(lb,ub)          _SAL2_Source_(_Ret_range_, (lb,ub), _Ret_range_impl_(lb,ub))
#define _Deref_in_range_(lb,ub)     _SAL2_Source_(_Deref_in_range_, (lb,ub), _Deref_in_range_impl_(lb,ub))
#define _Deref_out_range_(lb,ub)    _SAL2_Source_(_Deref_out_range_, (lb,ub), _Deref_out_range_impl_(lb,ub))
#define _Deref_ret_range_(lb,ub)    _SAL2_Source_(_Deref_ret_range_, (lb,ub), _Deref_ret_range_impl_(lb,ub))
#define _Pre_equal_to_(expr)        _SAL2_Source_(_Pre_equal_to_, (expr), _In_range_(==, expr))
#define _Post_equal_to_(expr)       _SAL2_Source_(_Post_equal_to_, (expr), _Out_range_(==, expr))

// annotation to express that a value (usually a field of a mutable class)
// is not changed by a function call
#define _Unchanged_(e)              _SAL2_Source_(_Unchanged_, (e), _At_(e, _Post_equal_to_(_Old_(e)) _Const_))

// Annotations to allow expressing generalized pre and post conditions.
// 'cond' may be any valid SAL expression that is considered to be true as a precondition
// or postcondition (respsectively).
#define _Pre_satisfies_(cond)       _SAL2_Source_(_Pre_satisfies_, (cond), _Pre_satisfies_impl_(cond))
#define _Post_satisfies_(cond)      _SAL2_Source_(_Post_satisfies_, (cond), _Post_satisfies_impl_(cond))

// Annotations to express struct, class and field invariants
#define _Struct_size_bytes_(size)                  _SAL2_Source_(_Struct_size_bytes_, (size), _Writable_bytes_(size))

#define _Field_size_(size)                         _SAL2_Source_(_Field_size_, (size), _Notnull_   _Writable_elements_(size))
#define _Field_size_opt_(size)                     _SAL2_Source_(_Field_size_opt_, (size), _Maybenull_ _Writable_elements_(size))
#define _Field_size_part_(size, count)             _SAL2_Source_(_Field_size_part_, (size, count), _Notnull_   _Writable_elements_(size) _Readable_elements_(count))
#define _Field_size_part_opt_(size, count)         _SAL2_Source_(_Field_size_part_opt_, (size, count), _Maybenull_ _Writable_elements_(size) _Readable_elements_(count))
#define _Field_size_full_(size)                    _SAL2_Source_(_Field_size_full_, (size), _Field_size_part_(size, size))
#define _Field_size_full_opt_(size)                _SAL2_Source_(_Field_size_full_opt_, (size), _Field_size_part_opt_(size, size))

#define _Field_size_bytes_(size)                   _SAL2_Source_(_Field_size_bytes_, (size), _Notnull_   _Writable_bytes_(size))
#define _Field_size_bytes_opt_(size)               _SAL2_Source_(_Field_size_bytes_opt_, (size), _Maybenull_ _Writable_bytes_(size))
#define _Field_size_bytes_part_(size, count)       _SAL2_Source_(_Field_size_bytes_part_, (size, count), _Notnull_   _Writable_bytes_(size) _Readable_bytes_(count))
#define _Field_size_bytes_part_opt_(size, count)   _SAL2_Source_(_Field_size_bytes_part_opt_, (size, count), _Maybenull_ _Writable_bytes_(size) _Readable_bytes_(count))
#define _Field_size_bytes_full_(size)              _SAL2_Source_(_Field_size_bytes_full_, (size), _Field_size_bytes_part_(size, size))
#define _Field_size_bytes_full_opt_(size)          _SAL2_Source_(_Field_size_bytes_full_opt_, (size), _Field_size_bytes_part_opt_(size, size))

#define _Field_z_                                  _SAL2_Source_(_Field_z_, (), _Null_terminated_)

#define _Field_range_(min,max)                     _SAL2_Source_(_Field_range_, (min,max), _Field_range_impl_(min,max))

//============================================================================
//   _Pre_/_Post_ Layer:
//============================================================================

//
// Raw Pre/Post for declaring custom pre/post conditions
//

#define _Pre_                             _Pre_impl_
#define _Post_                            _Post_impl_

//
// Validity property
//

#define _Valid_                           _Valid_impl_
#define _Notvalid_                        _Notvalid_impl_
#define _Maybevalid_                      _Maybevalid_impl_

//
// Buffer size properties
//

// Expressing buffer sizes without specifying pre or post condition
#define _Readable_bytes_(size)            _SAL2_Source_(_Readable_bytes_, (size), _Readable_bytes_impl_(size))
#define _Readable_elements_(size)         _SAL2_Source_(_Readable_elements_, (size), _Readable_elements_impl_(size))
#define _Writable_bytes_(size)            _SAL2_Source_(_Writable_bytes_, (size), _Writable_bytes_impl_(size))
#define _Writable_elements_(size)         _SAL2_Source_(_Writable_elements_, (size), _Writable_elements_impl_(size))

#define _Null_terminated_                 _SAL2_Source_(_Null_terminated_, (), _Null_terminated_impl_)
#define _NullNull_terminated_             _SAL2_Source_(_NullNull_terminated_, (), _NullNull_terminated_impl_)

// Expressing buffer size as pre or post condition
#define _Pre_readable_size_(size)         _SAL2_Source_(_Pre_readable_size_, (size), _Pre1_impl_(__count_impl(size))      _Pre_valid_impl_)
#define _Pre_writable_size_(size)         _SAL2_Source_(_Pre_writable_size_, (size), _Pre1_impl_(__cap_impl(size)))
#define _Pre_readable_byte_size_(size)    _SAL2_Source_(_Pre_readable_byte_size_, (size), _Pre1_impl_(__bytecount_impl(size))  _Pre_valid_impl_)
#define _Pre_writable_byte_size_(size)    _SAL2_Source_(_Pre_writable_byte_size_, (size), _Pre1_impl_(__bytecap_impl(size)))

#define _Post_readable_size_(size)        _SAL2_Source_(_Post_readable_size_, (size), _Post1_impl_(__count_impl(size))     _Post_valid_impl_)
#define _Post_writable_size_(size)        _SAL2_Source_(_Post_writable_size_, (size), _Post1_impl_(__cap_impl(size)))
#define _Post_readable_byte_size_(size)   _SAL2_Source_(_Post_readable_byte_size_, (size), _Post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)
#define _Post_writable_byte_size_(size)   _SAL2_Source_(_Post_writable_byte_size_, (size), _Post1_impl_(__bytecap_impl(size)))

//
// Pointer null-ness properties
//
#define _Null_                            _SAL2_Source_(_Null_, (), _Null_impl_)
#define _Notnull_                         _SAL2_Source_(_Notnull_, (), _Notnull_impl_)
#define _Maybenull_                       _SAL2_Source_(_Maybenull_, (), _Maybenull_impl_)

//
// _Pre_ annotations ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string
#define _Pre_z_                           _SAL2_Source_(_Pre_z_, (), _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)

// valid size unknown or indicated by type (e.g.:LPSTR)
#define _Pre_valid_                       _SAL2_Source_(_Pre_valid_, (), _Pre1_impl_(__notnull_impl_notref)   _Pre_valid_impl_)
#define _Pre_opt_valid_                   _SAL2_Source_(_Pre_opt_valid_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)

#define _Pre_invalid_                     _SAL2_Source_(_Pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))

// Overrides recursive valid when some field is not yet initialized when using _Inout_
#define _Pre_unknown_                     _SAL2_Source_(_Pre_unknown_, (), _Pre1_impl_(__maybevalid_impl))

// used with allocated but not yet initialized objects
#define _Pre_notnull_                     _SAL2_Source_(_Pre_notnull_, (), _Pre1_impl_(__notnull_impl_notref))
#define _Pre_maybenull_                   _SAL2_Source_(_Pre_maybenull_, (), _Pre1_impl_(__maybenull_impl_notref))
#define _Pre_null_                        _SAL2_Source_(_Pre_null_, (), _Pre1_impl_(__null_impl_notref))

//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call
#define _Post_z_                         _SAL2_Source_(_Post_z_, (), _Post1_impl_(__zterm_impl) _Post_valid_impl_)

// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );
#define _Post_valid_                     _SAL2_Source_(_Post_valid_, (), _Post_valid_impl_)
#define _Post_invalid_                   _SAL2_Source_(_Post_invalid_, (), _Deref_post1_impl_(__notvalid_impl))

// e.g. void free( _Post_ptr_invalid_ void* pv );
#define _Post_ptr_invalid_               _SAL2_Source_(_Post_ptr_invalid_, (), _Post1_impl_(__notvalid_impl))

// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );
#define _Post_notnull_                   _SAL2_Source_(_Post_notnull_, (), _Post1_impl_(__notnull_impl))

// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);
#define _Post_null_                      _SAL2_Source_(_Post_null_, (), _Post1_impl_(__null_impl))

#define _Post_maybenull_                 _SAL2_Source_(_Post_maybenull_, (), _Post1_impl_(__maybenull_impl))

#define _Prepost_z_                      _SAL2_Source_(_Prepost_z_, (), _Pre_z_      _Post_z_)


#pragma region Input Buffer SAL 1 compatibility macros

/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter
#define _In_count_(size)               _SAL1_1_Source_(_In_count_, (size), _Pre_count_(size)         _Deref_pre_readonly_)
#define _In_opt_count_(size)           _SAL1_1_Source_(_In_opt_count_, (size), _Pre_opt_count_(size)     _Deref_pre_readonly_)
#define _In_bytecount_(size)           _SAL1_1_Source_(_In_bytecount_, (size), _Pre_bytecount_(size)     _Deref_pre_readonly_)
#define _In_opt_bytecount_(size)       _SAL1_1_Source_(_In_opt_bytecount_, (size), _Pre_opt_bytecount_(size) _Deref_pre_readonly_)

// valid buffer extent described by a constant extression
#define _In_count_c_(size)             _SAL1_1_Source_(_In_count_c_, (size), _Pre_count_c_(size)         _Deref_pre_readonly_)
#define _In_opt_count_c_(size)         _SAL1_1_Source_(_In_opt_count_c_, (size), _Pre_opt_count_c_(size)     _Deref_pre_readonly_)
#define _In_bytecount_c_(size)         _SAL1_1_Source_(_In_bytecount_c_, (size), _Pre_bytecount_c_(size)     _Deref_pre_readonly_)
#define _In_opt_bytecount_c_(size)     _SAL1_1_Source_(_In_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)

// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter
#define _In_z_count_(size)               _SAL1_1_Source_(_In_z_count_, (size), _Pre_z_ _Pre_count_(size)         _Deref_pre_readonly_)
#define _In_opt_z_count_(size)           _SAL1_1_Source_(_In_opt_z_count_, (size), _Pre_opt_z_ _Pre_opt_count_(size)     _Deref_pre_readonly_)
#define _In_z_bytecount_(size)           _SAL1_1_Source_(_In_z_bytecount_, (size), _Pre_z_ _Pre_bytecount_(size)     _Deref_pre_readonly_)
#define _In_opt_z_bytecount_(size)       _SAL1_1_Source_(_In_opt_z_bytecount_, (size), _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_)

// nullterminated valid buffer extent described by a constant extression
#define _In_z_count_c_(size)             _SAL1_1_Source_(_In_z_count_c_, (size), _Pre_z_ _Pre_count_c_(size)         _Deref_pre_readonly_)
#define _In_opt_z_count_c_(size)         _SAL1_1_Source_(_In_opt_z_count_c_, (size), _Pre_opt_z_ _Pre_opt_count_c_(size)     _Deref_pre_readonly_)
#define _In_z_bytecount_c_(size)         _SAL1_1_Source_(_In_z_bytecount_c_, (size), _Pre_z_ _Pre_bytecount_c_(size)     _Deref_pre_readonly_)
#define _In_opt_z_bytecount_c_(size)     _SAL1_1_Source_(_In_opt_z_bytecount_c_, (size), _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)

// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _In_ptrdiff_count_(size)       _SAL1_1_Source_(_In_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size)     _Deref_pre_readonly_)
#define _In_opt_ptrdiff_count_(size)   _SAL1_1_Source_(_In_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_)

// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );
#define _In_count_x_(size)             _SAL1_1_Source_(_In_count_x_, (size), _Pre_count_x_(size)         _Deref_pre_readonly_)
#define _In_opt_count_x_(size)         _SAL1_1_Source_(_In_opt_count_x_, (size), _Pre_opt_count_x_(size)     _Deref_pre_readonly_)
#define _In_bytecount_x_(size)         _SAL1_1_Source_(_In_bytecount_x_, (size), _Pre_bytecount_x_(size)     _Deref_pre_readonly_)
#define _In_opt_bytecount_x_(size)     _SAL1_1_Source_(_In_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_)


// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter
#define _Out_cap_(size)                   _SAL1_1_Source_(_Out_cap_, (size), _Pre_cap_(size)           _Post_valid_impl_)
#define _Out_opt_cap_(size)               _SAL1_1_Source_(_Out_opt_cap_, (size), _Pre_opt_cap_(size)       _Post_valid_impl_)
#define _Out_bytecap_(size)               _SAL1_1_Source_(_Out_bytecap_, (size), _Pre_bytecap_(size)       _Post_valid_impl_)
#define _Out_opt_bytecap_(size)           _SAL1_1_Source_(_Out_opt_bytecap_, (size), _Pre_opt_bytecap_(size)   _Post_valid_impl_)

// buffer capacity is described by a constant expression
#define _Out_cap_c_(size)                 _SAL1_1_Source_(_Out_cap_c_, (size), _Pre_cap_c_(size)         _Post_valid_impl_)
#define _Out_opt_cap_c_(size)             _SAL1_1_Source_(_Out_opt_cap_c_, (size), _Pre_opt_cap_c_(size)     _Post_valid_impl_)
#define _Out_bytecap_c_(size)             _SAL1_1_Source_(_Out_bytecap_c_, (size), _Pre_bytecap_c_(size)     _Post_valid_impl_)
#define _Out_opt_bytecap_c_(size)         _SAL1_1_Source_(_Out_opt_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_)

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Out_cap_m_(mult,size)            _SAL1_1_Source_(_Out_cap_m_, (mult,size), _Pre_cap_m_(mult,size)     _Post_valid_impl_)
#define _Out_opt_cap_m_(mult,size)        _SAL1_1_Source_(_Out_opt_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_)
#define _Out_z_cap_m_(mult,size)          _SAL1_1_Source_(_Out_z_cap_m_, (mult,size), _Pre_cap_m_(mult,size)     _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_m_(mult,size)      _SAL1_1_Source_(_Out_opt_z_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_ _Post_z_)

// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _Out_ptrdiff_cap_(size)           _SAL1_1_Source_(_Out_ptrdiff_cap_, (size), _Pre_ptrdiff_cap_(size)     _Post_valid_impl_)
#define _Out_opt_ptrdiff_cap_(size)       _SAL1_1_Source_(_Out_opt_ptrdiff_cap_, (size), _Pre_opt_ptrdiff_cap_(size) _Post_valid_impl_)

// buffer capacity is described by a complex expression
#define _Out_cap_x_(size)                 _SAL1_1_Source_(_Out_cap_x_, (size), _Pre_cap_x_(size)         _Post_valid_impl_)
#define _Out_opt_cap_x_(size)             _SAL1_1_Source_(_Out_opt_cap_x_, (size), _Pre_opt_cap_x_(size)     _Post_valid_impl_)
#define _Out_bytecap_x_(size)             _SAL1_1_Source_(_Out_bytecap_x_, (size), _Pre_bytecap_x_(size)     _Post_valid_impl_)
#define _Out_opt_bytecap_x_(size)         _SAL1_1_Source_(_Out_opt_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_)

// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter
#define _Out_z_cap_(size)                 _SAL1_1_Source_(_Out_z_cap_, (size), _Pre_cap_(size)           _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_(size)             _SAL1_1_Source_(_Out_opt_z_cap_, (size), _Pre_opt_cap_(size)       _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_(size)             _SAL1_1_Source_(_Out_z_bytecap_, (size), _Pre_bytecap_(size)       _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_(size)         _SAL1_1_Source_(_Out_opt_z_bytecap_, (size), _Pre_opt_bytecap_(size)   _Post_valid_impl_ _Post_z_)

// buffer capacity is described by a constant expression
#define _Out_z_cap_c_(size)               _SAL1_1_Source_(_Out_z_cap_c_, (size), _Pre_cap_c_(size)         _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_c_(size)           _SAL1_1_Source_(_Out_opt_z_cap_c_, (size), _Pre_opt_cap_c_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_c_(size)           _SAL1_1_Source_(_Out_z_bytecap_c_, (size), _Pre_bytecap_c_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Out_opt_z_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_ _Post_z_)

// buffer capacity is described by a complex expression
#define _Out_z_cap_x_(size)               _SAL1_1_Source_(_Out_z_cap_x_, (size), _Pre_cap_x_(size)         _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_x_(size)           _SAL1_1_Source_(_Out_opt_z_cap_x_, (size), _Pre_opt_cap_x_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_x_(size)           _SAL1_1_Source_(_Out_z_bytecap_x_, (size), _Pre_bytecap_x_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Out_opt_z_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_ _Post_z_)

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );
#define _Out_cap_post_count_(cap,count)                _SAL1_1_Source_(_Out_cap_post_count_, (cap,count), _Pre_cap_(cap)         _Post_valid_impl_ _Post_count_(count))
#define _Out_opt_cap_post_count_(cap,count)            _SAL1_1_Source_(_Out_opt_cap_post_count_, (cap,count), _Pre_opt_cap_(cap)     _Post_valid_impl_ _Post_count_(count))
#define _Out_bytecap_post_bytecount_(cap,count)        _SAL1_1_Source_(_Out_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap)     _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_opt_bytecap_post_bytecount_(cap,count)    _SAL1_1_Source_(_Out_opt_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_bytecount_(count))

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );
#define _Out_z_cap_post_count_(cap,count)               _SAL1_1_Source_(_Out_z_cap_post_count_, (cap,count), _Pre_cap_(cap)         _Post_valid_impl_ _Post_z_count_(count))
#define _Out_opt_z_cap_post_count_(cap,count)           _SAL1_1_Source_(_Out_opt_z_cap_post_count_, (cap,count), _Pre_opt_cap_(cap)     _Post_valid_impl_ _Post_z_count_(count))
#define _Out_z_bytecap_post_bytecount_(cap,count)       _SAL1_1_Source_(_Out_z_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap)     _Post_valid_impl_ _Post_z_bytecount_(count))
#define _Out_opt_z_bytecap_post_bytecount_(cap,count)   _SAL1_1_Source_(_Out_opt_z_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_z_bytecount_(count))

// only use with dereferenced arguments e.g. '*pcch'
#define _Out_capcount_(capcount)             _SAL1_1_Source_(_Out_capcount_, (capcount), _Pre_cap_(capcount)         _Post_valid_impl_ _Post_count_(capcount))
#define _Out_opt_capcount_(capcount)         _SAL1_1_Source_(_Out_opt_capcount_, (capcount), _Pre_opt_cap_(capcount)     _Post_valid_impl_ _Post_count_(capcount))
#define _Out_bytecapcount_(capcount)         _SAL1_1_Source_(_Out_bytecapcount_, (capcount), _Pre_bytecap_(capcount)     _Post_valid_impl_ _Post_bytecount_(capcount))
#define _Out_opt_bytecapcount_(capcount)     _SAL1_1_Source_(_Out_opt_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_bytecount_(capcount))

#define _Out_capcount_x_(capcount)           _SAL1_1_Source_(_Out_capcount_x_, (capcount), _Pre_cap_x_(capcount)         _Post_valid_impl_ _Post_count_x_(capcount))
#define _Out_opt_capcount_x_(capcount)       _SAL1_1_Source_(_Out_opt_capcount_x_, (capcount), _Pre_opt_cap_x_(capcount)     _Post_valid_impl_ _Post_count_x_(capcount))
#define _Out_bytecapcount_x_(capcount)       _SAL1_1_Source_(_Out_bytecapcount_x_, (capcount), _Pre_bytecap_x_(capcount)     _Post_valid_impl_ _Post_bytecount_x_(capcount))
#define _Out_opt_bytecapcount_x_(capcount)   _SAL1_1_Source_(_Out_opt_bytecapcount_x_, (capcount), _Pre_opt_bytecap_x_(capcount) _Post_valid_impl_ _Post_bytecount_x_(capcount))

// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );
#define _Out_z_capcount_(capcount)           _SAL1_1_Source_(_Out_z_capcount_, (capcount), _Pre_cap_(capcount)         _Post_valid_impl_ _Post_z_count_(capcount))
#define _Out_opt_z_capcount_(capcount)       _SAL1_1_Source_(_Out_opt_z_capcount_, (capcount), _Pre_opt_cap_(capcount)     _Post_valid_impl_ _Post_z_count_(capcount))
#define _Out_z_bytecapcount_(capcount)       _SAL1_1_Source_(_Out_z_bytecapcount_, (capcount), _Pre_bytecap_(capcount)     _Post_valid_impl_ _Post_z_bytecount_(capcount))
#define _Out_opt_z_bytecapcount_(capcount)   _SAL1_1_Source_(_Out_opt_z_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_z_bytecount_(capcount))


// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_count_(size)               _SAL1_1_Source_(_Inout_count_, (size), _Prepost_count_(size))
#define _Inout_opt_count_(size)           _SAL1_1_Source_(_Inout_opt_count_, (size), _Prepost_opt_count_(size))
#define _Inout_bytecount_(size)           _SAL1_1_Source_(_Inout_bytecount_, (size), _Prepost_bytecount_(size))
#define _Inout_opt_bytecount_(size)       _SAL1_1_Source_(_Inout_opt_bytecount_, (size), _Prepost_opt_bytecount_(size))

#define _Inout_count_c_(size)             _SAL1_1_Source_(_Inout_count_c_, (size), _Prepost_count_c_(size))
#define _Inout_opt_count_c_(size)         _SAL1_1_Source_(_Inout_opt_count_c_, (size), _Prepost_opt_count_c_(size))
#define _Inout_bytecount_c_(size)         _SAL1_1_Source_(_Inout_bytecount_c_, (size), _Prepost_bytecount_c_(size))
#define _Inout_opt_bytecount_c_(size)     _SAL1_1_Source_(_Inout_opt_bytecount_c_, (size), _Prepost_opt_bytecount_c_(size))

// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_z_count_(size)               _SAL1_1_Source_(_Inout_z_count_, (size), _Prepost_z_ _Prepost_count_(size))
#define _Inout_opt_z_count_(size)           _SAL1_1_Source_(_Inout_opt_z_count_, (size), _Prepost_z_ _Prepost_opt_count_(size))
#define _Inout_z_bytecount_(size)           _SAL1_1_Source_(_Inout_z_bytecount_, (size), _Prepost_z_ _Prepost_bytecount_(size))
#define _Inout_opt_z_bytecount_(size)       _SAL1_1_Source_(_Inout_opt_z_bytecount_, (size), _Prepost_z_ _Prepost_opt_bytecount_(size))

#define _Inout_z_count_c_(size)             _SAL1_1_Source_(_Inout_z_count_c_, (size), _Prepost_z_ _Prepost_count_c_(size))
#define _Inout_opt_z_count_c_(size)         _SAL1_1_Source_(_Inout_opt_z_count_c_, (size), _Prepost_z_ _Prepost_opt_count_c_(size))
#define _Inout_z_bytecount_c_(size)         _SAL1_1_Source_(_Inout_z_bytecount_c_, (size), _Prepost_z_ _Prepost_bytecount_c_(size))
#define _Inout_opt_z_bytecount_c_(size)     _SAL1_1_Source_(_Inout_opt_z_bytecount_c_, (size), _Prepost_z_ _Prepost_opt_bytecount_c_(size))

#define _Inout_ptrdiff_count_(size)       _SAL1_1_Source_(_Inout_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size))
#define _Inout_opt_ptrdiff_count_(size)   _SAL1_1_Source_(_Inout_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size))

#define _Inout_count_x_(size)             _SAL1_1_Source_(_Inout_count_x_, (size), _Prepost_count_x_(size))
#define _Inout_opt_count_x_(size)         _SAL1_1_Source_(_Inout_opt_count_x_, (size), _Prepost_opt_count_x_(size))
#define _Inout_bytecount_x_(size)         _SAL1_1_Source_(_Inout_bytecount_x_, (size), _Prepost_bytecount_x_(size))
#define _Inout_opt_bytecount_x_(size)     _SAL1_1_Source_(_Inout_opt_bytecount_x_, (size), _Prepost_opt_bytecount_x_(size))

// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );
#define _Inout_cap_(size)                 _SAL1_1_Source_(_Inout_cap_, (size), _Pre_valid_cap_(size)           _Post_valid_)
#define _Inout_opt_cap_(size)             _SAL1_1_Source_(_Inout_opt_cap_, (size), _Pre_opt_valid_cap_(size)       _Post_valid_)
#define _Inout_bytecap_(size)             _SAL1_1_Source_(_Inout_bytecap_, (size), _Pre_valid_bytecap_(size)       _Post_valid_)
#define _Inout_opt_bytecap_(size)         _SAL1_1_Source_(_Inout_opt_bytecap_, (size), _Pre_opt_valid_bytecap_(size)   _Post_valid_)

#define _Inout_cap_c_(size)               _SAL1_1_Source_(_Inout_cap_c_, (size), _Pre_valid_cap_c_(size)         _Post_valid_)
#define _Inout_opt_cap_c_(size)           _SAL1_1_Source_(_Inout_opt_cap_c_, (size), _Pre_opt_valid_cap_c_(size)     _Post_valid_)
#define _Inout_bytecap_c_(size)           _SAL1_1_Source_(_Inout_bytecap_c_, (size), _Pre_valid_bytecap_c_(size)     _Post_valid_)
#define _Inout_opt_bytecap_c_(size)       _SAL1_1_Source_(_Inout_opt_bytecap_c_, (size), _Pre_opt_valid_bytecap_c_(size) _Post_valid_)

#define _Inout_cap_x_(size)               _SAL1_1_Source_(_Inout_cap_x_, (size), _Pre_valid_cap_x_(size)         _Post_valid_)
#define _Inout_opt_cap_x_(size)           _SAL1_1_Source_(_Inout_opt_cap_x_, (size), _Pre_opt_valid_cap_x_(size)     _Post_valid_)
#define _Inout_bytecap_x_(size)           _SAL1_1_Source_(_Inout_bytecap_x_, (size), _Pre_valid_bytecap_x_(size)     _Post_valid_)
#define _Inout_opt_bytecap_x_(size)       _SAL1_1_Source_(_Inout_opt_bytecap_x_, (size), _Pre_opt_valid_bytecap_x_(size) _Post_valid_)

// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _Inout_z_cap_(size)                  _SAL1_1_Source_(_Inout_z_cap_, (size), _Pre_z_cap_(size)            _Post_z_)
#define _Inout_opt_z_cap_(size)              _SAL1_1_Source_(_Inout_opt_z_cap_, (size), _Pre_opt_z_cap_(size)        _Post_z_)
#define _Inout_z_bytecap_(size)              _SAL1_1_Source_(_Inout_z_bytecap_, (size), _Pre_z_bytecap_(size)        _Post_z_)
#define _Inout_opt_z_bytecap_(size)          _SAL1_1_Source_(_Inout_opt_z_bytecap_, (size), _Pre_opt_z_bytecap_(size)    _Post_z_)

#define _Inout_z_cap_c_(size)                _SAL1_1_Source_(_Inout_z_cap_c_, (size), _Pre_z_cap_c_(size)          _Post_z_)
#define _Inout_opt_z_cap_c_(size)            _SAL1_1_Source_(_Inout_opt_z_cap_c_, (size), _Pre_opt_z_cap_c_(size)      _Post_z_)
#define _Inout_z_bytecap_c_(size)            _SAL1_1_Source_(_Inout_z_bytecap_c_, (size), _Pre_z_bytecap_c_(size)      _Post_z_)
#define _Inout_opt_z_bytecap_c_(size)        _SAL1_1_Source_(_Inout_opt_z_bytecap_c_, (size), _Pre_opt_z_bytecap_c_(size)  _Post_z_)

#define _Inout_z_cap_x_(size)                _SAL1_1_Source_(_Inout_z_cap_x_, (size), _Pre_z_cap_x_(size)          _Post_z_)
#define _Inout_opt_z_cap_x_(size)            _SAL1_1_Source_(_Inout_opt_z_cap_x_, (size), _Pre_opt_z_cap_x_(size)      _Post_z_)
#define _Inout_z_bytecap_x_(size)            _SAL1_1_Source_(_Inout_z_bytecap_x_, (size), _Pre_z_bytecap_x_(size)      _Post_z_)
#define _Inout_opt_z_bytecap_x_(size)        _SAL1_1_Source_(_Inout_opt_z_bytecap_x_, (size), _Pre_opt_z_bytecap_x_(size)  _Post_z_)


// returning pointers to valid objects
#define _Ret_                   _SAL1_1_Source_(_Ret_, (), _Ret_valid_)
#define _Ret_opt_               _SAL1_1_Source_(_Ret_opt_, (), _Ret_opt_valid_)

// annotations to express 'boundedness' of integral value parameter
#define _In_bound_           _SAL1_1_Source_(_In_bound_, (), _In_bound_impl_)
#define _Out_bound_          _SAL1_1_Source_(_Out_bound_, (), _Out_bound_impl_)
#define _Ret_bound_          _SAL1_1_Source_(_Ret_bound_, (), _Ret_bound_impl_)
#define _Deref_in_bound_     _SAL1_1_Source_(_Deref_in_bound_, (), _Deref_in_bound_impl_)
#define _Deref_out_bound_    _SAL1_1_Source_(_Deref_out_bound_, (), _Deref_out_bound_impl_)
#define _Deref_inout_bound_  _SAL1_1_Source_(_Deref_inout_bound_, (), _Deref_in_bound_ _Deref_out_bound_)
#define _Deref_ret_bound_    _SAL1_1_Source_(_Deref_ret_bound_, (), _Deref_ret_bound_impl_)

// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );
#define _Deref_out_             _SAL1_1_Source_(_Deref_out_, (), _Out_ _Deref_post_valid_)
#define _Deref_out_opt_         _SAL1_1_Source_(_Deref_out_opt_, (), _Out_ _Deref_post_opt_valid_)
#define _Deref_opt_out_         _SAL1_1_Source_(_Deref_opt_out_, (), _Out_opt_ _Deref_post_valid_)
#define _Deref_opt_out_opt_     _SAL1_1_Source_(_Deref_opt_out_opt_, (), _Out_opt_ _Deref_post_opt_valid_)

// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );
#define _Deref_out_z_           _SAL1_1_Source_(_Deref_out_z_, (), _Out_ _Deref_post_z_)
#define _Deref_out_opt_z_       _SAL1_1_Source_(_Deref_out_opt_z_, (), _Out_ _Deref_post_opt_z_)
#define _Deref_opt_out_z_       _SAL1_1_Source_(_Deref_opt_out_z_, (), _Out_opt_ _Deref_post_z_)
#define _Deref_opt_out_opt_z_   _SAL1_1_Source_(_Deref_opt_out_opt_z_, (), _Out_opt_ _Deref_post_opt_z_)

//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );
#define _Deref_pre_z_                           _SAL1_1_Source_(_Deref_pre_z_, (), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)
#define _Deref_pre_opt_z_                       _SAL1_1_Source_(_Deref_pre_opt_z_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)

// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter
#define _Deref_pre_cap_(size)                   _SAL1_1_Source_(_Deref_pre_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_impl(size)))
#define _Deref_pre_opt_cap_(size)               _SAL1_1_Source_(_Deref_pre_opt_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)))
#define _Deref_pre_bytecap_(size)               _SAL1_1_Source_(_Deref_pre_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_impl(size)))
#define _Deref_pre_opt_bytecap_(size)           _SAL1_1_Source_(_Deref_pre_opt_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)))

// buffer capacity is described by a constant expression
#define _Deref_pre_cap_c_(size)                 _SAL1_1_Source_(_Deref_pre_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_c_impl(size)))
#define _Deref_pre_opt_cap_c_(size)             _SAL1_1_Source_(_Deref_pre_opt_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)))
#define _Deref_pre_bytecap_c_(size)             _SAL1_1_Source_(_Deref_pre_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_c_impl(size)))
#define _Deref_pre_opt_bytecap_c_(size)         _SAL1_1_Source_(_Deref_pre_opt_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)))

// buffer capacity is described by a complex condition
#define _Deref_pre_cap_x_(size)                 _SAL1_1_Source_(_Deref_pre_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_x_impl(size)))
#define _Deref_pre_opt_cap_x_(size)             _SAL1_1_Source_(_Deref_pre_opt_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)))
#define _Deref_pre_bytecap_x_(size)             _SAL1_1_Source_(_Deref_pre_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_x_impl(size)))
#define _Deref_pre_opt_bytecap_x_(size)         _SAL1_1_Source_(_Deref_pre_opt_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_pre_z_cap_(size)                 _SAL1_1_Source_(_Deref_pre_z_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_(size)             _SAL1_1_Source_(_Deref_pre_opt_z_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_(size)             _SAL1_1_Source_(_Deref_pre_z_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_(size)         _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_z_cap_c_(size)               _SAL1_1_Source_(_Deref_pre_z_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_c_(size)           _SAL1_1_Source_(_Deref_pre_opt_z_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_c_(size)           _SAL1_1_Source_(_Deref_pre_z_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_z_cap_x_(size)               _SAL1_1_Source_(_Deref_pre_z_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_x_(size)           _SAL1_1_Source_(_Deref_pre_opt_z_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_x_(size)           _SAL1_1_Source_(_Deref_pre_z_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)

// known capacity and valid but unknown readable extent
#define _Deref_pre_valid_cap_(size)             _SAL1_1_Source_(_Deref_pre_valid_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_(size)         _SAL1_1_Source_(_Deref_pre_opt_valid_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_(size)         _SAL1_1_Source_(_Deref_pre_valid_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_(size)     _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_valid_cap_c_(size)           _SAL1_1_Source_(_Deref_pre_valid_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_c_(size)       _SAL1_1_Source_(_Deref_pre_opt_valid_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_c_(size)       _SAL1_1_Source_(_Deref_pre_valid_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_c_(size)   _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_valid_cap_x_(size)           _SAL1_1_Source_(_Deref_pre_valid_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Deref_pre_opt_valid_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_x_(size)       _SAL1_1_Source_(_Deref_pre_valid_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)

// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter
#define _Deref_pre_count_(size)                 _SAL1_1_Source_(_Deref_pre_count_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__count_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_count_(size)             _SAL1_1_Source_(_Deref_pre_opt_count_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_bytecount_(size)             _SAL1_1_Source_(_Deref_pre_bytecount_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_(size)         _SAL1_1_Source_(_Deref_pre_opt_bytecount_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)

// valid buffer extent is described by a constant expression
#define _Deref_pre_count_c_(size)               _SAL1_1_Source_(_Deref_pre_count_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_count_c_(size)           _SAL1_1_Source_(_Deref_pre_opt_count_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_bytecount_c_(size)           _SAL1_1_Source_(_Deref_pre_bytecount_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_c_(size)       _SAL1_1_Source_(_Deref_pre_opt_bytecount_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)

// valid buffer extent is described by a complex expression
#define _Deref_pre_count_x_(size)               _SAL1_1_Source_(_Deref_pre_count_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_count_x_(size)           _SAL1_1_Source_(_Deref_pre_opt_count_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_bytecount_x_(size)           _SAL1_1_Source_(_Deref_pre_bytecount_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_x_(size)       _SAL1_1_Source_(_Deref_pre_opt_bytecount_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)

// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );
#define _Deref_pre_valid_                       _SAL1_1_Source_(_Deref_pre_valid_, (), _Deref_pre1_impl_(__notnull_impl_notref)   _Pre_valid_impl_)
#define _Deref_pre_opt_valid_                   _SAL1_1_Source_(_Deref_pre_opt_valid_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)
#define _Deref_pre_invalid_                     _SAL1_1_Source_(_Deref_pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))

#define _Deref_pre_notnull_                     _SAL1_1_Source_(_Deref_pre_notnull_, (), _Deref_pre1_impl_(__notnull_impl_notref))
#define _Deref_pre_maybenull_                   _SAL1_1_Source_(_Deref_pre_maybenull_, (), _Deref_pre1_impl_(__maybenull_impl_notref))
#define _Deref_pre_null_                        _SAL1_1_Source_(_Deref_pre_null_, (), _Deref_pre1_impl_(__null_impl_notref))

// restrict access rights
#define _Deref_pre_readonly_                    _SAL1_1_Source_(_Deref_pre_readonly_, (), _Deref_pre1_impl_(__readaccess_impl_notref))
#define _Deref_pre_writeonly_                   _SAL1_1_Source_(_Deref_pre_writeonly_, (), _Deref_pre1_impl_(__writeaccess_impl_notref))

//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );
#define _Deref_post_z_                           _SAL1_1_Source_(_Deref_post_z_, (), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)
#define _Deref_post_opt_z_                       _SAL1_1_Source_(_Deref_post_opt_z_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)

// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter
#define _Deref_post_cap_(size)                   _SAL1_1_Source_(_Deref_post_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))
#define _Deref_post_opt_cap_(size)               _SAL1_1_Source_(_Deref_post_opt_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))
#define _Deref_post_bytecap_(size)               _SAL1_1_Source_(_Deref_post_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))
#define _Deref_post_opt_bytecap_(size)           _SAL1_1_Source_(_Deref_post_opt_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))

// buffer capacity is described by a constant expression
#define _Deref_post_cap_c_(size)                 _SAL1_1_Source_(_Deref_post_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))
#define _Deref_post_opt_cap_c_(size)             _SAL1_1_Source_(_Deref_post_opt_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))
#define _Deref_post_bytecap_c_(size)             _SAL1_1_Source_(_Deref_post_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))
#define _Deref_post_opt_bytecap_c_(size)         _SAL1_1_Source_(_Deref_post_opt_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))

// buffer capacity is described by a complex expression
#define _Deref_post_cap_x_(size)                 _SAL1_1_Source_(_Deref_post_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))
#define _Deref_post_opt_cap_x_(size)             _SAL1_1_Source_(_Deref_post_opt_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))
#define _Deref_post_bytecap_x_(size)             _SAL1_1_Source_(_Deref_post_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))
#define _Deref_post_opt_bytecap_x_(size)         _SAL1_1_Source_(_Deref_post_opt_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_post_z_cap_(size)                 _SAL1_1_Source_(_Deref_post_z_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_opt_z_cap_(size)             _SAL1_1_Source_(_Deref_post_opt_z_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_z_bytecap_(size)             _SAL1_1_Source_(_Deref_post_z_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size))   _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_(size)         _SAL1_1_Source_(_Deref_post_opt_z_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size))   _Post_valid_impl_)

#define _Deref_post_z_cap_c_(size)               _SAL1_1_Source_(_Deref_post_z_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_z_cap_c_(size)           _SAL1_1_Source_(_Deref_post_opt_z_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_z_bytecap_c_(size)           _SAL1_1_Source_(_Deref_post_z_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Deref_post_opt_z_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)

#define _Deref_post_z_cap_x_(size)               _SAL1_1_Source_(_Deref_post_z_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_z_cap_x_(size)           _SAL1_1_Source_(_Deref_post_opt_z_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_z_bytecap_x_(size)           _SAL1_1_Source_(_Deref_post_z_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Deref_post_opt_z_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)

// known capacity and valid but unknown readable extent
#define _Deref_post_valid_cap_(size)             _SAL1_1_Source_(_Deref_post_valid_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_(size)         _SAL1_1_Source_(_Deref_post_opt_valid_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_valid_bytecap_(size)         _SAL1_1_Source_(_Deref_post_valid_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size))   _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_(size)     _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size))   _Post_valid_impl_)

#define _Deref_post_valid_cap_c_(size)           _SAL1_1_Source_(_Deref_post_valid_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_c_(size)       _SAL1_1_Source_(_Deref_post_opt_valid_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_valid_bytecap_c_(size)       _SAL1_1_Source_(_Deref_post_valid_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_c_(size)   _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)

#define _Deref_post_valid_cap_x_(size)           _SAL1_1_Source_(_Deref_post_valid_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Deref_post_opt_valid_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_valid_bytecap_x_(size)       _SAL1_1_Source_(_Deref_post_valid_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)

// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter
#define _Deref_post_count_(size)                 _SAL1_1_Source_(_Deref_post_count_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_impl(size))       _Post_valid_impl_)
#define _Deref_post_opt_count_(size)             _SAL1_1_Source_(_Deref_post_opt_count_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_impl(size))       _Post_valid_impl_)
#define _Deref_post_bytecount_(size)             _SAL1_1_Source_(_Deref_post_bytecount_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size))   _Post_valid_impl_)
#define _Deref_post_opt_bytecount_(size)         _SAL1_1_Source_(_Deref_post_opt_bytecount_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size))   _Post_valid_impl_)

// buffer capacity is described by a constant expression
#define _Deref_post_count_c_(size)               _SAL1_1_Source_(_Deref_post_count_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_count_c_(size)           _SAL1_1_Source_(_Deref_post_opt_count_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_bytecount_c_(size)           _SAL1_1_Source_(_Deref_post_bytecount_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_c_(size)       _SAL1_1_Source_(_Deref_post_opt_bytecount_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)

// buffer capacity is described by a complex expression
#define _Deref_post_count_x_(size)               _SAL1_1_Source_(_Deref_post_count_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_count_x_(size)           _SAL1_1_Source_(_Deref_post_opt_count_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_bytecount_x_(size)           _SAL1_1_Source_(_Deref_post_bytecount_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_x_(size)       _SAL1_1_Source_(_Deref_post_opt_bytecount_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)

// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );
#define _Deref_post_valid_                       _SAL1_1_Source_(_Deref_post_valid_, (), _Deref_post1_impl_(__notnull_impl_notref)   _Post_valid_impl_)
#define _Deref_post_opt_valid_                   _SAL1_1_Source_(_Deref_post_opt_valid_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Post_valid_impl_)

#define _Deref_post_notnull_                     _SAL1_1_Source_(_Deref_post_notnull_, (), _Deref_post1_impl_(__notnull_impl_notref))
#define _Deref_post_maybenull_                   _SAL1_1_Source_(_Deref_post_maybenull_, (), _Deref_post1_impl_(__maybenull_impl_notref))
#define _Deref_post_null_                        _SAL1_1_Source_(_Deref_post_null_, (), _Deref_post1_impl_(__null_impl_notref))

//
// _Deref_ret_ ---
//

#define _Deref_ret_z_                            _SAL1_1_Source_(_Deref_ret_z_, (), _Deref_ret1_impl_(__notnull_impl_notref) _Deref_ret1_impl_(__zterm_impl))
#define _Deref_ret_opt_z_                        _SAL1_1_Source_(_Deref_ret_opt_z_, (), _Deref_ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__zterm_impl))

//
// special _Deref_ ---
//
#define _Deref2_pre_readonly_                    _SAL1_1_Source_(_Deref2_pre_readonly_, (), _Deref2_pre1_impl_(__readaccess_impl_notref))

//
// _Ret_ ---
//

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );
#define _Ret_opt_valid_                   _SAL1_1_Source_(_Ret_opt_valid_, (), _Ret1_impl_(__maybenull_impl_notref) _Ret_valid_impl_)
#define _Ret_opt_z_                       _SAL1_1_Source_(_Ret_opt_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)

// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter
#define _Ret_cap_(size)                   _SAL1_1_Source_(_Ret_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_impl(size)))
#define _Ret_opt_cap_(size)               _SAL1_1_Source_(_Ret_opt_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_impl(size)))
#define _Ret_bytecap_(size)               _SAL1_1_Source_(_Ret_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))
#define _Ret_opt_bytecap_(size)           _SAL1_1_Source_(_Ret_opt_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))

// Buffer capacity is described by a constant expression
#define _Ret_cap_c_(size)                 _SAL1_1_Source_(_Ret_cap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))
#define _Ret_opt_cap_c_(size)             _SAL1_1_Source_(_Ret_opt_cap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))
#define _Ret_bytecap_c_(size)             _SAL1_1_Source_(_Ret_bytecap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))
#define _Ret_opt_bytecap_c_(size)         _SAL1_1_Source_(_Ret_opt_bytecap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))

// Buffer capacity is described by a complex condition
#define _Ret_cap_x_(size)                 _SAL1_1_Source_(_Ret_cap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))
#define _Ret_opt_cap_x_(size)             _SAL1_1_Source_(_Ret_opt_cap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))
#define _Ret_bytecap_x_(size)             _SAL1_1_Source_(_Ret_bytecap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))
#define _Ret_opt_bytecap_x_(size)         _SAL1_1_Source_(_Ret_opt_bytecap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))

// return value is nullterminated and capacity is given by another parameter
#define _Ret_z_cap_(size)                 _SAL1_1_Source_(_Ret_z_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_z_cap_(size)             _SAL1_1_Source_(_Ret_opt_z_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size))     _Ret_valid_impl_)
#define _Ret_z_bytecap_(size)             _SAL1_1_Source_(_Ret_z_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_bytecap_(size)         _SAL1_1_Source_(_Ret_opt_z_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)

// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter
#define _Ret_count_(size)                 _SAL1_1_Source_(_Ret_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_count_(size)             _SAL1_1_Source_(_Ret_opt_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_impl(size))     _Ret_valid_impl_)
#define _Ret_bytecount_(size)             _SAL1_1_Source_(_Ret_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_(size)         _SAL1_1_Source_(_Ret_opt_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)

// Valid Buffer extent is described by a constant expression
#define _Ret_count_c_(size)               _SAL1_1_Source_(_Ret_count_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_c_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_count_c_(size)           _SAL1_1_Source_(_Ret_opt_count_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_c_impl(size))     _Ret_valid_impl_)
#define _Ret_bytecount_c_(size)           _SAL1_1_Source_(_Ret_bytecount_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_c_(size)       _SAL1_1_Source_(_Ret_opt_bytecount_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)

// Valid Buffer extent is described by a complex expression
#define _Ret_count_x_(size)               _SAL1_1_Source_(_Ret_count_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_x_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_count_x_(size)           _SAL1_1_Source_(_Ret_opt_count_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_x_impl(size))     _Ret_valid_impl_)
#define _Ret_bytecount_x_(size)           _SAL1_1_Source_(_Ret_bytecount_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_x_(size)       _SAL1_1_Source_(_Ret_opt_bytecount_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)

// return value is nullterminated and length is given by another parameter
#define _Ret_z_count_(size)               _SAL1_1_Source_(_Ret_z_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_z_count_(size)           _SAL1_1_Source_(_Ret_opt_z_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size))     _Ret_valid_impl_)
#define _Ret_z_bytecount_(size)           _SAL1_1_Source_(_Ret_z_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_bytecount_(size)       _SAL1_1_Source_(_Ret_opt_z_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)


// _Pre_ annotations ---
#define _Pre_opt_z_                       _SAL1_1_Source_(_Pre_opt_z_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)

// restrict access rights
#define _Pre_readonly_                    _SAL1_1_Source_(_Pre_readonly_, (), _Pre1_impl_(__readaccess_impl_notref))
#define _Pre_writeonly_                   _SAL1_1_Source_(_Pre_writeonly_, (), _Pre1_impl_(__writeaccess_impl_notref))

// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter
#define _Pre_cap_(size)                   _SAL1_1_Source_(_Pre_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size)))
#define _Pre_opt_cap_(size)               _SAL1_1_Source_(_Pre_opt_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size)))
#define _Pre_bytecap_(size)               _SAL1_1_Source_(_Pre_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))
#define _Pre_opt_bytecap_(size)           _SAL1_1_Source_(_Pre_opt_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))

// buffer capacity described by a constant expression
#define _Pre_cap_c_(size)                 _SAL1_1_Source_(_Pre_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))
#define _Pre_opt_cap_c_(size)             _SAL1_1_Source_(_Pre_opt_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))
#define _Pre_bytecap_c_(size)             _SAL1_1_Source_(_Pre_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))
#define _Pre_opt_bytecap_c_(size)         _SAL1_1_Source_(_Pre_opt_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))
#define _Pre_cap_c_one_                   _SAL1_1_Source_(_Pre_cap_c_one_, (), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))
#define _Pre_opt_cap_c_one_               _SAL1_1_Source_(_Pre_opt_cap_c_one_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Pre_cap_m_(mult,size)            _SAL1_1_Source_(_Pre_cap_m_, (mult,size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))
#define _Pre_opt_cap_m_(mult,size)        _SAL1_1_Source_(_Pre_opt_cap_m_, (mult,size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))

// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);
#define _Pre_cap_for_(param)              _SAL1_1_Source_(_Pre_cap_for_, (param), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))
#define _Pre_opt_cap_for_(param)          _SAL1_1_Source_(_Pre_opt_cap_for_, (param), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))

// buffer capacity described by a complex condition
#define _Pre_cap_x_(size)                 _SAL1_1_Source_(_Pre_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))
#define _Pre_opt_cap_x_(size)             _SAL1_1_Source_(_Pre_opt_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))
#define _Pre_bytecap_x_(size)             _SAL1_1_Source_(_Pre_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))
#define _Pre_opt_bytecap_x_(size)         _SAL1_1_Source_(_Pre_opt_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))

// buffer capacity described by the difference to another pointer parameter
#define _Pre_ptrdiff_cap_(ptr)            _SAL1_1_Source_(_Pre_ptrdiff_cap_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))
#define _Pre_opt_ptrdiff_cap_(ptr)        _SAL1_1_Source_(_Pre_opt_ptrdiff_cap_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))

// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );
#define _Pre_z_cap_(size)                 _SAL1_1_Source_(_Pre_z_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_opt_z_cap_(size)             _SAL1_1_Source_(_Pre_opt_z_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_z_bytecap_(size)             _SAL1_1_Source_(_Pre_z_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size))   _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_(size)         _SAL1_1_Source_(_Pre_opt_z_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size))   _Pre_valid_impl_)

#define _Pre_z_cap_c_(size)               _SAL1_1_Source_(_Pre_z_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_z_cap_c_(size)           _SAL1_1_Source_(_Pre_opt_z_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_z_bytecap_c_(size)           _SAL1_1_Source_(_Pre_z_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Pre_opt_z_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Pre_z_cap_x_(size)               _SAL1_1_Source_(_Pre_z_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_z_cap_x_(size)           _SAL1_1_Source_(_Pre_opt_z_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_z_bytecap_x_(size)           _SAL1_1_Source_(_Pre_z_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Pre_opt_z_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)

// known capacity and valid but unknown readable extent
#define _Pre_valid_cap_(size)             _SAL1_1_Source_(_Pre_valid_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_opt_valid_cap_(size)         _SAL1_1_Source_(_Pre_opt_valid_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_valid_bytecap_(size)         _SAL1_1_Source_(_Pre_valid_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size))   _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_(size)     _SAL1_1_Source_(_Pre_opt_valid_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size))   _Pre_valid_impl_)

#define _Pre_valid_cap_c_(size)           _SAL1_1_Source_(_Pre_valid_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_valid_cap_c_(size)       _SAL1_1_Source_(_Pre_opt_valid_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_valid_bytecap_c_(size)       _SAL1_1_Source_(_Pre_valid_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_c_(size)   _SAL1_1_Source_(_Pre_opt_valid_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Pre_valid_cap_x_(size)           _SAL1_1_Source_(_Pre_valid_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Pre_opt_valid_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_valid_bytecap_x_(size)       _SAL1_1_Source_(_Pre_valid_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Pre_opt_valid_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)

// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter
#define _Pre_count_(size)                 _SAL1_1_Source_(_Pre_count_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(size))       _Pre_valid_impl_)
#define _Pre_opt_count_(size)             _SAL1_1_Source_(_Pre_opt_count_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_impl(size))       _Pre_valid_impl_)
#define _Pre_bytecount_(size)             _SAL1_1_Source_(_Pre_bytecount_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(size))   _Pre_valid_impl_)
#define _Pre_opt_bytecount_(size)         _SAL1_1_Source_(_Pre_opt_bytecount_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(size))   _Pre_valid_impl_)

// Valid buffer extent described by a constant expression
#define _Pre_count_c_(size)               _SAL1_1_Source_(_Pre_count_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_count_c_(size)           _SAL1_1_Source_(_Pre_opt_count_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Pre_bytecount_c_(size)           _SAL1_1_Source_(_Pre_bytecount_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_c_(size)       _SAL1_1_Source_(_Pre_opt_bytecount_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)

// Valid buffer extent described by a complex expression
#define _Pre_count_x_(size)               _SAL1_1_Source_(_Pre_count_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_count_x_(size)           _SAL1_1_Source_(_Pre_opt_count_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Pre_bytecount_x_(size)           _SAL1_1_Source_(_Pre_bytecount_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_x_(size)       _SAL1_1_Source_(_Pre_opt_bytecount_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)

// Valid buffer extent described by the difference to another pointer parameter
#define _Pre_ptrdiff_count_(ptr)          _SAL1_1_Source_(_Pre_ptrdiff_count_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)
#define _Pre_opt_ptrdiff_count_(ptr)      _SAL1_1_Source_(_Pre_opt_ptrdiff_count_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)


// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call
#define _Post_maybez_                    _SAL_L_Source_(_Post_maybez_, (), _Post1_impl_(__maybezterm_impl))

// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );
#define _Post_cap_(size)                 _SAL1_1_Source_(_Post_cap_, (size), _Post1_impl_(__cap_impl(size)))
#define _Post_bytecap_(size)             _SAL1_1_Source_(_Post_bytecap_, (size), _Post1_impl_(__bytecap_impl(size)))

// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );
#define _Post_count_(size)               _SAL1_1_Source_(_Post_count_, (size), _Post1_impl_(__count_impl(size))       _Post_valid_impl_)
#define _Post_bytecount_(size)           _SAL1_1_Source_(_Post_bytecount_, (size), _Post1_impl_(__bytecount_impl(size))   _Post_valid_impl_)
#define _Post_count_c_(size)             _SAL1_1_Source_(_Post_count_c_, (size), _Post1_impl_(__count_c_impl(size))     _Post_valid_impl_)
#define _Post_bytecount_c_(size)         _SAL1_1_Source_(_Post_bytecount_c_, (size), _Post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Post_count_x_(size)             _SAL1_1_Source_(_Post_count_x_, (size), _Post1_impl_(__count_x_impl(size))     _Post_valid_impl_)
#define _Post_bytecount_x_(size)         _SAL1_1_Source_(_Post_bytecount_x_, (size), _Post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)

// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );
#define _Post_z_count_(size)             _SAL1_1_Source_(_Post_z_count_, (size), _Post2_impl_(__zterm_impl,__count_impl(size))       _Post_valid_impl_)
#define _Post_z_bytecount_(size)         _SAL1_1_Source_(_Post_z_bytecount_, (size), _Post2_impl_(__zterm_impl,__bytecount_impl(size))   _Post_valid_impl_)
#define _Post_z_count_c_(size)           _SAL1_1_Source_(_Post_z_count_c_, (size), _Post2_impl_(__zterm_impl,__count_c_impl(size))     _Post_valid_impl_)
#define _Post_z_bytecount_c_(size)       _SAL1_1_Source_(_Post_z_bytecount_c_, (size), _Post2_impl_(__zterm_impl,__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Post_z_count_x_(size)           _SAL1_1_Source_(_Post_z_count_x_, (size), _Post2_impl_(__zterm_impl,__count_x_impl(size))     _Post_valid_impl_)
#define _Post_z_bytecount_x_(size)       _SAL1_1_Source_(_Post_z_bytecount_x_, (size), _Post2_impl_(__zterm_impl,__bytecount_x_impl(size)) _Post_valid_impl_)

//
// _Prepost_ ---
//
// describing conditions that hold before and after the function call

#define _Prepost_opt_z_                  _SAL1_1_Source_(_Prepost_opt_z_, (), _Pre_opt_z_  _Post_z_)

#define _Prepost_count_(size)            _SAL1_1_Source_(_Prepost_count_, (size), _Pre_count_(size)           _Post_count_(size))
#define _Prepost_opt_count_(size)        _SAL1_1_Source_(_Prepost_opt_count_, (size), _Pre_opt_count_(size)       _Post_count_(size))
#define _Prepost_bytecount_(size)        _SAL1_1_Source_(_Prepost_bytecount_, (size), _Pre_bytecount_(size)       _Post_bytecount_(size))
#define _Prepost_opt_bytecount_(size)    _SAL1_1_Source_(_Prepost_opt_bytecount_, (size), _Pre_opt_bytecount_(size)   _Post_bytecount_(size))
#define _Prepost_count_c_(size)          _SAL1_1_Source_(_Prepost_count_c_, (size), _Pre_count_c_(size)         _Post_count_c_(size))
#define _Prepost_opt_count_c_(size)      _SAL1_1_Source_(_Prepost_opt_count_c_, (size), _Pre_opt_count_c_(size)     _Post_count_c_(size))
#define _Prepost_bytecount_c_(size)      _SAL1_1_Source_(_Prepost_bytecount_c_, (size), _Pre_bytecount_c_(size)     _Post_bytecount_c_(size))
#define _Prepost_opt_bytecount_c_(size)  _SAL1_1_Source_(_Prepost_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size))
#define _Prepost_count_x_(size)          _SAL1_1_Source_(_Prepost_count_x_, (size), _Pre_count_x_(size)         _Post_count_x_(size))
#define _Prepost_opt_count_x_(size)      _SAL1_1_Source_(_Prepost_opt_count_x_, (size), _Pre_opt_count_x_(size)     _Post_count_x_(size))
#define _Prepost_bytecount_x_(size)      _SAL1_1_Source_(_Prepost_bytecount_x_, (size), _Pre_bytecount_x_(size)     _Post_bytecount_x_(size))
#define _Prepost_opt_bytecount_x_(size)  _SAL1_1_Source_(_Prepost_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size))

#define _Prepost_valid_                   _SAL1_1_Source_(_Prepost_valid_, (), _Pre_valid_     _Post_valid_)
#define _Prepost_opt_valid_               _SAL1_1_Source_(_Prepost_opt_valid_, (), _Pre_opt_valid_ _Post_valid_)

//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call

#define _Deref_prepost_z_                         _SAL1_1_Source_(_Deref_prepost_z_, (), _Deref_pre_z_      _Deref_post_z_)
#define _Deref_prepost_opt_z_                     _SAL1_1_Source_(_Deref_prepost_opt_z_, (), _Deref_pre_opt_z_  _Deref_post_opt_z_)

#define _Deref_prepost_cap_(size)                 _SAL1_1_Source_(_Deref_prepost_cap_, (size), _Deref_pre_cap_(size)                _Deref_post_cap_(size))
#define _Deref_prepost_opt_cap_(size)             _SAL1_1_Source_(_Deref_prepost_opt_cap_, (size), _Deref_pre_opt_cap_(size)            _Deref_post_opt_cap_(size))
#define _Deref_prepost_bytecap_(size)             _SAL1_1_Source_(_Deref_prepost_bytecap_, (size), _Deref_pre_bytecap_(size)            _Deref_post_bytecap_(size))
#define _Deref_prepost_opt_bytecap_(size)         _SAL1_1_Source_(_Deref_prepost_opt_bytecap_, (size), _Deref_pre_opt_bytecap_(size)        _Deref_post_opt_bytecap_(size))

#define _Deref_prepost_cap_x_(size)               _SAL1_1_Source_(_Deref_prepost_cap_x_, (size), _Deref_pre_cap_x_(size)              _Deref_post_cap_x_(size))
#define _Deref_prepost_opt_cap_x_(size)           _SAL1_1_Source_(_Deref_prepost_opt_cap_x_, (size), _Deref_pre_opt_cap_x_(size)          _Deref_post_opt_cap_x_(size))
#define _Deref_prepost_bytecap_x_(size)           _SAL1_1_Source_(_Deref_prepost_bytecap_x_, (size), _Deref_pre_bytecap_x_(size)          _Deref_post_bytecap_x_(size))
#define _Deref_prepost_opt_bytecap_x_(size)       _SAL1_1_Source_(_Deref_prepost_opt_bytecap_x_, (size), _Deref_pre_opt_bytecap_x_(size)      _Deref_post_opt_bytecap_x_(size))

#define _Deref_prepost_z_cap_(size)               _SAL1_1_Source_(_Deref_prepost_z_cap_, (size), _Deref_pre_z_cap_(size)              _Deref_post_z_cap_(size))
#define _Deref_prepost_opt_z_cap_(size)           _SAL1_1_Source_(_Deref_prepost_opt_z_cap_, (size), _Deref_pre_opt_z_cap_(size)          _Deref_post_opt_z_cap_(size))
#define _Deref_prepost_z_bytecap_(size)           _SAL1_1_Source_(_Deref_prepost_z_bytecap_, (size), _Deref_pre_z_bytecap_(size)          _Deref_post_z_bytecap_(size))
#define _Deref_prepost_opt_z_bytecap_(size)       _SAL1_1_Source_(_Deref_prepost_opt_z_bytecap_, (size), _Deref_pre_opt_z_bytecap_(size)      _Deref_post_opt_z_bytecap_(size))

#define _Deref_prepost_valid_cap_(size)           _SAL1_1_Source_(_Deref_prepost_valid_cap_, (size), _Deref_pre_valid_cap_(size)          _Deref_post_valid_cap_(size))
#define _Deref_prepost_opt_valid_cap_(size)       _SAL1_1_Source_(_Deref_prepost_opt_valid_cap_, (size), _Deref_pre_opt_valid_cap_(size)      _Deref_post_opt_valid_cap_(size))
#define _Deref_prepost_valid_bytecap_(size)       _SAL1_1_Source_(_Deref_prepost_valid_bytecap_, (size), _Deref_pre_valid_bytecap_(size)      _Deref_post_valid_bytecap_(size))
#define _Deref_prepost_opt_valid_bytecap_(size)   _SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_, (size), _Deref_pre_opt_valid_bytecap_(size)  _Deref_post_opt_valid_bytecap_(size))

#define _Deref_prepost_valid_cap_x_(size)           _SAL1_1_Source_(_Deref_prepost_valid_cap_x_, (size), _Deref_pre_valid_cap_x_(size)          _Deref_post_valid_cap_x_(size))
#define _Deref_prepost_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Deref_prepost_opt_valid_cap_x_, (size), _Deref_pre_opt_valid_cap_x_(size)      _Deref_post_opt_valid_cap_x_(size))
#define _Deref_prepost_valid_bytecap_x_(size)       _SAL1_1_Source_(_Deref_prepost_valid_bytecap_x_, (size), _Deref_pre_valid_bytecap_x_(size)      _Deref_post_valid_bytecap_x_(size))
#define _Deref_prepost_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_x_, (size), _Deref_pre_opt_valid_bytecap_x_(size)  _Deref_post_opt_valid_bytecap_x_(size))

#define _Deref_prepost_count_(size)             _SAL1_1_Source_(_Deref_prepost_count_, (size), _Deref_pre_count_(size)            _Deref_post_count_(size))
#define _Deref_prepost_opt_count_(size)         _SAL1_1_Source_(_Deref_prepost_opt_count_, (size), _Deref_pre_opt_count_(size)        _Deref_post_opt_count_(size))
#define _Deref_prepost_bytecount_(size)         _SAL1_1_Source_(_Deref_prepost_bytecount_, (size), _Deref_pre_bytecount_(size)        _Deref_post_bytecount_(size))
#define _Deref_prepost_opt_bytecount_(size)     _SAL1_1_Source_(_Deref_prepost_opt_bytecount_, (size), _Deref_pre_opt_bytecount_(size)    _Deref_post_opt_bytecount_(size))

#define _Deref_prepost_count_x_(size)           _SAL1_1_Source_(_Deref_prepost_count_x_, (size), _Deref_pre_count_x_(size)          _Deref_post_count_x_(size))
#define _Deref_prepost_opt_count_x_(size)       _SAL1_1_Source_(_Deref_prepost_opt_count_x_, (size), _Deref_pre_opt_count_x_(size)      _Deref_post_opt_count_x_(size))
#define _Deref_prepost_bytecount_x_(size)       _SAL1_1_Source_(_Deref_prepost_bytecount_x_, (size), _Deref_pre_bytecount_x_(size)      _Deref_post_bytecount_x_(size))
#define _Deref_prepost_opt_bytecount_x_(size)   _SAL1_1_Source_(_Deref_prepost_opt_bytecount_x_, (size), _Deref_pre_opt_bytecount_x_(size)  _Deref_post_opt_bytecount_x_(size))

#define _Deref_prepost_valid_                    _SAL1_1_Source_(_Deref_prepost_valid_, (), _Deref_pre_valid_     _Deref_post_valid_)
#define _Deref_prepost_opt_valid_                _SAL1_1_Source_(_Deref_prepost_opt_valid_, (), _Deref_pre_opt_valid_ _Deref_post_opt_valid_)

//
// _Deref_<miscellaneous>
//
// used with references to arrays

#define _Deref_out_z_cap_c_(size)  _SAL1_1_Source_(_Deref_out_z_cap_c_, (size), _Deref_pre_cap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_cap_c_(size)  _SAL1_1_Source_(_Deref_inout_z_cap_c_, (size), _Deref_pre_z_cap_c_(size) _Deref_post_z_)
#define _Deref_out_z_bytecap_c_(size)  _SAL1_1_Source_(_Deref_out_z_bytecap_c_, (size), _Deref_pre_bytecap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_bytecap_c_(size)  _SAL1_1_Source_(_Deref_inout_z_bytecap_c_, (size), _Deref_pre_z_bytecap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_  _SAL1_1_Source_(_Deref_inout_z_, (), _Deref_prepost_z_)

#pragma endregion Input Buffer SAL 1 compatibility macros


//============================================================================
//   Implementation Layer:
//============================================================================


// Naming conventions:
// A symbol the begins with _SA_ is for the machinery of creating any
// annotations; many of those come from sourceannotations.h in the case
// of attributes.

// A symbol that ends with _impl is the very lowest level macro.  It is
// not required to be a legal standalone annotation, and in the case
// of attribute annotations, usually is not.  (In the case of some declspec
// annotations, it might be, but it should not be assumed so.)  Those
// symols will be used in the _PreN..., _PostN... and _RetN... annotations
// to build up more complete annotations.

// A symbol ending in _impl_ is reserved to the implementation as well,
// but it does form a complete annotation; usually they are used to build
// up even higher level annotations.


#if _USE_ATTRIBUTES_FOR_SAL || _USE_DECLSPECS_FOR_SAL // [
// Sharable "_impl" macros: these can be shared between the various annotation
// forms but are part of the implementation of the macros.  These are collected
// here to assure that only necessary differences in the annotations
// exist.

#define _Always_impl_(annos)            _Group_(annos _SAL_nop_impl_) _On_failure_impl_(annos _SAL_nop_impl_)
#define _Bound_impl_                    _SA_annotes0(SAL_bound)
#define _Field_range_impl_(min,max)     _Range_impl_(min,max)
#define _Literal_impl_                  _SA_annotes1(SAL_constant, __yes)
#define _Maybenull_impl_                _SA_annotes1(SAL_null, __maybe)
#define _Maybevalid_impl_               _SA_annotes1(SAL_valid, __maybe)
#define _Must_inspect_impl_ _Post_impl_ _SA_annotes0(SAL_mustInspect)
#define _Notliteral_impl_               _SA_annotes1(SAL_constant, __no)
#define _Notnull_impl_                  _SA_annotes1(SAL_null, __no)
#define _Notvalid_impl_                 _SA_annotes1(SAL_valid, __no)
#define _NullNull_terminated_impl_      _Group_(_SA_annotes1(SAL_nullTerminated, __yes) _SA_annotes1(SAL_readableTo,inexpressibleCount("NullNull terminated string")))
#define _Null_impl_                     _SA_annotes1(SAL_null, __yes)
#define _Null_terminated_impl_          _SA_annotes1(SAL_nullTerminated, __yes)
#define _Out_impl_                      _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl) _Post_valid_impl_
#define _Out_opt_impl_                  _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl) _Post_valid_impl_
#define _Points_to_data_impl_           _At_(*_Curr_, _SA_annotes1(SAL_mayBePointer, __no))
#define _Post_satisfies_impl_(cond)     _Post_impl_ _Satisfies_impl_(cond)
#define _Post_valid_impl_               _Post1_impl_(__valid_impl)
#define _Pre_satisfies_impl_(cond)      _Pre_impl_ _Satisfies_impl_(cond)
#define _Pre_valid_impl_                _Pre1_impl_(__valid_impl)
#define _Range_impl_(min,max)           _SA_annotes2(SAL_range, min, max)
#define _Readable_bytes_impl_(size)     _SA_annotes1(SAL_readableTo, byteCount(size))
#define _Readable_elements_impl_(size)  _SA_annotes1(SAL_readableTo, elementCount(size))
#define _Ret_valid_impl_                _Ret1_impl_(__valid_impl)
#define _Satisfies_impl_(cond)          _SA_annotes1(SAL_satisfies, cond)
#define _Valid_impl_                    _SA_annotes1(SAL_valid, __yes)
#define _Writable_bytes_impl_(size)     _SA_annotes1(SAL_writableTo, byteCount(size))
#define _Writable_elements_impl_(size)  _SA_annotes1(SAL_writableTo, elementCount(size))

#define _In_range_impl_(min,max)        _Pre_impl_ _Range_impl_(min,max)
#define _Out_range_impl_(min,max)       _Post_impl_ _Range_impl_(min,max)
#define _Ret_range_impl_(min,max)       _Post_impl_ _Range_impl_(min,max)
#define _Deref_in_range_impl_(min,max)  _Deref_pre_impl_ _Range_impl_(min,max)
#define _Deref_out_range_impl_(min,max) _Deref_post_impl_ _Range_impl_(min,max)
#define _Deref_ret_range_impl_(min,max) _Deref_post_impl_ _Range_impl_(min,max)

#define _Deref_pre_impl_                _Pre_impl_  _Notref_impl_ _Deref_impl_
#define _Deref_post_impl_               _Post_impl_ _Notref_impl_ _Deref_impl_

// The following are for the implementation machinery, and are not
// suitable for annotating general code.
// We're tying to phase this out, someday.  The parser quotes the param.
#define __AuToQuOtE                     _SA_annotes0(SAL_AuToQuOtE)

// Normally the parser does some simple type checking of annotation params,
// defer that check to the plugin.
#define __deferTypecheck                _SA_annotes0(SAL_deferTypecheck)

#define _SA_SPECSTRIZE( x ) #x
#define _SAL_nop_impl_       /* nothing */
#define __nop_impl(x)            x
#endif
# 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3


#if _USE_ATTRIBUTES_FOR_SAL // [

// Using attributes for sal

#if 0 /* expanded by -frewrite-includes */
#include "CodeAnalysis/sourceannotations.h"
#endif /* expanded by -frewrite-includes */
# 1561 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
# 1562 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3


#define _SA_annotes0(n)                [SAL_annotes(Name=#n)]
#define _SA_annotes1(n,pp1)            [SAL_annotes(Name=#n, p1=_SA_SPECSTRIZE(pp1))]
#define _SA_annotes2(n,pp1,pp2)        [SAL_annotes(Name=#n, p1=_SA_SPECSTRIZE(pp1), p2=_SA_SPECSTRIZE(pp2))]
#define _SA_annotes3(n,pp1,pp2,pp3)    [SAL_annotes(Name=#n, p1=_SA_SPECSTRIZE(pp1), p2=_SA_SPECSTRIZE(pp2), p3=_SA_SPECSTRIZE(pp3))]

#define _Pre_impl_                     [SAL_pre]
#define _Post_impl_                    [SAL_post]
#define _Deref_impl_                   [SAL_deref]
#define _Notref_impl_                  [SAL_notref]


// Declare a function to be an annotation or primop (respectively).
// Done this way so that they don't appear in the regular compiler's
// namespace.
#define __ANNOTATION(fun)              _SA_annotes0(SAL_annotation)  void __SA_##fun;
#define __PRIMOP(type, fun)            _SA_annotes0(SAL_primop)  type __SA_##fun;
#define __QUALIFIER(fun)               _SA_annotes0(SAL_qualifier)  void __SA_##fun;

// Benign declspec needed here for WindowsPREfast
#define __In_impl_ [SA_Pre(Valid=SA_Yes)] [SA_Pre(Deref=1, Notref=1, Access=SA_Read)] __declspec("SAL_pre SAL_valid")

#elif _USE_DECLSPECS_FOR_SAL // ][
# 1586 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// Using declspecs for sal

#define _SA_annotes0(n)                __declspec(#n)
#define _SA_annotes1(n,pp1)            __declspec(#n "(" _SA_SPECSTRIZE(pp1) ")" )
#define _SA_annotes2(n,pp1,pp2)        __declspec(#n "(" _SA_SPECSTRIZE(pp1) "," _SA_SPECSTRIZE(pp2) ")")
#define _SA_annotes3(n,pp1,pp2,pp3)    __declspec(#n "(" _SA_SPECSTRIZE(pp1) "," _SA_SPECSTRIZE(pp2) "," _SA_SPECSTRIZE(pp3) ")")

#define _Pre_impl_                     _SA_annotes0(SAL_pre)
#define _Post_impl_                    _SA_annotes0(SAL_post)
#define _Deref_impl_                   _SA_annotes0(SAL_deref)
#define _Notref_impl_                  _SA_annotes0(SAL_notref)

// Declare a function to be an annotation or primop (respectively).
// Done this way so that they don't appear in the regular compiler's
// namespace.
#define __ANNOTATION(fun)              _SA_annotes0(SAL_annotation) void __SA_##fun

#define __PRIMOP(type, fun)            _SA_annotes0(SAL_primop) type __SA_##fun

#define __QUALIFIER(fun)               _SA_annotes0(SAL_qualifier)  void __SA_##fun;

#define __In_impl_ _Pre_impl_ _SA_annotes0(SAL_valid) _Pre_impl_ _Deref_impl_ _Notref_impl_ _SA_annotes0(SAL_readonly)

#else // ][
# 1611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// Using "nothing" for sal

#define _SA_annotes0(n)
#define _SA_annotes1(n,pp1)
#define _SA_annotes2(n,pp1,pp2)
#define _SA_annotes3(n,pp1,pp2,pp3)

#define __ANNOTATION(fun)
#define __PRIMOP(type, fun)
#define __QUALIFIER(type, fun)

#endif // ]
# 1624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#if _USE_ATTRIBUTES_FOR_SAL || _USE_DECLSPECS_FOR_SAL // [

// Declare annotations that need to be declared.
__ANNOTATION(SAL_useHeader(void));
__ANNOTATION(SAL_bound(void));
__ANNOTATION(SAL_allocator(void));   //??? resolve with PFD
__ANNOTATION(SAL_file_parser(__AuToQuOtE __In_impl_ char *, __In_impl_ char *));
__ANNOTATION(SAL_source_code_content(__In_impl_ char *));
__ANNOTATION(SAL_analysisHint(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_untrusted_data_source(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_untrusted_data_source_this(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_validated(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_validated_this(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_encoded(void));
__ANNOTATION(SAL_adt(__AuToQuOtE __In_impl_ char *, __AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_add_adt_property(__AuToQuOtE __In_impl_ char *, __AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_remove_adt_property(__AuToQuOtE __In_impl_ char *, __AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_transfer_adt_property_from(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_post_type(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_volatile(void));
__ANNOTATION(SAL_nonvolatile(void));
__ANNOTATION(SAL_entrypoint(__AuToQuOtE __In_impl_ char *, __AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_blocksOn(__In_impl_ void*));
__ANNOTATION(SAL_mustInspect(void));

// Only appears in model files, but needs to be declared.
__ANNOTATION(SAL_TypeName(__AuToQuOtE __In_impl_ char *));

// To be declared well-known soon.
__ANNOTATION(SAL_interlocked(void);)

__QUALIFIER(SAL_name(__In_impl_ char *, __In_impl_ char *, __In_impl_ char *);)

__PRIMOP(char *, _Macro_value_(__In_impl_ char *));
__PRIMOP(int, _Macro_defined_(__In_impl_ char *));
__PRIMOP(char *, _Strstr_(__In_impl_ char *, __In_impl_ char *));

#endif // ]
# 1663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#if _USE_ATTRIBUTES_FOR_SAL // [

#define _Check_return_impl_           [SA_Post(MustCheck=SA_Yes)]

#define _Success_impl_(expr)          [SA_Success(Condition=#expr)]
#define _On_failure_impl_(annos)      [SAL_context(p1="SAL_failed")] _Group_(_Post_impl_ _Group_(annos _SAL_nop_impl_))

#define _Printf_format_string_impl_   [SA_FormatString(Style="printf")]
#define _Scanf_format_string_impl_    [SA_FormatString(Style="scanf")]
#define _Scanf_s_format_string_impl_  [SA_FormatString(Style="scanf_s")]

#define _In_bound_impl_               [SA_PreBound(Deref=0)]
#define _Out_bound_impl_              [SA_PostBound(Deref=0)]
#define _Ret_bound_impl_              [SA_PostBound(Deref=0)]
#define _Deref_in_bound_impl_         [SA_PreBound(Deref=1)]
#define _Deref_out_bound_impl_        [SA_PostBound(Deref=1)]
#define _Deref_ret_bound_impl_        [SA_PostBound(Deref=1)]

#define __valid_impl                  Valid=SA_Yes
#define __maybevalid_impl             Valid=SA_Maybe
#define __notvalid_impl               Valid=SA_No

#define __null_impl                   Null=SA_Yes
#define __maybenull_impl              Null=SA_Maybe
#define __notnull_impl                Null=SA_No

#define __null_impl_notref        Null=SA_Yes,Notref=1
#define __maybenull_impl_notref   Null=SA_Maybe,Notref=1
#define __notnull_impl_notref     Null=SA_No,Notref=1

#define __zterm_impl              NullTerminated=SA_Yes
#define __maybezterm_impl         NullTerminated=SA_Maybe
#define __maybzterm_impl          NullTerminated=SA_Maybe
#define __notzterm_impl           NullTerminated=SA_No

#define __readaccess_impl         Access=SA_Read
#define __writeaccess_impl        Access=SA_Write
#define __allaccess_impl          Access=SA_ReadWrite

#define __readaccess_impl_notref  Access=SA_Read,Notref=1
#define __writeaccess_impl_notref Access=SA_Write,Notref=1
#define __allaccess_impl_notref   Access=SA_ReadWrite,Notref=1

// For SAL2, we need to expect general expressions.

#define __cap_impl(size)          WritableElements="\n"#size
#define __bytecap_impl(size)      WritableBytes="\n"#size
#define __bytecount_impl(size)    ValidBytes="\n"#size
#define __count_impl(size)        ValidElements="\n"#size

#define __cap_c_impl(size)        WritableElementsConst=size
#define __cap_c_one_notref_impl   WritableElementsConst=1,Notref=1
#define __cap_for_impl(param)     WritableElementsLength=#param
#define __cap_x_impl(size)        WritableElements="\n@"#size

#define __bytecap_c_impl(size)    WritableBytesConst=size
#define __bytecap_x_impl(size)    WritableBytes="\n@"#size

#define __mult_impl(mult,size)    __cap_impl((mult)*(size))

#define __count_c_impl(size)      ValidElementsConst=size
#define __count_x_impl(size)      ValidElements="\n@"#size

#define __bytecount_c_impl(size)  ValidBytesConst=size
#define __bytecount_x_impl(size)  ValidBytes="\n@"#size


#define _At_impl_(target, annos)       [SAL_at(p1=#target)] _Group_(annos)
#define _At_buffer_impl_(target, iter, bound, annos)  [SAL_at_buffer(p1=#target, p2=#iter, p3=#bound)] _Group_(annos)
#define _When_impl_(expr, annos)       [SAL_when(p1=#expr)] _Group_(annos)

#define _Group_impl_(annos)            [SAL_begin] annos [SAL_end]
#define _GrouP_impl_(annos)            [SAL_BEGIN] annos [SAL_END]

#define _Use_decl_anno_impl_               _SA_annotes0(SAL_useHeader) // this is a special case!

#define _Pre1_impl_(p1)                    [SA_Pre(p1)]
#define _Pre2_impl_(p1,p2)                 [SA_Pre(p1,p2)]
#define _Pre3_impl_(p1,p2,p3)              [SA_Pre(p1,p2,p3)]

#define _Post1_impl_(p1)                   [SA_Post(p1)]
#define _Post2_impl_(p1,p2)                [SA_Post(p1,p2)]
#define _Post3_impl_(p1,p2,p3)             [SA_Post(p1,p2,p3)]

#define _Ret1_impl_(p1)                    [SA_Post(p1)]
#define _Ret2_impl_(p1,p2)                 [SA_Post(p1,p2)]
#define _Ret3_impl_(p1,p2,p3)              [SA_Post(p1,p2,p3)]

#define _Deref_pre1_impl_(p1)              [SA_Pre(Deref=1,p1)]
#define _Deref_pre2_impl_(p1,p2)           [SA_Pre(Deref=1,p1,p2)]
#define _Deref_pre3_impl_(p1,p2,p3)        [SA_Pre(Deref=1,p1,p2,p3)]


#define _Deref_post1_impl_(p1)             [SA_Post(Deref=1,p1)]
#define _Deref_post2_impl_(p1,p2)          [SA_Post(Deref=1,p1,p2)]
#define _Deref_post3_impl_(p1,p2,p3)       [SA_Post(Deref=1,p1,p2,p3)]

#define _Deref_ret1_impl_(p1)              [SA_Post(Deref=1,p1)]
#define _Deref_ret2_impl_(p1,p2)           [SA_Post(Deref=1,p1,p2)]
#define _Deref_ret3_impl_(p1,p2,p3)        [SA_Post(Deref=1,p1,p2,p3)]

#define _Deref2_pre1_impl_(p1)             [SA_Pre(Deref=2,Notref=1,p1)]
#define _Deref2_post1_impl_(p1)            [SA_Post(Deref=2,Notref=1,p1)]
#define _Deref2_ret1_impl_(p1)             [SA_Post(Deref=2,Notref=1,p1)]

// Obsolete -- may be needed for transition to attributes.
#define __inner_typefix(ctype)             [SAL_typefix(p1=_SA_SPECSTRIZE(ctype))]
#define __inner_exceptthat                 [SAL_except]


#elif _USE_DECLSPECS_FOR_SAL // ][
# 1775 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#define _Check_return_impl_ __post      _SA_annotes0(SAL_checkReturn)

#define _Success_impl_(expr)            _SA_annotes1(SAL_success, expr)
#define _On_failure_impl_(annos)        _SA_annotes1(SAL_context, SAL_failed) _Group_(_Post_impl_ _Group_(_SAL_nop_impl_ annos))

#define _Printf_format_string_impl_     _SA_annotes1(SAL_IsFormatString, "printf")
#define _Scanf_format_string_impl_      _SA_annotes1(SAL_IsFormatString, "scanf")
#define _Scanf_s_format_string_impl_    _SA_annotes1(SAL_IsFormatString, "scanf_s")

#define _In_bound_impl_                 _Pre_impl_ _Bound_impl_
#define _Out_bound_impl_                _Post_impl_ _Bound_impl_
#define _Ret_bound_impl_                _Post_impl_ _Bound_impl_
#define _Deref_in_bound_impl_           _Deref_pre_impl_ _Bound_impl_
#define _Deref_out_bound_impl_          _Deref_post_impl_ _Bound_impl_
#define _Deref_ret_bound_impl_          _Deref_post_impl_ _Bound_impl_


#define __null_impl              _SA_annotes0(SAL_null) // _SA_annotes1(SAL_null, __yes)
#define __notnull_impl           _SA_annotes0(SAL_notnull) // _SA_annotes1(SAL_null, __no)
#define __maybenull_impl         _SA_annotes0(SAL_maybenull) // _SA_annotes1(SAL_null, __maybe)

#define __valid_impl             _SA_annotes0(SAL_valid) // _SA_annotes1(SAL_valid, __yes)
#define __notvalid_impl          _SA_annotes0(SAL_notvalid) // _SA_annotes1(SAL_valid, __no)
#define __maybevalid_impl        _SA_annotes0(SAL_maybevalid) // _SA_annotes1(SAL_valid, __maybe)

#define __null_impl_notref       _Notref_ _Null_impl_
#define __maybenull_impl_notref  _Notref_ _Maybenull_impl_
#define __notnull_impl_notref    _Notref_ _Notnull_impl_

#define __zterm_impl             _SA_annotes1(SAL_nullTerminated, __yes)
#define __maybezterm_impl        _SA_annotes1(SAL_nullTerminated, __maybe)
#define __maybzterm_impl         _SA_annotes1(SAL_nullTerminated, __maybe)
#define __notzterm_impl          _SA_annotes1(SAL_nullTerminated, __no)

#define __readaccess_impl        _SA_annotes1(SAL_access, 0x1)
#define __writeaccess_impl       _SA_annotes1(SAL_access, 0x2)
#define __allaccess_impl         _SA_annotes1(SAL_access, 0x3)

#define __readaccess_impl_notref  _Notref_ _SA_annotes1(SAL_access, 0x1)
#define __writeaccess_impl_notref _Notref_ _SA_annotes1(SAL_access, 0x2)
#define __allaccess_impl_notref   _Notref_ _SA_annotes1(SAL_access, 0x3)

#define __cap_impl(size)         _SA_annotes1(SAL_writableTo,elementCount(size))
#define __cap_c_impl(size)       _SA_annotes1(SAL_writableTo,elementCount(size))
#define __cap_c_one_notref_impl  _Notref_ _SA_annotes1(SAL_writableTo,elementCount(1))
#define __cap_for_impl(param)    _SA_annotes1(SAL_writableTo,inexpressibleCount(sizeof(param)))
#define __cap_x_impl(size)       _SA_annotes1(SAL_writableTo,inexpressibleCount(#size))

#define __bytecap_impl(size)     _SA_annotes1(SAL_writableTo,byteCount(size))
#define __bytecap_c_impl(size)   _SA_annotes1(SAL_writableTo,byteCount(size))
#define __bytecap_x_impl(size)   _SA_annotes1(SAL_writableTo,inexpressibleCount(#size))

#define __mult_impl(mult,size)   _SA_annotes1(SAL_writableTo,(mult)*(size))

#define __count_impl(size)       _SA_annotes1(SAL_readableTo,elementCount(size))
#define __count_c_impl(size)     _SA_annotes1(SAL_readableTo,elementCount(size))
#define __count_x_impl(size)     _SA_annotes1(SAL_readableTo,inexpressibleCount(#size))

#define __bytecount_impl(size)   _SA_annotes1(SAL_readableTo,byteCount(size))
#define __bytecount_c_impl(size) _SA_annotes1(SAL_readableTo,byteCount(size))
#define __bytecount_x_impl(size) _SA_annotes1(SAL_readableTo,inexpressibleCount(#size))

#define _At_impl_(target, annos)     _SA_annotes0(SAL_at(target)) _Group_(annos)
#define _At_buffer_impl_(target, iter, bound, annos)  _SA_annotes3(SAL_at_buffer, target, iter, bound) _Group_(annos)
#define _Group_impl_(annos)          _SA_annotes0(SAL_begin) annos _SA_annotes0(SAL_end)
#define _GrouP_impl_(annos)          _SA_annotes0(SAL_BEGIN) annos _SA_annotes0(SAL_END)
#define _When_impl_(expr, annos)     _SA_annotes0(SAL_when(expr)) _Group_(annos)

#define _Use_decl_anno_impl_         __declspec("SAL_useHeader()") // this is a special case!

#define _Pre1_impl_(p1)              _Pre_impl_ p1
#define _Pre2_impl_(p1,p2)           _Pre_impl_ p1 _Pre_impl_ p2
#define _Pre3_impl_(p1,p2,p3)        _Pre_impl_ p1 _Pre_impl_ p2 _Pre_impl_ p3

#define _Post1_impl_(p1)             _Post_impl_ p1
#define _Post2_impl_(p1,p2)          _Post_impl_ p1 _Post_impl_ p2
#define _Post3_impl_(p1,p2,p3)       _Post_impl_ p1 _Post_impl_ p2 _Post_impl_ p3

#define _Ret1_impl_(p1)              _Post_impl_ p1
#define _Ret2_impl_(p1,p2)           _Post_impl_ p1 _Post_impl_ p2
#define _Ret3_impl_(p1,p2,p3)        _Post_impl_ p1 _Post_impl_ p2 _Post_impl_ p3

#define _Deref_pre1_impl_(p1)        _Deref_pre_impl_ p1
#define _Deref_pre2_impl_(p1,p2)     _Deref_pre_impl_ p1 _Deref_pre_impl_ p2
#define _Deref_pre3_impl_(p1,p2,p3)  _Deref_pre_impl_ p1 _Deref_pre_impl_ p2 _Deref_pre_impl_ p3

#define _Deref_post1_impl_(p1)       _Deref_post_impl_ p1
#define _Deref_post2_impl_(p1,p2)    _Deref_post_impl_ p1 _Deref_post_impl_ p2
#define _Deref_post3_impl_(p1,p2,p3) _Deref_post_impl_ p1 _Deref_post_impl_ p2 _Deref_post_impl_ p3

#define _Deref_ret1_impl_(p1)        _Deref_post_impl_ p1
#define _Deref_ret2_impl_(p1,p2)     _Deref_post_impl_ p1 _Deref_post_impl_ p2
#define _Deref_ret3_impl_(p1,p2,p3)  _Deref_post_impl_ p1 _Deref_post_impl_ p2 _Deref_post_impl_ p3

#define _Deref2_pre1_impl_(p1)       _Deref_pre_impl_ _Notref_impl_ _Deref_impl_ p1
#define _Deref2_post1_impl_(p1)      _Deref_post_impl_ _Notref_impl_ _Deref_impl_ p1
#define _Deref2_ret1_impl_(p1)       _Deref_post_impl_ _Notref_impl_ _Deref_impl_ p1

#define __inner_typefix(ctype)             _SA_annotes1(SAL_typefix, ctype)
#define __inner_exceptthat                 _SA_annotes0(SAL_except)

#elif defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) // ][
# 1878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// minimum attribute expansion for foreground build

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus // [
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus // ][
# 1888 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus // ]
# 1891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct __P_impl
{
#ifdef __cplusplus // [
    __P_impl();
#endif // ]
# 1899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
   int __d_;
};
typedef struct __P_impl __P_impl;

REPEATABLE
[source_annotation_attribute( SA( ReturnValue ) )]
struct __R_impl
{
#ifdef __cplusplus // [
    __R_impl();
#endif // ]
# 1910 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
   int __d_;
};
typedef struct __R_impl __R_impl;

[source_annotation_attribute( SA( Method ) )]
struct __M_
{
#ifdef __cplusplus // [
    __M_();
#endif // ]
# 1920 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
   int __d_;
};
typedef struct __M_ __M_;

[source_annotation_attribute( SA( All ) )]
struct __A_
{
#ifdef __cplusplus // [
    __A_();
#endif // ]
# 1930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
   int __d_;
};
typedef struct __A_ __A_;

[source_annotation_attribute( SA( Field ) )]
struct __F_
{
#ifdef __cplusplus // [
    __F_();
#endif // ]
# 1940 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
   int __d_;
};
typedef struct __F_ __F_;

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )


#define _SAL_nop_impl_

#define _At_impl_(target, annos)        [__A_(__d_=0)]
#define _At_buffer_impl_(target, iter, bound, annos)  [__A_(__d_=0)]
#define _When_impl_(expr, annos)        annos
#define _Group_impl_(annos)             annos
#define _GrouP_impl_(annos)             annos
#define _Use_decl_anno_impl_            [__M_(__d_=0)]

#define _Points_to_data_impl_           [__P_impl(__d_=0)]
#define _Literal_impl_                  [__P_impl(__d_=0)]
#define _Notliteral_impl_               [__P_impl(__d_=0)]

#define _Pre_valid_impl_                [__P_impl(__d_=0)]
#define _Post_valid_impl_               [__P_impl(__d_=0)]
#define _Ret_valid_impl_                [__R_impl(__d_=0)]

#define _Check_return_impl_             [__R_impl(__d_=0)]
#define _Must_inspect_impl_             [__R_impl(__d_=0)]

#define _Success_impl_(expr)            [__M_(__d_=0)]
#define _On_failure_impl_(expr)         [__M_(__d_=0)]
#define _Always_impl_(expr)             [__M_(__d_=0)]

#define _Printf_format_string_impl_     [__P_impl(__d_=0)]
#define _Scanf_format_string_impl_      [__P_impl(__d_=0)]
#define _Scanf_s_format_string_impl_    [__P_impl(__d_=0)]

#define _Raises_SEH_exception_impl_         [__M_(__d_=0)]
#define _Maybe_raises_SEH_exception_impl_   [__M_(__d_=0)]

#define _In_bound_impl_                 [__P_impl(__d_=0)]
#define _Out_bound_impl_                [__P_impl(__d_=0)]
#define _Ret_bound_impl_                [__R_impl(__d_=0)]
#define _Deref_in_bound_impl_           [__P_impl(__d_=0)]
#define _Deref_out_bound_impl_          [__P_impl(__d_=0)]
#define _Deref_ret_bound_impl_          [__R_impl(__d_=0)]

#define _Range_impl_(min,max)           [__P_impl(__d_=0)]
#define _In_range_impl_(min,max)        [__P_impl(__d_=0)]
#define _Out_range_impl_(min,max)       [__P_impl(__d_=0)]
#define _Ret_range_impl_(min,max)       [__R_impl(__d_=0)]
#define _Deref_in_range_impl_(min,max)  [__P_impl(__d_=0)]
#define _Deref_out_range_impl_(min,max) [__P_impl(__d_=0)]
#define _Deref_ret_range_impl_(min,max) [__R_impl(__d_=0)]

#define _Field_range_impl_(min,max)     [__F_(__d_=0)]

#define _Pre_satisfies_impl_(cond)      [__A_(__d_=0)]
#define _Post_satisfies_impl_(cond)     [__A_(__d_=0)]
#define _Satisfies_impl_(cond)          [__A_(__d_=0)]

#define _Null_impl_                     [__A_(__d_=0)]
#define _Notnull_impl_                  [__A_(__d_=0)]
#define _Maybenull_impl_                [__A_(__d_=0)]

#define _Valid_impl_                    [__A_(__d_=0)]
#define _Notvalid_impl_                 [__A_(__d_=0)]
#define _Maybevalid_impl_               [__A_(__d_=0)]

#define _Readable_bytes_impl_(size)     [__A_(__d_=0)]
#define _Readable_elements_impl_(size)  [__A_(__d_=0)]
#define _Writable_bytes_impl_(size)     [__A_(__d_=0)]
#define _Writable_elements_impl_(size)  [__A_(__d_=0)]

#define _Null_terminated_impl_          [__A_(__d_=0)]
#define _NullNull_terminated_impl_      [__A_(__d_=0)]

#define _Pre_impl_                      [__P_impl(__d_=0)]
#define _Pre1_impl_(p1)                 [__P_impl(__d_=0)]
#define _Pre2_impl_(p1,p2)              [__P_impl(__d_=0)]
#define _Pre3_impl_(p1,p2,p3)           [__P_impl(__d_=0)]

#define _Post_impl_                     [__P_impl(__d_=0)]
#define _Post1_impl_(p1)                [__P_impl(__d_=0)]
#define _Post2_impl_(p1,p2)             [__P_impl(__d_=0)]
#define _Post3_impl_(p1,p2,p3)          [__P_impl(__d_=0)]

#define _Ret1_impl_(p1)                 [__R_impl(__d_=0)]
#define _Ret2_impl_(p1,p2)              [__R_impl(__d_=0)]
#define _Ret3_impl_(p1,p2,p3)           [__R_impl(__d_=0)]

#define _Deref_pre1_impl_(p1)           [__P_impl(__d_=0)]
#define _Deref_pre2_impl_(p1,p2)        [__P_impl(__d_=0)]
#define _Deref_pre3_impl_(p1,p2,p3)     [__P_impl(__d_=0)]

#define _Deref_post1_impl_(p1)          [__P_impl(__d_=0)]
#define _Deref_post2_impl_(p1,p2)       [__P_impl(__d_=0)]
#define _Deref_post3_impl_(p1,p2,p3)    [__P_impl(__d_=0)]

#define _Deref_ret1_impl_(p1)           [__R_impl(__d_=0)]
#define _Deref_ret2_impl_(p1,p2)        [__R_impl(__d_=0)]
#define _Deref_ret3_impl_(p1,p2,p3)     [__R_impl(__d_=0)]

#define _Deref2_pre1_impl_(p1)          //[__P_impl(__d_=0)]
#define _Deref2_post1_impl_(p1)         //[__P_impl(__d_=0)]
#define _Deref2_ret1_impl_(p1)          //[__P_impl(__d_=0)]

#else // ][
# 2047 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3


#define _SAL_nop_impl_ X

#define _At_impl_(target, annos)
#define _When_impl_(expr, annos)
#define _Group_impl_(annos)
#define _GrouP_impl_(annos)
#define _At_buffer_impl_(target, iter, bound, annos)
#define _Use_decl_anno_impl_
#define _Points_to_data_impl_
#define _Literal_impl_
#define _Notliteral_impl_
#define _Notref_impl_

#define _Pre_valid_impl_
#define _Post_valid_impl_
#define _Ret_valid_impl_

#define _Check_return_impl_
#define _Must_inspect_impl_

#define _Success_impl_(expr)
#define _On_failure_impl_(annos)
#define _Always_impl_(annos)

#define _Printf_format_string_impl_
#define _Scanf_format_string_impl_
#define _Scanf_s_format_string_impl_

#define _In_bound_impl_
#define _Out_bound_impl_
#define _Ret_bound_impl_
#define _Deref_in_bound_impl_
#define _Deref_out_bound_impl_
#define _Deref_ret_bound_impl_

#define _Range_impl_(min,max)
#define _In_range_impl_(min,max)
#define _Out_range_impl_(min,max)
#define _Ret_range_impl_(min,max)
#define _Deref_in_range_impl_(min,max)
#define _Deref_out_range_impl_(min,max)
#define _Deref_ret_range_impl_(min,max)

#define _Satisfies_impl_(expr)
#define _Pre_satisfies_impl_(expr)
#define _Post_satisfies_impl_(expr)

#define _Null_impl_
#define _Notnull_impl_
#define _Maybenull_impl_

#define _Valid_impl_
#define _Notvalid_impl_
#define _Maybevalid_impl_

#define _Field_range_impl_(min,max)

#define _Pre_impl_
#define _Pre1_impl_(p1)
#define _Pre2_impl_(p1,p2)
#define _Pre3_impl_(p1,p2,p3)

#define _Post_impl_
#define _Post1_impl_(p1)
#define _Post2_impl_(p1,p2)
#define _Post3_impl_(p1,p2,p3)

#define _Ret1_impl_(p1)
#define _Ret2_impl_(p1,p2)
#define _Ret3_impl_(p1,p2,p3)

#define _Deref_pre1_impl_(p1)
#define _Deref_pre2_impl_(p1,p2)
#define _Deref_pre3_impl_(p1,p2,p3)

#define _Deref_post1_impl_(p1)
#define _Deref_post2_impl_(p1,p2)
#define _Deref_post3_impl_(p1,p2,p3)

#define _Deref_ret1_impl_(p1)
#define _Deref_ret2_impl_(p1,p2)
#define _Deref_ret3_impl_(p1,p2,p3)

#define _Deref2_pre1_impl_(p1)
#define _Deref2_post1_impl_(p1)
#define _Deref2_ret1_impl_(p1)

#define _Readable_bytes_impl_(size)
#define _Readable_elements_impl_(size)
#define _Writable_bytes_impl_(size)
#define _Writable_elements_impl_(size)

#define _Null_terminated_impl_
#define _NullNull_terminated_impl_

// Obsolete -- may be needed for transition to attributes.
#define __inner_typefix(ctype)
#define __inner_exceptthat

#endif // ]
# 2149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/

#define __specstrings

#ifdef  __cplusplus // [
#ifndef __nothrow // [
# define __nothrow __declspec(nothrow)
#endif // ]
# 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
extern "C" {
#else // ][
# 2363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#ifndef __nothrow // [
# define __nothrow
#endif // ]
# 2366 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#endif  /* __cplusplus */ // ]
# 2367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*/

#if !defined(__midl) && defined(_PREFAST_) // [

    /*
     In the primitive "SAL_*" annotations "SAL" stands for Standard
     Annotation Language.  These "SAL_*" annotations are the
     primitives the compiler understands and high-level MACROs
     will decompose into these primivates.
    */

    #define _SA_SPECSTRIZE( x ) #x

    /*
     __null p
     __notnull p
     __maybenull p

     Annotates a pointer p. States that pointer p is null. Commonly used
     in the negated form __notnull or the possibly null form __maybenull.
    */

    #define __null                  _Null_impl_
    #define __notnull               _Notnull_impl_
    #define __maybenull             _Maybenull_impl_

    /*
     __readonly l
     __notreadonly l
     __mabyereadonly l

     Annotates a location l. States that location l is not modified after
     this point.  If the annotation is placed on the precondition state of
     a function, the restriction only applies until the postcondition state
     of the function.  __maybereadonly states that the annotated location
     may be modified, whereas __notreadonly states that a location must be
     modified.
    */

    #define __readonly              _Pre1_impl_(__readaccess_impl)
    #define __notreadonly           _Pre1_impl_(__allaccess_impl)
    #define __maybereadonly         _Pre1_impl_(__readaccess_impl)

    /*
     __valid v
     __notvalid v
     __maybevalid v

     Annotates any value v. States that the value satisfies all properties of
     valid values of its type. For example, for a string buffer, valid means
     that the buffer pointer is either NULL or points to a NULL-terminated string.
    */

    #define __valid                 _Valid_impl_
    #define __notvalid              _Notvalid_impl_
    #define __maybevalid            _Maybevalid_impl_

    /*
     __readableTo(extent) p

     Annotates a buffer pointer p.  If the buffer can be read, extent describes
     how much of the buffer is readable. For a reader of the buffer, this is
     an explicit permission to read up to that amount, rather than a restriction to
     read only up to it.
    */

    #define __readableTo(extent)    _SA_annotes1(SAL_readableTo, extent)

    /*

     __elem_readableTo(size)

     Annotates a buffer pointer p as being readable to size elements.
    */

    #define __elem_readableTo(size)   _SA_annotes1(SAL_readableTo, elementCount( size ))

    /*
     __byte_readableTo(size)

     Annotates a buffer pointer p as being readable to size bytes.
    */
    #define __byte_readableTo(size)   _SA_annotes1(SAL_readableTo, byteCount(size))

    /*
     __writableTo(extent) p

     Annotates a buffer pointer p. If the buffer can be modified, extent
     describes how much of the buffer is writable (usually the allocation
     size). For a writer of the buffer, this is an explicit permission to
     write up to that amount, rather than a restriction to write only up to it.
    */
    #define __writableTo(size)   _SA_annotes1(SAL_writableTo, size)

    /*
     __elem_writableTo(size)

     Annotates a buffer pointer p as being writable to size elements.
    */
    #define __elem_writableTo(size)   _SA_annotes1(SAL_writableTo, elementCount( size ))

    /*
     __byte_writableTo(size)

     Annotates a buffer pointer p as being writable to size bytes.
    */
    #define __byte_writableTo(size)   _SA_annotes1(SAL_writableTo, byteCount( size))

    /*
     __deref p

     Annotates a pointer p. The next annotation applies one dereference down
     in the type. If readableTo(p, size) then the next annotation applies to
     all elements *(p+i) for which i satisfies the size. If p is a pointer
     to a struct, the next annotation applies to all fields of the struct.
    */
    #define __deref                 _Deref_impl_

    /*
     __pre __next_annotation

     The next annotation applies in the precondition state
    */
    #define __pre                   _Pre_impl_

    /*
     __post __next_annotation

     The next annotation applies in the postcondition state
    */
    #define __post                  _Post_impl_

    /*
     __precond(<expr>)

     When <expr> is true, the next annotation applies in the precondition state
     (currently not enabled)
    */
    #define __precond(expr)         __pre

    /*
     __postcond(<expr>)

     When <expr> is true, the next annotation applies in the postcondition state
     (currently not enabled)
    */
    #define __postcond(expr)        __post

    /*
     __exceptthat

     Given a set of annotations Q containing __exceptthat maybeP, the effect of
     the except clause is to erase any P or notP annotations (explicit or
     implied) within Q at the same level of dereferencing that the except
     clause appears, and to replace it with maybeP.

      Example 1: __valid __pre_except_maybenull on a pointer p means that the
                 pointer may be null, and is otherwise valid, thus overriding
                 the implicit notnull annotation implied by __valid on
                 pointers.

      Example 2: __valid __deref __pre_except_maybenull on an int **p means
                 that p is not null (implied by valid), but the elements
                 pointed to by p could be null, and are otherwise valid.
    */
    #define __exceptthat                __inner_exceptthat

    /*
     _refparam

     Added to all out parameter macros to indicate that they are all reference
     parameters.
    */
    #define __refparam                  _Notref_ __deref __notreadonly

    /*
     __inner_*

     Helper macros that directly correspond to certain high-level annotations.

    */

    /*
     Macros to classify the entrypoints and indicate their category.

     Pre-defined control point categories include: RPC, LPC, DeviceDriver, UserToKernel, ISAPI, COM.

    */
    #define __inner_control_entrypoint(category) _SA_annotes2(SAL_entrypoint, controlEntry, category)


    /*
     Pre-defined data entry point categories include: Registry, File, Network.
    */
    #define __inner_data_entrypoint(category)    _SA_annotes2(SAL_entrypoint, dataEntry, category)

    #define __inner_override                    _SA_annotes0(__override)
    #define __inner_callback                    _SA_annotes0(__callback)
    #define __inner_blocksOn(resource)          _SA_annotes1(SAL_blocksOn, resource)
    #define __inner_fallthrough_dec             __inline __nothrow void __FallThrough() {}
    #define __inner_fallthrough                 __FallThrough();

    #define __post_except_maybenull     __post __inner_exceptthat _Maybenull_impl_
    #define __pre_except_maybenull      __pre  __inner_exceptthat _Maybenull_impl_

    #define __post_deref_except_maybenull       __post __deref __inner_exceptthat _Maybenull_impl_
    #define __pre_deref_except_maybenull    __pre  __deref __inner_exceptthat _Maybenull_impl_

    #define __inexpressible_readableTo(size)  _Readable_elements_impl_(_Inexpressible_(size))
    #define __inexpressible_writableTo(size)  _Writable_elements_impl_(_Inexpressible_(size))


#else // ][
# 2595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
    #define __null
    #define __notnull
    #define __maybenull
    #define __readonly
    #define __notreadonly
    #define __maybereadonly
    #define __valid
    #define __notvalid
    #define __maybevalid
    #define __readableTo(extent)
    #define __elem_readableTo(size)
    #define __byte_readableTo(size)
    #define __writableTo(size)
    #define __elem_writableTo(size)
    #define __byte_writableTo(size)
    #define __deref
    #define __pre
    #define __post
    #define __precond(expr)
    #define __postcond(expr)
    #define __exceptthat
    #define __inner_override
    #define __inner_callback
    #define __inner_blocksOn(resource)
    #define __inner_fallthrough_dec
    #define __inner_fallthrough
    #define __refparam
    #define __inner_control_entrypoint(category)
    #define __inner_data_entrypoint(category)

    #define __post_except_maybenull
    #define __pre_except_maybenull
    #define __post_deref_except_maybenull
    #define __pre_deref_except_maybenull

    #define __inexpressible_readableTo(size)
    #define __inexpressible_writableTo(size)

#endif /* !defined(__midl) && defined(_PREFAST_) */ // ]
# 2634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/

#define __ecount(size)                                           _SAL1_Source_(__ecount, (size), __notnull __elem_writableTo(size))
#define __bcount(size)                                           _SAL1_Source_(__bcount, (size), __notnull __byte_writableTo(size))
#define __in                                                     _SAL1_Source_(__in, (), _In_)
#define __in_ecount(size)                                        _SAL1_Source_(__in_ecount, (size), _In_reads_(size))
#define __in_bcount(size)                                        _SAL1_Source_(__in_bcount, (size), _In_reads_bytes_(size))
#define __in_z                                                   _SAL1_Source_(__in_z, (), _In_z_)
#define __in_ecount_z(size)                                      _SAL1_Source_(__in_ecount_z, (size), _In_reads_z_(size))
#define __in_bcount_z(size)                                      _SAL1_Source_(__in_bcount_z, (size), __in_bcount(size) __pre __nullterminated)
#define __in_nz                                                  _SAL1_Source_(__in_nz, (), __in)
#define __in_ecount_nz(size)                                     _SAL1_Source_(__in_ecount_nz, (size), __in_ecount(size))
#define __in_bcount_nz(size)                                     _SAL1_Source_(__in_bcount_nz, (size), __in_bcount(size))
#define __out                                                    _SAL1_Source_(__out, (), _Out_)
#define __out_ecount(size)                                       _SAL1_Source_(__out_ecount, (size), _Out_writes_(size))
#define __out_bcount(size)                                       _SAL1_Source_(__out_bcount, (size), _Out_writes_bytes_(size))
#define __out_ecount_part(size,length)                           _SAL1_Source_(__out_ecount_part, (size,length), _Out_writes_to_(size,length))
#define __out_bcount_part(size,length)                           _SAL1_Source_(__out_bcount_part, (size,length), _Out_writes_bytes_to_(size,length))
#define __out_ecount_full(size)                                  _SAL1_Source_(__out_ecount_full, (size), _Out_writes_all_(size))
#define __out_bcount_full(size)                                  _SAL1_Source_(__out_bcount_full, (size), _Out_writes_bytes_all_(size))
#define __out_z                                                  _SAL1_Source_(__out_z, (), __post __valid __refparam __post __nullterminated)
#define __out_z_opt                                              _SAL1_Source_(__out_z_opt, (), __post __valid __refparam __post __nullterminated __pre_except_maybenull)
#define __out_ecount_z(size)                                     _SAL1_Source_(__out_ecount_z, (size), __ecount(size) __post __valid __refparam __post __nullterminated)
#define __out_bcount_z(size)                                     _SAL1_Source_(__out_bcount_z, (size), __bcount(size) __post __valid __refparam __post __nullterminated)
#define __out_ecount_part_z(size,length)                         _SAL1_Source_(__out_ecount_part_z, (size,length), __out_ecount_part(size,length) __post __nullterminated)
#define __out_bcount_part_z(size,length)                         _SAL1_Source_(__out_bcount_part_z, (size,length), __out_bcount_part(size,length) __post __nullterminated)
#define __out_ecount_full_z(size)                                _SAL1_Source_(__out_ecount_full_z, (size), __out_ecount_full(size) __post __nullterminated)
#define __out_bcount_full_z(size)                                _SAL1_Source_(__out_bcount_full_z, (size), __out_bcount_full(size) __post __nullterminated)
#define __out_nz                                                 _SAL1_Source_(__out_nz, (), __post __valid __refparam)
#define __out_nz_opt                                             _SAL1_Source_(__out_nz_opt, (), __post __valid __refparam __post_except_maybenull_)
#define __out_ecount_nz(size)                                    _SAL1_Source_(__out_ecount_nz, (size), __ecount(size) __post __valid __refparam)
#define __out_bcount_nz(size)                                    _SAL1_Source_(__out_bcount_nz, (size), __bcount(size) __post __valid __refparam)
#define __inout                                                  _SAL1_Source_(__inout, (), _Inout_)
#define __inout_ecount(size)                                     _SAL1_Source_(__inout_ecount, (size), _Inout_updates_(size))
#define __inout_bcount(size)                                     _SAL1_Source_(__inout_bcount, (size), _Inout_updates_bytes_(size))
#define __inout_ecount_part(size,length)                         _SAL1_Source_(__inout_ecount_part, (size,length), _Inout_updates_to_(size,length))
#define __inout_bcount_part(size,length)                         _SAL1_Source_(__inout_bcount_part, (size,length), _Inout_updates_bytes_to_(size,length))
#define __inout_ecount_full(size)                                _SAL1_Source_(__inout_ecount_full, (size), _Inout_updates_all_(size))
#define __inout_bcount_full(size)                                _SAL1_Source_(__inout_bcount_full, (size), _Inout_updates_bytes_all_(size))
#define __inout_z                                                _SAL1_Source_(__inout_z, (), _Inout_z_)
#define __inout_ecount_z(size)                                   _SAL1_Source_(__inout_ecount_z, (size), _Inout_updates_z_(size))
#define __inout_bcount_z(size)                                   _SAL1_Source_(__inout_bcount_z, (size), __inout_bcount(size) __pre __nullterminated __post __nullterminated)
#define __inout_nz                                               _SAL1_Source_(__inout_nz, (), __inout)
#define __inout_ecount_nz(size)                                  _SAL1_Source_(__inout_ecount_nz, (size), __inout_ecount(size))
#define __inout_bcount_nz(size)                                  _SAL1_Source_(__inout_bcount_nz, (size), __inout_bcount(size))
#define __ecount_opt(size)                                       _SAL1_Source_(__ecount_opt, (size), __ecount(size)                              __pre_except_maybenull)
#define __bcount_opt(size)                                       _SAL1_Source_(__bcount_opt, (size), __bcount(size)                              __pre_except_maybenull)
#define __in_opt                                                 _SAL1_Source_(__in_opt, (), _In_opt_)
#define __in_ecount_opt(size)                                    _SAL1_Source_(__in_ecount_opt, (size), _In_reads_opt_(size))
#define __in_bcount_opt(size)                                    _SAL1_Source_(__in_bcount_opt, (size), _In_reads_bytes_opt_(size))
#define __in_z_opt                                               _SAL1_Source_(__in_z_opt, (), _In_opt_z_)
#define __in_ecount_z_opt(size)                                  _SAL1_Source_(__in_ecount_z_opt, (size), __in_ecount_opt(size) __pre __nullterminated)
#define __in_bcount_z_opt(size)                                  _SAL1_Source_(__in_bcount_z_opt, (size), __in_bcount_opt(size) __pre __nullterminated)
#define __in_nz_opt                                              _SAL1_Source_(__in_nz_opt, (), __in_opt)
#define __in_ecount_nz_opt(size)                                 _SAL1_Source_(__in_ecount_nz_opt, (size), __in_ecount_opt(size))
#define __in_bcount_nz_opt(size)                                 _SAL1_Source_(__in_bcount_nz_opt, (size), __in_bcount_opt(size))
#define __out_opt                                                _SAL1_Source_(__out_opt, (), _Out_opt_)
#define __out_ecount_opt(size)                                   _SAL1_Source_(__out_ecount_opt, (size), _Out_writes_opt_(size))
#define __out_bcount_opt(size)                                   _SAL1_Source_(__out_bcount_opt, (size), _Out_writes_bytes_opt_(size))
#define __out_ecount_part_opt(size,length)                       _SAL1_Source_(__out_ecount_part_opt, (size,length), __out_ecount_part(size,length)              __pre_except_maybenull)
#define __out_bcount_part_opt(size,length)                       _SAL1_Source_(__out_bcount_part_opt, (size,length), __out_bcount_part(size,length)              __pre_except_maybenull)
#define __out_ecount_full_opt(size)                              _SAL1_Source_(__out_ecount_full_opt, (size), __out_ecount_full(size)                     __pre_except_maybenull)
#define __out_bcount_full_opt(size)                              _SAL1_Source_(__out_bcount_full_opt, (size), __out_bcount_full(size)                     __pre_except_maybenull)
#define __out_ecount_z_opt(size)                                 _SAL1_Source_(__out_ecount_z_opt, (size), __out_ecount_opt(size) __post __nullterminated)
#define __out_bcount_z_opt(size)                                 _SAL1_Source_(__out_bcount_z_opt, (size), __out_bcount_opt(size) __post __nullterminated)
#define __out_ecount_part_z_opt(size,length)                     _SAL1_Source_(__out_ecount_part_z_opt, (size,length), __out_ecount_part_opt(size,length) __post __nullterminated)
#define __out_bcount_part_z_opt(size,length)                     _SAL1_Source_(__out_bcount_part_z_opt, (size,length), __out_bcount_part_opt(size,length) __post __nullterminated)
#define __out_ecount_full_z_opt(size)                            _SAL1_Source_(__out_ecount_full_z_opt, (size), __out_ecount_full_opt(size) __post __nullterminated)
#define __out_bcount_full_z_opt(size)                            _SAL1_Source_(__out_bcount_full_z_opt, (size), __out_bcount_full_opt(size) __post __nullterminated)
#define __out_ecount_nz_opt(size)                                _SAL1_Source_(__out_ecount_nz_opt, (size), __out_ecount_opt(size) __post __nullterminated)
#define __out_bcount_nz_opt(size)                                _SAL1_Source_(__out_bcount_nz_opt, (size), __out_bcount_opt(size) __post __nullterminated)
#define __inout_opt                                              _SAL1_Source_(__inout_opt, (), _Inout_opt_)
#define __inout_ecount_opt(size)                                 _SAL1_Source_(__inout_ecount_opt, (size), __inout_ecount(size)                        __pre_except_maybenull)
#define __inout_bcount_opt(size)                                 _SAL1_Source_(__inout_bcount_opt, (size), __inout_bcount(size)                        __pre_except_maybenull)
#define __inout_ecount_part_opt(size,length)                     _SAL1_Source_(__inout_ecount_part_opt, (size,length), __inout_ecount_part(size,length)            __pre_except_maybenull)
#define __inout_bcount_part_opt(size,length)                     _SAL1_Source_(__inout_bcount_part_opt, (size,length), __inout_bcount_part(size,length)            __pre_except_maybenull)
#define __inout_ecount_full_opt(size)                            _SAL1_Source_(__inout_ecount_full_opt, (size), __inout_ecount_full(size)                   __pre_except_maybenull)
#define __inout_bcount_full_opt(size)                            _SAL1_Source_(__inout_bcount_full_opt, (size), __inout_bcount_full(size)                   __pre_except_maybenull)
#define __inout_z_opt                                            _SAL1_Source_(__inout_z_opt, (), __inout_opt __pre __nullterminated __post __nullterminated)
#define __inout_ecount_z_opt(size)                               _SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)
#define __inout_ecount_z_opt(size)                               _SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)
#define __inout_bcount_z_opt(size)                               _SAL1_Source_(__inout_bcount_z_opt, (size), __inout_bcount_opt(size))
#define __inout_nz_opt                                           _SAL1_Source_(__inout_nz_opt, (), __inout_opt)
#define __inout_ecount_nz_opt(size)                              _SAL1_Source_(__inout_ecount_nz_opt, (size), __inout_ecount_opt(size))
#define __inout_bcount_nz_opt(size)                              _SAL1_Source_(__inout_bcount_nz_opt, (size), __inout_bcount_opt(size))
#define __deref_ecount(size)                                     _SAL1_Source_(__deref_ecount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __elem_writableTo(size))
#define __deref_bcount(size)                                     _SAL1_Source_(__deref_bcount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __byte_writableTo(size))
#define __deref_out                                              _SAL1_Source_(__deref_out, (), _Outptr_)
#define __deref_out_ecount(size)                                 _SAL1_Source_(__deref_out_ecount, (size), _Outptr_result_buffer_(size))
#define __deref_out_bcount(size)                                 _SAL1_Source_(__deref_out_bcount, (size), _Outptr_result_bytebuffer_(size))
#define __deref_out_ecount_part(size,length)                     _SAL1_Source_(__deref_out_ecount_part, (size,length), _Outptr_result_buffer_to_(size,length))
#define __deref_out_bcount_part(size,length)                     _SAL1_Source_(__deref_out_bcount_part, (size,length), _Outptr_result_bytebuffer_to_(size,length))
#define __deref_out_ecount_full(size)                            _SAL1_Source_(__deref_out_ecount_full, (size), __deref_out_ecount_part(size,size))
#define __deref_out_bcount_full(size)                            _SAL1_Source_(__deref_out_bcount_full, (size), __deref_out_bcount_part(size,size))
#define __deref_out_z                                            _SAL1_Source_(__deref_out_z, (), _Outptr_result_z_)
#define __deref_out_ecount_z(size)                               _SAL1_Source_(__deref_out_ecount_z, (size), __deref_out_ecount(size) __post __deref __nullterminated)
#define __deref_out_bcount_z(size)                               _SAL1_Source_(__deref_out_bcount_z, (size), __deref_out_bcount(size) __post __deref __nullterminated)
#define __deref_out_nz                                           _SAL1_Source_(__deref_out_nz, (), __deref_out)
#define __deref_out_ecount_nz(size)                              _SAL1_Source_(__deref_out_ecount_nz, (size), __deref_out_ecount(size))
#define __deref_out_bcount_nz(size)                              _SAL1_Source_(__deref_out_bcount_nz, (size), __deref_out_ecount(size))
#define __deref_inout                                            _SAL1_Source_(__deref_inout, (), _Notref_ __notnull _Notref_ __elem_readableTo(1) __pre __deref __valid __post _Notref_ __deref __valid __refparam)
#define __deref_inout_z                                          _SAL1_Source_(__deref_inout_z, (), __deref_inout __pre __deref __nullterminated __post _Notref_ __deref __nullterminated)
#define __deref_inout_ecount(size)                               _SAL1_Source_(__deref_inout_ecount, (size), __deref_inout __pre __deref __elem_writableTo(size) __post _Notref_ __deref __elem_writableTo(size))
#define __deref_inout_bcount(size)                               _SAL1_Source_(__deref_inout_bcount, (size), __deref_inout __pre __deref __byte_writableTo(size) __post _Notref_ __deref __byte_writableTo(size))
#define __deref_inout_ecount_part(size,length)                   _SAL1_Source_(__deref_inout_ecount_part, (size,length), __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length))
#define __deref_inout_bcount_part(size,length)                   _SAL1_Source_(__deref_inout_bcount_part, (size,length), __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length))
#define __deref_inout_ecount_full(size)                          _SAL1_Source_(__deref_inout_ecount_full, (size), __deref_inout_ecount_part(size,size))
#define __deref_inout_bcount_full(size)                          _SAL1_Source_(__deref_inout_bcount_full, (size), __deref_inout_bcount_part(size,size))
#define __deref_inout_ecount_z(size)                             _SAL1_Source_(__deref_inout_ecount_z, (size), __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_bcount_z(size)                             _SAL1_Source_(__deref_inout_bcount_z, (size), __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_nz                                         _SAL1_Source_(__deref_inout_nz, (), __deref_inout)
#define __deref_inout_ecount_nz(size)                            _SAL1_Source_(__deref_inout_ecount_nz, (size), __deref_inout_ecount(size))
#define __deref_inout_bcount_nz(size)                            _SAL1_Source_(__deref_inout_bcount_nz, (size), __deref_inout_ecount(size))
#define __deref_ecount_opt(size)                                 _SAL1_Source_(__deref_ecount_opt, (size), __deref_ecount(size)                        __post_deref_except_maybenull)
#define __deref_bcount_opt(size)                                 _SAL1_Source_(__deref_bcount_opt, (size), __deref_bcount(size)                        __post_deref_except_maybenull)
#define __deref_out_opt                                          _SAL1_Source_(__deref_out_opt, (), __deref_out                                 __post_deref_except_maybenull)
#define __deref_out_ecount_opt(size)                             _SAL1_Source_(__deref_out_ecount_opt, (size), __deref_out_ecount(size)                    __post_deref_except_maybenull)
#define __deref_out_bcount_opt(size)                             _SAL1_Source_(__deref_out_bcount_opt, (size), __deref_out_bcount(size)                    __post_deref_except_maybenull)
#define __deref_out_ecount_part_opt(size,length)                 _SAL1_Source_(__deref_out_ecount_part_opt, (size,length), __deref_out_ecount_part(size,length)        __post_deref_except_maybenull)
#define __deref_out_bcount_part_opt(size,length)                 _SAL1_Source_(__deref_out_bcount_part_opt, (size,length), __deref_out_bcount_part(size,length)        __post_deref_except_maybenull)
#define __deref_out_ecount_full_opt(size)                        _SAL1_Source_(__deref_out_ecount_full_opt, (size), __deref_out_ecount_full(size)               __post_deref_except_maybenull)
#define __deref_out_bcount_full_opt(size)                        _SAL1_Source_(__deref_out_bcount_full_opt, (size), __deref_out_bcount_full(size)               __post_deref_except_maybenull)
#define __deref_out_z_opt                                        _SAL1_Source_(__deref_out_z_opt, (), _Outptr_result_maybenull_z_)
#define __deref_out_ecount_z_opt(size)                           _SAL1_Source_(__deref_out_ecount_z_opt, (size), __deref_out_ecount_opt(size) __post __deref __nullterminated)
#define __deref_out_bcount_z_opt(size)                           _SAL1_Source_(__deref_out_bcount_z_opt, (size), __deref_out_bcount_opt(size) __post __deref __nullterminated)
#define __deref_out_nz_opt                                       _SAL1_Source_(__deref_out_nz_opt, (), __deref_out_opt)
#define __deref_out_ecount_nz_opt(size)                          _SAL1_Source_(__deref_out_ecount_nz_opt, (size), __deref_out_ecount_opt(size))
#define __deref_out_bcount_nz_opt(size)                          _SAL1_Source_(__deref_out_bcount_nz_opt, (size), __deref_out_bcount_opt(size))
#define __deref_inout_opt                                        _SAL1_Source_(__deref_inout_opt, (), __deref_inout                               __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_opt(size)                           _SAL1_Source_(__deref_inout_ecount_opt, (size), __deref_inout_ecount(size)                  __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_opt(size)                           _SAL1_Source_(__deref_inout_bcount_opt, (size), __deref_inout_bcount(size)                  __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_part_opt(size,length)               _SAL1_Source_(__deref_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part(size,length)      __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_part_opt(size,length)               _SAL1_Source_(__deref_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part(size,length)      __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_full_opt(size)                      _SAL1_Source_(__deref_inout_ecount_full_opt, (size), __deref_inout_ecount_full(size)             __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_full_opt(size)                      _SAL1_Source_(__deref_inout_bcount_full_opt, (size), __deref_inout_bcount_full(size)             __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_z_opt                                      _SAL1_Source_(__deref_inout_z_opt, (), __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_ecount_z_opt(size)                         _SAL1_Source_(__deref_inout_ecount_z_opt, (size), __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_bcount_z_opt(size)                         _SAL1_Source_(__deref_inout_bcount_z_opt, (size), __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_nz_opt                                     _SAL1_Source_(__deref_inout_nz_opt, (), __deref_inout_opt)
#define __deref_inout_ecount_nz_opt(size)                        _SAL1_Source_(__deref_inout_ecount_nz_opt, (size), __deref_inout_ecount_opt(size))
#define __deref_inout_bcount_nz_opt(size)                        _SAL1_Source_(__deref_inout_bcount_nz_opt, (size), __deref_inout_bcount_opt(size))
#define __deref_opt_ecount(size)                                 _SAL1_Source_(__deref_opt_ecount, (size), __deref_ecount(size)                        __pre_except_maybenull)
#define __deref_opt_bcount(size)                                 _SAL1_Source_(__deref_opt_bcount, (size), __deref_bcount(size)                        __pre_except_maybenull)
#define __deref_opt_out                                          _SAL1_Source_(__deref_opt_out, (), _Outptr_opt_)
#define __deref_opt_out_z                                        _SAL1_Source_(__deref_opt_out_z, (), _Outptr_opt_result_z_)
#define __deref_opt_out_ecount(size)                             _SAL1_Source_(__deref_opt_out_ecount, (size), __deref_out_ecount(size)                    __pre_except_maybenull)
#define __deref_opt_out_bcount(size)                             _SAL1_Source_(__deref_opt_out_bcount, (size), __deref_out_bcount(size)                    __pre_except_maybenull)
#define __deref_opt_out_ecount_part(size,length)                 _SAL1_Source_(__deref_opt_out_ecount_part, (size,length), __deref_out_ecount_part(size,length)        __pre_except_maybenull)
#define __deref_opt_out_bcount_part(size,length)                 _SAL1_Source_(__deref_opt_out_bcount_part, (size,length), __deref_out_bcount_part(size,length)        __pre_except_maybenull)
#define __deref_opt_out_ecount_full(size)                        _SAL1_Source_(__deref_opt_out_ecount_full, (size), __deref_out_ecount_full(size)               __pre_except_maybenull)
#define __deref_opt_out_bcount_full(size)                        _SAL1_Source_(__deref_opt_out_bcount_full, (size), __deref_out_bcount_full(size)               __pre_except_maybenull)
#define __deref_opt_inout                                        _SAL1_Source_(__deref_opt_inout, (), _Inout_opt_)
#define __deref_opt_inout_ecount(size)                           _SAL1_Source_(__deref_opt_inout_ecount, (size), __deref_inout_ecount(size)                  __pre_except_maybenull)
#define __deref_opt_inout_bcount(size)                           _SAL1_Source_(__deref_opt_inout_bcount, (size), __deref_inout_bcount(size)                  __pre_except_maybenull)
#define __deref_opt_inout_ecount_part(size,length)               _SAL1_Source_(__deref_opt_inout_ecount_part, (size,length), __deref_inout_ecount_part(size,length)      __pre_except_maybenull)
#define __deref_opt_inout_bcount_part(size,length)               _SAL1_Source_(__deref_opt_inout_bcount_part, (size,length), __deref_inout_bcount_part(size,length)      __pre_except_maybenull)
#define __deref_opt_inout_ecount_full(size)                      _SAL1_Source_(__deref_opt_inout_ecount_full, (size), __deref_inout_ecount_full(size)             __pre_except_maybenull)
#define __deref_opt_inout_bcount_full(size)                      _SAL1_Source_(__deref_opt_inout_bcount_full, (size), __deref_inout_bcount_full(size)             __pre_except_maybenull)
#define __deref_opt_inout_z                                      _SAL1_Source_(__deref_opt_inout_z, (), __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_ecount_z(size)                         _SAL1_Source_(__deref_opt_inout_ecount_z, (size), __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_bcount_z(size)                         _SAL1_Source_(__deref_opt_inout_bcount_z, (size), __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_nz                                     _SAL1_Source_(__deref_opt_inout_nz, (), __deref_opt_inout)
#define __deref_opt_inout_ecount_nz(size)                        _SAL1_Source_(__deref_opt_inout_ecount_nz, (size), __deref_opt_inout_ecount(size))
#define __deref_opt_inout_bcount_nz(size)                        _SAL1_Source_(__deref_opt_inout_bcount_nz, (size), __deref_opt_inout_bcount(size))
#define __deref_opt_ecount_opt(size)                             _SAL1_Source_(__deref_opt_ecount_opt, (size), __deref_ecount_opt(size)                    __pre_except_maybenull)
#define __deref_opt_bcount_opt(size)                             _SAL1_Source_(__deref_opt_bcount_opt, (size), __deref_bcount_opt(size)                    __pre_except_maybenull)
#define __deref_opt_out_opt                                      _SAL1_Source_(__deref_opt_out_opt, (), _Outptr_opt_result_maybenull_)
#define __deref_opt_out_ecount_opt(size)                         _SAL1_Source_(__deref_opt_out_ecount_opt, (size), __deref_out_ecount_opt(size)                __pre_except_maybenull)
#define __deref_opt_out_bcount_opt(size)                         _SAL1_Source_(__deref_opt_out_bcount_opt, (size), __deref_out_bcount_opt(size)                __pre_except_maybenull)
#define __deref_opt_out_ecount_part_opt(size,length)             _SAL1_Source_(__deref_opt_out_ecount_part_opt, (size,length), __deref_out_ecount_part_opt(size,length)    __pre_except_maybenull)
#define __deref_opt_out_bcount_part_opt(size,length)             _SAL1_Source_(__deref_opt_out_bcount_part_opt, (size,length), __deref_out_bcount_part_opt(size,length)    __pre_except_maybenull)
#define __deref_opt_out_ecount_full_opt(size)                    _SAL1_Source_(__deref_opt_out_ecount_full_opt, (size), __deref_out_ecount_full_opt(size)           __pre_except_maybenull)
#define __deref_opt_out_bcount_full_opt(size)                    _SAL1_Source_(__deref_opt_out_bcount_full_opt, (size), __deref_out_bcount_full_opt(size)           __pre_except_maybenull)
#define __deref_opt_out_z_opt                                    _SAL1_Source_(__deref_opt_out_z_opt, (), __post __deref __valid __refparam __pre_except_maybenull __pre_deref_except_maybenull __post_deref_except_maybenull __post __deref __nullterminated)
#define __deref_opt_out_ecount_z_opt(size)                       _SAL1_Source_(__deref_opt_out_ecount_z_opt, (size), __deref_opt_out_ecount_opt(size) __post __deref __nullterminated)
#define __deref_opt_out_bcount_z_opt(size)                       _SAL1_Source_(__deref_opt_out_bcount_z_opt, (size), __deref_opt_out_bcount_opt(size) __post __deref __nullterminated)
#define __deref_opt_out_nz_opt                                   _SAL1_Source_(__deref_opt_out_nz_opt, (), __deref_opt_out_opt)
#define __deref_opt_out_ecount_nz_opt(size)                      _SAL1_Source_(__deref_opt_out_ecount_nz_opt, (size), __deref_opt_out_ecount_opt(size))
#define __deref_opt_out_bcount_nz_opt(size)                      _SAL1_Source_(__deref_opt_out_bcount_nz_opt, (size), __deref_opt_out_bcount_opt(size))
#define __deref_opt_inout_opt                                    _SAL1_Source_(__deref_opt_inout_opt, (), __deref_inout_opt                           __pre_except_maybenull)
#define __deref_opt_inout_ecount_opt(size)                       _SAL1_Source_(__deref_opt_inout_ecount_opt, (size), __deref_inout_ecount_opt(size)              __pre_except_maybenull)
#define __deref_opt_inout_bcount_opt(size)                       _SAL1_Source_(__deref_opt_inout_bcount_opt, (size), __deref_inout_bcount_opt(size)              __pre_except_maybenull)
#define __deref_opt_inout_ecount_part_opt(size,length)           _SAL1_Source_(__deref_opt_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part_opt(size,length)  __pre_except_maybenull)
#define __deref_opt_inout_bcount_part_opt(size,length)           _SAL1_Source_(__deref_opt_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part_opt(size,length)  __pre_except_maybenull)
#define __deref_opt_inout_ecount_full_opt(size)                  _SAL1_Source_(__deref_opt_inout_ecount_full_opt, (size), __deref_inout_ecount_full_opt(size)         __pre_except_maybenull)
#define __deref_opt_inout_bcount_full_opt(size)                  _SAL1_Source_(__deref_opt_inout_bcount_full_opt, (size), __deref_inout_bcount_full_opt(size)         __pre_except_maybenull)
#define __deref_opt_inout_z_opt                                  _SAL1_Source_(__deref_opt_inout_z_opt, (), __deref_opt_inout_opt  __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_ecount_z_opt(size)                     _SAL1_Source_(__deref_opt_inout_ecount_z_opt, (size), __deref_opt_inout_ecount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_bcount_z_opt(size)                     _SAL1_Source_(__deref_opt_inout_bcount_z_opt, (size), __deref_opt_inout_bcount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_nz_opt                                 _SAL1_Source_(__deref_opt_inout_nz_opt, (), __deref_opt_inout_opt)
#define __deref_opt_inout_ecount_nz_opt(size)                    _SAL1_Source_(__deref_opt_inout_ecount_nz_opt, (size), __deref_opt_inout_ecount_opt(size))
#define __deref_opt_inout_bcount_nz_opt(size)                    _SAL1_Source_(__deref_opt_inout_bcount_nz_opt, (size), __deref_opt_inout_bcount_opt(size))

/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/

#define __success(expr)                      _SAL1_1_Source_(__success, (expr), _Success_(expr))
#define __nullterminated                     _SAL1_Source_(__nullterminated, (), _Null_terminated_)
#define __nullnullterminated                 _SAL1_Source_(__nullnulltermiated, (), _SAL_nop_impl_)
#define __reserved                           _SAL1_Source_(__reserved, (), _Reserved_)
#define __checkReturn                        _SAL1_Source_(__checkReturn, (), _Check_return_)
#define __typefix(ctype)                     _SAL1_Source_(__typefix, (ctype), __inner_typefix(ctype))
#define __override                           __inner_override
#define __callback                           __inner_callback
#define __format_string                      _SAL1_1_Source_(__format_string, (), _Printf_format_string_)
#define __blocksOn(resource)                 _SAL_L_Source_(__blocksOn, (resource), __inner_blocksOn(resource))
#define __control_entrypoint(category)       _SAL_L_Source_(__control_entrypoint, (category), __inner_control_entrypoint(category))
#define __data_entrypoint(category)          _SAL_L_Source_(__data_entrypoint, (category), __inner_data_entrypoint(category))

#ifdef _USING_V110_SDK71_ // [
#ifndef _PREFAST_ // [
#define __useHeader
#else // ][
# 2863 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#error Code analysis is not supported when using Visual C++ 11.0/12.0 with the Windows 7.1 SDK.
#endif // ]
# 2865 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#else // ][
# 2866 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define __useHeader                          _Use_decl_anno_impl_
#endif // ]
# 2868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#ifdef _USING_V110_SDK71_ // [
#ifndef _PREFAST_ // [
#define __on_failure(annotes)
#else // ][
# 2873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#error Code analysis is not supported when using Visual C++ 11.0/12.0 with the Windows 7.1 SDK.
#endif // ]
# 2875 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#else // ][
# 2876 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define __on_failure(annotes)                _SAL1_1_Source_(__on_failure, (annotes), _On_failure_impl_(annotes _SAL_nop_impl_))
#endif // ]
# 2878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#ifndef __fallthrough // [
    __inner_fallthrough_dec
    #define __fallthrough __inner_fallthrough
#endif // ]
# 2883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#ifndef __analysis_assume // [
#ifdef _PREFAST_ // [
#define __analysis_assume(expr) __assume(expr)
#else // ][
# 2888 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define __analysis_assume(expr)
#endif // ]
# 2890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#endif // ]
# 2891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#ifndef _Analysis_assume_ // [
#ifdef _PREFAST_ // [
#define _Analysis_assume_(expr) __assume(expr)
#else // ][
# 2896 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define _Analysis_assume_(expr)
#endif // ]
# 2898 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#endif // ]
# 2899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#define _Analysis_noreturn_    _SAL2_Source_(_Analysis_noreturn_, (), _SA_annotes0(SAL_terminates))

#ifdef _PREFAST_ // [
__inline __nothrow
void __AnalysisAssumeNullterminated(_Post_ _Null_terminated_ void *p);

#define _Analysis_assume_nullterminated_(x) __AnalysisAssumeNullterminated(x)

#else // ][
# 2909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
#define _Analysis_assume_nullterminated_(x)
#endif // ]
# 2911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

//
// Set the analysis mode (global flags to analysis).
// They take effect at the point of declaration; use at global scope
// as a declaration.
//

// Synthesize a unique symbol.
#define ___MKID(x, y) x ## y
#define __MKID(x, y) ___MKID(x, y)
#define __GENSYM(x) __MKID(x, __COUNTER__)

__ANNOTATION(SAL_analysisMode(__AuToQuOtE __In_impl_ char *mode);)

#define _Analysis_mode_impl_(mode) _SAL2_Source_(_Analysis_mode_impl_, (mode), _SA_annotes1(SAL_analysisMode, #mode))

//
// Floating point warnings are only meaningful in kernel-mode on x86
// so avoid reporting them on other platforms.
//
#ifndef _M_IX86 // [

#define _Analysis_mode_(mode)                                                 \
    __pragma(warning(disable: 28110 28111 28161 28162))                       \
    typedef _Analysis_mode_impl_(mode) int                                    \
        __GENSYM(__prefast_analysis_mode_flag);

#else // ][
# 2939 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#define _Analysis_mode_(mode)                                                 \
    typedef _Analysis_mode_impl_(mode) int                                    \
        __GENSYM(__prefast_analysis_mode_flag);

#endif // ]
# 2945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

// The following are predefined:
//  _Analysis_operator_new_throw_   (operator new throws)
//  _Analysis_operator_new_null_        (operator new returns null)
//  _Analysis_operator_new_never_fails_ (operator new never fails)
//

// Function class annotations.
__ANNOTATION(SAL_functionClassNew(__In_impl_ char*);)
__PRIMOP(int, _In_function_class_(__In_impl_ char*);)
#define _In_function_class_(x)  _In_function_class_(#x)
#define _Called_from_function_class_(x) _In_function_class_(x)

#define _Function_class_(x)  _SAL2_Source_(_Function_class_, (x), _SA_annotes1(SAL_functionClassNew, _SA_SPECSTRIZE(x)))

#define _Enum_is_bitflag_    _SAL2_Source_(_Enum_is_bitflag_, (), _SA_annotes0(SAL_enumIsBitflag))
#define _Strict_type_match_  _SAL2_Source_(_Strict_type_match, (), _SA_annotes0(SAL_strictType2))

#define _Maybe_raises_SEH_exception_   _SAL2_Source_(_Maybe_raises_SEH_exception_, (x), _Pre_ _SA_annotes1(SAL_inTry,__yes))
#define _Raises_SEH_exception_         _SAL2_Source_(_Raises_SEH_exception_, (x), _Maybe_raises_SEH_exception_ _Analysis_noreturn_)

#ifdef  __cplusplus // [
}
#endif // ]
# 2969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <concurrencysal.h>
#endif /* expanded by -frewrite-includes */
# 2970 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 1 3
/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/

#ifndef CONCURRENCYSAL_H
#define CONCURRENCYSAL_H

#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

#ifdef  __cplusplus // [
extern "C" {
#endif  // ]
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

#if !defined(__midl) && defined(_PREFAST_) && !defined(_SDV_)

__ANNOTATION(SAL_guarded_by(__deferTypecheck void *));
__ANNOTATION(SAL_write_guarded_by(__deferTypecheck void *));
__ANNOTATION(SAL_requires_lock_held(__deferTypecheck void *));
__ANNOTATION(SAL_requires_exclusive_lock_held(__deferTypecheck void *));
__ANNOTATION(SAL_requires_shared_lock_held(__deferTypecheck void *));
__ANNOTATION(SAL_requires_lock_not_held(__deferTypecheck void *));
__ANNOTATION(SAL_requires_no_locks_held(void));
__ANNOTATION(SAL_set_lock_count_to_zero(__deferTypecheck void *));
__ANNOTATION(SAL_set_lock_count_to_one(__deferTypecheck void *));
__ANNOTATION(SAL_acquires_lock(__deferTypecheck void *));
__ANNOTATION(SAL_acquires_exclusive_lock(__deferTypecheck void *));
__ANNOTATION(SAL_acquires_shared_lock(__deferTypecheck void *));
__ANNOTATION(SAL_releases_lock(__deferTypecheck void *));
__ANNOTATION(SAL_releases_exclusive_lock(__deferTypecheck void *));
__ANNOTATION(SAL_releases_shared_lock(__deferTypecheck void *));
__ANNOTATION(SAL_ignore_lock_match(__deferTypecheck void *));
__ANNOTATION(SAL_has_lock_property(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_has_lock_level(__AuToQuOtE __In_impl_ char *));
__ANNOTATION(SAL_lock_level_order(__deferTypecheck void *, __deferTypecheck void *));
__ANNOTATION(SAL_no_competing_thread(void));
__ANNOTATION(SAL_set_same_lock(__deferTypecheck void *, __deferTypecheck void *));

/*
 * pre-defined global system locks
 */
extern int _Global_interlock_;
extern int _Global_cancel_spin_lock_;
extern int _Global_critical_region_;

/*
 * Annotation identifiers
 */
#define _Internal_create_CSAL_identifier_(id) const char id##[] = "";

_Internal_create_CSAL_identifier_(_Lock_kind_mutex_)
_Internal_create_CSAL_identifier_(_Lock_kind_event_)
_Internal_create_CSAL_identifier_(_Lock_kind_semaphore_)
_Internal_create_CSAL_identifier_(_Lock_kind_spin_lock_)
_Internal_create_CSAL_identifier_(_Lock_kind_critical_section_)

/*
 * data protection
 */
#define _Guarded_by_(lock) _SAL2_Source_(_Guarded_by_, (lock), _SA_annotes1(SAL_guarded_by,lock))
#define _Write_guarded_by_(lock) _SAL2_Source_(_Write_guarded_by_, (lock), _SA_annotes1(SAL_write_guarded_by,lock))
#define _Interlocked_ _Guarded_by_(_Global_interlock_)

/*
 * interlocked operand used in interlocked instructions
 */
#ifndef _Interlocked_operand_
#define _Interlocked_operand_ _SAL2_Source_(_Interlocked_operand_, (), _Pre_ _SA_annotes0(SAL_interlocked))
#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

/*
 * caller/callee locking contracts
 */
#define _Requires_lock_held_(lock)  _SAL2_Source_(_Requires_lock_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_lock_held,lock))
#define _Requires_exclusive_lock_held_(lock)  _SAL2_Source_(_Requires_exclusive_lock_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_exclusive_lock_held,lock))
#define _Requires_shared_lock_held_(lock)  _SAL2_Source_(_Requires_shared_lock_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_shared_lock_held,lock))

#define _Requires_lock_not_held_(lock)  _SAL2_Source_(_Requires_lock_not_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_lock_not_held,lock))
#define _Requires_no_locks_held_  _SAL2_Source_(_Requires_no_locks_held_, (), _Pre_ _SA_annotes0(SAL_requires_no_locks_held))

/*
 * acquire/release locking side effects
 */
#define _Acquires_lock_(lock)  _SAL2_Source_(_Acquires_lock_, (lock), _Post_ _SA_annotes1(SAL_acquires_lock,lock))
#define _Acquires_exclusive_lock_(lock)  _SAL2_Source_(_Acquires_exclusive_lock_, (lock), _Post_ _SA_annotes1(SAL_acquires_exclusive_lock,lock))
#define _Acquires_shared_lock_(lock)  _SAL2_Source_(_Acquires_shared_lock_, (lock), _Post_ _SA_annotes1(SAL_acquires_shared_lock,lock))

#define _Releases_lock_(lock)  _SAL2_Source_(_Releases_lock_, (lock), _Post_ _SA_annotes1(SAL_releases_lock,lock))
#define _Releases_exclusive_lock_(lock)  _SAL2_Source_(_Releases_exclusive_lock_, (lock), _Post_ _SA_annotes1(SAL_releases_exclusive_lock,lock))
#define _Releases_shared_lock_(lock)  _SAL2_Source_(_Releases_shared_lock_, (lock), _Post_ _SA_annotes1(SAL_releases_shared_lock,lock))

/*
 * acquire/release locking side effects for non-reentrant locks
 */
#define _Acquires_nonreentrant_lock_(lock) \
     _SAL2_Source_(_Acquires_nonreentrant_lock_, (lock), \
    _Requires_lock_not_held_(lock) \
    _Acquires_lock_(lock))

#define _Releases_nonreentrant_lock_(lock) \
     _SAL2_Source_(_Releases_nonreentrant_lock_, (lock), \
    _Requires_lock_held_(lock) \
    _Releases_lock_(lock))

#define _Post_same_lock_(a,b)  _SAL2_Source_(_Post_same_lock_, (a,b), _Post_ _SA_annotes2(SAL_set_same_lock,a,b))

/*
 * lock level
 */
#define _Create_lock_level_(level) _Internal_create_CSAL_identifier_(level)

#define _Has_lock_level_(level)  _SAL2_Source_(_Has_lock_level_, (level), _SA_annotes1(SAL_has_lock_level,#level))

#define _Internal_lock_level_order_(a,b)  _SAL2_Source_(_Internal_lock_level_order_, (a,b), _SA_annotes2(SAL_lock_level_order,a,b))
#define _Csalcat1_(x,y) x##y
#define _Csalcat2_(x,y) _Csalcat1_(x,y)

#define _Lock_level_order_(a,b) \
    extern _Internal_lock_level_order_(a,b) void _Sal_order_##a##_##b(_In_z_ const char*a, _In_z_ const char*b); \
    static __inline void CSALCAT2(CSAL_LockOrder,__COUNTER__)(void){_Sal_order_##a##_##b(#a,#b);}

/*
 * threading context
 */
#define _No_competing_thread_  _SAL2_Source_(_No_competing_thread_, (), _Pre_ _SA_annotes0(SAL_no_competing_thread))

/*
 * refinement and suppression
 */
extern _Acquires_lock_(*plock) void _Internal_acquires_lock_(void* plock);
extern _Releases_lock_(*plock) void _Internal_releases_lock_(void* plock);

#define _Internal_set_lock_count_to_zero_(lock)  _SAL2_Source_(Internal_set_lock_count_to_zero_, (lock), _Post_ _SA_annotes1(SAL_set_lock_count_to_zero,lock))
#define _Internal_set_lock_count_to_one_(lock)  _SAL2_Source_(_Internal_set_lock_count_to_one_, (lock), _Post_ _SA_annotes1(SAL_set_lock_count_to_one,lock))

extern _Internal_set_lock_count_to_one_(*plock) void _Internal_lock_held_(void* plock);
extern _Internal_set_lock_count_to_zero_(*plock) void _Internal_lock_not_held_(void* plock);
extern _Post_same_lock_(*plock1, *plock2) void _Internal_same_lock_(void* plock1, void* plock2);

#define _Analysis_assume_lock_acquired_(lock)  _Internal_acquires_lock_((void*)(&(lock)))
#define _Analysis_assume_lock_released_(lock)  _Internal_releases_lock_((void*)(&(lock)))

#define _Analysis_assume_lock_held_(lock) _Internal_lock_held_((void*)(&(lock)))
#define _Analysis_assume_lock_not_held_(lock) _Internal_lock_not_held_((void*)(&(lock)))
#define _Analysis_assume_same_lock_(lock1, lock2) _Internal_same_lock_((void*)(&(lock1)), (void*)(&(lock2)))

/*
 * _Function_ignore_lock_checking_ may be deprecated in future versions of SAL
 */
#define _Function_ignore_lock_checking_(lock)  _SAL2_Source_(_Function_ignore_lock_checking_, (lock), _Pre_ _SA_annotes1(SAL_ignore_lock_match,lock))
extern _Function_ignore_lock_checking_(*plock) void _Internal_suppress_lock_checking_(void* plock);

/*
 * _Analysis_suppress_lock_checking_ may be deprecated in future versions of SAL
 */
#define _Analysis_suppress_lock_checking_(lock) _Internal_suppress_lock_checking_((void*)(&(lock)));

#define _Benign_race_begin_ __pragma(warning(push)) __pragma(warning(disable:26100 26101 26150 26130 26180 26131 26181 28112))
#define _Benign_race_end_ __pragma(warning(pop))

#define _No_competing_thread_begin_ __pragma(warning(push)) __pragma(warning(disable:26100 26101 26150 26101 26151 26110 26160 26130 26180 26131 26181 28112))
#define _No_competing_thread_end_ __pragma(warning(pop))

/*
 * lock kinds
 */
#define _Has_lock_kind_(kind)  _SAL2_Source_(_Has_lock_kind_, (kind), _SA_annotes1(SAL_has_lock_property,#kind))


/*
 * Old spelling
 * Note: the old version may be deprecated in the future!!!
 */
extern int __system_interlock;
extern int __system_cancel_spinlock;
extern int __system_critical_region;

#define __guarded_by(lock) _SAL1_1_Source_(__guarded_by, (lock), _SA_annotes1(SAL_guarded_by,lock))
#define __write_guarded_by(lock) _SAL1_1_Source_(__write_guarded_by, (lock), _SA_annotes1(SAL_write_guarded_by,lock))
#define __interlocked __guarded_by(_Global_interlock_)

/*
 * caller/callee locking contracts
 */
#define __requires_lock_held(lock) _SAL1_1_Source_(__requires_lock_held, (lock), __pre _SA_annotes1(SAL_requires_lock_held,lock))
#define __requires_exclusive_lock_held(lock) _SAL1_1_Source_(__requires_exclusive_lock_held, (lock), __pre _SA_annotes1(SAL_requires_exclusive_lock_held,lock))
#define __requires_shared_lock_held(lock) _SAL1_1_Source_(__requires_shared_lock_held, (lock), __pre _SA_annotes1(SAL_requires_shared_lock_held,lock))

#define __requires_lock_not_held(lock) _SAL1_1_Source_(__requires_lock_not_held, (lock), __pre _SA_annotes1(SAL_requires_lock_not_held,lock))
#define __requires_no_locks_held _SAL1_1_Source_(__requires_no_locks_held, (), __pre _SA_annotes0(SAL_requires_no_locks_held))

/*
 * acquire/release locking side effects
 */
#define __acquires_lock(lock) _SAL1_1_Source_(__acquires_lock, (lock), __post _SA_annotes1(SAL_acquires_lock,lock))
#define __acquires_exclusive_lock(lock) _SAL1_1_Source_(__acquires_exclusive_lock, (lock), __post _SA_annotes1(SAL_acquires_exclusive_lock,lock))
#define __acquires_shared_lock(lock) _SAL1_1_Source_(__acquires_shared_lock, (lock), __post _SA_annotes1(SAL_acquires_shared_lock,lock))

#define __releases_lock(lock) _SAL1_1_Source_(__releases_lock, (lock), __post _SA_annotes1(SAL_releases_lock,lock))
#define __releases_exclusive_lock(lock) _SAL1_1_Source_(__releases_exclusive_lock, (lock),__post _SA_annotes1(SAL_releases_exclusive_lock,lock))
#define __releases_shared_lock(lock) _SAL1_1_Source_(__releases_shared_lock, (lock), __post _SA_annotes1(SAL_releases_shared_lock,lock))

/*
 * lock properties
 * The following kind options are supported:
 * __has_lock_property(MUTEX)
 * __has_lock_property(EVENT)
 * __has_lock_property(SEMAPHORE)
 * __has_lock_property(OTHER_HANDLE)
 * __has_lock_property(REENTRANT)
 * __has_lock_property(NON_REENTRANT)
 */
#define __has_lock_property(kind) _SAL1_1_Source_(__has_lock_property, (kind), _SA_annotes1(SAL_has_lock_property,#kind))

/*
 * lock level
 */
#define __declare_lock_level(level) _Internal_create_CSAL_identifier_(level)
#define __has_lock_level(level) _SAL1_1_Source_(__has_lock_level, (level), _SA_annotes1(SAL_has_lock_level,#level))

#define __internal_lock_level_order(a,b) _SAL1_1_Source_(__internal_lock_level_order, (a,b), _SA_annotes2(SAL_lock_level_order,#a,#b))
#define CSALCAT1(x,y) x##y
#define CSALCAT2(x,y) CSALCAT1(x,y)

#define __lock_level_order(a,b) \
    extern __internal_lock_level_order(a,b) void __sal_order_##a##_##b(__in_z char*a, __in_z char*b); \
    static __inline void CSALCAT2(CSAL_LockOrder,__COUNTER__)(void){__sal_order_##a##_##b(#a,#b);}

/*
 * threading context
 */
#define __no_competing_thread _SAL1_1_Source_(__no_competing_thread, (), __pre _SA_annotes0(SAL_no_competing_thread))

/*
 * refinement and suppression
 */
extern __acquires_lock(*plock) void __internal_acquires_lock(void* plock);
extern __releases_lock(*plock) void __internal_releases_lock(void* plock);

#define __analysis_assume_lock_acquired(lock) __internal_acquires_lock((void*)(&(lock)))
#define __analysis_assume_lock_released(lock) __internal_releases_lock((void*)(&(lock)))

#define __function_ignore_lock_checking(lock) _SAL1_1_Source_(__function_ignore_lock_cleanup, (lock), __pre _SA_annotes1(SAL_ignore_lock_match,lock))
extern __function_ignore_lock_checking(*plock) void __internal_suppress_lock_checking(void* plock);

#define __analysis_suppress_lock_checking(lock) __internal_suppress_lock_checking((void*)(&(lock)));

#define BENIGN_RACE_BEGIN __pragma(warning(push)) __pragma(warning(disable:26100 26150 26130 26180 26131 26181))
#define BENIGN_RACE_END __pragma(warning(pop))

#define NO_COMPETING_THREAD_BEGIN __pragma(warning(push)) __pragma(warning(disable:26100 26150 26101 26151 26110 26160 26130 26180 26131 26181))
#define NO_COMPETING_THREAD_END __pragma(warning(pop))

#else
# 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

#ifndef _Interlocked_operand_
#define _Interlocked_operand_
#endif
# 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

#define _Guarded_by_(lock)
#define _Write_guarded_by_(lock)
#define _Interlocked_
#define _Requires_lock_held_(lock)
#define _Requires_exclusive_lock_held_(lock)
#define _Requires_shared_lock_held_(lock)
#define _Requires_lock_not_held_(lock)
#define _Requires_no_locks_held_
#define _Acquires_lock_(lock)
#define _Acquires_exclusive_lock_(lock)
#define _Acquires_shared_lock_(lock)
#define _Releases_lock_(lock)
#define _Releases_exclusive_lock_(lock)
#define _Releases_shared_lock_(lock)
#define _Acquires_nonreentrant_lock_(lock)
#define _Releases_nonreentrant_lock_(lock)

#define _Post_same_lock_(lock1,lock2)

#define _Internal_set_lock_count_(lock, count)

#define _Create_lock_level_(level)
#define _Has_lock_level_(level)
#define _Internal_lock_level_order_(a,b)
#define _Csalcat1_(x,y)
#define _Csalcat2_(x,y)
#define _Lock_level_order_(a,b)
#define _No_competing_thread_
#define _Analysis_assume_lock_acquired_(lock)
#define _Analysis_assume_lock_released_(lock)
#define _Analysis_assume_lock_held_(lock)
#define _Analysis_assume_lock_not_held_(lock)
#define _Analysis_assume_same_lock_(lock1, lock2)
#define _Function_ignore_lock_checking_(lock)
#define _Analysis_suppress_lock_checking_(lock)

#define _Benign_race_begin_ __pragma(warning(push))
#define _Benign_race_end_ __pragma(warning(pop))

#define _No_competing_thread_begin_ __pragma(warning(push))
#define _No_competing_thread_end_ __pragma(warning(pop))

#define _Has_lock_kind_(kind)

/*
 * Old spelling: will be deprecated
 */
#define __guarded_by(lock)
#define __write_guarded_by(lock)
#define __interlocked
#define __requires_lock_held(lock)
#define __requires_exclusive_lock_held(lock)
#define __requires_shared_lock_held(lock)
#define __requires_lock_not_held(lock)
#define __requires_no_locks_held
#define __acquires_lock(lock)
#define __acquires_exclusive_lock(lock)
#define __acquires_shared_lock(lock)
#define __releases_lock(lock)
#define __releases_exclusive_lock(lock)
#define __releases_shared_lock(lock)

#define __has_lock_property(kind)
#define __declare_lock_level(level)
#define __has_lock_level(level)
#define __internal_lock_level_order(a,b)
#define CSALCAT1(x,y)
#define CSALCAT2(x,y)
#define __lock_level_order(a,b)
#define __no_competing_thread
#define __analysis_assume_lock_acquired(lock)
#define __analysis_assume_lock_released(lock)
#define __function_ignore_lock_checking(lock)
#define __analysis_suppress_lock_checking(lock)

#define BENIGN_RACE_BEGIN __pragma(warning(push))
#define BENIGN_RACE_END __pragma(warning(pop))

#define NO_COMPETING_THREAD_BEGIN __pragma(warning(push))
#define NO_COMPETING_THREAD_END __pragma(warning(pop))

#endif
# 352 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

#ifdef __cplusplus
}
#endif
# 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3

#endif // CONCURRENCYSAL_H
# 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\concurrencysal.h" 3
# 2971 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\sal.h" 2 3

# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 1 3
/* ===-------- vadefs.h ---------------------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

/* Only include this if we are aiming for MSVC compatibility. */
#ifndef _MSC_VER
#if 0 /* expanded by -frewrite-includes */
#include_next <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 26 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
# 27 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
#else
# 28 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3

#ifndef __clang_vadefs_h
#define __clang_vadefs_h

#if 0 /* expanded by -frewrite-includes */
#include_next <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 32 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 1 3
//
// vadefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header
// in the CRT header lattice, and is always the first CRT header to be included,
// explicitly or implicitly.  Therefore, this header also has several definitions
// that are used throughout the CRT.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
#define _INC_VADEFS

#define _CRT_PACKING 8
#pragma pack(push, _CRT_PACKING)

#ifdef __cplusplus
extern "C" {
#endif
# 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#if !defined _W64
#define _W64
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#ifndef _UINTPTR_T_DEFINED
    #define _UINTPTR_T_DEFINED
    #ifdef _WIN64
        typedef unsigned __int64  uintptr_t;
    #else
# 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
        typedef unsigned int uintptr_t;
    #endif
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
#endif
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#ifndef _VA_LIST_DEFINED
    #define _VA_LIST_DEFINED
    #ifdef _M_CEE_PURE
        typedef System::ArgIterator va_list;
    #else
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
        typedef char* va_list;
    #endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
#endif
# 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#ifdef __cplusplus
    #define _ADDRESSOF(v) (&const_cast<char&>(reinterpret_cast<const volatile char&>(v)))
#else
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
    #define _ADDRESSOF(v) (&(v))
#endif
# 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#if (defined _M_ARM || defined _M_HYBRID_X86_ARM64) && !defined _M_CEE_PURE
    #define _VA_ALIGN       4
    #define _SLOTSIZEOF(t)  ((sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1))
    #define _APALIGN(t,ap)  (((va_list)0 - (ap)) & (__alignof(t) - 1))
#elif defined _M_ARM64 && !defined _M_CEE_PURE
# 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
    #define _VA_ALIGN       8
    #define _SLOTSIZEOF(t)  ((sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1))
    #define _APALIGN(t,ap)  (((va_list)0 - (ap)) & (__alignof(t) - 1))
#else
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
    #define _SLOTSIZEOF(t)  (sizeof(t))
    #define _APALIGN(t,ap)  (__alignof(t))
#endif
# 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#if defined _M_CEE_PURE || (defined _M_CEE && !defined _M_ARM && !defined _M_ARM64)

    void  __cdecl __va_start(va_list*, ...);
    void* __cdecl __va_arg(va_list*, ...);
    void  __cdecl __va_end(va_list*);

    #define __crt_va_start_a(ap, v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
    #define __crt_va_arg(ap, t)     (*(t *)__va_arg(&ap, _SLOTSIZEOF(t), _APALIGN(t,ap), (t*)0))
    #define __crt_va_end(ap)        ((void)(__va_end(&ap)))

#elif defined _M_IX86 && !defined _M_HYBRID_X86_ARM64
# 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

    #define _INTSIZEOF(n)          ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))

    #define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))
    #define __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
    #define __crt_va_end(ap)        ((void)(ap = (va_list)0))

#elif defined _M_ARM
# 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

    #ifdef __cplusplus
        void __cdecl __va_start(va_list*, ...);
        #define __crt_va_start_a(ap, v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), _ADDRESSOF(v))))
    #else
# 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
        #define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v)))
    #endif
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

    #define __crt_va_arg(ap, t) (*(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))
    #define __crt_va_end(ap)    ((void)(ap = (va_list)0))

#elif defined _M_HYBRID_X86_ARM64
# 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3
    void __cdecl __va_start(va_list*, ...);
    #define __crt_va_start_a(ap,v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
    #define __crt_va_arg(ap, t)    (*(t*)((ap += _SLOTSIZEOF(t)) - _SLOTSIZEOF(t)))
    #define __crt_va_end(ap)       ((void)(ap = (va_list)0))

#elif defined _M_ARM64
# 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

    void __cdecl __va_start(va_list*, ...);

    #define __crt_va_start_a(ap,v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
    #define __crt_va_arg(ap, t)                                                 \
        ((sizeof(t) > (2 * sizeof(__int64)))                                   \
            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))               \
            : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))
    #define __crt_va_end(ap)       ((void)(ap = (va_list)0))


#elif defined _M_X64
# 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

    void __cdecl __va_start(va_list* , ...);

    #define __crt_va_start_a(ap, x) ((void)(__va_start(&ap, x)))
    #define __crt_va_arg(ap, t)                                               \
        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \
            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))             \
            :  *(t* )((ap += sizeof(__int64)) - sizeof(__int64)))
    #define __crt_va_end(ap)        ((void)(ap = (va_list)0))

#endif
# 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#ifdef __cplusplus
} // extern "C"
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#if defined __cplusplus && !defined _CRT_NO_VA_START_VALIDATION
    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    } // extern "C++"

    #define __crt_va_start(ap, x) ((void)(__vcrt_va_start_verify_argument_type<decltype(x)>(), __crt_va_start_a(ap, x)))

#else // ^^^ __cplusplus ^^^ // vvv !__cplusplus vvv //
# 158 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

    #define __crt_va_start(ap, x) __crt_va_start_a(ap, x)

#endif
# 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vadefs.h" 3

#pragma pack(pop)
# 33 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 2 3

/* Override macros from vadefs.h with definitions that work with Clang. */
#ifdef _crt_va_start
#undef _crt_va_start
#define _crt_va_start(ap, param) __builtin_va_start(ap, param)
#endif
# 39 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
#ifdef _crt_va_end
#undef _crt_va_end
#define _crt_va_end(ap)          __builtin_va_end(ap)
#endif
# 43 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
#ifdef _crt_va_arg
#undef _crt_va_arg
#define _crt_va_arg(ap, type)    __builtin_va_arg(ap, type)
#endif
# 47 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3

/* VS 2015 switched to double underscore names, which is an improvement, but now
 * we have to intercept those names too.
 */
#ifdef __crt_va_start
#undef __crt_va_start
#define __crt_va_start(ap, param) __builtin_va_start(ap, param)
#endif
# 55 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
#ifdef __crt_va_end
#undef __crt_va_end
#define __crt_va_end(ap)          __builtin_va_end(ap)
#endif
# 59 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
#ifdef __crt_va_arg
#undef __crt_va_arg
#define __crt_va_arg(ap, type)    __builtin_va_arg(ap, type)
#endif
# 63 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3

#endif
# 65 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
#endif
# 66 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 2 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 1 3
//
// corecrt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the CoreCRT library.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 2 3

_CRT_BEGIN_C_HEADER



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Annotation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _ACRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _ACRTIMP _CRTIMP
    #elif !defined _CORECRT_BUILD && defined _DLL
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _ACRTIMP __declspec(dllimport)
    #else
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _ACRTIMP
    #endif
# 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

// If you need the ability to remove __declspec(import) from an API, to support static replacement,
// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.
#ifndef _ACRTIMP_ALT
    #define _ACRTIMP_ALT _ACRTIMP
#endif
# 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _DCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _DCRTIMP _CRTIMP
    #elif !defined _CORECRT_BUILD && defined _DLL
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _DCRTIMP __declspec(dllimport)
    #else
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _DCRTIMP
    #endif
# 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _CRT_SUPPRESS_RESTRICT || defined _CORECRT_BUILD
    #define _CRTRESTRICT
#else
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _CRTRESTRICT __declspec(restrict)
#endif
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _MSC_VER && _MSC_VER >= 1900 && !defined _CORECRT_BUILD
    #define _CRTALLOCATOR __declspec(allocator)
#else
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _CRTALLOCATOR
#endif
# 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _M_CEE && defined _M_X64
    // This is only needed when managed code is calling the native APIs,
    // targeting the 64-bit runtime.
    #define _CRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _CRT_JIT_INTRINSIC
#endif
# 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators
#ifdef _GUARDOVERFLOW_CRT_ALLOCATORS
    #define _CRT_GUARDOVERFLOW __declspec(guard(overflow))
#else
# 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _CRT_GUARDOVERFLOW
#endif
# 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _DLL && defined _M_HYBRID && (defined _CORECRT_BUILD || defined _VCRT_BUILD)
    #define _CRT_HYBRIDPATCHABLE __declspec(hybrid_patchable)
#else
# 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _CRT_HYBRIDPATCHABLE
#endif
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CONST_RETURN const
        #define _CRT_CONST_CORRECT_OVERLOADS
    #else
# 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CONST_RETURN
    #endif
# 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#define _WConst_return _CONST_RETURN // For backwards compatibility

#ifndef _CRT_ALIGN
    #ifdef __midl
        #define _CRT_ALIGN(x)
    #else
# 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CRT_ALIGN(x) __declspec(align(x))
    #endif
# 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _PREFAST_ && defined _CA_SHOULD_CHECK_RETURN
    #define _Check_return_opt_ _Check_return_
#else
# 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _Check_return_opt_
#endif
# 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _PREFAST_ && defined _CA_SHOULD_CHECK_RETURN_WER
    #define _Check_return_wat_ _Check_return_
#else
# 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define _Check_return_wat_
#endif
# 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if !defined __midl && !defined MIDL_PASS && defined _PREFAST_
    #define __crt_typefix(ctype) __declspec("SAL_typefix(" _CRT_STRINGIZE(ctype) ")")
#else
# 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #define __crt_typefix(ctype)
#endif
# 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Miscellaneous Stuff
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef __cplusplus
extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#endif
# 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined __cplusplus
    typedef bool  __crt_bool;
#elif defined __midl
# 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __crt_bool;
#else
# 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    typedef _Bool __crt_bool;
#endif
# 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#define _ARGMAX   100
#define _TRUNCATE ((size_t)-1)
#define _CRT_INT_MAX 2147483647
#define _CRT_SIZE_MAX ((size_t)-1)

#define __FILEW__     _CRT_WIDE(__FILE__)
#define __FUNCTIONW__ _CRT_WIDE(__FUNCTION__)

#ifndef _STATIC_ASSERT
    #define _STATIC_ASSERT(expr) typedef char __static_assert_t[(expr) != 0]
#endif
# 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define NULL ((void *)0)
    #endif
# 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

// CRT headers are included into some kinds of source files where only data type
// definitions and macro definitions are required but function declarations and
// inline function definitions are not.  These files include assembly files, IDL
// files, and resource files.  The tools that process these files often have a
// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro
// is defined to 1 when we are compiling a file that actually needs functions to
// be declared (and defined, where applicable), and to 0 when we are compiling a
// file that does not.  This allows us to suppress declarations and definitions
// that are not compilable with the aforementioned tools.
#if !defined _CRT_FUNCTIONS_REQUIRED
    #if defined __assembler || defined __midl || defined RC_INVOKED
        #define _CRT_FUNCTIONS_REQUIRED 0
    #else
# 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CRT_FUNCTIONS_REQUIRED 1
    #endif
# 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if !defined _NO_INLINING && !_CRT_FUNCTIONS_REQUIRED
        #define _NO_INLINING // Suppress <tchar.h> inlines
#endif
# 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_UNUSED
    #define _CRT_UNUSED(x) (void)x
#endif
# 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Windows API Partitioning and ARM Desktop Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
    #ifdef WINAPI_FAMILY
        #if 0 /* expanded by -frewrite-includes */
#include <winapifamily.h>
#endif /* expanded by -frewrite-includes */
# 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
# 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
            #define _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
        #else
# 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
            #ifdef WINAPI_FAMILY_PHONE_APP
                #if WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP
                    #define _CRT_USE_WINAPI_FAMILY_PHONE_APP
                #endif
# 210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
            #endif
# 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #endif
# 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #else
# 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
    #endif
# 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE
    #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 0
#endif
# 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_BUILD_DESKTOP_APP
    #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
        #define _CRT_BUILD_DESKTOP_APP 1
    #else
# 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CRT_BUILD_DESKTOP_APP 0
    #endif
# 227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

// Verify that the ARM Desktop SDK is available when building an ARM Desktop app
#ifdef _M_ARM
    #if _CRT_BUILD_DESKTOP_APP && !_ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE
        #error Compiling Desktop applications for the ARM platform is not supported.
    #endif
# 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Invalid Parameter Handler
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _DEBUG
    _ACRTIMP void __cdecl _invalid_parameter(
        _In_opt_z_ wchar_t const*,
        _In_opt_z_ wchar_t const*,
        _In_opt_z_ wchar_t const*,
        _In_       unsigned int,
        _In_       uintptr_t
        );
#endif
# 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

_ACRTIMP_ALT void __cdecl _invalid_parameter_noinfo(void);
_ACRTIMP __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
_ACRTIMP void __cdecl _invoke_watson(
    _In_opt_z_ wchar_t const* _Expression,
    _In_opt_z_ wchar_t const* _FunctionName,
    _In_opt_z_ wchar_t const* _FileName,
    _In_       unsigned int _LineNo,
    _In_       uintptr_t _Reserved);

#ifndef _CRT_SECURE_INVALID_PARAMETER
    #ifdef _DEBUG
        #define _CRT_SECURE_INVALID_PARAMETER(expr) \
            ::_invalid_parameter(_CRT_WIDE(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0)
    #else
# 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        // By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes
        // _invalid_parameter_noinfo_noreturn(), which is marked
        // __declspec(noreturn) and does not return control to the application.
        // Even if _set_invalid_parameter_handler() is used to set a new invalid
        // parameter handler which does return control to the application,
        // _invalid_parameter_noinfo_noreturn() will terminate the application
        // and invoke Watson. You can overwrite the definition of
        // _CRT_SECURE_INVALID_PARAMETER if you need.
        //
        // _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries
        // and the SafeInt library.
        #define _CRT_SECURE_INVALID_PARAMETER(expr) \
            ::_invalid_parameter_noinfo_noreturn()
    #endif
# 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Deprecation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define _CRT_INTERNAL_NONSTDC_NAMES                                            \
    (                                                                          \
        ( defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || \
        (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__                 )    \
    )

#if defined _CRT_NONSTDC_NO_DEPRECATE && !defined _CRT_NONSTDC_NO_WARNINGS
    #define _CRT_NONSTDC_NO_WARNINGS
#endif
# 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_NONSTDC_DEPRECATE
    #ifdef _CRT_NONSTDC_NO_WARNINGS
        #define _CRT_NONSTDC_DEPRECATE(_NewName)
    #else
# 306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CRT_NONSTDC_DEPRECATE(_NewName) _CRT_DEPRECATE_TEXT(             \
            "The POSIX name for this item is deprecated. Instead, use the ISO C " \
            "and C++ conformant name: " #_NewName ". See online help for details.")
    #endif
# 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Managed CRT Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _PGLOBAL
    #ifdef _M_CEE
        #ifdef __cplusplus_cli
            #define _PGLOBAL __declspec(process)
        #else
# 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
            #define _PGLOBAL
        #endif
# 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #else
# 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _PGLOBAL
    #endif
# 329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _AGLOBAL
    #ifdef _M_CEE
        #define _AGLOBAL __declspec(appdomain)
    #else
# 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _AGLOBAL
    #endif
# 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _M_CEE && !defined _M_CEE_PURE
    #define _M_CEE_MIXED
#endif
# 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// SecureCRT Configuration
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined _CRTBLD || defined _CORECRT_BUILD || defined _VCRT_BUILD
    // Disable C++ overloads internally:
    #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES       0
    #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
    #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES         0
#endif
# 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if !_CRT_FUNCTIONS_REQUIRED
    // If we don't require function declarations at all, we need not define the
    // overloads (MIDL and RC do not need the C++ overloads).
    #undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
    #undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
    #undef  _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
    #undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
    #undef  _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY

    #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
    #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
    #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
    #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
    #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
#endif
# 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#define __STDC_SECURE_LIB__ 200411L
#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__ // For backwards compatibility

#ifndef __STDC_WANT_SECURE_LIB__
    #define __STDC_WANT_SECURE_LIB__ 1
#endif
# 379 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if !__STDC_WANT_SECURE_LIB__ && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef RC_INVOKED
    #if defined _CRT_SECURE_NO_DEPRECATE_GLOBALS && !defined _CRT_SECURE_NO_WARNINGS_GLOBALS
        #define _CRT_SECURE_NO_WARNINGS_GLOBALS
    #endif
# 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_GLOBALS
    #ifdef RC_INVOKED
        #define _CRT_INSECURE_DEPRECATE_GLOBALS(replacement)
    #else
# 394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #ifdef _CRT_SECURE_NO_WARNINGS_GLOBALS
            #define _CRT_INSECURE_DEPRECATE_GLOBALS(replacement)
        #else
# 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
            #define _CRT_INSECURE_DEPRECATE_GLOBALS(replacement) _CRT_INSECURE_DEPRECATE(replacement)
        #endif
# 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif
# 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _CRT_MANAGED_HEAP_NO_DEPRECATE && !defined _CRT_MANAGED_HEAP_NO_WARNINGS
    #define _CRT_MANAGED_HEAP_NO_WARNINGS
#endif
# 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE

#if defined _CRT_OBSOLETE_NO_DEPRECATE && !defined _CRT_OBSOLETE_NO_WARNINGS
    #define _CRT_OBSOLETE_NO_WARNINGS
#endif
# 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_OBSOLETE
    #ifdef _CRT_OBSOLETE_NO_WARNINGS
        #define _CRT_OBSOLETE(_NewItem)
    #else
# 416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #define _CRT_OBSOLETE(_NewItem) _CRT_DEPRECATE_TEXT(                   \
            "This function or variable has been superceded by newer library "  \
            "or operating system functionality. Consider using " #_NewItem " " \
            "instead. See online help for details.")
    #endif
# 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef RC_INVOKED
    #ifndef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
        #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
    #else
# 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
            #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
        #endif
# 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif
# 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

    #ifndef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0
        #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
    #else
# 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
            #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
        #endif
# 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif
# 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

    #ifndef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
        #if __STDC_WANT_SECURE_LIB__
              #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
        #else
# 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
              #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
        #endif
# 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #else
# 449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
            #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
        #endif
# 452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif
# 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

    #ifndef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
        #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
    #else
# 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
            #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
        #endif
# 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif
# 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

    #ifndef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
        #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
    #else
# 465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        #if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
           #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
        #endif
# 468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif
# 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_SECURE_CPP_NOTHROW
    #define _CRT_SECURE_CPP_NOTHROW throw()
#endif
# 474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Basic Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
    _Field_range_(1, 2) int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ // state of a multibyte translation
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;

#if defined _USE_32BIT_TIME_T && defined _WIN64
    #error You cannot use 32-bit time_t (_USE_32BIT_TIME_T) with _WIN64
#endif
# 514 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if defined _VCRT_BUILD || defined _CORECRT_BUILD
    #define _CRT_NO_TIME_T
#endif
# 518 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#ifndef _CRT_NO_TIME_T
    #ifdef _USE_32BIT_TIME_T
        typedef __time32_t time_t;
    #else
# 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        typedef __time64_t time_t;
    #endif
# 525 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

// Indicate that these common types are defined
#ifndef _TIME_T_DEFINED
    #define _TIME_T_DEFINED
#endif
# 531 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

#if __STDC_WANT_SECURE_LIB__
    typedef size_t rsize_t;
#endif
# 535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Secure Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef RC_INVOKED
    #if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst)     \
            extern "C++"                                                                          \
            {                                                                                     \
                template <size_t _Size>                                                           \
                inline                                                                            \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW  \
                {                                                                                 \
                    return _FuncName(_Dst, _Size);                                                \
                }                                                                                 \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1)   \
            extern "C++"                                                                                         \
            {                                                                                                    \
                template <size_t _Size>                                                                          \
                inline                                                                                           \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                \
                    return _FuncName(_Dst, _Size, _TArg1);                                                       \
                }                                                                                                \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)  \
            extern "C++"                                                                                                         \
            {                                                                                                                    \
                template <size_t _Size>                                                                                          \
                inline                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                \
                    return _FuncName(_Dst, _Size, _TArg1, _TArg2);                                                               \
                }                                                                                                                \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            extern "C++"                                                                                                                         \
            {                                                                                                                                    \
                template <size_t _Size>                                                                                                          \
                inline                                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                                \
                    return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3);                                                                       \
                }                                                                                                                                \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
            extern "C++"                                                                                                                                          \
            {                                                                                                                                                     \
                template <size_t _Size>                                                                                                                           \
                inline                                                                                                                                            \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW  \
                {                                                                                                                                                 \
                    return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4);                                                                                \
                }                                                                                                                                                 \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)  \
            extern "C++"                                                                                                         \
            {                                                                                                                    \
                template <size_t _Size>                                                                                          \
                inline                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                \
                    return _FuncName(_HArg1, _Dst, _Size, _TArg1);                                                               \
                }                                                                                                                \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            extern "C++"                                                                                                                         \
            {                                                                                                                                    \
                template <size_t _Size>                                                                                                          \
                inline                                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                                \
                    return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2);                                                                       \
                }                                                                                                                                \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            extern "C++"                                                                                                                                          \
            {                                                                                                                                                     \
                template <size_t _Size>                                                                                                                           \
                inline                                                                                                                                            \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW  \
                {                                                                                                                                                 \
                    return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2, _TArg3);                                                                                \
                }                                                                                                                                                 \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)  \
            extern "C++"                                                                                                         \
            {                                                                                                                    \
                template <size_t _Size>                                                                                          \
                inline                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                \
                    return _FuncName(_HArg1, _HArg2, _Dst, _Size);                                                               \
                }                                                                                                                \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1) \
            extern "C++"                                                                                                           \
            {                                                                                                                      \
                __pragma(warning(push));                                                                                           \
                __pragma(warning(disable: 4793));                                                                                  \
                template <size_t _Size>                                                                                            \
                inline                                                                                                             \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW              \
                {                                                                                                                  \
                    va_list _ArgList;                                                                                              \
                    __crt_va_start(_ArgList, _TArg1);                                                                              \
                    return _VFuncName(_Dst, _Size, _TArg1, _ArgList);                                                              \
                }                                                                                                                  \
                __pragma(warning(pop));                                                                                            \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            extern "C++"                                                                                                                            \
            {                                                                                                                                       \
                __pragma(warning(push));                                                                                                            \
                __pragma(warning(disable: 4793));                                                                                                   \
                template <size_t _Size>                                                                                                             \
                inline                                                                                                                              \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW               \
                {                                                                                                                                   \
                    va_list _ArgList;                                                                                                               \
                    __crt_va_start(_ArgList, _TArg2);                                                                                               \
                    return _VFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList);                                                                       \
                }                                                                                                                                   \
                __pragma(warning(pop));                                                                                                             \
            }

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src)               \
            extern "C++"                                                                                          \
            {                                                                                                     \
                template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>                  \
                inline                                                                                            \
                _ReturnType __CRTDECL _FuncName(                                                                  \
                    _In_z_ _DstType const* _Src,                                                                  \
                    _Post_z_ _DstType (&_Drive)[_DriveSize],                                                      \
                    _Post_z_ _DstType (&_Dir)[_DirSize],                                                          \
                    _Post_z_ _DstType (&_Name)[_NameSize],                                                        \
                    _Post_z_ _DstType (&_Ext)[_ExtSize]                                                           \
                    ) _CRT_SECURE_CPP_NOTHROW                                                                     \
                {                                                                                                 \
                    return _FuncName(_Src, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); \
                }                                                                                                 \
            }

    #else  // ^^^ _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES ^^^ // vvv !_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES vvv //
# 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
        #define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src)

    #endif // !_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
# 711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _VFuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, __cdecl, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Standard Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef RC_INVOKED
    #if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES

        #define __RETURN_POLICY_SAME(_FunctionCall, _Dst) return (_FunctionCall)
        #define __RETURN_POLICY_DST(_FunctionCall, _Dst)  return ((_FunctionCall) == 0 ? _Dst : 0)
        #define __RETURN_POLICY_VOID(_FunctionCall, _Dst) (_FunctionCall); return
        #define __EMPTY_DECLSPEC

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst); \
                return _FuncName(_Dst); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst); \
                return _FuncName(_Dst); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _SizeRead = 0; \
                errno_t _Err = _FuncName##_s(_Dst + 2, (_Size - 2) < ((size_t)_Dst[0]) ? (_Size - 2) : ((size_t)_Dst[0]), &_SizeRead); \
                _Dst[1] = (_DstType)(_SizeRead); \
                return (_Err == 0 ? _Dst + 2 : 0); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName((_DstType *)_Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName<2>(_DstType (&_Dst)[2]) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName((_DstType *)_Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1); \
                return _FuncName(_Dst, _TArg1); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2); \
                return _FuncName(_Dst, _TArg1, _TArg2); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3); \
                return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4); \
                return _FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1); \
                return _FuncName(_HArg1, _Dst, _TArg1); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, const _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType * &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _Dst, _TArg1); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, _Size, _TArg1), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _DstType (&_Dst)[1], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, 1, _TArg1), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst) \
            { \
                _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst); \
                return _FuncName(_HArg1, _HArg2, _Dst); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _HArg2, _Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, _Size), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, 1), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _ArgList) \
            { \
                _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _ArgList); \
                return _VFuncName(_Dst, _TArg1, _ArgList); \
            } \
            extern "C++" \
            { \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
                __pragma(warning(pop)); \
                \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
                template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
            } \
                __pragma(warning(pop)); \
                \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
                template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
            } \
                __pragma(warning(pop)); \
                \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
            } \
                __pragma(warning(pop)); \
                \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_SalAttributeDst _DstType *&_Dst, _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _VFuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
            { \
                _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList); \
                return _VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
            } \
            extern "C++" \
            { \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
                __pragma(warning(pop)); \
                \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
            } \
                __pragma(warning(pop)); \
                \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
                __pragma(warning(pop)); \
                \
                __pragma(warning(push)); \
                __pragma(warning(disable: 4793)); \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
                __pragma(warning(pop)); \
                \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_SalAttributeDst _DstType *&_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _VFuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            size_t __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) \
            { \
                _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2); \
                return _FuncName(_Dst, _TArg1, _TArg2); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
            } \
            template <size_t _Size> \
            inline \
            size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            }

        #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            __inline \
            size_t __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
            { \
                _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3); \
                return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            template <size_t _Size> \
            inline \
            size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2, _TArg3); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2, _TArg3); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            }

        #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst)

        #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
            } \
            }

        #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1)

        #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
            } \
            }

        #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

        #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
            } \
            }

        #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

        #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            }

        #if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, __cdecl, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _VFuncName##_s, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType _DstType, _Dst)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType _DstType, _Dst, _TType1, _TArg1)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

        #else // ^^^ _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT ^^^ // vvv _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT vvv //
# 1712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
                    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName,_VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

        #endif // !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
# 1785 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

    #else  // ^^^ _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES ^^^ // vvv !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES vvv //
# 1787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

        #define __RETURN_POLICY_SAME(_FunctionCall)
        #define __RETURN_POLICY_DST(_FunctionCall)
        #define __RETURN_POLICY_VOID(_FunctionCall)
        #define __EMPTY_DECLSPEC

        #if _CRT_FUNCTIONS_REQUIRED

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

        #else // ^^^ _CRT_FUNCTIONS_REQUIRED ^^^ // vvv !_CRT_FUNCTIONS_REQUIRED vvv //
# 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3

            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(...)
            #define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(...)
            #define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(...)
            #define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(...)

        #endif // !_CRT_FUNCTIONS_REQUIRED
# 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    #endif // !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
# 1978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#endif
# 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3



_CRT_END_C_HEADER
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 2 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// CRT DLL Export/Import Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _CRTIMP2
    #if defined CRTDLL2 && defined _CRTBLD
        #define _CRTIMP2 __declspec(dllexport)
    #else
# 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
        #define _CRTIMP2
    #endif
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
#endif
# 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3

#ifndef _CRTIMP3
    #if defined MSVC_SUPPLEMENTAL_1 && defined _CRTBLD
        #define _CRTIMP3 __declspec(dllexport)
    #else
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
        #define _CRTIMP3
    #endif
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
#endif
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3

#ifndef _CONCRTIMP
    #if defined CONCRTDLL && defined _CRTBLD
        #define _CONCRTIMP __declspec(dllexport)
    #else
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
        #if defined _DLL && !defined _STATIC_CPPLIB
            #define _CONCRTIMP __declspec(dllimport)
        #else
# 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
            #define _CONCRTIMP
        #endif
# 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
    #endif
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
#endif
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3

#ifndef _MRTIMP2
    #if defined CRTDLL2 && defined _CRTBLD
        #define _MRTIMP2 __declspec(dllexport)
    #elif defined MRTDLL && defined _CRTBLD
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
        #define _MRTIMP2 _MRTIMP
    #else
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
        #define _MRTIMP2
    #endif
# 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
#endif
# 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\crtdefs.h" 3
# 116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 2 3

#ifndef _STL_WARNING_LEVEL
 #if defined(_MSVC_WARNING_LEVEL) && _MSVC_WARNING_LEVEL >= 4
  #define _STL_WARNING_LEVEL	4
 #else /* defined(_MSVC_WARNING_LEVEL) && _MSVC_WARNING_LEVEL >= 4 */
# 121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _STL_WARNING_LEVEL	3
 #endif /* defined(_MSVC_WARNING_LEVEL) && _MSVC_WARNING_LEVEL >= 4 */
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _STL_WARNING_LEVEL */
# 124 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _STL_WARNING_LEVEL < 3
 #error _STL_WARNING_LEVEL cannot be less than 3.
#endif /* _STL_WARNING_LEVEL < 3 */
# 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _STL_WARNING_LEVEL > 4
 #error _STL_WARNING_LEVEL cannot be greater than 4.
#endif /* _STL_WARNING_LEVEL > 4 */
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// warning C4577: 'noexcept' used with no exception handling mode specified;
// termination on exception is not guaranteed. Specify /EHsc
#if _HAS_EXCEPTIONS
 #define _STL_DISABLED_WARNING_C4577
#else /* _HAS_EXCEPTIONS */
# 138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _STL_DISABLED_WARNING_C4577	4577
#endif /* _HAS_EXCEPTIONS */
# 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _STL_EXTRA_DISABLED_WARNINGS
 #define _STL_EXTRA_DISABLED_WARNINGS
#endif /* _STL_EXTRA_DISABLED_WARNINGS */
# 144 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// warning C4494: Ignoring __declspec(allocator) because the function return
// type is not a pointer or reference
// warning C4702: unreachable code
// warning C4988: variable declared outside class/function scope (/Wall /d1WarnOnGlobals)
#ifndef _STL_DISABLED_WARNINGS
 #define _STL_DISABLED_WARNINGS 4494 _STL_DISABLED_WARNING_C4577 4702 4988 _STL_EXTRA_DISABLED_WARNINGS
#endif /* _STL_DISABLED_WARNINGS */
# 152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

#define _CPPLIB_VER	650
#define _MSVC_STL_VERSION 141
#define _MSVC_STL_UPDATE 201711

#ifndef _ALLOW_COMPILER_AND_STL_VERSION_MISMATCH
 #ifdef __EDG__
  // not attempting to detect __EDG_VERSION__ being less than expected
 #elif defined(__clang__)
# 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #if __clang_major__ < 5	// Coarse-grained, not inspecting __clang_minor__ and __clang_patchlevel__
   #error STL1000: Unexpected compiler version, expected Clang 5.
  #endif /* ^^^ old Clang ^^^ */
# 170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #elif defined(_MSC_VER)
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #if _MSC_VER < 1912	// Coarse-grained, not inspecting _MSC_FULL_VER
   #error STL1001: Unexpected compiler version, expected MSVC 19.12.
  #endif /* ^^^ old MSVC ^^^ */
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #else /* vvv other compilers vvv */
# 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  // not attempting to detect other compilers
 #endif /* ^^^ other compilers ^^^ */
# 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _ALLOW_COMPILER_AND_STL_VERSION_MISMATCH */
# 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#define _NOEXCEPT				noexcept

#if _HAS_EXCEPTIONS
 #define _NOEXCEPT_COND(...)	noexcept(__VA_ARGS__)
 #define _NOEXCEPT_OPER(...)	noexcept(__VA_ARGS__)
#else /* _HAS_EXCEPTIONS */
# 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _NOEXCEPT_COND(...)	noexcept
 #define _NOEXCEPT_OPER(...)	true
#endif /* _HAS_EXCEPTIONS */
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_STATIC_RTTI
 #define _HAS_STATIC_RTTI	1
#endif /* _HAS_STATIC_RTTI */
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if defined(_CPPRTTI) && !_HAS_STATIC_RTTI
 #error /GR implies _HAS_STATIC_RTTI.
#endif /* defined(_CPPRTTI) && !_HAS_STATIC_RTTI */
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// C++17 constexpr additions
#if _HAS_CXX17
 #define _CONSTEXPR17 constexpr
#else /* ^^^ has C++17 constexpr additions ^^^ / vvv no C++17 constexpr additions vvv */
# 201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CONSTEXPR17 inline
#endif /* _HAS_CXX17 */
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff
#ifndef _HAS_AUTO_PTR_ETC
 #define _HAS_AUTO_PTR_ETC	(!_HAS_CXX17)
#endif /* _HAS_AUTO_PTR_ETC */
# 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// P0003R5 Removing Dynamic Exception Specifications
#ifndef _HAS_UNEXPECTED
 #define _HAS_UNEXPECTED	(!_HAS_CXX17)
#endif /* _HAS_UNEXPECTED */
# 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// P0004R1 Removing Deprecated Iostreams Aliases
#ifndef _HAS_OLD_IOSTREAMS_MEMBERS
 #define _HAS_OLD_IOSTREAMS_MEMBERS	(!_HAS_CXX17)
#endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 218 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// P0298R3 std::byte
#ifndef _HAS_STD_BYTE
 #define _HAS_STD_BYTE	_HAS_CXX17	// inspected by GSL, do not remove
#endif /* _HAS_STD_BYTE */
# 223 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// P0302R1 Removing Allocator Support In std::function
// LWG 2385 function::assign allocator argument doesn't make sense
// LWG 2921 packaged_task and type-erased allocators
// LWG 2976 Dangling uses_allocator specialization for packaged_task
#ifndef _HAS_FUNCTION_ALLOCATOR_SUPPORT
 #define _HAS_FUNCTION_ALLOCATOR_SUPPORT	(!_HAS_CXX17)
#endif /* _HAS_FUNCTION_ALLOCATOR_SUPPORT */
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// The non-Standard std::tr1 namespace and TR1-only machinery
#ifndef _HAS_TR1_NAMESPACE
 #define _HAS_TR1_NAMESPACE	(!_HAS_CXX17)
#endif /* _HAS_TR1_NAMESPACE */
# 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _HAS_TR1_NAMESPACE
 #ifdef _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING
  #define _DEPRECATE_TR1_NAMESPACE
 #else /* _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING */
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _DEPRECATE_TR1_NAMESPACE	[[deprecated("warning STL4002: " \
	"The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " \
	"define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]]
 #endif /* _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING */
# 245 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_TR1_NAMESPACE */
# 246 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// The non-Standard std::identity struct
#ifndef _HAS_IDENTITY_STRUCT
 #define _HAS_IDENTITY_STRUCT	(!_HAS_CXX17)
#endif /* _HAS_IDENTITY_STRUCT */
# 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _HAS_IDENTITY_STRUCT
 #ifdef _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING
  #define _DEPRECATE_IDENTITY_STRUCT
 #else /* _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING */
# 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _DEPRECATE_IDENTITY_STRUCT	[[deprecated("warning STL4003: " \
	"The non-Standard std::identity struct is deprecated and will be REMOVED. You can " \
	"define _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING to acknowledge that you have received this warning.")]]
 #endif /* _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING */
# 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_IDENTITY_STRUCT */
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// The non-Standard std::tr2::sys namespace
#ifndef _HAS_TR2_SYS_NAMESPACE
 #define _HAS_TR2_SYS_NAMESPACE	(!_HAS_CXX17)
#endif /* _HAS_TR2_SYS_NAMESPACE */
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _HAS_TR2_SYS_NAMESPACE
 #ifdef _SILENCE_TR2_SYS_NAMESPACE_DEPRECATION_WARNING
  #define _DEPRECATE_TR2_SYS_NAMESPACE
 #else /* _SILENCE_TR2_SYS_NAMESPACE_DEPRECATION_WARNING */
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _DEPRECATE_TR2_SYS_NAMESPACE	[[deprecated("warning STL4018: " \
	"The non-Standard std::tr2::sys namespace is deprecated and will be REMOVED. " \
	"It is superseded by std::experimental::filesystem. You can " \
	"define _SILENCE_TR2_SYS_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]]
 #endif /* _SILENCE_TR2_SYS_NAMESPACE_DEPRECATION_WARNING */
# 276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_TR2_SYS_NAMESPACE */
# 277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// Enforcement of matching allocator value_types
#ifndef _ENFORCE_MATCHING_ALLOCATORS
 #define _ENFORCE_MATCHING_ALLOCATORS	_HAS_CXX17
#endif /* _ENFORCE_MATCHING_ALLOCATORS */
# 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#define _MISMATCHED_ALLOCATOR_MESSAGE(_CONTAINER, _VALUE_TYPE) \
	_CONTAINER " requires that Allocator's value_type match " _VALUE_TYPE \
	" (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" \
	" Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" \
	" to suppress this diagnostic."

// [[nodiscard]] attributes on STL functions
#ifndef _HAS_NODISCARD
 #ifdef __EDG__
  #define _HAS_NODISCARD	0	// TRANSITION, VSO#509963
 #else /* __EDG__ */
# 294 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_NODISCARD	_HAS_CXX17
 #endif /* __EDG__ */
# 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_NODISCARD */
# 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _HAS_NODISCARD
 #define _NODISCARD [[nodiscard]]
#else /* ^^^ CAN HAZ [[nodiscard]] ^^^ // vvv NO CAN HAZ [[nodiscard]] vvv */
# 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _NODISCARD
#endif /* _HAS_NODISCARD */
# 303 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3


// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// Other C++17 deprecation warnings

// N4659 D.4 [depr.cpp.headers]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_C_HEADER	[[deprecated("warning STL4004: " \
	"<ccomplex>, <cstdalign>, <cstdbool>, and <ctgmath> are deprecated in C++17. " \
	"You can define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_C_HEADER
#endif /* ^^^ warning disabled ^^^ */
# 319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.6 [depr.str.strstreams]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_STRSTREAM_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_STRSTREAM	[[deprecated("warning STL4005: <strstream> is deprecated in C++17. " \
	"You can define _SILENCE_CXX17_STRSTREAM_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_STRSTREAM
#endif /* ^^^ warning disabled ^^^ */
# 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.7 [depr.uncaught]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_UNCAUGHT_EXCEPTION	[[deprecated("warning STL4006: " \
	"std::uncaught_exception() is deprecated in C++17. " \
	"It is superseded by std::uncaught_exceptions(), plural. " \
	"You can define _SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 339 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_UNCAUGHT_EXCEPTION
#endif /* ^^^ warning disabled ^^^ */
# 341 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.8.1 [depr.weak.result_type]
// N4659 D.8.2 [depr.func.adaptor.typedefs]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS	[[deprecated("warning STL4007: Many result_type typedefs " \
	"and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " \
	"You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS
#endif /* ^^^ warning disabled ^^^ */
# 353 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.8.3 [depr.negators]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_NEGATORS_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_NEGATORS	[[deprecated("warning STL4008: " \
	"std::not1(), std::not2(), std::unary_negate, and std::binary_negate are deprecated in C++17. " \
	"They are superseded by std::not_fn(). " \
	"You can define _SILENCE_CXX17_NEGATORS_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_NEGATORS
#endif /* ^^^ warning disabled ^^^ */
# 365 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.9 [depr.default.allocator]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_ALLOCATOR_VOID_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_ALLOCATOR_VOID	[[deprecated("warning STL4009: " \
	"std::allocator<void> is deprecated in C++17. " \
	"You can define _SILENCE_CXX17_ALLOCATOR_VOID_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 374 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_ALLOCATOR_VOID
#endif /* ^^^ warning disabled ^^^ */
# 376 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.9 [depr.default.allocator]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS	[[deprecated("warning STL4010: " \
	"Various members of std::allocator are deprecated in C++17. " \
	"Use std::allocator_traits instead of accessing these members directly. " \
	"You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 386 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS
#endif /* ^^^ warning disabled ^^^ */
# 388 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.10 [depr.storage.iterator]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_RAW_STORAGE_ITERATOR_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_RAW_STORAGE_ITERATOR	[[deprecated("warning STL4011: " \
	"std::raw_storage_iterator is deprecated in C++17. " \
	"Consider using the std::uninitialized_copy() family of algorithms instead. " \
	"You can define _SILENCE_CXX17_RAW_STORAGE_ITERATOR_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_RAW_STORAGE_ITERATOR
#endif /* ^^^ warning disabled ^^^ */
# 400 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.11 [depr.temporary.buffer]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_TEMPORARY_BUFFER_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_TEMPORARY_BUFFER	[[deprecated("warning STL4012: " \
	"std::get_temporary_buffer() and std::return_temporary_buffer() are deprecated in C++17. " \
	"You can define _SILENCE_CXX17_TEMPORARY_BUFFER_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_TEMPORARY_BUFFER
#endif /* ^^^ warning disabled ^^^ */
# 411 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.12 [depr.meta.types]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_IS_LITERAL_TYPE_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_IS_LITERAL_TYPE	[[deprecated("warning STL4013: " \
	"std::is_literal_type and std::is_literal_type_v are deprecated in C++17. " \
	"You can define _SILENCE_CXX17_IS_LITERAL_TYPE_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 420 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_IS_LITERAL_TYPE
#endif /* ^^^ warning disabled ^^^ */
# 422 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.12 [depr.meta.types]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_RESULT_OF	[[deprecated("warning STL4014: " \
	"std::result_of and std::result_of_t are deprecated in C++17. " \
	"They are superseded by std::invoke_result and std::invoke_result_t. " \
	"You can define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 432 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_RESULT_OF
#endif /* ^^^ warning disabled ^^^ */
# 434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.13 [depr.iterator.primitives]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_ITERATOR_BASE_CLASS	[[deprecated("warning STL4015: " \
	"The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17. " \
	"(The <iterator> header is NOT deprecated.) The C++ Standard has never required user-defined iterators to " \
	"derive from std::iterator. To fix this warning, stop deriving from std::iterator and start providing " \
	"publicly accessible typedefs named iterator_category, value_type, difference_type, pointer, and reference. " \
	"Note that value_type is required to be non-const, even for constant iterators. " \
	"You can define _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 447 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_ITERATOR_BASE_CLASS
#endif /* ^^^ warning disabled ^^^ */
# 449 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.14 [depr.util.smartptr.shared.obs]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_SHARED_PTR_UNIQUE_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_SHARED_PTR_UNIQUE	[[deprecated("warning STL4016: " \
	"std::shared_ptr::unique() is deprecated in C++17. " \
	"You can define _SILENCE_CXX17_SHARED_PTR_UNIQUE_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 458 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_SHARED_PTR_UNIQUE
#endif /* ^^^ warning disabled ^^^ */
# 460 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// N4659 D.15 [depr.locale.stdcvt]
// N4659 D.16 [depr.conversions]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING) \
	&& !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
 #define _CXX17_DEPRECATE_CODECVT_HEADER	[[deprecated("warning STL4017: " \
	"std::wbuffer_convert, std::wstring_convert, and the <codecvt> header (containing std::codecvt_mode, " \
	"std::codecvt_utf8, std::codecvt_utf16, and std::codecvt_utf8_utf16) are deprecated in C++17. " \
	"(The std::codecvt class template is NOT deprecated.) " \
	"The C++ Standard doesn't provide equivalent non-deprecated functionality; " \
	"consider using MultiByteToWideChar() and WideCharToMultiByte() from <Windows.h> instead. " \
	"You can define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING " \
	"or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]
#else /* ^^^ warning enabled ^^^ / vvv warning disabled vvv */
# 474 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CXX17_DEPRECATE_CODECVT_HEADER
#endif /* ^^^ warning disabled ^^^ */
# 476 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

// Experimental partial support of P0024R2 parallel algorithms
#ifdef _SILENCE_PARALLEL_ALGORITHMS_EXPERIMENTAL_WARNING
 #define _EXPERIMENTAL_PARALLEL_ALGORITHMS
#else /* ^^^ warning disabled ^^^ / vvv warning enabled vvv */
# 481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _EXPERIMENTAL_PARALLEL_ALGORITHMS	[[deprecated("warning STL4019: Parallel algorithms support is " \
	"experimental in this release of Visual C++. Object files and static libraries that include <execution> " \
	"may need to be rebuilt to link with a future update of Visual C++, and programs using <execution> " \
	"may not run on Windows XP. This warning will be removed when parallel algorithms support is completed in a " \
	"future update. You can define _SILENCE_PARALLEL_ALGORITHMS_EXPERIMENTAL_WARNING to acknowledge that you " \
	"have received this warning.")]]
#endif /* _SILENCE_PARALLEL_ALGORITHMS_EXPERIMENTAL_WARNING */
# 488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS
 #ifdef __EDG__
  #define _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS 0	// TRANSITION, VSO#509219
 #elif defined(__clang__)
# 493 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS 0	// TRANSITION, LLVM#34942
 #else /* ^^^ compiler support unavailable ^^^ // vvv compiler support available vvv */
# 495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS _HAS_CXX17
 #endif /* ^^^ compiler support available ^^^ */
# 497 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS */
# 498 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_CONSTEXPR_CHAR_TRAITS
 #if defined(__clang__) || defined(__EDG__)
  #define _HAS_CONSTEXPR_CHAR_TRAITS	_HAS_CXX17
 #else /* ^^^ compiler support available ^^^ // vvv compiler support unavailable vvv */
# 503 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_CONSTEXPR_CHAR_TRAITS	0	// TRANSITION, VSO#364512
 #endif /* ^^^ compiler support unavailable ^^^ */
# 505 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 506 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _HAS_CONSTEXPR_CHAR_TRAITS
 #define _CHAR_TRAITS_CONSTEXPR	_CONSTEXPR17
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 510 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CHAR_TRAITS_CONSTEXPR	inline
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 512 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_DEDUCTION_GUIDES
 #if defined(_DEDUCTION_GUIDES_SUPPORTED) || defined(__cpp_deduction_guides)
  #define _HAS_DEDUCTION_GUIDES	_HAS_CXX17
 #else /* ^^^ compiler support available ^^^ // vvv compiler support unavailable vvv */
# 517 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_DEDUCTION_GUIDES	0
 #endif /* ^^^ compiler support unavailable ^^^ */
# 519 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_DEDUCTION_GUIDES */
# 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_INLINE_VARIABLES
 #if defined(_INLINE_VARIABLES_SUPPORTED) || defined(__cpp_inline_variables)
  #define _HAS_INLINE_VARIABLES	_HAS_CXX17
 #else /* ^^^ compiler support available ^^^ // vvv compiler support unavailable vvv */
# 525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_INLINE_VARIABLES	0
 #endif /* ^^^ compiler support unavailable ^^^ */
# 527 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_INLINE_VARIABLES */
# 528 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if _HAS_INLINE_VARIABLES
 #define _INLINE_VAR	inline
#else /* _HAS_INLINE_VARIABLES */
# 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _INLINE_VAR
#endif /* _HAS_INLINE_VARIABLES */
# 534 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if !defined(__STDCPP_DEFAULT_NEW_ALIGNMENT__) /* TRANSITION, VSO#511675 (fixed) */ \
    || (defined(__clang__) && defined(_WIN64)) /* TRANSITION, LLVM#35356 */
 #undef __STDCPP_DEFAULT_NEW_ALIGNMENT__
 #define __STDCPP_DEFAULT_NEW_ALIGNMENT__ (2 * sizeof(void *))
#endif /* __STDCPP_DEFAULT_NEW_ALIGNMENT__ is defined incorrectly or not defined */
# 540 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_ALIGNED_NEW
 #if defined(_ALIGNED_NEW_SUPPORTED) || defined(__cpp_aligned_new) \
     || (defined(__EDG__) && _MSVC_LANG > 201402L) // TRANSITION, VSO#525365
  #define _HAS_ALIGNED_NEW 1
 #else /* ^^^ compiler support available ^^^ // vvv compiler support unavailable vvv */
# 546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_ALIGNED_NEW 0
 #endif /* ^^^ compiler support unavailable ^^^ */
# 548 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_ALIGNED_NEW */
# 549 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _HAS_NOEXCEPT_FUNCTION_TYPES
 #if defined(_NOEXCEPT_TYPES_SUPPORTED) || defined(__cpp_noexcept_function_type)
  #define _HAS_NOEXCEPT_FUNCTION_TYPES	1
 #else /* ^^^ compiler support available ^^^ // vvv compiler support unavailable vvv */
# 554 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _HAS_NOEXCEPT_FUNCTION_TYPES	0
 #endif /* ^^^ compiler support unavailable ^^^ */
# 556 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 557 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifdef _RTC_CONVERSION_CHECKS_ENABLED
 #ifndef _ALLOW_RTCc_IN_STL
  #error /RTCc rejects conformant code, so it is not supported by the C++ Standard Library. Either remove this \
compiler option, or define _ALLOW_RTCc_IN_STL to acknowledge that you have received this warning.
 #endif /* _ALLOW_RTCc_IN_STL */
# 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _RTC_CONVERSION_CHECKS_ENABLED */
# 564 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _DECLSPEC_ALLOCATOR
 #ifdef __clang__
  #define _DECLSPEC_ALLOCATOR
 #else /* ^^^ Clang ^^^ // vvv non-Clang vvv */
# 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _DECLSPEC_ALLOCATOR	__declspec(allocator)
 #endif /* ^^^ non-Clang ^^^ */
# 571 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _DECLSPEC_ALLOCATOR */
# 572 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that
 * have the term DEPRECATE in them. We use deprecate here ONLY to signal the compiler to
 * emit a warning about these items. The use of deprecate should NOT be taken to imply that
 * any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Checked Iterators".
*/

#if defined(MRTDLL) && defined(_CRTBLD)
/*
process-global is the default for code built with /clr or /clr:oldSyntax.
appdomain-global is the default for code built with /clr:pure.
Code in MSVCM is built with /clr, but is used by user code built with /clr:pure
so it must conform to the expectations of /clr:pure clients.
Use __PURE_APPDOMAIN_GLOBAL when a global needs to be appdomain-global for pure
clients and process-global for mixed clients.
*/
#define __PURE_APPDOMAIN_GLOBAL   __declspec(appdomain)
#else
# 594 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#define __PURE_APPDOMAIN_GLOBAL
#endif
# 596 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

		/* CURRENT DLL NAMES */
#ifndef _CRT_MSVCP_CURRENT
	#ifdef _CRT_WINDOWS
		/* Windows */
		#ifdef _DEBUG
			#define _CRT_MSVCP_CURRENT "msvcpd_win.dll"
		#else
# 604 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#define _CRT_MSVCP_CURRENT "msvcp_win.dll"
		#endif
# 606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#else
# 607 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		/* Visual Studio */
		#ifdef _DEBUG
			#define _CRT_MSVCP_CURRENT "msvcp140d.dll"
		#else
# 611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#define _CRT_MSVCP_CURRENT "msvcp140.dll"
		#endif
# 613 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#endif
# 614 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif
# 615 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifdef _ITERATOR_DEBUG_LEVEL /* A. _ITERATOR_DEBUG_LEVEL is already defined. */

	/* A1. Validate _ITERATOR_DEBUG_LEVEL. */
	#if _ITERATOR_DEBUG_LEVEL > 2 && defined(_DEBUG)
		#error _ITERATOR_DEBUG_LEVEL > 2 is not supported in debug mode.
	#elif _ITERATOR_DEBUG_LEVEL > 1 && !defined(_DEBUG)
# 622 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#error _ITERATOR_DEBUG_LEVEL > 1 is not supported in release mode.
	#endif
# 624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	/* A2. Inspect _HAS_ITERATOR_DEBUGGING. */
	#ifdef _HAS_ITERATOR_DEBUGGING /* A2i. _HAS_ITERATOR_DEBUGGING is already defined, validate it. */
		#if _ITERATOR_DEBUG_LEVEL == 2 && _HAS_ITERATOR_DEBUGGING != 1
			#error _ITERATOR_DEBUG_LEVEL == 2 must imply _HAS_ITERATOR_DEBUGGING == 1 .
		#elif _ITERATOR_DEBUG_LEVEL < 2 && _HAS_ITERATOR_DEBUGGING != 0
# 630 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#error _ITERATOR_DEBUG_LEVEL < 2 must imply _HAS_ITERATOR_DEBUGGING == 0 .
		#endif
# 632 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#else /* A2ii. _HAS_ITERATOR_DEBUGGING is not yet defined, derive it. */
# 633 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#if _ITERATOR_DEBUG_LEVEL == 2
			#define _HAS_ITERATOR_DEBUGGING 1
		#else
# 636 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#define _HAS_ITERATOR_DEBUGGING 0
		#endif
# 638 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#endif /* _HAS_ITERATOR_DEBUGGING */
# 639 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	/* A3. Inspect _SECURE_SCL. */
	#ifdef _SECURE_SCL /* A3i. _SECURE_SCL is already defined, validate it. */
		#if _ITERATOR_DEBUG_LEVEL > 0 && _SECURE_SCL != 1
			#error _ITERATOR_DEBUG_LEVEL > 0 must imply _SECURE_SCL == 1 .
		#elif _ITERATOR_DEBUG_LEVEL == 0 && _SECURE_SCL != 0
# 645 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#error _ITERATOR_DEBUG_LEVEL == 0 must imply _SECURE_SCL == 0 .
		#endif
# 647 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#else /* A3ii. _SECURE_SCL is not yet defined, derive it. */
# 648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#if _ITERATOR_DEBUG_LEVEL > 0
			#define _SECURE_SCL 1
		#else
# 651 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#define _SECURE_SCL 0
		#endif
# 653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#endif /* _SECURE_SCL */
# 654 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#else /* B. _ITERATOR_DEBUG_LEVEL is not yet defined. */
# 656 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	/* B1. Inspect _HAS_ITERATOR_DEBUGGING. */
	#ifdef _HAS_ITERATOR_DEBUGGING /* B1i. _HAS_ITERATOR_DEBUGGING is already defined, validate it. */
		#if _HAS_ITERATOR_DEBUGGING > 1
			#error _HAS_ITERATOR_DEBUGGING must be either 0 or 1 .
		#elif _HAS_ITERATOR_DEBUGGING == 1 && !defined(_DEBUG)
# 662 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#error _HAS_ITERATOR_DEBUGGING == 1 is not supported in release mode.
		#endif
# 664 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#else /* B1ii. _HAS_ITERATOR_DEBUGGING is not yet defined, default it. */
# 665 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#ifdef _DEBUG
			#define _HAS_ITERATOR_DEBUGGING 1
		#else
# 668 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#define _HAS_ITERATOR_DEBUGGING 0
		#endif
# 670 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#endif /* _HAS_ITERATOR_DEBUGGING */
# 671 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	/* B2. Inspect _SECURE_SCL. */
	#ifdef _SECURE_SCL /* B2i. _SECURE_SCL is already defined, validate it. */
		#if _SECURE_SCL > 1
			#error _SECURE_SCL must be either 0 or 1 .
		#endif
# 677 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#else /* B2ii. _SECURE_SCL is not yet defined, default it. */
# 678 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#if _HAS_ITERATOR_DEBUGGING == 1
			#define _SECURE_SCL 1
		#else
# 681 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#define _SECURE_SCL 0
		#endif
# 683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#endif /* _SECURE_SCL */
# 684 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	/* B3. Derive _ITERATOR_DEBUG_LEVEL. */
	#if _HAS_ITERATOR_DEBUGGING
		#define _ITERATOR_DEBUG_LEVEL 2
	#elif _SECURE_SCL
# 689 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#define _ITERATOR_DEBUG_LEVEL 1
	#else
# 691 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#define _ITERATOR_DEBUG_LEVEL 0
	#endif
# 693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#endif /* _ITERATOR_DEBUG_LEVEL */
# 695 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#define _STRINGIZEX(x) #x
#define _STRINGIZE(x) _STRINGIZEX(x)

#ifdef __cplusplus
	#ifndef _ALLOW_MSC_VER_MISMATCH
		#pragma detect_mismatch("_MSC_VER", "1900")
	#endif /* _ALLOW_MSC_VER_MISMATCH */
# 703 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	#ifndef _ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", _STRINGIZE(_ITERATOR_DEBUG_LEVEL))
	#endif /* _ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH */
# 707 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	#ifndef _ALLOW_RUNTIME_LIBRARY_MISMATCH
		#if !defined(_DLL) && !defined(_DEBUG)
			#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")
		#elif !defined(_DLL) && defined(_DEBUG)
# 712 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#pragma detect_mismatch("RuntimeLibrary", "MTd_StaticDebug")
		#elif defined(_DLL) && !defined(_DEBUG)
# 714 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
		#elif defined(_DLL) && defined(_DEBUG)
# 716 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
			#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
		#endif /* defined(_DLL) etc. */
# 718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#endif /* _ALLOW_RUNTIME_LIBRARY_MISMATCH */
# 719 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* __cplusplus */
# 720 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifdef _ITERATOR_DEBUG_ARRAY_OVERLOADS
	#if _ITERATOR_DEBUG_ARRAY_OVERLOADS != 0 && _ITERATOR_DEBUG_ARRAY_OVERLOADS != 1
		#error _ITERATOR_DEBUG_ARRAY_OVERLOADS must be either 0 or 1 .
	#elif _ITERATOR_DEBUG_LEVEL == 0 && _ITERATOR_DEBUG_ARRAY_OVERLOADS == 1
# 725 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#error _ITERATOR_DEBUG_LEVEL == 0 must imply _ITERATOR_DEBUG_ARRAY_OVERLOADS == 0 .
	#endif
# 727 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#else /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 728 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	#if _ITERATOR_DEBUG_LEVEL == 0
		#define _ITERATOR_DEBUG_ARRAY_OVERLOADS 0
	#else
# 731 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
		#define _ITERATOR_DEBUG_ARRAY_OVERLOADS 1
	#endif
# 733 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 734 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

/* See note on use of deprecate at the top of this file */
#if !defined(_SCL_SECURE_NO_WARNINGS) && defined(_SCL_SECURE_NO_DEPRECATE)
#define _SCL_SECURE_NO_WARNINGS
#endif
# 739 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if !defined (_SECURE_SCL_DEPRECATE)
#if defined(_SCL_SECURE_NO_WARNINGS)
#define _SECURE_SCL_DEPRECATE 0
#else
# 744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#define _SECURE_SCL_DEPRECATE 1
#endif
# 746 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif
# 747 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

/* _SECURE_SCL switches: helper macros */
/* See note on use of deprecate at the top of this file */

#if _ITERATOR_DEBUG_LEVEL > 0 && _SECURE_SCL_DEPRECATE
#define _SCL_INSECURE_DEPRECATE_FN(_Func) \
	_CRT_DEPRECATE_TEXT( \
		"Call to 'std::" #_Func "' with parameters that may be unsafe - " \
		"this call relies on the caller to check that the passed values are correct. " \
		"To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " \
		"See documentation on how to use Visual C++ 'Checked Iterators'")
#else
# 759 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#define _SCL_INSECURE_DEPRECATE_FN(_Func)
#endif
# 761 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _SCL_SECURE_INVALID_PARAMETER
 #define _SCL_SECURE_INVALID_PARAMETER(expr) _CRT_SECURE_INVALID_PARAMETER(expr)
#endif
# 765 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #define _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT		_SCL_SECURE_INVALID_PARAMETER("invalid argument")
 #define _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT			_SCL_SECURE_INVALID_PARAMETER("out of range")

 #define _SCL_SECURE_ALWAYS_VALIDATE(cond)				\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;		\
		}												\
		_Analysis_assume_(cond);						\
	}

 #define _SCL_SECURE_CRT_VALIDATE(cond, retvalue)		\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_INVALID_PARAMETER(cond);		\
			return (retvalue);							\
		}												\
	}

 #if _ITERATOR_DEBUG_LEVEL > 0

 #define _SCL_SECURE_VALIDATE(cond)						\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;		\
		}												\
		_Analysis_assume_(cond);						\
	}

 #define _SCL_SECURE_VALIDATE_RANGE(cond)				\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE(#cond && 0);						\
			_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;			\
		}												\
		_Analysis_assume_(cond);						\
	}

 #else /* _ITERATOR_DEBUG_LEVEL > 0 */
# 812 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #define _SCL_SECURE_VALIDATE(cond)
 #define _SCL_SECURE_VALIDATE_RANGE(cond)

 #endif /* _ITERATOR_DEBUG_LEVEL > 0 */
# 817 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if __STDC_WANT_SECURE_LIB__
#define _CRT_SECURE_MEMCPY(dest, destsize, source, count) ::memcpy_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_WMEMCPY(dest, destsize, source, count) ::wmemcpy_s((dest), (destsize), (source), (count))
#else
# 822 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#define _CRT_SECURE_MEMCPY(dest, destsize, source, count) ::memcpy((dest), (source), (count))
#define _CRT_SECURE_WMEMCPY(dest, destsize, source, count) ::wmemcpy((dest), (source), (count))
#endif
# 825 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <use_ansi.h>
#endif /* expanded by -frewrite-includes */
# 826 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 1 3
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _CRTBLD
#define _CRT_NOPRAGMA_LIBS
#else
# 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3
#undef _CRT_NOPRAGMA_LIBS
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#ifndef _CRT_NOPRAGMA_LIBS

#if !defined(_M_CEE_PURE) && !defined(MRTDLL)

#undef _DEBUG_AFFIX
#undef _IDL_AFFIX
#undef _IDL_DEFAULT
#undef _LIB_STEM

#ifdef _DEBUG
    #define _DEBUG_AFFIX "d"
    #define _IDL_DEFAULT 2
#else
# 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3
    #define _DEBUG_AFFIX ""
    #define _IDL_DEFAULT 0
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _LIB_STEM "msvcprt"
#else
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3
    #define _LIB_STEM "libcpmt"

    #if _ITERATOR_DEBUG_LEVEL != _IDL_DEFAULT
        #define _IDL_AFFIX _STRINGIZE(_ITERATOR_DEBUG_LEVEL)
    #endif
# 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3
#endif
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#ifdef _IDL_AFFIX
#else
# 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3
    #define _IDL_AFFIX ""
#endif
# 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#pragma comment(lib, _LIB_STEM _DEBUG_AFFIX _IDL_AFFIX)

#undef _DEBUG_AFFIX
#undef _IDL_AFFIX
#undef _IDL_DEFAULT
#undef _LIB_STEM

#endif /* !defined(_M_CEE_PURE) && !defined(MRTDLL) */
# 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#endif  /* _CRT_NOPRAGMA_LIBS */
# 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3

#endif	/* _USE_ANSI_CPP */
# 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\use_ansi.h" 3
# 827 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 2 3

#define _WARNING_MESSAGE(NUMBER, MESSAGE) \
	__FILE__ "(" _CRT_STRINGIZE(__LINE__) "): warning " NUMBER ": " MESSAGE

#ifdef _STATIC_CPPLIB
    #ifndef _DISABLE_DEPRECATE_STATIC_CPPLIB
        #ifdef _DLL
            #pragma message(_WARNING_MESSAGE("STL4000", "_STATIC_CPPLIB is deprecated and will be REMOVED."))
        #endif
# 836 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
        #ifdef _M_CEE_MIXED
            #error _STATIC_CPPLIB is not supported while building with /clr
        #endif
# 839 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
    #endif // !_DISABLE_DEPRECATE_STATIC_CPPLIB
# 840 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
    #ifdef _M_CEE_PURE
        #error _STATIC_CPPLIB cannot be used with /clr:pure (the resulting assembly would not be pure)
    #endif
# 843 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif // _STATIC_CPPLIB
# 844 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#if defined(_M_CEE_PURE) && !defined(_SILENCE_CLR_PURE_DEPRECATION_WARNING)
	#pragma message(_WARNING_MESSAGE("STL4001", "/clr:pure is deprecated and will be REMOVED."))
#endif
# 848 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #ifndef _MRTIMP2_PURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_PURE
  #else
# 853 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _MRTIMP2_PURE _MRTIMP2
  #endif
# 855 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif
# 856 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #ifndef _MRTIMP2_PURE_NPURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_PURE_NPURE
  #else
# 861 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _MRTIMP2_PURE_NPURE _MRTIMP2_NPURE
  #endif
# 863 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif
# 864 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

/* Define _MRTIMP2_NPURE */
 #ifndef _MRTIMP2_NPURE
  #if   defined(MRTDLL) && defined(_CRTBLD)
    #if !defined(_M_CEE_PURE)
      #define _MRTIMP2_NPURE __declspec(dllexport)
    #else
# 871 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
      #define _MRTIMP2_NPURE
    #endif
# 873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #else   /* ndef MRTDLL && _CRTBLD */
# 874 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _MRTIMP2_NPURE
  #endif  /* MRTDLL && _CRTBLD */
# 876 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif  /* _MRTIMP2_NPURE */
# 877 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #if defined(_DLL) && !defined(_STATIC_CPPLIB) && !defined(_M_CEE_PURE)
  #define _DLL_CPPLIB
 #endif
# 881 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #ifndef _CRTIMP2_PURE
  #if   defined(MRTDLL) && defined(_CRTBLD)
   #define _CRTIMP2_PURE
  #else
# 886 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #ifdef  _M_CEE_PURE
     #define _CRTIMP2_PURE
   #else
# 889 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
     #define _CRTIMP2_PURE _CRTIMP2
   #endif
# 891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #endif
# 892 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif
# 893 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

 #ifdef _CRTBLD
/* These functions are for enabling STATIC_CPPLIB functionality */
  #define _cpp_stdin  (__acrt_iob_func(0))
  #define _cpp_stdout (__acrt_iob_func(1))
  #define _cpp_stderr (__acrt_iob_func(2))
  #define _cpp_isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
 #endif  /* _CRTBLD */
# 901 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _CRTIMP2_IMPORT
 #if defined(CRTDLL2) && defined(_CRTBLD)
  #define _CRTIMP2_IMPORT __declspec(dllexport)
 #else
# 906 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #if defined(_DLL) && !defined(_STATIC_CPPLIB)
   #define _CRTIMP2_IMPORT __declspec(dllimport)
  #else
# 909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _CRTIMP2_IMPORT
  #endif
# 911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif
# 912 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif
# 913 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _CRTIMP2_PURE_IMPORT
 #if defined(MRTDLL) && defined(_CRTBLD)
  #define _CRTIMP2_PURE_IMPORT
 #else
# 918 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #ifdef _M_CEE_PURE
   #define _CRTIMP2_PURE_IMPORT
  #else
# 921 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _CRTIMP2_PURE_IMPORT _CRTIMP2_IMPORT
  #endif
# 923 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #endif
# 924 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif
# 925 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _CRTDATA2_IMPORT
 #if defined(MRTDLL) && defined(_CRTBLD)
  #define _CRTDATA2_IMPORT
 #else
# 930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _CRTDATA2_IMPORT _CRTIMP2_IMPORT
 #endif
# 932 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif
# 933 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _CRTIMP2_NCEEPURE_IMPORT
 #ifdef _M_CEE_PURE
  #define _CRTIMP2_NCEEPURE_IMPORT
 #else
# 938 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _CRTIMP2_NCEEPURE_IMPORT _CRTIMP2_IMPORT
 #endif
# 940 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif
# 941 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

		/* NAMESPACE */
#define _STD_BEGIN	namespace std {
#define _STD_END	}
#define _STD	::std::

/*
We use the stdext (standard extension) namespace to contain extensions that are not part of the current standard
*/
#define _STDEXT_BEGIN	namespace stdext {
#define _STDEXT_END		}
#define _STDEXT			::stdext::

#ifdef __cplusplus
 #define _CSTD	::

 #define _EXTERN_C			extern "C" {
 #define _END_EXTERN_C		}
#else /* ^^^ __cplusplus ^^^ // vvv !__cplusplus vvv */
# 960 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
 #define _CSTD

 #define _EXTERN_C
 #define _END_EXTERN_C
#endif /* __cplusplus */
# 965 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG_V1	36
#define _MAX_SIG_DIG_V2	768

		/* STDIO PROPERTIES */
#define _Filet FILE

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE			0
#define _LOCK_MALLOC			1
#define _LOCK_STREAM			2
#define _LOCK_DEBUG				3
#define _LOCK_AT_THREAD_EXIT	4

 #ifdef __cplusplus
_STD_BEGIN
enum _Uninitialized
	{	// tag for suppressing initialization
	_Noinit
	};

		// CLASS _Lockit
class _CRTIMP2_PURE_IMPORT _Lockit
	{	// lock while object in existence -- MUST NEST
public:
 #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Lockit()
		: _Locktype(0)
		{	// default construct
		_Lockit_ctor(this);
		}

	explicit __CLR_OR_THIS_CALL _Lockit(int _Kind)
		{	// set the lock
		_Lockit_ctor(this, _Kind);
		}

	__CLR_OR_THIS_CALL ~_Lockit() _NOEXCEPT
		{	// clear the lock
		_Lockit_dtor(this);
		}

 #else /* defined(_M_CEE_PURE) || defined(MRTDLL) */
# 1016 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	__thiscall _Lockit();	// default construct
	explicit __thiscall _Lockit(int);	// set the lock
	__thiscall ~_Lockit() _NOEXCEPT;	// clear the lock
 #endif /* defined(_M_CEE_PURE) || defined(MRTDLL) */
# 1020 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

	static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(int);
	static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(int);

private:
	static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *);
	static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *, int);
	static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(_Lockit *);

public:
	__CLR_OR_THIS_CALL _Lockit(const _Lockit&) = delete;
	_Lockit& __CLR_OR_THIS_CALL operator=(const _Lockit&) = delete;

private:
	int _Locktype;
	};

 #ifdef _M_CEE
class _CRTIMP2_PURE_IMPORT _EmptyLockit
	{	// empty lock class used for bin compat
private:
	int _Locktype;
	};

  #ifndef _PREPARE_CONSTRAINED_REGIONS
   #ifdef _M_CEE_PURE
    #define _PREPARE_CONSTRAINED_REGIONS	1
   #else /* _M_CEE_PURE */
# 1048 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
    #define _PREPARE_CONSTRAINED_REGIONS	0
   #endif /* _M_CEE_PURE */
# 1050 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #endif /* _PREPARE_CONSTRAINED_REGIONS */
# 1051 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

  #if _PREPARE_CONSTRAINED_REGIONS
   #define _BEGIN_LOCK(_Kind) \
	{ \
	bool _MustReleaseLock = false; \
	int _LockKind = _Kind; \
	System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
	try \
		{ \
		System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
		try \
			{ \
			} \
		finally \
			{ \
			_STD _Lockit::_Lockit_ctor(_LockKind); \
			_MustReleaseLock = true; \
			}

   #define _END_LOCK() \
		} \
	finally \
		{ \
		if (_MustReleaseLock) \
			{ \
			_STD _Lockit::_Lockit_dtor(_LockKind); \
			} \
		} \
	}

  #else /* _PREPARE_CONSTRAINED_REGIONS */
# 1082 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
   #define _BEGIN_LOCK(_Kind) \
	{ \
		_STD _Lockit _Lock(_Kind);

   #define _END_LOCK() \
	}

  #endif /* _PREPARE_CONSTRAINED_REGIONS */
# 1090 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

  #define _BEGIN_LOCINFO(_VarName) \
	_BEGIN_LOCK(_LOCK_LOCALE) \
	_Locinfo _VarName;

  #define _END_LOCINFO() \
	_END_LOCK()

  #define _RELIABILITY_CONTRACT \
	[System::Runtime::ConstrainedExecution::ReliabilityContract( \
		System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState, \
		System::Runtime::ConstrainedExecution::Cer::Success)]

 #else /* _M_CEE */
# 1104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
  #define _BEGIN_LOCK(_Kind) \
	{ \
		_STD _Lockit _Lock(_Kind);

  #define _END_LOCK() \
	}

  #define _BEGIN_LOCINFO(_VarName) \
	{ \
		_Locinfo _VarName;

  #define _END_LOCINFO() \
	}

  #define _RELIABILITY_CONTRACT
 #endif /* _M_CEE */
# 1120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

class _CRTIMP2_PURE_IMPORT _Init_locks
	{	// initialize mutexes
public:
 #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Init_locks()
		{	// default construct
		_Init_locks_ctor(this);
		}

	__CLR_OR_THIS_CALL ~_Init_locks() _NOEXCEPT
		{	// destroy the object
		_Init_locks_dtor(this);
		}

 #else /* defined(_M_CEE_PURE) || defined(MRTDLL) */
# 1136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
	__thiscall _Init_locks();
	__thiscall ~_Init_locks() _NOEXCEPT;
 #endif /* defined(_M_CEE_PURE) || defined(MRTDLL) */
# 1139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

private:
	static _MRTIMP2_NPURE void __cdecl _Init_locks_ctor(_Init_locks *);
	static _MRTIMP2_NPURE void __cdecl _Init_locks_dtor(_Init_locks *);
	};

_STD_END
 #endif /* __cplusplus */
# 1147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

#ifndef _RELIABILITY_CONTRACT
 #define _RELIABILITY_CONTRACT
#endif /* _RELIABILITY_CONTRACT */
# 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

		/* MISCELLANEOUS MACROS AND TYPES */
_MRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;

#define _Mbstinit(x)	mbstate_t x = {}

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3
#endif /* _YVALS */
# 1164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\yvals.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <stdint.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 1 3
/*===---- stdint.h - Standard header for sized integer types --------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __CLANG_STDINT_H
#define __CLANG_STDINT_H

/* If we're hosted, fall back to the system's stdint.h, which might have
 * additional definitions.
 */
#if __STDC_HOSTED__ && (1)/*__has_include_next(<stdint.h>)*/

// C99 7.18.3 Limits of other integer types
//
//  Footnote 219, 220: C++ implementations should define these macros only when
//  __STDC_LIMIT_MACROS is defined before <stdint.h> is included.
//
//  Footnote 222: C++ implementations should define these macros only when
//  __STDC_CONSTANT_MACROS is defined before <stdint.h> is included.
//
// C++11 [cstdint.syn]p2:
//
//  The macros defined by <cstdint> are provided unconditionally. In particular,
//  the symbols __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS (mentioned in
//  footnotes 219, 220, and 222 in the C standard) play no role in C++.
//
// C11 removed the problematic footnotes.
//
// Work around this inconsistency by always defining those macros in C++ mode,
// so that a C library implementation which follows the C99 standard can be
// used in C++.
# ifdef __cplusplus
#  if !defined(__STDC_LIMIT_MACROS)
#   define __STDC_LIMIT_MACROS
#   define __STDC_LIMIT_MACROS_DEFINED_BY_CLANG
#  endif
# 59 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  if !defined(__STDC_CONSTANT_MACROS)
#   define __STDC_CONSTANT_MACROS
#   define __STDC_CONSTANT_MACROS_DEFINED_BY_CLANG
#  endif
# 63 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# endif
# 64 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#if 0 /* expanded by -frewrite-includes */
# include_next <stdint.h>
#endif /* expanded by -frewrite-includes */
# 65 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 1 3
//
// stdint.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdint.h> header.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 3
#define _STDINT

#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 2 3



typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64

#define INT_LEAST8_MIN   INT8_MIN
#define INT_LEAST16_MIN  INT16_MIN
#define INT_LEAST32_MIN  INT32_MIN
#define INT_LEAST64_MIN  INT64_MIN
#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX
#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_MIN    INT8_MIN
#define INT_FAST16_MIN   INT32_MIN
#define INT_FAST32_MIN   INT32_MIN
#define INT_FAST64_MIN   INT64_MIN
#define INT_FAST8_MAX    INT8_MAX
#define INT_FAST16_MAX   INT32_MAX
#define INT_FAST32_MAX   INT32_MAX
#define INT_FAST64_MAX   INT64_MAX
#define UINT_FAST8_MAX   UINT8_MAX
#define UINT_FAST16_MAX  UINT32_MAX
#define UINT_FAST32_MAX  UINT32_MAX
#define UINT_FAST64_MAX  UINT64_MAX

#ifdef _WIN64
    #define INTPTR_MIN   INT64_MIN
    #define INTPTR_MAX   INT64_MAX
    #define UINTPTR_MAX  UINT64_MAX
#else
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 3
    #define INTPTR_MIN   INT32_MIN
    #define INTPTR_MAX   INT32_MAX
    #define UINTPTR_MAX  UINT32_MAX
#endif
# 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 3

#define INTMAX_MIN       INT64_MIN
#define INTMAX_MAX       INT64_MAX
#define UINTMAX_MAX      UINT64_MAX

#define PTRDIFF_MIN      INTPTR_MIN
#define PTRDIFF_MAX      INTPTR_MAX

#ifndef SIZE_MAX
    #define SIZE_MAX     UINTPTR_MAX
#endif
# 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 3

#define SIG_ATOMIC_MIN   INT32_MIN
#define SIG_ATOMIC_MAX   INT32_MAX

#define WCHAR_MIN        0x0000
#define WCHAR_MAX        0xffff

#define WINT_MIN         0x0000
#define WINT_MAX         0xffff

#define INT8_C(x)    (x)
#define INT16_C(x)   (x)
#define INT32_C(x)   (x)
#define INT64_C(x)   (x ## LL)

#define UINT8_C(x)   (x)
#define UINT16_C(x)  (x)
#define UINT32_C(x)  (x ## U)
#define UINT64_C(x)  (x ## ULL)

#define INTMAX_C(x)  INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)



#endif // RC_INVOKED
# 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdint.h" 3

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */
# 66 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 2 3

# ifdef __STDC_LIMIT_MACROS_DEFINED_BY_CLANG
#  undef __STDC_LIMIT_MACROS
#  undef __STDC_LIMIT_MACROS_DEFINED_BY_CLANG
# endif
# 71 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# ifdef __STDC_CONSTANT_MACROS_DEFINED_BY_CLANG
#  undef __STDC_CONSTANT_MACROS
#  undef __STDC_CONSTANT_MACROS_DEFINED_BY_CLANG
# endif
# 75 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#else
# 77 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* C99 7.18.1.1 Exact-width integer types.
 * C99 7.18.1.2 Minimum-width integer types.
 * C99 7.18.1.3 Fastest minimum-width integer types.
 *
 * The standard requires that exact-width type be defined for 8-, 16-, 32-, and
 * 64-bit types if they are implemented. Other exact width types are optional.
 * This implementation defines an exact-width types for every integer width
 * that is represented in the standard integer types.
 *
 * The standard also requires minimum-width types be defined for 8-, 16-, 32-,
 * and 64-bit widths regardless of whether there are corresponding exact-width
 * types.
 *
 * To accommodate targets that are missing types that are exactly 8, 16, 32, or
 * 64 bits wide, this implementation takes an approach of cascading
 * redefintions, redefining __int_leastN_t to successively smaller exact-width
 * types. It is therefore important that the types are defined in order of
 * descending widths.
 *
 * We currently assume that the minimum-width types and the fastest
 * minimum-width types are the same. This is allowed by the standard, but is
 * suboptimal.
 *
 * In violation of the standard, some targets do not implement a type that is
 * wide enough to represent all of the required widths (8-, 16-, 32-, 64-bit).
 * To accommodate these targets, a required minimum-width type is only
 * defined if there exists an exact-width type of equal or greater width.
 */

#ifdef __INT64_TYPE__
# ifndef __int8_t_defined /* glibc sys/types.h also defines int64_t*/
typedef __INT64_TYPE__ int64_t;
# endif /* __int8_t_defined */
# 111 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
typedef __UINT64_TYPE__ uint64_t;
# define __int_least64_t int64_t
# define __uint_least64_t uint64_t
# define __int_least32_t int64_t
# define __uint_least32_t uint64_t
# define __int_least16_t int64_t
# define __uint_least16_t uint64_t
# define __int_least8_t int64_t
# define __uint_least8_t uint64_t
#endif /* __INT64_TYPE__ */
# 121 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least64_t
typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
typedef __int_least64_t int_fast64_t;
typedef __uint_least64_t uint_fast64_t;
#endif /* __int_least64_t */
# 128 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT56_TYPE__
typedef __INT56_TYPE__ int56_t;
typedef __UINT56_TYPE__ uint56_t;
typedef int56_t int_least56_t;
typedef uint56_t uint_least56_t;
typedef int56_t int_fast56_t;
typedef uint56_t uint_fast56_t;
# define __int_least32_t int56_t
# define __uint_least32_t uint56_t
# define __int_least16_t int56_t
# define __uint_least16_t uint56_t
# define __int_least8_t int56_t
# define __uint_least8_t uint56_t
#endif /* __INT56_TYPE__ */
# 143 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT48_TYPE__
typedef __INT48_TYPE__ int48_t;
typedef __UINT48_TYPE__ uint48_t;
typedef int48_t int_least48_t;
typedef uint48_t uint_least48_t;
typedef int48_t int_fast48_t;
typedef uint48_t uint_fast48_t;
# define __int_least32_t int48_t
# define __uint_least32_t uint48_t
# define __int_least16_t int48_t
# define __uint_least16_t uint48_t
# define __int_least8_t int48_t
# define __uint_least8_t uint48_t
#endif /* __INT48_TYPE__ */
# 159 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT40_TYPE__
typedef __INT40_TYPE__ int40_t;
typedef __UINT40_TYPE__ uint40_t;
typedef int40_t int_least40_t;
typedef uint40_t uint_least40_t;
typedef int40_t int_fast40_t;
typedef uint40_t uint_fast40_t;
# define __int_least32_t int40_t
# define __uint_least32_t uint40_t
# define __int_least16_t int40_t
# define __uint_least16_t uint40_t
# define __int_least8_t int40_t
# define __uint_least8_t uint40_t
#endif /* __INT40_TYPE__ */
# 175 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT32_TYPE__

# ifndef __int8_t_defined /* glibc sys/types.h also defines int32_t*/
typedef __INT32_TYPE__ int32_t;
# endif /* __int8_t_defined */
# 182 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

# ifndef __uint32_t_defined  /* more glibc compatibility */
# define __uint32_t_defined
typedef __UINT32_TYPE__ uint32_t;
# endif /* __uint32_t_defined */
# 187 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

# define __int_least32_t int32_t
# define __uint_least32_t uint32_t
# define __int_least16_t int32_t
# define __uint_least16_t uint32_t
# define __int_least8_t int32_t
# define __uint_least8_t uint32_t
#endif /* __INT32_TYPE__ */
# 195 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least32_t
typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;
typedef __int_least32_t int_fast32_t;
typedef __uint_least32_t uint_fast32_t;
#endif /* __int_least32_t */
# 202 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT24_TYPE__
typedef __INT24_TYPE__ int24_t;
typedef __UINT24_TYPE__ uint24_t;
typedef int24_t int_least24_t;
typedef uint24_t uint_least24_t;
typedef int24_t int_fast24_t;
typedef uint24_t uint_fast24_t;
# define __int_least16_t int24_t
# define __uint_least16_t uint24_t
# define __int_least8_t int24_t
# define __uint_least8_t uint24_t
#endif /* __INT24_TYPE__ */
# 215 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT16_TYPE__
#ifndef __int8_t_defined /* glibc sys/types.h also defines int16_t*/
typedef __INT16_TYPE__ int16_t;
#endif /* __int8_t_defined */
# 220 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
typedef __UINT16_TYPE__ uint16_t;
# define __int_least16_t int16_t
# define __uint_least16_t uint16_t
# define __int_least8_t int16_t
# define __uint_least8_t uint16_t
#endif /* __INT16_TYPE__ */
# 226 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least16_t
typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;
typedef __int_least16_t int_fast16_t;
typedef __uint_least16_t uint_fast16_t;
#endif /* __int_least16_t */
# 233 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT8_TYPE__
#ifndef __int8_t_defined  /* glibc sys/types.h also defines int8_t*/
typedef __INT8_TYPE__ int8_t;
#endif /* __int8_t_defined */
# 239 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
typedef __UINT8_TYPE__ uint8_t;
# define __int_least8_t int8_t
# define __uint_least8_t uint8_t
#endif /* __INT8_TYPE__ */
# 243 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least8_t
typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;
typedef __int_least8_t int_fast8_t;
typedef __uint_least8_t uint_fast8_t;
#endif /* __int_least8_t */
# 250 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* prevent glibc sys/types.h from defining conflicting types */
#ifndef __int8_t_defined
# define __int8_t_defined
#endif /* __int8_t_defined */
# 255 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* C99 7.18.1.4 Integer types capable of holding object pointers.
 */
#define __stdint_join3(a,b,c) a ## b ## c

#ifndef _INTPTR_T
#ifndef __intptr_t_defined
typedef __INTPTR_TYPE__ intptr_t;
#define __intptr_t_defined
#define _INTPTR_T
#endif
# 266 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif
# 267 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifndef _UINTPTR_T
typedef __UINTPTR_TYPE__ uintptr_t;
#define _UINTPTR_T
#endif
# 272 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* C99 7.18.1.5 Greatest-width integer types.
 */
typedef __INTMAX_TYPE__  intmax_t;
typedef __UINTMAX_TYPE__ uintmax_t;

/* C99 7.18.4 Macros for minimum-width integer constants.
 *
 * The standard requires that integer constant macros be defined for all the
 * minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width
 * types are required, the corresponding integer constant macros are defined
 * here. This implementation also defines minimum-width types for every other
 * integer width that the target implements, so corresponding macros are
 * defined below, too.
 *
 * These macros are defined using the same successive-shrinking approach as
 * the type definitions above. It is likewise important that macros are defined
 * in order of decending width.
 *
 * Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the
 * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).
 */

#define __int_c_join(a, b) a ## b
#define __int_c(v, suffix) __int_c_join(v, suffix)
#define __uint_c(v, suffix) __int_c_join(v##U, suffix)


#ifdef __INT64_TYPE__
# ifdef __INT64_C_SUFFIX__
#  define __int64_c_suffix __INT64_C_SUFFIX__
#  define __int32_c_suffix __INT64_C_SUFFIX__
#  define __int16_c_suffix __INT64_C_SUFFIX__
#  define  __int8_c_suffix __INT64_C_SUFFIX__
# else
# 307 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  undef __int64_c_suffix
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT64_C_SUFFIX__ */
# 312 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT64_TYPE__ */
# 313 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least64_t
# ifdef __int64_c_suffix
#  define INT64_C(v) __int_c(v, __int64_c_suffix)
#  define UINT64_C(v) __uint_c(v, __int64_c_suffix)
# else
# 319 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT64_C(v) v
#  define UINT64_C(v) v ## U
# endif /* __int64_c_suffix */
# 322 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __int_least64_t */
# 323 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT56_TYPE__
# ifdef __INT56_C_SUFFIX__
#  define INT56_C(v) __int_c(v, __INT56_C_SUFFIX__)
#  define UINT56_C(v) __uint_c(v, __INT56_C_SUFFIX__)
#  define __int32_c_suffix __INT56_C_SUFFIX__
#  define __int16_c_suffix __INT56_C_SUFFIX__
#  define __int8_c_suffix  __INT56_C_SUFFIX__
# else
# 333 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT56_C(v) v
#  define UINT56_C(v) v ## U
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT56_C_SUFFIX__ */
# 339 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT56_TYPE__ */
# 340 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT48_TYPE__
# ifdef __INT48_C_SUFFIX__
#  define INT48_C(v) __int_c(v, __INT48_C_SUFFIX__)
#  define UINT48_C(v) __uint_c(v, __INT48_C_SUFFIX__)
#  define __int32_c_suffix __INT48_C_SUFFIX__
#  define __int16_c_suffix __INT48_C_SUFFIX__
#  define __int8_c_suffix  __INT48_C_SUFFIX__
# else
# 350 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT48_C(v) v
#  define UINT48_C(v) v ## U
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT48_C_SUFFIX__ */
# 356 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT48_TYPE__ */
# 357 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT40_TYPE__
# ifdef __INT40_C_SUFFIX__
#  define INT40_C(v) __int_c(v, __INT40_C_SUFFIX__)
#  define UINT40_C(v) __uint_c(v, __INT40_C_SUFFIX__)
#  define __int32_c_suffix __INT40_C_SUFFIX__
#  define __int16_c_suffix __INT40_C_SUFFIX__
#  define __int8_c_suffix  __INT40_C_SUFFIX__
# else
# 367 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT40_C(v) v
#  define UINT40_C(v) v ## U
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT40_C_SUFFIX__ */
# 373 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT40_TYPE__ */
# 374 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT32_TYPE__
# ifdef __INT32_C_SUFFIX__
#  define __int32_c_suffix __INT32_C_SUFFIX__
#  define __int16_c_suffix __INT32_C_SUFFIX__
#  define __int8_c_suffix  __INT32_C_SUFFIX__
#else
# 382 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT32_C_SUFFIX__ */
# 386 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT32_TYPE__ */
# 387 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least32_t
# ifdef __int32_c_suffix
#  define INT32_C(v) __int_c(v, __int32_c_suffix)
#  define UINT32_C(v) __uint_c(v, __int32_c_suffix)
# else
# 393 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT32_C(v) v
#  define UINT32_C(v) v ## U
# endif /* __int32_c_suffix */
# 396 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __int_least32_t */
# 397 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT24_TYPE__
# ifdef __INT24_C_SUFFIX__
#  define INT24_C(v) __int_c(v, __INT24_C_SUFFIX__)
#  define UINT24_C(v) __uint_c(v, __INT24_C_SUFFIX__)
#  define __int16_c_suffix __INT24_C_SUFFIX__
#  define __int8_c_suffix  __INT24_C_SUFFIX__
# else
# 406 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT24_C(v) v
#  define UINT24_C(v) v ## U
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT24_C_SUFFIX__ */
# 411 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT24_TYPE__ */
# 412 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT16_TYPE__
# ifdef __INT16_C_SUFFIX__
#  define __int16_c_suffix __INT16_C_SUFFIX__
#  define __int8_c_suffix  __INT16_C_SUFFIX__
#else
# 419 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT16_C_SUFFIX__ */
# 422 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT16_TYPE__ */
# 423 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least16_t
# ifdef __int16_c_suffix
#  define INT16_C(v) __int_c(v, __int16_c_suffix)
#  define UINT16_C(v) __uint_c(v, __int16_c_suffix)
# else
# 429 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT16_C(v) v
#  define UINT16_C(v) v ## U
# endif /* __int16_c_suffix */
# 432 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __int_least16_t */
# 433 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT8_TYPE__
# ifdef __INT8_C_SUFFIX__
#  define __int8_c_suffix __INT8_C_SUFFIX__
#else
# 439 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  undef  __int8_c_suffix
# endif /* __INT8_C_SUFFIX__ */
# 441 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __INT8_TYPE__ */
# 442 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __int_least8_t
# ifdef __int8_c_suffix
#  define INT8_C(v) __int_c(v, __int8_c_suffix)
#  define UINT8_C(v) __uint_c(v, __int8_c_suffix)
# else
# 448 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define INT8_C(v) v
#  define UINT8_C(v) v ## U
# endif /* __int8_c_suffix */
# 451 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __int_least8_t */
# 452 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


/* C99 7.18.2.1 Limits of exact-width integer types.
 * C99 7.18.2.2 Limits of minimum-width integer types.
 * C99 7.18.2.3 Limits of fastest minimum-width integer types.
 *
 * The presence of limit macros are completely optional in C99.  This
 * implementation defines limits for all of the types (exact- and
 * minimum-width) that it defines above, using the limits of the minimum-width
 * type for any types that do not have exact-width representations.
 *
 * As in the type definitions, this section takes an approach of
 * successive-shrinking to determine which limits to use for the standard (8,
 * 16, 32, 64) bit widths when they don't have exact representations. It is
 * therefore important that the defintions be kept in order of decending
 * widths.
 *
 * Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the
 * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).
 */

#ifdef __INT64_TYPE__
# define INT64_MAX           INT64_C( 9223372036854775807)
# define INT64_MIN         (-INT64_C( 9223372036854775807)-1)
# define UINT64_MAX         UINT64_C(18446744073709551615)
# define __INT_LEAST64_MIN   INT64_MIN
# define __INT_LEAST64_MAX   INT64_MAX
# define __UINT_LEAST64_MAX UINT64_MAX
# define __INT_LEAST32_MIN   INT64_MIN
# define __INT_LEAST32_MAX   INT64_MAX
# define __UINT_LEAST32_MAX UINT64_MAX
# define __INT_LEAST16_MIN   INT64_MIN
# define __INT_LEAST16_MAX   INT64_MAX
# define __UINT_LEAST16_MAX UINT64_MAX
# define __INT_LEAST8_MIN    INT64_MIN
# define __INT_LEAST8_MAX    INT64_MAX
# define __UINT_LEAST8_MAX  UINT64_MAX
#endif /* __INT64_TYPE__ */
# 490 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT_LEAST64_MIN
# define INT_LEAST64_MIN   __INT_LEAST64_MIN
# define INT_LEAST64_MAX   __INT_LEAST64_MAX
# define UINT_LEAST64_MAX __UINT_LEAST64_MAX
# define INT_FAST64_MIN    __INT_LEAST64_MIN
# define INT_FAST64_MAX    __INT_LEAST64_MAX
# define UINT_FAST64_MAX  __UINT_LEAST64_MAX
#endif /* __INT_LEAST64_MIN */
# 499 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT56_TYPE__
# define INT56_MAX           INT56_C(36028797018963967)
# define INT56_MIN         (-INT56_C(36028797018963967)-1)
# define UINT56_MAX         UINT56_C(72057594037927935)
# define INT_LEAST56_MIN     INT56_MIN
# define INT_LEAST56_MAX     INT56_MAX
# define UINT_LEAST56_MAX   UINT56_MAX
# define INT_FAST56_MIN      INT56_MIN
# define INT_FAST56_MAX      INT56_MAX
# define UINT_FAST56_MAX    UINT56_MAX
# define __INT_LEAST32_MIN   INT56_MIN
# define __INT_LEAST32_MAX   INT56_MAX
# define __UINT_LEAST32_MAX UINT56_MAX
# define __INT_LEAST16_MIN   INT56_MIN
# define __INT_LEAST16_MAX   INT56_MAX
# define __UINT_LEAST16_MAX UINT56_MAX
# define __INT_LEAST8_MIN    INT56_MIN
# define __INT_LEAST8_MAX    INT56_MAX
# define __UINT_LEAST8_MAX  UINT56_MAX
#endif /* __INT56_TYPE__ */
# 521 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT48_TYPE__
# define INT48_MAX           INT48_C(140737488355327)
# define INT48_MIN         (-INT48_C(140737488355327)-1)
# define UINT48_MAX         UINT48_C(281474976710655)
# define INT_LEAST48_MIN     INT48_MIN
# define INT_LEAST48_MAX     INT48_MAX
# define UINT_LEAST48_MAX   UINT48_MAX
# define INT_FAST48_MIN      INT48_MIN
# define INT_FAST48_MAX      INT48_MAX
# define UINT_FAST48_MAX    UINT48_MAX
# define __INT_LEAST32_MIN   INT48_MIN
# define __INT_LEAST32_MAX   INT48_MAX
# define __UINT_LEAST32_MAX UINT48_MAX
# define __INT_LEAST16_MIN   INT48_MIN
# define __INT_LEAST16_MAX   INT48_MAX
# define __UINT_LEAST16_MAX UINT48_MAX
# define __INT_LEAST8_MIN    INT48_MIN
# define __INT_LEAST8_MAX    INT48_MAX
# define __UINT_LEAST8_MAX  UINT48_MAX
#endif /* __INT48_TYPE__ */
# 543 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT40_TYPE__
# define INT40_MAX           INT40_C(549755813887)
# define INT40_MIN         (-INT40_C(549755813887)-1)
# define UINT40_MAX         UINT40_C(1099511627775)
# define INT_LEAST40_MIN     INT40_MIN
# define INT_LEAST40_MAX     INT40_MAX
# define UINT_LEAST40_MAX   UINT40_MAX
# define INT_FAST40_MIN      INT40_MIN
# define INT_FAST40_MAX      INT40_MAX
# define UINT_FAST40_MAX    UINT40_MAX
# define __INT_LEAST32_MIN   INT40_MIN
# define __INT_LEAST32_MAX   INT40_MAX
# define __UINT_LEAST32_MAX UINT40_MAX
# define __INT_LEAST16_MIN   INT40_MIN
# define __INT_LEAST16_MAX   INT40_MAX
# define __UINT_LEAST16_MAX UINT40_MAX
# define __INT_LEAST8_MIN    INT40_MIN
# define __INT_LEAST8_MAX    INT40_MAX
# define __UINT_LEAST8_MAX  UINT40_MAX
#endif /* __INT40_TYPE__ */
# 565 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT32_TYPE__
# define INT32_MAX           INT32_C(2147483647)
# define INT32_MIN         (-INT32_C(2147483647)-1)
# define UINT32_MAX         UINT32_C(4294967295)
# define __INT_LEAST32_MIN   INT32_MIN
# define __INT_LEAST32_MAX   INT32_MAX
# define __UINT_LEAST32_MAX UINT32_MAX
# define __INT_LEAST16_MIN   INT32_MIN
# define __INT_LEAST16_MAX   INT32_MAX
# define __UINT_LEAST16_MAX UINT32_MAX
# define __INT_LEAST8_MIN    INT32_MIN
# define __INT_LEAST8_MAX    INT32_MAX
# define __UINT_LEAST8_MAX  UINT32_MAX
#endif /* __INT32_TYPE__ */
# 581 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT_LEAST32_MIN
# define INT_LEAST32_MIN   __INT_LEAST32_MIN
# define INT_LEAST32_MAX   __INT_LEAST32_MAX
# define UINT_LEAST32_MAX __UINT_LEAST32_MAX
# define INT_FAST32_MIN    __INT_LEAST32_MIN
# define INT_FAST32_MAX    __INT_LEAST32_MAX
# define UINT_FAST32_MAX  __UINT_LEAST32_MAX
#endif /* __INT_LEAST32_MIN */
# 590 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT24_TYPE__
# define INT24_MAX           INT24_C(8388607)
# define INT24_MIN         (-INT24_C(8388607)-1)
# define UINT24_MAX         UINT24_C(16777215)
# define INT_LEAST24_MIN     INT24_MIN
# define INT_LEAST24_MAX     INT24_MAX
# define UINT_LEAST24_MAX   UINT24_MAX
# define INT_FAST24_MIN      INT24_MIN
# define INT_FAST24_MAX      INT24_MAX
# define UINT_FAST24_MAX    UINT24_MAX
# define __INT_LEAST16_MIN   INT24_MIN
# define __INT_LEAST16_MAX   INT24_MAX
# define __UINT_LEAST16_MAX UINT24_MAX
# define __INT_LEAST8_MIN    INT24_MIN
# define __INT_LEAST8_MAX    INT24_MAX
# define __UINT_LEAST8_MAX  UINT24_MAX
#endif /* __INT24_TYPE__ */
# 609 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT16_TYPE__
#define INT16_MAX            INT16_C(32767)
#define INT16_MIN          (-INT16_C(32767)-1)
#define UINT16_MAX          UINT16_C(65535)
# define __INT_LEAST16_MIN   INT16_MIN
# define __INT_LEAST16_MAX   INT16_MAX
# define __UINT_LEAST16_MAX UINT16_MAX
# define __INT_LEAST8_MIN    INT16_MIN
# define __INT_LEAST8_MAX    INT16_MAX
# define __UINT_LEAST8_MAX  UINT16_MAX
#endif /* __INT16_TYPE__ */
# 622 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT_LEAST16_MIN
# define INT_LEAST16_MIN   __INT_LEAST16_MIN
# define INT_LEAST16_MAX   __INT_LEAST16_MAX
# define UINT_LEAST16_MAX __UINT_LEAST16_MAX
# define INT_FAST16_MIN    __INT_LEAST16_MIN
# define INT_FAST16_MAX    __INT_LEAST16_MAX
# define UINT_FAST16_MAX  __UINT_LEAST16_MAX
#endif /* __INT_LEAST16_MIN */
# 631 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3


#ifdef __INT8_TYPE__
# define INT8_MAX            INT8_C(127)
# define INT8_MIN          (-INT8_C(127)-1)
# define UINT8_MAX          UINT8_C(255)
# define __INT_LEAST8_MIN    INT8_MIN
# define __INT_LEAST8_MAX    INT8_MAX
# define __UINT_LEAST8_MAX  UINT8_MAX
#endif /* __INT8_TYPE__ */
# 641 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifdef __INT_LEAST8_MIN
# define INT_LEAST8_MIN   __INT_LEAST8_MIN
# define INT_LEAST8_MAX   __INT_LEAST8_MAX
# define UINT_LEAST8_MAX __UINT_LEAST8_MAX
# define INT_FAST8_MIN    __INT_LEAST8_MIN
# define INT_FAST8_MAX    __INT_LEAST8_MAX
# define UINT_FAST8_MAX  __UINT_LEAST8_MAX
#endif /* __INT_LEAST8_MIN */
# 650 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* Some utility macros */
#define  __INTN_MIN(n)  __stdint_join3( INT, n, _MIN)
#define  __INTN_MAX(n)  __stdint_join3( INT, n, _MAX)
#define __UINTN_MAX(n)  __stdint_join3(UINT, n, _MAX)
#define  __INTN_C(n, v) __stdint_join3( INT, n, _C(v))
#define __UINTN_C(n, v) __stdint_join3(UINT, n, _C(v))

/* C99 7.18.2.4 Limits of integer types capable of holding object pointers. */
/* C99 7.18.3 Limits of other integer types. */

#define  INTPTR_MIN  (-__INTPTR_MAX__-1)
#define  INTPTR_MAX    __INTPTR_MAX__
#define UINTPTR_MAX   __UINTPTR_MAX__
#define PTRDIFF_MIN (-__PTRDIFF_MAX__-1)
#define PTRDIFF_MAX   __PTRDIFF_MAX__
#define    SIZE_MAX      __SIZE_MAX__

/* ISO9899:2011 7.20 (C11 Annex K): Define RSIZE_MAX if __STDC_WANT_LIB_EXT1__
 * is enabled. */
#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1
#define   RSIZE_MAX            (SIZE_MAX >> 1)
#endif
# 673 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* C99 7.18.2.5 Limits of greatest-width integer types. */
#define  INTMAX_MIN (-__INTMAX_MAX__-1)
#define  INTMAX_MAX   __INTMAX_MAX__
#define UINTMAX_MAX  __UINTMAX_MAX__

/* C99 7.18.3 Limits of other integer types. */
#define SIG_ATOMIC_MIN __INTN_MIN(__SIG_ATOMIC_WIDTH__)
#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)
#ifdef __WINT_UNSIGNED__
# define WINT_MIN       __UINTN_C(__WINT_WIDTH__, 0)
# define WINT_MAX       __UINTN_MAX(__WINT_WIDTH__)
#else
# 686 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# define WINT_MIN       __INTN_MIN(__WINT_WIDTH__)
# define WINT_MAX       __INTN_MAX(__WINT_WIDTH__)
#endif
# 689 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

#ifndef WCHAR_MAX
# define WCHAR_MAX __WCHAR_MAX__
#endif
# 693 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#ifndef WCHAR_MIN
# if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)
#  define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)
# else
# 697 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#  define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)
# endif
# 699 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif
# 700 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3

/* 7.18.4.2 Macros for greatest-width integer constants. */
#define  INTMAX_C(v) __int_c(v,  __INTMAX_C_SUFFIX__)
#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)

#endif /* __STDC_HOSTED__ */
# 706 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
#endif /* __CLANG_STDINT_H */
# 707 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 2 3

 #ifndef RC_INVOKED
_STD_BEGIN
using _CSTD int8_t; using _CSTD int16_t;
using _CSTD int32_t; using _CSTD int64_t;
using _CSTD uint8_t; using _CSTD uint16_t;
using _CSTD uint32_t; using _CSTD uint64_t;

using _CSTD int_least8_t; using _CSTD int_least16_t;
using _CSTD int_least32_t; using _CSTD int_least64_t;
using _CSTD uint_least8_t; using _CSTD uint_least16_t;
using _CSTD uint_least32_t; using _CSTD uint_least64_t;

using _CSTD int_fast8_t; using _CSTD int_fast16_t;
using _CSTD int_fast32_t; using _CSTD int_fast64_t;
using _CSTD uint_fast8_t; using _CSTD uint_fast16_t;
using _CSTD uint_fast32_t; using _CSTD uint_fast64_t;

using _CSTD intmax_t; using _CSTD intptr_t;
using _CSTD uintmax_t; using _CSTD uintptr_t;

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _CSTD int8_t; using _CSTD int16_t;
using _CSTD int32_t; using _CSTD int64_t;
using _CSTD uint8_t; using _CSTD uint16_t;
using _CSTD uint32_t; using _CSTD uint64_t;

using _CSTD int_least8_t; using _CSTD int_least16_t;
using _CSTD int_least32_t; using _CSTD int_least64_t;
using _CSTD uint_least8_t; using _CSTD uint_least16_t;
using _CSTD uint_least32_t; using _CSTD uint_least64_t;

using _CSTD int_fast8_t; using _CSTD int_fast16_t;
using _CSTD int_fast32_t; using _CSTD int_fast64_t;
using _CSTD uint_fast8_t; using _CSTD uint_fast16_t;
using _CSTD uint_fast32_t; using _CSTD uint_fast64_t;

using _CSTD intmax_t; using _CSTD intptr_t;
using _CSTD uintmax_t; using _CSTD uintptr_t;
}
#endif /* _HAS_TR1_NAMESPACE */
# 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 3
_STD_END
 #endif /* RC_INVOKED */
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 3

#endif /* _CSTDINT_ */
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdint" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 1 3
// cstdlib standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3
#ifndef _CSTDLIB_
#define _CSTDLIB_
#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdlib.h>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 1 3
//
// stdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdlib.h> header.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#define _INC_STDLIB

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_malloc.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 1 3
//
// corecrt_malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.  These pieces of the allocation library are
// shared by both <stdlib.h> and <malloc.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3

_CRT_BEGIN_C_HEADER



#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
    #pragma push_macro("_aligned_free")
    #pragma push_macro("_aligned_malloc")
    #pragma push_macro("_aligned_msize")
    #pragma push_macro("_aligned_offset_malloc")
    #pragma push_macro("_aligned_offset_realloc")
    #pragma push_macro("_aligned_offset_recalloc")
    #pragma push_macro("_aligned_realloc")
    #pragma push_macro("_aligned_recalloc")
    #pragma push_macro("_expand")
    #pragma push_macro("_freea")
    #pragma push_macro("_msize")
    #pragma push_macro("_recalloc")
    #pragma push_macro("calloc")
    #pragma push_macro("free")
    #pragma push_macro("malloc")
    #pragma push_macro("realloc")

    #undef _aligned_free
    #undef _aligned_malloc
    #undef _aligned_msize
    #undef _aligned_offset_malloc
    #undef _aligned_offset_realloc
    #undef _aligned_offset_recalloc
    #undef _aligned_realloc
    #undef _aligned_recalloc
    #undef _expand
    #undef _freea
    #undef _msize
    #undef _recalloc
    #undef calloc
    #undef free
    #undef malloc
    #undef realloc
#endif
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _calloc_base(
    _In_ size_t _Count,
    _In_ size_t _Size
    );

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRT_JIT_INTRINSIC _CRTALLOCATOR _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl calloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Count,
    _In_ _CRT_GUARDOVERFLOW size_t _Size
    );

_Check_return_
_ACRTIMP int __cdecl _callnewh(
    _In_ size_t _Size
    );

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRT_HYBRIDPATCHABLE
void* __cdecl _expand(
    _Pre_notnull_           void*  _Block,
    _In_ _CRT_GUARDOVERFLOW size_t _Size
    );

_ACRTIMP
void __cdecl _free_base(
    _Pre_maybenull_ _Post_invalid_ void* _Block
    );

_ACRTIMP _CRT_HYBRIDPATCHABLE
void __cdecl free(
    _Pre_maybenull_ _Post_invalid_ void* _Block
    );

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _malloc_base(
    _In_ size_t _Size
    );

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRT_JIT_INTRINSIC _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl malloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Size
    );

_Check_return_
_ACRTIMP
size_t __cdecl _msize_base(
    _Pre_notnull_ void* _Block
    );

_Check_return_
_ACRTIMP _CRT_HYBRIDPATCHABLE
size_t __cdecl _msize(
    _Pre_notnull_ void* _Block
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _realloc_base(
    _Pre_maybenull_ _Post_invalid_  void*  _Block,
    _In_                            size_t _Size
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl realloc(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _recalloc_base(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_                           size_t _Count,
    _In_                           size_t _Size
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _recalloc(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Count,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size
    );

_ACRTIMP
void __cdecl _aligned_free(
    _Pre_maybenull_ _Post_invalid_ void* _Block
    );

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_malloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Size,
    _In_                    size_t _Alignment
    );

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_offset_malloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Size,
    _In_                    size_t _Alignment,
    _In_                    size_t _Offset
    );

_Check_return_
_ACRTIMP
size_t __cdecl _aligned_msize(
    _Pre_notnull_ void*  _Block,
    _In_          size_t _Alignment,
    _In_          size_t _Offset
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_offset_realloc(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment,
    _In_                           size_t _Offset
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_offset_recalloc(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Count,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment,
    _In_                           size_t _Offset
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_realloc(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment
    );

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_recalloc(
    _Pre_maybenull_ _Post_invalid_ void*  _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Count,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment
    );

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
    #pragma pop_macro("realloc")
    #pragma pop_macro("malloc")
    #pragma pop_macro("free")
    #pragma pop_macro("calloc")
    #pragma pop_macro("_recalloc")
    #pragma pop_macro("_msize")
    #pragma pop_macro("_freea")
    #pragma pop_macro("_expand")
    #pragma pop_macro("_aligned_recalloc")
    #pragma pop_macro("_aligned_realloc")
    #pragma pop_macro("_aligned_offset_recalloc")
    #pragma pop_macro("_aligned_offset_realloc")
    #pragma pop_macro("_aligned_offset_malloc")
    #pragma pop_macro("_aligned_msize")
    #pragma pop_macro("_aligned_malloc")
    #pragma pop_macro("_aligned_free")
#endif
# 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3



_CRT_END_C_HEADER
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_search.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 1 3
//
// corecrt_search.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations of functions for sorting and searching.  These declarations are
// split out so that they may be included by both <stdlib.h> and <search.h>.
// <stdlib.h> does not include <search.h> to avoid introducing conflicts with
// other user headers named <search.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 90 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 93 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#    define NULL 0
#  endif
# 104 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#else
# 105 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#  define NULL ((void*)0)
#endif
# 107 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 113 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 1 3
/*===---- __stddef_max_align_t.h - Definition of max_align_t for modules ---===
 *
 * Copyright (c) 2014 Chandler Carruth
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __CLANG_MAX_ALIGN_T_DEFINED
#define __CLANG_MAX_ALIGN_T_DEFINED

#if defined(_MSC_VER)
typedef double max_align_t;
#elif defined(__APPLE__)
# 32 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 3
typedef long double max_align_t;
#else
# 34 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 3
// Define 'max_align_t' to match the GCC definition.
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
#endif
# 42 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 3

#endif
# 44 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 3
# 119 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 2 3
#endif
# 120 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#endif
# 138 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 2 3

_CRT_BEGIN_C_HEADER


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);


#if __STDC_WANT_SECURE_LIB__

    _Check_return_
    _ACRTIMP void* __cdecl bsearch_s(
        _In_                                               void const* _Key,
        _In_reads_bytes_(_NumOfElements * _SizeOfElements) void const* _Base,
        _In_                                               rsize_t     _NumOfElements,
        _In_                                               rsize_t     _SizeOfElements,
        _In_                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        _In_opt_                                           void*       _Context
        );

    _ACRTIMP void __cdecl qsort_s(
        _Inout_updates_bytes_(_NumOfElements * _SizeOfElements) void*   _Base,
        _In_                                                    rsize_t _NumOfElements,
        _In_                                                    rsize_t _SizeOfElements,
        _In_                    _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        _In_opt_                                                void*   _Context
        );

#endif // __STDC_WANT_SECURE_LIB__
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3



_Check_return_
_ACRTIMP void* __cdecl bsearch(
    _In_                                               void const* _Key,
    _In_reads_bytes_(_NumOfElements * _SizeOfElements) void const* _Base,
    _In_                                               size_t      _NumOfElements,
    _In_                                               size_t      _SizeOfElements,
    _In_                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

_ACRTIMP void __cdecl qsort(
    _Inout_updates_bytes_(_NumOfElements * _SizeOfElements) void*  _Base,
    _In_                                                    size_t _NumOfElements,
    _In_                                                    size_t _SizeOfElements,
    _In_                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

_Check_return_
_ACRTIMP void* __cdecl _lfind_s(
    _In_                                                  void const*   _Key,
    _In_reads_bytes_((*_NumOfElements) * _SizeOfElements) void const*   _Base,
    _Inout_                                               unsigned int* _NumOfElements,
    _In_                                                  size_t        _SizeOfElements,
    _In_                        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    _In_                                                  void*         _Context
    );

_Check_return_
_ACRTIMP void* __cdecl _lfind(
    _In_                                                  void const*   _Key,
    _In_reads_bytes_((*_NumOfElements) * _SizeOfElements) void const*   _Base,
    _Inout_                                               unsigned int* _NumOfElements,
    _In_                                                  unsigned int  _SizeOfElements,
    _In_                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

_Check_return_
_ACRTIMP void* __cdecl _lsearch_s(
    _In_                                                        void const*   _Key,
    _Inout_updates_bytes_((*_NumOfElements ) * _SizeOfElements) void*         _Base,
    _Inout_                                                     unsigned int* _NumOfElements,
    _In_                                                        size_t        _SizeOfElements,
    _In_                              _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    _In_                                                        void*         _Context
    );

_Check_return_
_ACRTIMP void* __cdecl _lsearch(
    _In_                                                        void const*   _Key,
    _Inout_updates_bytes_((*_NumOfElements ) * _SizeOfElements) void*         _Base,
    _Inout_                                                     unsigned int* _NumOfElements,
    _In_                                                        unsigned int  _SizeOfElements,
    _In_                           _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );



// Managed search routines
#if defined __cplusplus && defined _M_CEE
extern "C++"
{
    typedef int (__clrcall* _CoreCrtMgdSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__clrcall* _CoreCrtMgdNonSecureSearchSortCompareFunction)(void const*, void const*);

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_
        void* __clrcall bsearch_s(
                _In_                                               void const* _Key,
                _In_reads_bytes_(_NumOfElements * _SizeOfElements) void const* _Base,
                _In_                                               rsize_t     _NumOfElements,
                _In_                                               rsize_t     _SizeOfElements,
                _In_                _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
                _In_                                               void*       _Context);

        void __clrcall qsort_s(
                _Inout_updates_bytes_(_NumOfElements * _SizeOfElements) void*   _Base,
                _In_                                                    rsize_t _NumOfElements,
                _In_                                                    rsize_t _SizeOfElements,
                _In_                 _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
                _In_                                                    void*   _Context);

    #endif // __STDC_WANT_SECURE_LIB__
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3

    _Check_return_
    void* __clrcall bsearch(
        _In_                                               void const* _Key,
        _In_reads_bytes_(_NumOfElements * _SizeOfElements) void const* _Base,
        _In_                                               size_t _NumOfElements,
        _In_                                               size_t _SizeOfElements,
        _In_        _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );

    _Check_return_
    void* __clrcall _lfind_s(
        _In_                                               void const*   _Key,
        _In_reads_bytes_(_NumOfElements * _SizeOfElements) void const*   _Base,
        _Inout_                                            unsigned int* _NumOfElements,
        _In_                                               size_t        _SizeOfElements,
        _In_                  _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
        _In_                                               void*         _Context
        );

    _Check_return_
    void* __clrcall _lfind(
        _In_                                                  void const*   _Key,
        _In_reads_bytes_((*_NumOfElements) * _SizeOfElements) void const*   _Base,
        _Inout_                                               unsigned int* _NumOfElements,
        _In_                                                  unsigned int  _SizeOfElements,
        _In_                  _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );

    _Check_return_
    void* __clrcall _lsearch_s(
        _In_                                                  void const*   _Key,
        _In_reads_bytes_((*_NumOfElements) * _SizeOfElements) void*         _Base,
        _In_                                                  unsigned int* _NumOfElements,
        _In_                                                  size_t        _SizeOfElements,
        _In_                     _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
        _In_                                                  void*         _Context
        );

    _Check_return_
    void* __clrcall _lsearch(
        _In_                                                       void const*   _Key,
        _Inout_updates_bytes_((*_NumOfElements) * _SizeOfElements) void*         _Base,
        _Inout_                                                    unsigned int* _NumOfElements,
        _In_                                                       unsigned int  _SizeOfElements,
        _In_                       _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );

    void __clrcall qsort(
        _Inout_updates_bytes_(_NumOfElements * _SizeOfElements) void*  _Base,
        _In_                                                    size_t _NumOfElements,
        _In_                                                    size_t _SizeOfElements,
        _In_             _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );
}
#endif // defined __cplusplus && defined _M_CEE
# 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3



#if _CRT_INTERNAL_NONSTDC_NAMES

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_lfind)
    _ACRTIMP void* __cdecl lfind(
        _In_                                                  void const*   _Key,
        _In_reads_bytes_((*_NumOfElements) * _SizeOfElements) void const*   _Base,
        _Inout_                                               unsigned int* _NumOfElements,
        _In_                                                  unsigned int  _SizeOfElements,
        _In_                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_lsearch)
    _ACRTIMP void* __cdecl lsearch(
        _In_                                                       void const*   _Key,
        _Inout_updates_bytes_((*_NumOfElements) * _SizeOfElements) void*         _Base,
        _Inout_                                                    unsigned int* _NumOfElements,
        _In_                                                       unsigned int  _SizeOfElements,
        _In_                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3



_CRT_END_C_HEADER
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wstdlib.h>
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 1 3
//
// corecrt_wstdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) C Standard Library functions
// that are declared by both <stdlib.h> and <wchar.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3

_CRT_BEGIN_C_HEADER



// Maximum number of elements, including null terminator (and negative sign
// where appropriate), needed for integer-to-string conversions for several
// bases and integer types.
#define _MAX_ITOSTR_BASE16_COUNT   (8  + 1)
#define _MAX_ITOSTR_BASE10_COUNT   (1 + 10 + 1)
#define _MAX_ITOSTR_BASE8_COUNT    (11 + 1)
#define _MAX_ITOSTR_BASE2_COUNT    (32 + 1)

#define _MAX_LTOSTR_BASE16_COUNT   (8  + 1)
#define _MAX_LTOSTR_BASE10_COUNT   (1 + 10 + 1)
#define _MAX_LTOSTR_BASE8_COUNT    (11 + 1)
#define _MAX_LTOSTR_BASE2_COUNT    (32 + 1)

#define _MAX_ULTOSTR_BASE16_COUNT  (8  + 1)
#define _MAX_ULTOSTR_BASE10_COUNT  (10 + 1)
#define _MAX_ULTOSTR_BASE8_COUNT   (11 + 1)
#define _MAX_ULTOSTR_BASE2_COUNT   (32 + 1)

#define _MAX_I64TOSTR_BASE16_COUNT (16 + 1)
#define _MAX_I64TOSTR_BASE10_COUNT (1 + 19 + 1)
#define _MAX_I64TOSTR_BASE8_COUNT  (22 + 1)
#define _MAX_I64TOSTR_BASE2_COUNT  (64 + 1)

#define _MAX_U64TOSTR_BASE16_COUNT (16 + 1)
#define _MAX_U64TOSTR_BASE10_COUNT (20 + 1)
#define _MAX_U64TOSTR_BASE8_COUNT  (22 + 1)
#define _MAX_U64TOSTR_BASE2_COUNT  (64 + 1)


#if _CRT_FUNCTIONS_REQUIRED

    _Success_(return == 0)
    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _itow_s(
        _In_                         int      _Value,
        _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
        _In_                         size_t   _BufferCount,
        _In_                         int      _Radix
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
        errno_t, _itow_s,
        _In_ int,     _Value,
             wchar_t, _Buffer,
        _In_ int,     _Radix
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
        wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _itow,
        _In_                    int,     _Value,
        _Pre_notnull_ _Post_z_, wchar_t, _Buffer,
        _In_                    int,     _Radix
        )

    _Success_(return == 0)
    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _ltow_s(
        _In_                         long     _Value,
        _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
        _In_                         size_t   _BufferCount,
        _In_                         int      _Radix
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
        errno_t, _ltow_s,
        _In_ long,    _Value,
             wchar_t, _Buffer,
        _In_ int,     _Radix
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
        wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _ltow,
        _In_                    long,    _Value,
        _Pre_notnull_ _Post_z_, wchar_t, _Buffer,
        _In_                    int,     _Radix
        )

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _ultow_s(
        _In_                         unsigned long _Value,
        _Out_writes_z_(_BufferCount) wchar_t*      _Buffer,
        _In_                         size_t        _BufferCount,
        _In_                         int           _Radix
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
        errno_t, _ultow_s,
        _In_ unsigned long, _Value,
             wchar_t,       _Buffer,
        _In_ int,           _Radix
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
        wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _ultow,
        _In_                    unsigned long, _Value,
        _Pre_notnull_ _Post_z_, wchar_t,       _Buffer,
        _In_                    int,           _Radix
        )

    _Check_return_
    _ACRTIMP double __cdecl wcstod(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr
        );

    _Check_return_
    _ACRTIMP double __cdecl _wcstod_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP long __cdecl wcstol(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix
        );

    _Check_return_
    _ACRTIMP long __cdecl _wcstol_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP long long __cdecl wcstoll(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix
        );

    _Check_return_
    _ACRTIMP long long __cdecl _wcstoll_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP unsigned long __cdecl wcstoul(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix
        );

    _Check_return_
    _ACRTIMP unsigned long __cdecl _wcstoul_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP unsigned long long __cdecl wcstoull(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix
        );

    _Check_return_
    _ACRTIMP unsigned long long __cdecl _wcstoull_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP long double __cdecl wcstold(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr
        );

    _Check_return_
    _ACRTIMP long double __cdecl _wcstold_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP float __cdecl wcstof(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr
        );

    _Check_return_
    _ACRTIMP float __cdecl _wcstof_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP double __cdecl _wtof(
        _In_z_ wchar_t const* _String
        );

    _Check_return_
    _ACRTIMP double __cdecl _wtof_l(
        _In_z_   wchar_t const* _String,
        _In_opt_ _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP int __cdecl _wtoi(
        _In_z_ wchar_t const* _String
        );

    _Check_return_
    _ACRTIMP int __cdecl _wtoi_l(
        _In_z_   wchar_t const* _String,
        _In_opt_ _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP long __cdecl _wtol(
        _In_z_ wchar_t const* _String
        );

    _Check_return_
    _ACRTIMP long __cdecl _wtol_l(
        _In_z_   wchar_t const* _String,
        _In_opt_ _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP long long __cdecl _wtoll(
        _In_z_ wchar_t const* _String
        );

    _Check_return_
    _ACRTIMP long long __cdecl _wtoll_l(
        _In_z_   wchar_t const* _String,
        _In_opt_ _locale_t      _Locale
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _i64tow_s(
        _In_                         __int64  _Value,
        _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
        _In_                         size_t   _BufferCount,
        _In_                         int      _Radix
        );

    _CRT_INSECURE_DEPRECATE(_i64tow_s)
    _ACRTIMP wchar_t* __cdecl _i64tow(
        _In_                   __int64  _Value,
        _Pre_notnull_ _Post_z_ wchar_t* _Buffer,
        _In_                   int      _Radix
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _ui64tow_s(
        _In_                         unsigned __int64 _Value,
        _Out_writes_z_(_BufferCount) wchar_t*         _Buffer,
        _In_                         size_t           _BufferCount,
        _In_                         int              _Radix
        );

    _CRT_INSECURE_DEPRECATE(_ui64tow_s)
    _ACRTIMP wchar_t* __cdecl _ui64tow(
        _In_                   unsigned __int64 _Value,
        _Pre_notnull_ _Post_z_ wchar_t*         _Buffer,
        _In_                   int              _Radix
        );

    _Check_return_
    _ACRTIMP __int64 __cdecl _wtoi64(
        _In_z_ wchar_t const* _String
        );

    _Check_return_
    _ACRTIMP __int64 __cdecl _wtoi64_l(
        _In_z_   wchar_t const* _String,
        _In_opt_ _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP __int64 __cdecl _wcstoi64(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix
        );

    _Check_return_
    _ACRTIMP __int64 __cdecl _wcstoi64_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix,
        _In_opt_                 _locale_t      _Locale
        );

    _Check_return_
    _ACRTIMP unsigned __int64 __cdecl _wcstoui64(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix
        );

    _Check_return_
    _ACRTIMP unsigned __int64 __cdecl _wcstoui64_l(
        _In_z_                   wchar_t const* _String,
        _Out_opt_ _Deref_post_z_ wchar_t**      _EndPtr,
        _In_                     int            _Radix,
        _In_opt_                 _locale_t      _Locale
        );

    #pragma push_macro("_wfullpath")
    #undef _wfullpath

    _Success_(return != 0)
    _Check_return_
    _ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wfullpath(
        _Out_writes_opt_z_(_BufferCount) wchar_t*       _Buffer,
        _In_z_                           wchar_t const* _Path,
        _In_                             size_t         _BufferCount
        );

    #pragma pop_macro("_wfullpath")

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _wmakepath_s(
        _Out_writes_z_(_BufferCount) wchar_t*       _Buffer,
        _In_                         size_t         _BufferCount,
        _In_opt_z_                   wchar_t const* _Drive,
        _In_opt_z_                   wchar_t const* _Dir,
        _In_opt_z_                   wchar_t const* _Filename,
        _In_opt_z_                   wchar_t const* _Ext
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
        errno_t, _wmakepath_s,
                   wchar_t,        _Buffer,
        _In_opt_z_ wchar_t const*, _Drive,
        _In_opt_z_ wchar_t const*, _Dir,
        _In_opt_z_ wchar_t const*, _Filename,
        _In_opt_z_ wchar_t const*, _Ext
        )

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(
        void, __RETURN_POLICY_VOID, _ACRTIMP, _wmakepath,
        _Pre_notnull_ _Post_z_, wchar_t,        _Buffer,
        _In_opt_z_              wchar_t const*, _Drive,
        _In_opt_z_              wchar_t const*, _Dir,
        _In_opt_z_              wchar_t const*, _Filename,
        _In_opt_z_              wchar_t const*, _Ext
        )
#pragma warning(pop)

    _ACRTIMP void __cdecl _wperror(
        _In_opt_z_ wchar_t const* _ErrorMessage
        );

    _CRT_INSECURE_DEPRECATE(_wsplitpath_s)
    _ACRTIMP void __cdecl _wsplitpath(
        _In_z_                   wchar_t const* _FullPath,
        _Pre_maybenull_ _Post_z_ wchar_t*       _Drive,
        _Pre_maybenull_ _Post_z_ wchar_t*       _Dir,
        _Pre_maybenull_ _Post_z_ wchar_t*       _Filename,
        _Pre_maybenull_ _Post_z_ wchar_t*       _Ext
        );

    _ACRTIMP errno_t __cdecl _wsplitpath_s(
        _In_z_                             wchar_t const* _FullPath,
        _Out_writes_opt_z_(_DriveCount)    wchar_t*       _Drive,
        _In_                               size_t         _DriveCount,
        _Out_writes_opt_z_(_DirCount)      wchar_t*       _Dir,
        _In_                               size_t         _DirCount,
        _Out_writes_opt_z_(_FilenameCount) wchar_t*       _Filename,
        _In_                               size_t         _FilenameCount,
        _Out_writes_opt_z_(_ExtCount)      wchar_t*       _Ext,
        _In_                               size_t         _ExtCount
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(
        errno_t, _wsplitpath_s,
        wchar_t, _Path
        )



    #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

        #pragma push_macro("_wdupenv_s")
        #undef _wdupenv_s

        _Check_return_wat_
        _DCRTIMP errno_t __cdecl _wdupenv_s(
            _Outptr_result_buffer_maybenull_(*_BufferCount) _Outptr_result_maybenull_z_ wchar_t**      _Buffer,
            _Out_opt_                                                                   size_t*        _BufferCount,
            _In_z_                                                                      wchar_t const* _VarName
            );

        #pragma pop_macro("_wdupenv_s")

        _Check_return_ _CRT_INSECURE_DEPRECATE(_wdupenv_s)
        _DCRTIMP wchar_t* __cdecl _wgetenv(
            _In_z_ wchar_t const* _VarName
            );

        _Success_(return == 0)
        _Check_return_wat_
        _DCRTIMP errno_t __cdecl _wgetenv_s(
            _Out_                            size_t*        _RequiredCount,
            _Out_writes_opt_z_(_BufferCount) wchar_t*       _Buffer,
            _In_                             size_t         _BufferCount,
            _In_z_                           wchar_t const* _VarName
            );

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
            _Success_(return == 0)
            errno_t, _wgetenv_s,
            _Out_  size_t*,        _RequiredCount,
                   wchar_t,        _Buffer,
            _In_z_ wchar_t const*, _VarName
            )

        _Check_return_
        _DCRTIMP int __cdecl _wputenv(
            _In_z_ wchar_t const* _EnvString
            );

        _Check_return_wat_
        _DCRTIMP errno_t __cdecl _wputenv_s(
            _In_z_ wchar_t const* _Name,
            _In_z_ wchar_t const* _Value
            );

        _DCRTIMP errno_t __cdecl _wsearchenv_s(
            _In_z_                       wchar_t const* _Filename,
            _In_z_                       wchar_t const* _VarName,
            _Out_writes_z_(_BufferCount) wchar_t*       _Buffer,
            _In_                         size_t         _BufferCount
            );

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(
            errno_t, _wsearchenv_s,
            _In_z_ wchar_t const*, _Filename,
            _In_z_ wchar_t const*, _VarName,
                   wchar_t,        _ResultPath
                   )

        __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(
            void, __RETURN_POLICY_VOID, _DCRTIMP, _wsearchenv,
            _In_z_                  wchar_t const*, _Filename,
            _In_z_                  wchar_t const*, _VarName,
            _Pre_notnull_ _Post_z_, wchar_t,        _ResultPath
            )

        _DCRTIMP int __cdecl _wsystem(
            _In_opt_z_ wchar_t const* _Command
            );

    #endif // _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
# 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
#endif // _CRT_FUNCTIONS_REQUIRED
# 481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3



_CRT_END_C_HEADER
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <limits.h>
#endif /* expanded by -frewrite-includes */
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 1 3
/*===---- limits.h - Standard header for integer sizes --------------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __CLANG_LIMITS_H
#define __CLANG_LIMITS_H

/* The system's limits.h may, in turn, try to #include_next GCC's limits.h.
   Avert this #include_next madness. */
#if defined __GNUC__ && !defined _GCC_LIMITS_H_
#define _GCC_LIMITS_H_
#endif
# 33 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3

/* System headers include a number of constants from POSIX in <limits.h>.
   Include it if we're hosted. */
#if __STDC_HOSTED__ && (1)/*__has_include_next(<limits.h>)*/
#if 0 /* expanded by -frewrite-includes */
#include_next <limits.h>
#endif /* expanded by -frewrite-includes */
# 39 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 1 3
//
// limits.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <limits.h> header.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3
#define _INC_LIMITS

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 2 3

_CRT_BEGIN_C_HEADER



#define CHAR_BIT      8         // number of bits in a char
#define SCHAR_MIN   (-128)      // minimum signed char value
#define SCHAR_MAX     127       // maximum signed char value
#define UCHAR_MAX     0xff      // maximum unsigned char value

#ifndef _CHAR_UNSIGNED
    #define CHAR_MIN    SCHAR_MIN   // mimimum char value
    #define CHAR_MAX    SCHAR_MAX   // maximum char value
#else
# 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3
    #define CHAR_MIN    0
    #define CHAR_MAX    UCHAR_MAX
#endif
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3

#define MB_LEN_MAX    5             // max. # bytes in multibyte char
#define SHRT_MIN    (-32768)        // minimum (signed) short value
#define SHRT_MAX      32767         // maximum (signed) short value
#define USHRT_MAX     0xffff        // maximum unsigned short value
#define INT_MIN     (-2147483647 - 1) // minimum (signed) int value
#define INT_MAX       2147483647    // maximum (signed) int value
#define UINT_MAX      0xffffffff    // maximum unsigned int value
#define LONG_MIN    (-2147483647L - 1) // minimum (signed) long value
#define LONG_MAX      2147483647L   // maximum (signed) long value
#define ULONG_MAX     0xffffffffUL  // maximum unsigned long value
#define LLONG_MAX     9223372036854775807i64       // maximum signed long long int value
#define LLONG_MIN   (-9223372036854775807i64 - 1)  // minimum signed long long int value
#define ULLONG_MAX    0xffffffffffffffffui64       // maximum unsigned long long int value

#define _I8_MIN     (-127i8 - 1)    // minimum signed 8 bit value
#define _I8_MAX       127i8         // maximum signed 8 bit value
#define _UI8_MAX      0xffui8       // maximum unsigned 8 bit value

#define _I16_MIN    (-32767i16 - 1) // minimum signed 16 bit value
#define _I16_MAX      32767i16      // maximum signed 16 bit value
#define _UI16_MAX     0xffffui16    // maximum unsigned 16 bit value

#define _I32_MIN    (-2147483647i32 - 1) // minimum signed 32 bit value
#define _I32_MAX      2147483647i32 // maximum signed 32 bit value
#define _UI32_MAX     0xffffffffui32 // maximum unsigned 32 bit value

// minimum signed 64 bit value
#define _I64_MIN    (-9223372036854775807i64 - 1)
// maximum signed 64 bit value
#define _I64_MAX      9223372036854775807i64
// maximum unsigned 64 bit value
#define _UI64_MAX     0xffffffffffffffffui64

#if _INTEGRAL_MAX_BITS >= 128
    // minimum signed 128 bit value
    #define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
    // maximum signed 128 bit value
    #define _I128_MAX     170141183460469231731687303715884105727i128
    // maximum unsigned 128 bit value
    #define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif
# 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3

#ifndef SIZE_MAX
    #ifdef _WIN64
        #define SIZE_MAX _UI64_MAX
    #else
# 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3
        #define SIZE_MAX UINT_MAX
    #endif
# 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3
#endif
# 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3

#if __STDC_WANT_SECURE_LIB__
    #ifndef RSIZE_MAX
        #define RSIZE_MAX (SIZE_MAX >> 1)
    #endif
# 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3
#endif
# 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits.h" 3



_CRT_END_C_HEADER
# 40 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 2 3
#endif
# 41 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3

/* Many system headers try to "help us out" by defining these.  No really, we
   know how big each datatype is. */
#undef  SCHAR_MIN
#undef  SCHAR_MAX
#undef  UCHAR_MAX
#undef  SHRT_MIN
#undef  SHRT_MAX
#undef  USHRT_MAX
#undef  INT_MIN
#undef  INT_MAX
#undef  UINT_MAX
#undef  LONG_MIN
#undef  LONG_MAX
#undef  ULONG_MAX

#undef  CHAR_BIT
#undef  CHAR_MIN
#undef  CHAR_MAX

/* C90/99 5.2.4.2.1 */
#define SCHAR_MAX __SCHAR_MAX__
#define SHRT_MAX  __SHRT_MAX__
#define INT_MAX   __INT_MAX__
#define LONG_MAX  __LONG_MAX__

#define SCHAR_MIN (-__SCHAR_MAX__-1)
#define SHRT_MIN  (-__SHRT_MAX__ -1)
#define INT_MIN   (-__INT_MAX__  -1)
#define LONG_MIN  (-__LONG_MAX__ -1L)

#define UCHAR_MAX (__SCHAR_MAX__*2  +1)
#define USHRT_MAX (__SHRT_MAX__ *2  +1)
#define UINT_MAX  (__INT_MAX__  *2U +1U)
#define ULONG_MAX (__LONG_MAX__ *2UL+1UL)

#ifndef MB_LEN_MAX
#define MB_LEN_MAX 1
#endif
# 80 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3

#define CHAR_BIT  __CHAR_BIT__

#ifdef __CHAR_UNSIGNED__  /* -funsigned-char */
#define CHAR_MIN 0
#define CHAR_MAX UCHAR_MAX
#else
# 87 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3
#define CHAR_MIN SCHAR_MIN
#define CHAR_MAX __SCHAR_MAX__
#endif
# 90 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3

/* C99 5.2.4.2.1: Added long long.
   C++11 18.3.3.2: same contents as the Standard C Library header <limits.h>.
 */
#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L

#undef  LLONG_MIN
#undef  LLONG_MAX
#undef  ULLONG_MAX

#define LLONG_MAX  __LONG_LONG_MAX__
#define LLONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULLONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif
# 104 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3

/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
   that we don't have something like #pragma poison that could be used to
   deprecate a macro - the code should just use LLONG_MAX and friends.
 */
#if defined(__GNU_LIBRARY__) ? defined(__USE_GNU) : !defined(__STRICT_ANSI__)

#undef   LONG_LONG_MIN
#undef   LONG_LONG_MAX
#undef   ULONG_LONG_MAX

#define LONG_LONG_MAX  __LONG_LONG_MAX__
#define LONG_LONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULONG_LONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif
# 119 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3

#endif /* __CLANG_LIMITS_H */
# 121 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\limits.h" 3
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3

_CRT_BEGIN_C_HEADER



#ifndef _countof
    #define _countof __crt_countof
#endif
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



// Minimum and maximum macros
#define __max(a,b) (((a) > (b)) ? (a) : (b))
#define __min(a,b) (((a) < (b)) ? (a) : (b))



_ACRTIMP void __cdecl _swab(
    _Inout_updates_(_SizeInBytes) _Post_readable_size_(_SizeInBytes) char* _Buf1,
    _Inout_updates_(_SizeInBytes) _Post_readable_size_(_SizeInBytes) char* _Buf2,
    _In_                                                             int   _SizeInBytes
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Exit and Abort
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Argument values for exit()
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

#if _CRT_FUNCTIONS_REQUIRED
    _ACRTIMP __declspec(noreturn) void __cdecl exit(_In_ int _Code);
    _ACRTIMP __declspec(noreturn) void __cdecl _exit(_In_ int _Code);
    _ACRTIMP __declspec(noreturn) void __cdecl _Exit(_In_ int _Code);
    _ACRTIMP __declspec(noreturn) void __cdecl quick_exit(_In_ int _Code);
    _ACRTIMP __declspec(noreturn) void __cdecl abort(void);
#endif // _CRT_FUNCTIONS_REQUIRED
# 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

// Argument values for _set_abort_behavior().
#define _WRITE_ABORT_MSG  0x1 // debug only, has no effect in release
#define _CALL_REPORTFAULT 0x2

_ACRTIMP unsigned int __cdecl _set_abort_behavior(
    _In_ unsigned int _Flags,
    _In_ unsigned int _Mask
    );



#ifndef _CRT_ONEXIT_T_DEFINED
    #define _CRT_ONEXIT_T_DEFINED

    typedef int (__CRTDECL* _onexit_t)(void);
    #ifdef _M_CEE
        typedef int (__clrcall* _onexit_m_t)(void);
    #endif
# 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#endif
# 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

#if _CRT_INTERNAL_NONSTDC_NAMES
    // Non-ANSI name for compatibility
    #define onexit_t _onexit_t
#endif
# 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



#ifdef _M_CEE
    #pragma warning (push)
    #pragma warning (disable: 4985)

    _Check_return_ int __clrcall _atexit_m_appdomain(_In_opt_ void (__clrcall* _Function)(void));

    _onexit_m_t __clrcall _onexit_m_appdomain(_onexit_m_t _Function);

    #ifdef _M_CEE_MIXED
        #ifdef __cplusplus
        [System::Security::SecurityCritical]
        #endif
# 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        _Check_return_ int __clrcall _atexit_m(_In_opt_ void (__clrcall* _Function)(void));

        _onexit_m_t __clrcall _onexit_m(_onexit_m_t _Function);
    #else
# 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        #ifdef __cplusplus
        [System::Security::SecurityCritical]
        #endif
# 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        _Check_return_ inline int __clrcall _atexit_m(_In_opt_ void (__clrcall* _Function)(void))
        {
            return _atexit_m_appdomain(_Function);
        }

        inline _onexit_m_t __clrcall _onexit_m(_onexit_t _Function)
        {
            return _onexit_m_appdomain(_Function);
        }
    #endif
# 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    #pragma warning (pop)
#endif
# 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



#ifdef _M_CEE_PURE
    // In pure mode, atexit is the same as atexit_m_appdomain
    extern "C++"
    {

    #ifdef __cplusplus
    [System::Security::SecurityCritical]
    #endif
# 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    inline  int __clrcall atexit(void (__clrcall* _Function)(void))
    {
        return _atexit_m_appdomain(_Function);
    }

    inline _onexit_t __clrcall _onexit(_onexit_t _Function)
    {
        return _onexit_m_appdomain(_Function);
    }

    } // extern "C++"
#else
# 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(_In_opt_ _onexit_t _Func);
#endif
# 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

int __cdecl at_quick_exit(void (__cdecl*)(void));



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Global State (errno, global handlers, etc.)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _M_CEE_PURE
    // a purecall handler procedure. Never returns normally
    typedef void (__cdecl* _purecall_handler)(void);

    // Invalid parameter handler function pointer type
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    // Establishes a purecall handler
    _VCRTIMP _purecall_handler __cdecl _set_purecall_handler(
        _In_opt_ _purecall_handler _Handler
        );

    _VCRTIMP _purecall_handler __cdecl _get_purecall_handler(void);

    // Establishes an invalid parameter handler
    _ACRTIMP _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
        _In_opt_ _invalid_parameter_handler _Handler
        );

    _ACRTIMP _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    _ACRTIMP _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
        _In_opt_ _invalid_parameter_handler _Handler
        );

    _ACRTIMP _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#endif
# 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3


#if defined __cplusplus && defined _M_CEE_PURE
extern "C++"
{
    typedef void (__clrcall* _purecall_handler)(void);
    typedef _purecall_handler _purecall_handler_m;

    _MRTIMP _purecall_handler __cdecl _set_purecall_handler(
        _In_opt_ _purecall_handler _Handler
        );
} // extern "C++"
#endif
# 198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



// Argument values for _set_error_mode().
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

_Check_return_opt_ _ACRTIMP int __cdecl _set_error_mode(_In_ int _Mode);



#if _CRT_FUNCTIONS_REQUIRED
    _ACRTIMP int* __cdecl _errno(void);
    #define errno (*_errno())

    _ACRTIMP errno_t __cdecl _set_errno(_In_ int _Value);
    _ACRTIMP errno_t __cdecl _get_errno(_Out_ int* _Value);

    _ACRTIMP unsigned long* __cdecl __doserrno(void);
    #define _doserrno (*__doserrno())

    _ACRTIMP errno_t __cdecl _set_doserrno(_In_ unsigned long _Value);
    _ACRTIMP errno_t __cdecl _get_doserrno(_Out_ unsigned long * _Value);

    // This is non-const for backwards compatibility; do not modify it.
    _ACRTIMP _CRT_INSECURE_DEPRECATE(strerror) char** __cdecl __sys_errlist(void);
    #define _sys_errlist (__sys_errlist())

    _ACRTIMP _CRT_INSECURE_DEPRECATE(strerror) int * __cdecl __sys_nerr(void);
    #define _sys_nerr (*__sys_nerr())

    _ACRTIMP void __cdecl perror(_In_opt_z_ char const* _ErrMsg);
#endif // _CRT_FUNCTIONS_REQUIRED
# 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



// These point to the executable module name.
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_pgmptr ) _ACRTIMP char**    __cdecl __p__pgmptr (void);
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_wpgmptr) _ACRTIMP wchar_t** __cdecl __p__wpgmptr(void);
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_fmode  ) _ACRTIMP int*      __cdecl __p__fmode  (void);

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
    _CRT_INSECURE_DEPRECATE_GLOBALS(_get_pgmptr ) extern char*    _pgmptr;
    _CRT_INSECURE_DEPRECATE_GLOBALS(_get_wpgmptr) extern wchar_t* _wpgmptr;
    #ifndef _CORECRT_BUILD
        _CRT_INSECURE_DEPRECATE_GLOBALS(_get_fmode  ) extern int      _fmode;
    #endif
# 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#else
# 248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    #define _pgmptr  (*__p__pgmptr ())
    #define _wpgmptr (*__p__wpgmptr())
    #define _fmode   (*__p__fmode  ())
#endif
# 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

_Success_(return == 0)
_ACRTIMP errno_t __cdecl _get_pgmptr (_Outptr_result_z_ char**    _Value);

_Success_(return == 0)
_ACRTIMP errno_t __cdecl _get_wpgmptr(_Outptr_result_z_ wchar_t** _Value);

_ACRTIMP errno_t __cdecl _set_fmode  (_In_              int       _Mode );

_ACRTIMP errno_t __cdecl _get_fmode  (_Out_             int*      _PMode);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Math
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

_Check_return_ int       __cdecl abs   (_In_ int       _Number);
_Check_return_ long      __cdecl labs  (_In_ long      _Number);
_Check_return_ long long __cdecl llabs (_In_ long long _Number);
_Check_return_ __int64   __cdecl _abs64(_In_ __int64   _Number);

_Check_return_ unsigned short   __cdecl _byteswap_ushort(_In_ unsigned short   _Number);
_Check_return_ unsigned long    __cdecl _byteswap_ulong (_In_ unsigned long    _Number);
_Check_return_ unsigned __int64 __cdecl _byteswap_uint64(_In_ unsigned __int64 _Number);

_Check_return_ _ACRTIMP div_t   __cdecl div  (_In_ int       _Numerator, _In_ int       _Denominator);
_Check_return_ _ACRTIMP ldiv_t  __cdecl ldiv (_In_ long      _Numerator, _In_ long      _Denominator);
_Check_return_ _ACRTIMP lldiv_t __cdecl lldiv(_In_ long long _Numerator, _In_ long long _Denominator);

// These functions have declspecs in their declarations in the Windows headers,
// which cause PREfast to fire 6540.
#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
    _In_ unsigned int _Value,
    _In_ int          _Shift
    );

_Check_return_
unsigned long __cdecl _lrotl(
    _In_ unsigned long _Value,
    _In_ int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
    _In_ unsigned __int64 _Value,
    _In_ int              _Shift
    );

unsigned int __cdecl _rotr(
    _In_ unsigned int _Value,
    _In_ int          _Shift
    );

_Check_return_
unsigned long __cdecl _lrotr(
    _In_ unsigned long _Value,
    _In_ int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
    _In_ unsigned __int64 _Value,
    _In_ int              _Shift
    );

#pragma warning (pop)



// Maximum value that can be returned by the rand function:
#define RAND_MAX 0x7fff

_ACRTIMP void __cdecl srand(_In_ unsigned int _Seed);

_Check_return_ _ACRTIMP int __cdecl rand(void);

#if defined _CRT_RAND_S || defined _CRTBLD
    _ACRTIMP errno_t __cdecl rand_s(_Out_ unsigned int* _RandomValue);
#endif
# 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



#ifdef __cplusplus
extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#endif // __cplusplus
# 379 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3




// Structs used to fool the compiler into not generating floating point
// instructions when copying and pushing [long] double values
#define _CRT_DOUBLE_DEC

#ifndef _LDSUPPORT

    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    #define _PTR_LD(x) ((unsigned char*)(&(x)->ld))

#else // _LDSUPPORT
# 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    // push and pop long, which is #defined as __int64 by a spec2k test
    #pragma push_macro("long")
    #undef long
    typedef long double _LDOUBLE;
    #pragma pop_macro("long")

    #define _PTR_LD(x) ((unsigned char  *)(x))

#endif // _LDSUPPORT
# 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;

// push and pop long, which is #defined as __int64 by a spec2k test
#pragma push_macro("long")
#undef long

typedef struct
{
    long double x;
} _LONGDOUBLE;

#pragma pop_macro("long")

#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow String to Number Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_                    _ACRTIMP double    __cdecl atof   (_In_z_ char const* _String);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int       __cdecl atoi   (_In_z_ char const* _String);
_Check_return_                    _ACRTIMP long      __cdecl atol   (_In_z_ char const* _String);
_Check_return_                    _ACRTIMP long long __cdecl atoll  (_In_z_ char const* _String);
_Check_return_                    _ACRTIMP __int64   __cdecl _atoi64(_In_z_ char const* _String);

_Check_return_ _ACRTIMP double    __cdecl _atof_l  (_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int       __cdecl _atoi_l  (_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP long      __cdecl _atol_l  (_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP long long __cdecl _atoll_l (_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP __int64   __cdecl _atoi64_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP int __cdecl _atoflt (_Out_ _CRT_FLOAT*  _Result, _In_z_ char const* _String);
_Check_return_ _ACRTIMP int __cdecl _atodbl (_Out_ _CRT_DOUBLE* _Result, _In_z_ char*       _String);
_Check_return_ _ACRTIMP int __cdecl _atoldbl(_Out_ _LDOUBLE*    _Result, _In_z_ char*       _String);

_Check_return_
_ACRTIMP int __cdecl _atoflt_l(
    _Out_    _CRT_FLOAT* _Result,
    _In_z_   char const* _String,
    _In_opt_ _locale_t   _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _atodbl_l(
    _Out_    _CRT_DOUBLE* _Result,
    _In_z_   char*        _String,
    _In_opt_ _locale_t    _Locale
    );


_Check_return_
_ACRTIMP int __cdecl _atoldbl_l(
    _Out_    _LDOUBLE* _Result,
    _In_z_   char*     _String,
    _In_opt_ _locale_t _Locale
    );

_Check_return_
_ACRTIMP float __cdecl strtof(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr
    );

_Check_return_
_ACRTIMP float __cdecl _strtof_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP double __cdecl strtod(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr
    );

_Check_return_
_ACRTIMP double __cdecl _strtod_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP long double __cdecl strtold(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr
    );

_Check_return_
_ACRTIMP long double __cdecl _strtold_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP long __cdecl strtol(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix
    );

_Check_return_
_ACRTIMP long __cdecl _strtol_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP long long __cdecl strtoll(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix
    );

_Check_return_
_ACRTIMP long long __cdecl _strtoll_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP unsigned long __cdecl strtoul(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix
    );

_Check_return_
_ACRTIMP unsigned long __cdecl _strtoul_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP unsigned long long __cdecl strtoull(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix
    );

_Check_return_
_ACRTIMP unsigned long long __cdecl _strtoull_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP __int64 __cdecl _strtoi64(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix
    );

_Check_return_
_ACRTIMP __int64 __cdecl _strtoi64_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
    );

_Check_return_
_ACRTIMP unsigned __int64 __cdecl _strtoui64(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix
    );

_Check_return_
_ACRTIMP unsigned __int64 __cdecl _strtoui64_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char**      _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Number to Narrow String Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _itoa_s(
    _In_                         int    _Value,
    _Out_writes_z_(_BufferCount) char*  _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         int    _Radix
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    _Success_(return == 0)
    errno_t, _itoa_s,
    _In_ int,  _Value,
         char, _Buffer,
    _In_ int,  _Radix
    )

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _itoa,
    _In_                    int,  _Value,
    _Pre_notnull_ _Post_z_, char, _Buffer,
    _In_                    int,  _Radix
    )
#pragma warning(pop)

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _ltoa_s(
    _In_                         long   _Value,
    _Out_writes_z_(_BufferCount) char*  _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         int    _Radix
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _ltoa_s,
    _In_ long, _Value,
         char, _Buffer,
    _In_ int,  _Radix
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _ltoa,
    _In_                    long, _Value,
    _Pre_notnull_ _Post_z_, char, _Buffer,
    _In_                    int,  _Radix
    )

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _ultoa_s(
    _In_                         unsigned long _Value,
    _Out_writes_z_(_BufferCount) char*         _Buffer,
    _In_                         size_t        _BufferCount,
    _In_                         int           _Radix
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _ultoa_s,
    _In_ unsigned long, _Value,
         char,          _Buffer,
    _In_ int,           _Radix
    )

#pragma warning(push)
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _ultoa,
    _In_                    unsigned long, _Value,
    _Pre_notnull_ _Post_z_, char,          _Buffer,
    _In_                    int,           _Radix
    )
#pragma warning(pop)

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _i64toa_s(
    _In_                         __int64 _Value,
    _Out_writes_z_(_BufferCount) char*   _Buffer,
    _In_                         size_t  _BufferCount,
    _In_                         int     _Radix
    );

_Success_(return == 0)
_CRT_INSECURE_DEPRECATE(_i64toa_s)
_ACRTIMP char* __cdecl _i64toa(
    _In_                   __int64 _Value,
    _Pre_notnull_ _Post_z_ char*   _Buffer,
    _In_                   int     _Radix
    );

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _ui64toa_s(
    _In_                         unsigned __int64 _Value,
    _Out_writes_z_(_BufferCount) char*            _Buffer,
    _In_                         size_t           _BufferCount,
    _In_                         int              _Radix
    );

_CRT_INSECURE_DEPRECATE(_ui64toa_s)
_ACRTIMP char* __cdecl _ui64toa(
    _In_                   unsigned __int64 _Value,
    _Pre_notnull_ _Post_z_ char*            _Buffer,
    _In_                   int              _Radix
    );



// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It
// should be at least as long as the number of digits in the largest double
// precision value (?.?e308 in IEEE arithmetic).  We will use the same size
// buffer as is used in the printf support routines.
//
// (This value actually allows 40 additional decimal places; even though there
// are only 16 digits of accuracy in a double precision IEEE number, the user may
// ask for more to effect zero padding.)
#define _CVTBUFSIZE (309 + 40) // # of digits in max. dp value + slop

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _ecvt_s(
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_  size_t                       _BufferCount,
    _In_  double                       _Value,
    _In_  int                          _DigitCount,
    _Out_ int*                         _PtDec,
    _Out_ int*                         _PtSign
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    errno_t, _ecvt_s,
          char,   _Buffer,
    _In_  double, _Value,
    _In_  int,    _DigitCount,
    _Out_ int*,   _PtDec,
    _Out_ int*,   _PtSign
    )

_Check_return_ _CRT_INSECURE_DEPRECATE(_ecvt_s)
_ACRTIMP char* __cdecl _ecvt(
    _In_  double _Value,
    _In_  int    _DigitCount,
    _Out_ int*   _PtDec,
    _Out_ int*   _PtSign
    );

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _fcvt_s(
    _Out_writes_z_(_BufferCount) char*  _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         double _Value,
    _In_                         int    _FractionalDigitCount,
    _Out_                        int*   _PtDec,
    _Out_                        int*   _PtSign
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    _Success_(return == 0)
    errno_t, _fcvt_s,
          char,   _Buffer,
    _In_  double, _Value,
    _In_  int,    _FractionalDigitCount,
    _Out_ int*,   _PtDec,
    _Out_ int*,   _PtSign
    )

_Success_(return == 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(_fcvt_s)
_ACRTIMP char* __cdecl _fcvt(
    _In_  double _Value,
    _In_  int    _FractionalDigitCount,
    _Out_ int*   _PtDec,
    _Out_ int*   _PtSign
    );

_Success_(return == 0)
_ACRTIMP errno_t __cdecl _gcvt_s(
    _Out_writes_z_(_BufferCount) char*  _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         double _Value,
    _In_                         int    _DigitCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    _Success_(return == 0)
    errno_t, _gcvt_s,
         char,   _Buffer,
    _In_ double, _Value,
    _In_ int,    _DigitCount
    )

_CRT_INSECURE_DEPRECATE(_gcvt_s)
_ACRTIMP char* __cdecl _gcvt(
    _In_                   double _Value,
    _In_                   int    _DigitCount,
    _Pre_notnull_ _Post_z_ char*  _Buffer
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Multibyte String Operations and Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Maximum number of bytes in multi-byte character in the current locale
// (also defined in ctype.h).
#ifndef MB_CUR_MAX
    #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
        #define MB_CUR_MAX __mb_cur_max
    #else
# 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        #define MB_CUR_MAX ___mb_cur_max_func()
    #endif
# 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    #ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
        extern int __mb_cur_max;
    #else
# 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        #define __mb_cur_max (___mb_cur_max_func())
    #endif
# 843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    _Post_satisfies_(return > 0 && return < MB_LEN_MAX)
    _ACRTIMP int __cdecl ___mb_cur_max_func(void);

    _Post_satisfies_(return > 0 && return < MB_LEN_MAX)
    _ACRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#endif
# 850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



_Check_return_
_ACRTIMP int __cdecl mblen(
    _In_reads_bytes_opt_(_MaxCount) _Pre_opt_z_ char const* _Ch,
    _In_                                        size_t      _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _mblen_l(
    _In_reads_bytes_opt_(_MaxCount) _Pre_opt_z_ char const* _Ch,
    _In_                                        size_t      _MaxCount,
    _In_opt_                                    _locale_t   _Locale
    );

_Check_return_
_Post_satisfies_(return <= _String_length_(_String))
_ACRTIMP size_t __cdecl _mbstrlen(
    _In_z_ char const* _String
    );

_Check_return_
_Post_satisfies_(return <= _String_length_(_String) || return == (size_t)-1)
_ACRTIMP size_t __cdecl _mbstrlen_l(
    _In_z_   char const* _String,
    _In_opt_ _locale_t   _Locale
    );

_Check_return_
_Post_satisfies_((return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1)
_ACRTIMP size_t __cdecl _mbstrnlen(
    _In_z_ char const* _String,
    _In_   size_t      _MaxCount
    );

_Post_satisfies_((return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1)
_Check_return_
_ACRTIMP size_t __cdecl _mbstrnlen_l(
    _In_z_   char const* _String,
    _In_     size_t      _MaxCount,
    _In_opt_ _locale_t   _Locale
    );

_Success_(return != -1)
_ACRTIMP int __cdecl mbtowc(
    _Pre_notnull_ _Post_z_               wchar_t*    _DstCh,
    _In_reads_or_z_opt_(_SrcSizeInBytes) char const* _SrcCh,
    _In_                                 size_t      _SrcSizeInBytes
    );

_Success_(return != -1)
_ACRTIMP int __cdecl _mbtowc_l(
    _Pre_notnull_ _Post_z_               wchar_t*    _DstCh,
    _In_reads_or_z_opt_(_SrcSizeInBytes) char const* _SrcCh,
    _In_                                 size_t      _SrcSizeInBytes,
    _In_opt_                             _locale_t   _Locale
    );

_Check_return_opt_
_ACRTIMP errno_t __cdecl mbstowcs_s(
    _Out_opt_                                                 size_t*     _PtNumOfCharConverted,
    _Out_writes_to_opt_(_SizeInWords, *_PtNumOfCharConverted) wchar_t*    _DstBuf,
    _In_                                                      size_t      _SizeInWords,
    _In_reads_or_z_(_MaxCount)                                char const* _SrcBuf,
    _In_                                                      size_t      _MaxCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(
    errno_t, mbstowcs_s,
    _Out_opt_ size_t*,     _PtNumOfCharConverted,
    _Post_z_  wchar_t,     _Dest,
    _In_z_    char const*, _Source,
    _In_      size_t,      _MaxCount
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(
    _ACRTIMP, mbstowcs,
    _Out_writes_opt_z_(_MaxCount), wchar_t,     _Dest,
    _In_z_                         char const*, _Source,
    _In_                           size_t,      _MaxCount
    )

_Check_return_opt_
_ACRTIMP errno_t __cdecl _mbstowcs_s_l(
    _Out_opt_                                                 size_t*     _PtNumOfCharConverted,
    _Out_writes_to_opt_(_SizeInWords, *_PtNumOfCharConverted) wchar_t*    _DstBuf,
    _In_                                                      size_t      _SizeInWords,
    _In_reads_or_z_(_MaxCount)                                char const* _SrcBuf,
    _In_                                                      size_t      _MaxCount,
    _In_opt_                                                  _locale_t   _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
    errno_t, _mbstowcs_s_l,
    _Out_opt_ size_t*,     _PtNumOfCharConverted,
    _Post_z_  wchar_t,     _Dest,
    _In_z_    char const*, _Source,
    _In_      size_t,      _MaxCount,
    _In_opt_  _locale_t,   _Locale
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(
    _ACRTIMP, _mbstowcs_l, _mbstowcs_s_l,
    _Out_writes_opt_z_(_Size)  wchar_t,
    _Out_writes_z_(_MaxCount), wchar_t,     _Dest,
    _In_z_                     char const*, _Source,
    _In_                       size_t,      _MaxCount,
    _In_opt_                   _locale_t,   _Locale
    )




_CRT_INSECURE_DEPRECATE(wctomb_s)
_ACRTIMP int __cdecl wctomb(
    _Out_writes_opt_z_(MB_LEN_MAX) char*   _MbCh,
    _In_                           wchar_t _WCh
    );

_CRT_INSECURE_DEPRECATE(_wctomb_s_l)
_ACRTIMP int __cdecl _wctomb_l(
    _Pre_maybenull_ _Post_z_ char*     _MbCh,
    _In_                     wchar_t   _WCh,
    _In_opt_                 _locale_t _Locale
    );

#if __STDC_WANT_SECURE_LIB__

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl wctomb_s(
        _Out_opt_                                                int*    _SizeConverted,
        _Out_writes_bytes_to_opt_(_SizeInBytes, *_SizeConverted) char*   _MbCh,
        _In_                                                     rsize_t _SizeInBytes,
        _In_                                                     wchar_t _WCh
        );

#endif // __STDC_WANT_SECURE_LIB__
# 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wctomb_s_l(
    _Out_opt_                        int*     _SizeConverted,
    _Out_writes_opt_z_(_SizeInBytes) char*     _MbCh,
    _In_                             size_t    _SizeInBytes,
    _In_                             wchar_t   _WCh,
    _In_opt_                         _locale_t _Locale);

_Check_return_wat_
_ACRTIMP errno_t __cdecl wcstombs_s(
    _Out_opt_                                                          size_t*        _PtNumOfCharConverted,
    _Out_writes_bytes_to_opt_(_DstSizeInBytes, *_PtNumOfCharConverted) char*          _Dst,
    _In_                                                               size_t         _DstSizeInBytes,
    _In_z_                                                             wchar_t const* _Src,
    _In_                                                               size_t         _MaxCountInBytes
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(
    errno_t, wcstombs_s,
    _Out_opt_                     size_t*,        _PtNumOfCharConverted,
    _Out_writes_bytes_opt_(_Size) char,           _Dest,
    _In_z_                        wchar_t const*, _Source,
    _In_                          size_t,         _MaxCount
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(
    _ACRTIMP, wcstombs,
    _Out_writes_opt_(_MaxCount),   char,           _Dest,
    _In_z_                         wchar_t const*, _Source,
    _In_                           size_t,         _MaxCount
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcstombs_s_l(
    _Out_opt_                                                          size_t*        _PtNumOfCharConverted,
    _Out_writes_bytes_to_opt_(_DstSizeInBytes, *_PtNumOfCharConverted) char*          _Dst,
    _In_                                                               size_t         _DstSizeInBytes,
    _In_z_                                                             wchar_t const* _Src,
    _In_                                                               size_t         _MaxCountInBytes,
    _In_opt_                                                           _locale_t      _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
    errno_t, _wcstombs_s_l,
    _Out_opt_               size_t*,        _PtNumOfCharConverted,
    _Out_writes_opt_(_Size) char,           _Dest,
    _In_z_                  wchar_t const*, _Source,
    _In_                    size_t,         _MaxCount,
    _In_opt_                _locale_t,      _Locale
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(
    _ACRTIMP, _wcstombs_l, _wcstombs_s_l,
    _Out_writes_opt_z_(_Size)  char,
    _Out_writes_(_MaxCount),   char,           _Dest,
    _In_z_                     wchar_t const*, _Source,
    _In_                       size_t,         _MaxCount,
    _In_opt_                   _locale_t,      _Locale
    )



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Path Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Sizes for buffers used by the _makepath() and _splitpath() functions.
// note that the sizes include space for 0-terminator
#define _MAX_PATH   260 // max. length of full pathname
#define _MAX_DRIVE  3   // max. length of drive component
#define _MAX_DIR    256 // max. length of path component
#define _MAX_FNAME  256 // max. length of file name component
#define _MAX_EXT    256 // max. length of extension component


#pragma push_macro("_fullpath")
#undef _fullpath

_Success_(return != 0)
_Check_return_
_ACRTIMP _CRTALLOCATOR char* __cdecl _fullpath(
    _Out_writes_opt_z_(_BufferCount) char*       _Buffer,
    _In_z_                           char const* _Path,
    _In_                             size_t      _BufferCount
    );

#pragma pop_macro("_fullpath")

_Check_return_wat_
_ACRTIMP errno_t __cdecl _makepath_s(
    _Out_writes_z_(_BufferCount) char*       _Buffer,
    _In_                         size_t      _BufferCount,
    _In_opt_z_                   char const* _Drive,
    _In_opt_z_                   char const* _Dir,
    _In_opt_z_                   char const* _Filename,
    _In_opt_z_                   char const* _Ext
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    errno_t, _makepath_s,
               char,        _Buffer,
    _In_opt_z_ char const*, _Drive,
    _In_opt_z_ char const*, _Dir,
    _In_opt_z_ char const*, _Filename,
    _In_opt_z_ char const*, _Ext
    )

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(
    void, __RETURN_POLICY_VOID, _ACRTIMP, _makepath,
    _Pre_notnull_ _Post_z_, char,        _Buffer,
    _In_opt_z_              char const*, _Drive,
    _In_opt_z_              char const*, _Dir,
    _In_opt_z_              char const*, _Filename,
    _In_opt_z_              char const*, _Ext
    )
#pragma warning(pop)

_CRT_INSECURE_DEPRECATE(_splitpath_s)
_ACRTIMP void __cdecl _splitpath(
    _In_z_                   char const* _FullPath,
    _Pre_maybenull_ _Post_z_ char*       _Drive,
    _Pre_maybenull_ _Post_z_ char*       _Dir,
    _Pre_maybenull_ _Post_z_ char*       _Filename,
    _Pre_maybenull_ _Post_z_ char*       _Ext
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _splitpath_s(
    _In_z_                             char const* _FullPath,
    _Out_writes_opt_z_(_DriveCount)    char*       _Drive,
    _In_                               size_t      _DriveCount,
    _Out_writes_opt_z_(_DirCount)      char*       _Dir,
    _In_                               size_t      _DirCount,
    _Out_writes_opt_z_(_FilenameCount) char*       _Filename,
    _In_                               size_t      _FilenameCount,
    _Out_writes_opt_z_(_ExtCount)      char*       _Ext,
    _In_                               size_t      _ExtCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(errno_t, _splitpath_s, char, _Dest)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// APIs Only Available in Desktop Apps
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

    #if __STDC_WANT_SECURE_LIB__

    _Check_return_opt_
    _Success_(return == 0)
    _DCRTIMP errno_t __cdecl getenv_s(
        _Out_                            size_t*     _RequiredCount,
        _Out_writes_opt_z_(_BufferCount) char*       _Buffer,
        _In_                             rsize_t     _BufferCount,
        _In_z_                           char const* _VarName
        );

    #endif // __STDC_WANT_SECURE_LIB__
# 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3




    _ACRTIMP int*       __cdecl __p___argc (void);
    _ACRTIMP char***    __cdecl __p___argv (void);
    _ACRTIMP wchar_t*** __cdecl __p___wargv(void);

    #ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
        extern int       __argc;
        extern char**    __argv;
        extern wchar_t** __wargv;
    #else
# 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        #define __argc  (*__p___argc())  // Pointer to number of command line arguments
        #define __argv  (*__p___argv())  // Pointer to table of narrow command line arguments
        #define __wargv (*__p___wargv()) // Pointer to table of wide command line arguments
    #endif
# 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    _DCRTIMP char***    __cdecl __p__environ (void);
    _DCRTIMP wchar_t*** __cdecl __p__wenviron(void);

    #ifndef _CRT_BEST_PRACTICES_USAGE
        #define _CRT_V12_LEGACY_FUNCTIONALITY
    #endif
# 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    #ifndef _CRT_V12_LEGACY_FUNCTIONALITY
        // Deprecated symbol: Do not expose environment global pointers unless
        // legacy access is specifically requested
        #define _environ    crt_usage_error__do_not_reference_global_pointer_directly__environ
        #define _wenviron   crt_usage_error__do_not_reference_global_pointer_directly__wenviron
    #else
# 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        #define _environ  (*__p__environ())  // Pointer to narrow environment table
        #define _wenviron (*__p__wenviron()) // Pointer to wide environment table
    #endif
# 1189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



    // Sizes for buffers used by the getenv/putenv family of functions.
    #define _MAX_ENV 32767


    #if _CRT_FUNCTIONS_REQUIRED

        _Check_return_ _CRT_INSECURE_DEPRECATE(_dupenv_s)
        _DCRTIMP char* __cdecl getenv(
            _In_z_ char const* _VarName
            );

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
            errno_t, getenv_s,
            _Out_  size_t*,     _RequiredCount,
                   char,        _Buffer,
            _In_z_ char const*, _VarName
            )

        #if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
            #pragma push_macro("_dupenv_s")
            #undef _dupenv_s
        #endif
# 1214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

        _Check_return_opt_
        _DCRTIMP errno_t __cdecl _dupenv_s(
            _Outptr_result_buffer_maybenull_(*_BufferCount) _Outptr_result_maybenull_z_ char**      _Buffer,
            _Out_opt_                                                                   size_t*     _BufferCount,
            _In_z_                                                                      char const* _VarName
            );

        #if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
            #pragma pop_macro("_dupenv_s")
        #endif
# 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

        _DCRTIMP int __cdecl system(
            _In_opt_z_ char const* _Command
            );

        // The functions below have declspecs in their declarations in the Windows
        // headers, causing PREfast to fire 6540 here
        #pragma warning (push)
        #pragma warning (disable:6540)

        _Check_return_
        _DCRTIMP int __cdecl _putenv(
            _In_z_ char const* _EnvString
            );

        _Check_return_wat_
        _DCRTIMP errno_t __cdecl _putenv_s(
            _In_z_ char const* _Name,
            _In_z_ char const* _Value
            );

        #pragma warning (pop)

        _DCRTIMP errno_t __cdecl _searchenv_s(
            _In_z_                       char const* _Filename,
            _In_z_                       char const* _VarName,
            _Out_writes_z_(_BufferCount) char*       _Buffer,
            _In_                         size_t      _BufferCount
            );

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(
            errno_t, _searchenv_s,
            _In_z_ char const*, _Filename,
            _In_z_ char const*, _VarName,
                   char,        _Buffer
            )

        __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(
            void, __RETURN_POLICY_VOID, _DCRTIMP, _searchenv,
            _In_z_                  char const*, _Filename,
            _In_z_                  char const*, _VarName,
            _Pre_notnull_ _Post_z_, char,        _Buffer
            )

        // The Win32 API SetErrorMode, Beep and Sleep should be used instead.
        _CRT_OBSOLETE(SetErrorMode)
        _DCRTIMP void __cdecl _seterrormode(
            _In_ int _Mode
            );

        _CRT_OBSOLETE(Beep)
        _DCRTIMP void __cdecl _beep(
            _In_ unsigned _Frequency,
            _In_ unsigned _Duration
            );

        _CRT_OBSOLETE(Sleep)
        _DCRTIMP void __cdecl _sleep(
            _In_ unsigned long _Duration
            );

    #endif // _CRT_FUNCTIONS_REQUIRED
# 1287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

#endif // _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
# 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if _CRT_INTERNAL_NONSTDC_NAMES

    #ifndef __cplusplus
        #define max(a,b) (((a) > (b)) ? (a) : (b))
        #define min(a,b) (((a) < (b)) ? (a) : (b))
    #endif
# 1303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    #define sys_errlist _sys_errlist
    #define sys_nerr    _sys_nerr

    #pragma warning(push)
    #pragma warning(disable: 4141) // Using deprecated twice

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_ecvt) _CRT_INSECURE_DEPRECATE(_ecvt_s)
    _ACRTIMP char* __cdecl ecvt(
        _In_  double _Value,
        _In_  int    _DigitCount,
        _Out_ int*   _PtDec,
        _Out_ int*   _PtSign
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_fcvt) _CRT_INSECURE_DEPRECATE(_fcvt_s)
    _ACRTIMP char* __cdecl fcvt(
        _In_  double _Value,
        _In_  int    _FractionalDigitCount,
        _Out_ int*   _PtDec,
        _Out_ int*   _PtSign
        );

    _CRT_NONSTDC_DEPRECATE(_gcvt) _CRT_INSECURE_DEPRECATE(_fcvt_s)
    _ACRTIMP char* __cdecl gcvt(
        _In_                   double _Value,
        _In_                   int    _DigitCount,
        _Pre_notnull_ _Post_z_ char*  _DstBuf
        );

    _CRT_NONSTDC_DEPRECATE(_itoa) _CRT_INSECURE_DEPRECATE(_itoa_s)
    _ACRTIMP char* __cdecl itoa(
        _In_                   int   _Value,
        _Pre_notnull_ _Post_z_ char* _Buffer,
        _In_                   int   _Radix
        );

    _CRT_NONSTDC_DEPRECATE(_ltoa) _CRT_INSECURE_DEPRECATE(_ltoa_s)
    _ACRTIMP char* __cdecl ltoa(
        _In_                   long  _Value,
        _Pre_notnull_ _Post_z_ char* _Buffer,
        _In_                   int   _Radix
        );


    _CRT_NONSTDC_DEPRECATE(_swab)
    _ACRTIMP void __cdecl swab(
        _Inout_updates_z_(_SizeInBytes) char* _Buf1,
        _Inout_updates_z_(_SizeInBytes) char* _Buf2,
        _In_                            int   _SizeInBytes
        );

    _CRT_NONSTDC_DEPRECATE(_ultoa) _CRT_INSECURE_DEPRECATE(_ultoa_s)
    _ACRTIMP char* __cdecl ultoa(
        _In_                   unsigned long _Value,
        _Pre_notnull_ _Post_z_ char*         _Buffer,
        _In_                   int           _Radix
        );

    #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

        #define environ _environ

        _Check_return_ _CRT_NONSTDC_DEPRECATE(_putenv)
        _DCRTIMP int __cdecl putenv(
            _In_z_ char const* _EnvString
            );

    #endif // _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
# 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3

    #pragma warning(pop)

    onexit_t __cdecl onexit(_In_opt_ onexit_t _Func);

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 1378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3



_CRT_END_C_HEADER
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <math.h>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 1 3
//
// math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <math.h> header.  This header consists of two parts:
// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains
// the nonstandard but useful constant definitions.  The headers are divided in
// this way for modularity (to support the C++ modules feature).
//
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_math.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 1 3
//
// corecrt_math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The majority of the C Standard Library <math.h> functionality.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
#define _INC_MATH

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

_CRT_BEGIN_C_HEADER

#pragma warning(push)
#pragma warning(disable:4738) // storing 32-bit float result in memory, possible loss of performance
#pragma warning(disable:4820) // padding added after data member



#ifndef __assembler
    // Definition of the _exception struct, which is passed to the matherr function
    // when a floating point exception is detected:
    struct _exception
    {
        int    type;   // exception type - see below
        char*  name;   // name of function where error occurred
        double arg1;   // first argument to function
        double arg2;   // second argument (if any) to function
        double retval; // value to be returned by function
    };

    // Definition of the _complex struct to be used by those who use the complex
    // functions and want type checking.
    #ifndef _COMPLEX_DEFINED
        #define _COMPLEX_DEFINED

        struct _complex
        {
            double x, y; // real and imaginary parts
        };

        #if _CRT_INTERNAL_NONSTDC_NAMES && !defined __cplusplus
            // Non-ANSI name for compatibility
            #define complex _complex
        #endif
# 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
    #endif
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
#endif // __assembler
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3



// On x86, when not using /arch:SSE2 or greater, floating point operations
// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.
// (When /fp:fast is used, floating point operations may be consistent, so
// we use the default types.)
#if defined _M_IX86 && _M_IX86_FP < 2 && !defined _M_FP_FAST
    typedef long double float_t;
    typedef long double double_t;
#else
# 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
    typedef float  float_t;
    typedef double double_t;
#endif
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3



// Constant definitions for the exception type passed in the _exception struct
#define _DOMAIN     1   // argument domain error
#define _SING       2   // argument singularity
#define _OVERFLOW   3   // overflow range error
#define _UNDERFLOW  4   // underflow range error
#define _TLOSS      5   // total loss of precision
#define _PLOSS      6   // partial loss of precision

// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines.
#ifndef __assembler
    #ifndef _M_CEE_PURE
        extern double const _HUGE;
    #else
# 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
        double const _HUGE = System::Double::PositiveInfinity;
    #endif
# 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
#endif
# 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

#ifndef _HUGE_ENUF
    #define _HUGE_ENUF  1e+300  // _HUGE_ENUF*_HUGE_ENUF must overflow
#endif
# 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

#define INFINITY   ((float)(_HUGE_ENUF * _HUGE_ENUF))
#define HUGE_VAL   ((double)INFINITY)
#define HUGE_VALF  ((float)INFINITY)
#define HUGE_VALL  ((long double)INFINITY)
#define NAN        ((float)(INFINITY * 0.0F))

#define _DENORM    (-2)
#define _FINITE    (-1)
#define _INFCODE   1
#define _NANCODE   2

#define FP_INFINITE  _INFCODE
#define FP_NAN       _NANCODE
#define FP_NORMAL    _FINITE
#define FP_SUBNORMAL _DENORM
#define FP_ZERO      0

#define _C2          1  // 0 if not 2's complement
#define FP_ILOGB0   (-0x7fffffff - _C2)
#define FP_ILOGBNAN 0x7fffffff

#define MATH_ERRNO        1
#define MATH_ERREXCEPT    2
#define math_errhandling  (MATH_ERRNO | MATH_ERREXCEPT)

// Values for use as arguments to the _fperrraise function
#define _FE_DIVBYZERO 0x04
#define _FE_INEXACT   0x20
#define _FE_INVALID   0x01
#define _FE_OVERFLOW  0x08
#define _FE_UNDERFLOW 0x10

#define _D0_C  3 // little-endian, small long doubles
#define _D1_C  2
#define _D2_C  1
#define _D3_C  0

#define _DBIAS 0x3fe
#define _DOFF  4

#define _F0_C  1 // little-endian
#define _F1_C  0

#define _FBIAS 0x7e
#define _FOFF  7
#define _FRND  1

#define _L0_C  3 // little-endian, 64-bit long doubles
#define _L1_C  2
#define _L2_C  1
#define _L3_C  0

#define _LBIAS 0x3fe
#define _LOFF  4

// IEEE 754 double properties
#define _DFRAC  ((unsigned short)((1 << _DOFF) - 1))
#define _DMASK  ((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX   ((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN  ((unsigned short)0x8000)

// IEEE 754 float properties
#define _FFRAC  ((unsigned short)((1 << _FOFF) - 1))
#define _FMASK  ((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX   ((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN  ((unsigned short)0x8000)

// IEEE 754 long double properties
#define _LFRAC  ((unsigned short)(-1))
#define _LMASK  ((unsigned short)0x7fff)
#define _LMAX   ((unsigned short)0x7fff)
#define _LSIGN  ((unsigned short)0x8000)

#define _DHUGE_EXP (int)(_DMAX * 900L / 1000)
#define _FHUGE_EXP (int)(_FMAX * 900L / 1000)
#define _LHUGE_EXP (int)(_LMAX * 900L / 1000)

#define _DSIGN_C(_Val)  (((_double_val *)(char*)&(_Val))->_Sh[_D0_C] & _DSIGN)
#define _FSIGN_C(_Val)  (((_float_val  *)(char*)&(_Val))->_Sh[_F0_C] & _FSIGN)
#define _LSIGN_C(_Val)  (((_ldouble_val*)(char*)&(_Val))->_Sh[_L0_C] & _LSIGN)

void __cdecl _fperrraise(_In_ int _Except);

_Check_return_ _ACRTIMP short __cdecl _dclass(_In_ double _X);
_Check_return_ _ACRTIMP short __cdecl _ldclass(_In_ long double _X);
_Check_return_ _ACRTIMP short __cdecl _fdclass(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _dsign(_In_ double _X);
_Check_return_ _ACRTIMP int __cdecl _ldsign(_In_ long double _X);
_Check_return_ _ACRTIMP int __cdecl _fdsign(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _dpcomp(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int __cdecl _ldpcomp(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP int __cdecl _fdpcomp(_In_ float _X, _In_ float _Y);

_Check_return_ _ACRTIMP short __cdecl _dtest(_In_ double* _Px);
_Check_return_ _ACRTIMP short __cdecl _ldtest(_In_ long double* _Px);
_Check_return_ _ACRTIMP short __cdecl _fdtest(_In_ float* _Px);

_ACRTIMP short __cdecl _d_int(_Inout_ double* _Px, _In_ short _Xexp);
_ACRTIMP short __cdecl _ld_int(_Inout_ long double* _Px, _In_ short _Xexp);
_ACRTIMP short __cdecl _fd_int(_Inout_ float* _Px, _In_ short _Xexp);

_ACRTIMP short __cdecl _dscale(_Inout_ double* _Px, _In_ long _Lexp);
_ACRTIMP short __cdecl _ldscale(_Inout_ long double* _Px, _In_ long _Lexp);
_ACRTIMP short __cdecl _fdscale(_Inout_ float* _Px, _In_ long _Lexp);

_ACRTIMP short __cdecl _dunscale(_Out_ short* _Pex, _Inout_ double* _Px);
_ACRTIMP short __cdecl _ldunscale(_Out_ short* _Pex, _Inout_ long double* _Px);
_ACRTIMP short __cdecl _fdunscale(_Out_ short* _Pex, _Inout_ float* _Px);

_Check_return_ _ACRTIMP short __cdecl _dexp(_Inout_ double* _Px, _In_ double _Y, _In_ long _Eoff);
_Check_return_ _ACRTIMP short __cdecl _ldexp(_Inout_ long double* _Px, _In_ long double _Y, _In_ long _Eoff);
_Check_return_ _ACRTIMP short __cdecl _fdexp(_Inout_ float* _Px, _In_ float _Y, _In_ long _Eoff);

_Check_return_ _ACRTIMP short __cdecl _dnorm(_Inout_updates_(4) unsigned short* _Ps);
_Check_return_ _ACRTIMP short __cdecl _fdnorm(_Inout_updates_(2) unsigned short* _Ps);

_Check_return_ _ACRTIMP double __cdecl _dpoly(_In_ double _X, _In_reads_(_N) double const* _Tab, _In_ int _N);
_Check_return_ _ACRTIMP long double __cdecl _ldpoly(_In_ long double _X, _In_reads_(_N) long double const* _Tab, _In_ int _N);
_Check_return_ _ACRTIMP float __cdecl _fdpoly(_In_ float _X, _In_reads_(_N) float const* _Tab, _In_ int _N);

_Check_return_ _ACRTIMP double __cdecl _dlog(_In_ double _X, _In_ int _Baseflag);
_Check_return_ _ACRTIMP long double __cdecl _ldlog(_In_ long double _X, _In_ int _Baseflag);
_Check_return_ _ACRTIMP float __cdecl _fdlog(_In_ float _X, _In_ int _Baseflag);

_Check_return_ _ACRTIMP double __cdecl _dsin(_In_ double _X, _In_ unsigned int _Qoff);
_Check_return_ _ACRTIMP long double __cdecl _ldsin(_In_ long double _X, _In_ unsigned int _Qoff);
_Check_return_ _ACRTIMP float __cdecl _fdsin(_In_ float _X, _In_ unsigned int _Qoff);

// double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    double _Val;
} _double_val;

// float declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[2];
    float _Val;
} _float_val;

// long double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   // pun float types as integer array
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;

#define _FP_LT  1
#define _FP_EQ  2
#define _FP_GT  4

#ifndef __cplusplus

    #define _CLASS_ARG(_Val)                                  __pragma(warning(suppress:6334))(sizeof ((_Val) + (float)0) == sizeof (float) ? 'f' : sizeof ((_Val) + (double)0) == sizeof (double) ? 'd' : 'l')
    #define _CLASSIFY(_Val, _FFunc, _DFunc, _LDFunc)          (_CLASS_ARG(_Val) == 'f' ? _FFunc((float)(_Val)) : _CLASS_ARG(_Val) == 'd' ? _DFunc((double)(_Val)) : _LDFunc((long double)(_Val)))
    #define _CLASSIFY2(_Val1, _Val2, _FFunc, _DFunc, _LDFunc) (_CLASS_ARG((_Val1) + (_Val2)) == 'f' ? _FFunc((float)(_Val1), (float)(_Val2)) : _CLASS_ARG((_Val1) + (_Val2)) == 'd' ? _DFunc((double)(_Val1), (double)(_Val2)) : _LDFunc((long double)(_Val1), (long double)(_Val2)))

    #define fpclassify(_Val)      (_CLASSIFY(_Val, _fdclass, _dclass, _ldclass))
    #define _FPCOMPARE(_Val1, _Val2) (_CLASSIFY2(_Val1, _Val2, _fdpcomp, _dpcomp, _ldpcomp))

    #define isfinite(_Val)      (fpclassify(_Val) <= 0)
    #define isinf(_Val)         (fpclassify(_Val) == FP_INFINITE)
    #define isnan(_Val)         (fpclassify(_Val) == FP_NAN)
    #define isnormal(_Val)      (fpclassify(_Val) == FP_NORMAL)
    #define signbit(_Val)       (_CLASSIFY(_Val, _fdsign, _dsign, _ldsign))

    #define isgreater(x, y)      ((_FPCOMPARE(x, y) & _FP_GT) != 0)
    #define isgreaterequal(x, y) ((_FPCOMPARE(x, y) & (_FP_EQ | _FP_GT)) != 0)
    #define isless(x, y)         ((_FPCOMPARE(x, y) & _FP_LT) != 0)
    #define islessequal(x, y)    ((_FPCOMPARE(x, y) & (_FP_LT | _FP_EQ)) != 0)
    #define islessgreater(x, y)  ((_FPCOMPARE(x, y) & (_FP_LT | _FP_GT)) != 0)
    #define isunordered(x, y)    (_FPCOMPARE(x, y) == 0)

#else // __cplusplus
# 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
extern "C++"
{
    _Check_return_ inline int fpclassify(_In_ float _X) throw()
    {
        return _fdtest(&_X);
    }

    _Check_return_ inline int fpclassify(_In_ double _X) throw()
    {
        return _dtest(&_X);
    }

    _Check_return_ inline int fpclassify(_In_ long double _X) throw()
    {
        return _ldtest(&_X);
    }

    _Check_return_ inline bool signbit(_In_ float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

    _Check_return_ inline bool signbit(_In_ double _X) throw()
    {
        return _dsign(_X) != 0;
    }

    _Check_return_ inline bool signbit(_In_ long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

    _Check_return_ inline int _fpcomp(_In_ float _X, _In_ float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

    _Check_return_ inline int _fpcomp(_In_ double _X, _In_ double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

    _Check_return_ inline int _fpcomp(_In_ long double _X, _In_ long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   // determine combined type
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   // determine combined type
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   // determine combined type
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   // determine widened real type
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   // determine widened real type
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   // determine equivalent real type
        typedef double _Type;   // default is double
    };

    template <> struct _Real_type<float>
    {   // determine equivalent real type
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   // determine equivalent real type
        typedef long double _Type;
    };

    template <class _T1, class _T2>
    _Check_return_ inline int _fpcomp(_In_ _T1 _X, _In_ _T2 _Y) throw()
    {   // compare _Left and _Right
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
    _Check_return_ inline bool isfinite(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
    _Check_return_ inline bool isinf(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) == FP_INFINITE;
    }

    template <class _Ty>
    _Check_return_ inline bool isnan(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) == FP_NAN;
    }

    template <class _Ty>
    _Check_return_ inline bool isnormal(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) == FP_NORMAL;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isgreater(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & _FP_GT) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isgreaterequal(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (_FP_EQ | _FP_GT)) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isless(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & _FP_LT) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool islessequal(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (_FP_LT | _FP_EQ)) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool islessgreater(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (_FP_LT | _FP_GT)) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isunordered(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  // extern "C++"
#endif // __cplusplus
# 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3



#if _CRT_FUNCTIONS_REQUIRED

    _Check_return_ int       __cdecl abs(_In_ int _X);
    _Check_return_ long      __cdecl labs(_In_ long _X);
    _Check_return_ long long __cdecl llabs(_In_ long long _X);

    _Check_return_ double __cdecl acos(_In_ double _X);
    _Check_return_ double __cdecl asin(_In_ double _X);
    _Check_return_ double __cdecl atan(_In_ double _X);
    _Check_return_ double __cdecl atan2(_In_ double _Y, _In_ double _X);

    _Check_return_ double __cdecl cos(_In_ double _X);
    _Check_return_ double __cdecl cosh(_In_ double _X);
    _Check_return_ double __cdecl exp(_In_ double _X);
    _Check_return_ _CRT_JIT_INTRINSIC double __cdecl fabs(_In_ double _X);
    _Check_return_ double __cdecl fmod(_In_ double _X, _In_ double _Y);
    _Check_return_ double __cdecl log(_In_ double _X);
    _Check_return_ double __cdecl log10(_In_ double _X);
    _Check_return_ double __cdecl pow(_In_ double _X, _In_ double _Y);
    _Check_return_ double __cdecl sin(_In_ double _X);
    _Check_return_ double __cdecl sinh(_In_ double _X);
    _Check_return_ _CRT_JIT_INTRINSIC double __cdecl sqrt(_In_ double _X);
    _Check_return_ double __cdecl tan(_In_ double _X);
    _Check_return_ double __cdecl tanh(_In_ double _X);

    _Check_return_ _ACRTIMP double    __cdecl acosh(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl asinh(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl atanh(_In_ double _X);
    _Check_return_ _ACRTIMP  double    __cdecl atof(_In_z_ char const* _String);
    _Check_return_ _ACRTIMP  double    __cdecl _atof_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
    _Check_return_ _ACRTIMP double    __cdecl _cabs(_In_ struct _complex _Complex_value);
    _Check_return_ _ACRTIMP double    __cdecl cbrt(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl ceil(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl _chgsign(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl copysign(_In_ double _Number, _In_ double _Sign);
    _Check_return_ _ACRTIMP double    __cdecl _copysign(_In_ double _Number, _In_ double _Sign);
    _Check_return_ _ACRTIMP double    __cdecl erf(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl erfc(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl exp2(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl expm1(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl fdim(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double    __cdecl floor(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl fma(_In_ double _X, _In_ double _Y, _In_ double _Z);
    _Check_return_ _ACRTIMP double    __cdecl fmax(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double    __cdecl fmin(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double    __cdecl frexp(_In_ double _X, _Out_ int* _Y);
    _Check_return_ _ACRTIMP double    __cdecl hypot(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double    __cdecl _hypot(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP int       __cdecl ilogb(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl ldexp(_In_ double _X, _In_ int _Y);
    _Check_return_ _ACRTIMP double    __cdecl lgamma(_In_ double _X);
    _Check_return_ _ACRTIMP long long __cdecl llrint(_In_ double _X);
    _Check_return_ _ACRTIMP long long __cdecl llround(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl log1p(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl log2(_In_ double _X);
    _Check_return_ _ACRTIMP double    __cdecl logb(_In_ double _X);
    _Check_return_ _ACRTIMP long      __cdecl lrint(_In_ double _X);
    _Check_return_ _ACRTIMP long      __cdecl lround(_In_ double _X);

    int __CRTDECL _matherr(_Inout_ struct _exception* _Except);

    _Check_return_ _ACRTIMP double __cdecl modf(_In_ double _X, _Out_ double* _Y);
    _Check_return_ _ACRTIMP double __cdecl nan(_In_ char const* _X);
    _Check_return_ _ACRTIMP double __cdecl nearbyint(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl nextafter(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double __cdecl nexttoward(_In_ double _X, _In_ long double _Y);
    _Check_return_ _ACRTIMP double __cdecl remainder(_In_ double _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double __cdecl remquo(_In_ double _X, _In_ double _Y, _Out_ int* _Z);
    _Check_return_ _ACRTIMP double __cdecl rint(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl round(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl scalbln(_In_ double _X, _In_ long _Y);
    _Check_return_ _ACRTIMP double __cdecl scalbn(_In_ double _X, _In_ int _Y);
    _Check_return_ _ACRTIMP double __cdecl tgamma(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl trunc(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl _j0(_In_ double _X );
    _Check_return_ _ACRTIMP double __cdecl _j1(_In_ double _X );
    _Check_return_ _ACRTIMP double __cdecl _jn(int _X, _In_ double _Y);
    _Check_return_ _ACRTIMP double __cdecl _y0(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl _y1(_In_ double _X);
    _Check_return_ _ACRTIMP double __cdecl _yn(_In_ int _X, _In_ double _Y);

    _Check_return_ _ACRTIMP float     __cdecl acoshf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl asinhf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl atanhf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl cbrtf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl _chgsignf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl copysignf(_In_ float _Number, _In_ float _Sign);
    _Check_return_ _ACRTIMP float     __cdecl _copysignf(_In_ float _Number, _In_ float _Sign);
    _Check_return_ _ACRTIMP float     __cdecl erff(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl erfcf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl expm1f(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl exp2f(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl fdimf(_In_ float _X, _In_ float _Y);
    _Check_return_ _ACRTIMP float     __cdecl fmaf(_In_ float _X, _In_ float _Y, _In_ float _Z);
    _Check_return_ _ACRTIMP float     __cdecl fmaxf(_In_ float _X, _In_ float _Y);
    _Check_return_ _ACRTIMP float     __cdecl fminf(_In_ float _X, _In_ float _Y);
    _Check_return_ _ACRTIMP float     __cdecl _hypotf(_In_ float _X, _In_ float _Y);
    _Check_return_ _ACRTIMP int       __cdecl ilogbf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl lgammaf(_In_ float _X);
    _Check_return_ _ACRTIMP long long __cdecl llrintf(_In_ float _X);
    _Check_return_ _ACRTIMP long long __cdecl llroundf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl log1pf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl log2f(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl logbf(_In_ float _X);
    _Check_return_ _ACRTIMP long      __cdecl lrintf(_In_ float _X);
    _Check_return_ _ACRTIMP long      __cdecl lroundf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl nanf(_In_ char const* _X);
    _Check_return_ _ACRTIMP float     __cdecl nearbyintf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl nextafterf(_In_ float _X, _In_ float _Y);
    _Check_return_ _ACRTIMP float     __cdecl nexttowardf(_In_ float _X, _In_ long double _Y);
    _Check_return_ _ACRTIMP float     __cdecl remainderf(_In_ float _X, _In_ float _Y);
    _Check_return_ _ACRTIMP float     __cdecl remquof(_In_ float _X, _In_ float _Y, _Out_ int* _Z);
    _Check_return_ _ACRTIMP float     __cdecl rintf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl roundf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl scalblnf(_In_ float _X, _In_ long _Y);
    _Check_return_ _ACRTIMP float     __cdecl scalbnf(_In_ float _X, _In_ int _Y);
    _Check_return_ _ACRTIMP float     __cdecl tgammaf(_In_ float _X);
    _Check_return_ _ACRTIMP float     __cdecl truncf(_In_ float _X);

    #if defined _M_IX86

        _Check_return_ _ACRTIMP int  __cdecl _set_SSE2_enable(_In_ int _Flag);

    #endif
# 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

    #if defined _M_X64

        _Check_return_ _ACRTIMP float __cdecl _logbf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl _nextafterf(_In_ float _X, _In_ float _Y);
        _Check_return_ _ACRTIMP int   __cdecl _finitef(_In_ float _X);
        _Check_return_ _ACRTIMP int   __cdecl _isnanf(_In_ float _X);
        _Check_return_ _ACRTIMP int   __cdecl _fpclassf(_In_ float _X);

        _Check_return_ _ACRTIMP int   __cdecl _set_FMA3_enable(_In_ int _Flag);
        _Check_return_ _ACRTIMP int   __cdecl _get_FMA3_enable(void);

    #elif defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64
# 600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

        _Check_return_ _ACRTIMP int   __cdecl _finitef(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl _logbf(_In_ float _X);

    #endif
# 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3



    #if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _CORECRT_BUILD_APISET

        _Check_return_ _ACRTIMP float __cdecl acosf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl asinf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl atan2f(_In_ float _Y, _In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl atanf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl ceilf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl cosf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl coshf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl expf(_In_ float _X);

    #else
# 620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

        _Check_return_ __inline float __CRTDECL acosf(_In_ float _X)
        {
            return (float)acos(_X);
        }

        _Check_return_ __inline float __CRTDECL asinf(_In_ float _X)
        {
            return (float)asin(_X);
        }

        _Check_return_ __inline float __CRTDECL atan2f(_In_ float _Y, _In_ float _X)
        {
            return (float)atan2(_Y, _X);
        }

        _Check_return_ __inline float __CRTDECL atanf(_In_ float _X)
        {
            return (float)atan(_X);
        }

        _Check_return_ __inline float __CRTDECL ceilf(_In_ float _X)
        {
            return (float)ceil(_X);
        }

        _Check_return_ __inline float __CRTDECL cosf(_In_ float _X)
        {
            return (float)cos(_X);
        }

        _Check_return_ __inline float __CRTDECL coshf(_In_ float _X)
        {
            return (float)cosh(_X);
        }

        _Check_return_ __inline float __CRTDECL expf(_In_ float _X)
        {
            return (float)exp(_X);
        }

    #endif
# 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

    #if defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64

        _Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP float __cdecl fabsf(_In_ float  _X);

    #else
# 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

        _Check_return_ __inline float __CRTDECL fabsf(_In_ float _X)
        {
            return (float)fabs(_X);
        }

    #endif
# 675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

    #if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64

        _Check_return_ _ACRTIMP float __cdecl floorf(_In_ float _X);
        _Check_return_ _ACRTIMP float __cdecl fmodf(_In_ float _X, _In_ float _Y);

    #else
# 682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

        _Check_return_ __inline float __CRTDECL floorf(_In_ float _X)
        {
            return (float)floor(_X);
        }

        _Check_return_ __inline float __CRTDECL fmodf(_In_ float _X, _In_ float _Y)
        {
            return (float)fmod(_X, _Y);
        }

    #endif
# 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

    _Check_return_ __inline float __CRTDECL frexpf(_In_ float _X, _Out_ int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

    _Check_return_ __inline float __CRTDECL hypotf(_In_ float _X, _In_ float _Y)
    {
        return _hypotf(_X, _Y);
    }

    _Check_return_ __inline float __CRTDECL ldexpf(_In_ float _X, _In_ int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    #if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _CORECRT_BUILD_APISET

        _Check_return_ _ACRTIMP float  __cdecl log10f(_In_ float _X);
        _Check_return_ _ACRTIMP float  __cdecl logf(_In_ float _X);
        _Check_return_ _ACRTIMP float  __cdecl modff(_In_ float _X, _Out_ float *_Y);
        _Check_return_ _ACRTIMP float  __cdecl powf(_In_ float _X, _In_ float _Y);
        _Check_return_ _ACRTIMP float  __cdecl sinf(_In_ float _X);
        _Check_return_ _ACRTIMP float  __cdecl sinhf(_In_ float _X);
        _Check_return_ _ACRTIMP float  __cdecl sqrtf(_In_ float _X);
        _Check_return_ _ACRTIMP float  __cdecl tanf(_In_ float _X);
        _Check_return_ _ACRTIMP float  __cdecl tanhf(_In_ float _X);

    #else
# 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

        _Check_return_ __inline float __CRTDECL log10f(_In_ float _X)
        {
            return (float)log10(_X);
        }

        _Check_return_ __inline float __CRTDECL logf(_In_ float _X)
        {
            return (float)log(_X);
        }

        _Check_return_ __inline float __CRTDECL modff(_In_ float _X, _Out_ float* _Y)
        {
            double _F, _I;
            _F = modf(_X, &_I);
            *_Y = (float)_I;
            return (float)_F;
        }

        _Check_return_ __inline float __CRTDECL powf(_In_ float _X, _In_ float _Y)
        {
            return (float)pow(_X, _Y);
        }

        _Check_return_ __inline float __CRTDECL sinf(_In_ float _X)
        {
            return (float)sin(_X);
        }

        _Check_return_ __inline float __CRTDECL sinhf(_In_ float _X)
        {
            return (float)sinh(_X);
        }

        _Check_return_ __inline float __CRTDECL sqrtf(_In_ float _X)
        {
            return (float)sqrt(_X);
        }

        _Check_return_ __inline float __CRTDECL tanf(_In_ float _X)
        {
            return (float)tan(_X);
        }

        _Check_return_ __inline float __CRTDECL tanhf(_In_ float _X)
        {
            return (float)tanh(_X);
        }

    #endif
# 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

    _Check_return_ _ACRTIMP long double __cdecl acoshl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL acosl(_In_ long double _X)
    {
        return acos((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl asinhl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL asinl(_In_ long double _X)
    {
        return asin((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL atan2l(_In_ long double _Y, _In_ long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl atanhl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL atanl(_In_ long double _X)
    {
        return atan((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl cbrtl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL ceill(_In_ long double _X)
    {
        return ceil((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL _chgsignl(_In_ long double _X)
    {
        return _chgsign((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl copysignl(_In_ long double _Number, _In_ long double _Sign);

    _Check_return_ __inline long double __CRTDECL _copysignl(_In_ long double _Number, _In_ long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

    _Check_return_ __inline long double __CRTDECL coshl(_In_ long double _X)
    {
        return cosh((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL cosl(_In_ long double _X)
    {
        return cos((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl erfl(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl erfcl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL expl(_In_ long double _X)
    {
        return exp((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl exp2l(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl expm1l(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL fabsl(_In_ long double _X)
    {
        return fabs((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl fdiml(_In_ long double _X, _In_ long double _Y);

    _Check_return_ __inline long double __CRTDECL floorl(_In_ long double _X)
    {
        return floor((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl fmal(_In_ long double _X, _In_ long double _Y, _In_ long double _Z);
    _Check_return_ _ACRTIMP long double __cdecl fmaxl(_In_ long double _X, _In_ long double _Y);
    _Check_return_ _ACRTIMP long double __cdecl fminl(_In_ long double _X, _In_ long double _Y);

    _Check_return_ __inline long double __CRTDECL fmodl(_In_ long double _X, _In_ long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

    _Check_return_ __inline long double __CRTDECL frexpl(_In_ long double _X, _Out_ int *_Y)
    {
        return frexp((double)_X, _Y);
    }

    _Check_return_ _ACRTIMP int __cdecl ilogbl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL _hypotl(_In_ long double _X, _In_ long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

    _Check_return_ __inline long double __CRTDECL hypotl(_In_ long double _X, _In_ long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

    _Check_return_ __inline long double __CRTDECL ldexpl(_In_ long double _X, _In_ int _Y)
    {
        return ldexp((double)_X, _Y);
    }

    _Check_return_ _ACRTIMP long double __cdecl lgammal(_In_ long double _X);
    _Check_return_ _ACRTIMP long long __cdecl llrintl(_In_ long double _X);
    _Check_return_ _ACRTIMP long long __cdecl llroundl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL logl(_In_ long double _X)
    {
        return log((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL log10l(_In_ long double _X)
    {
        return log10((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl log1pl(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl log2l(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl logbl(_In_ long double _X);
    _Check_return_ _ACRTIMP long __cdecl lrintl(_In_ long double _X);
    _Check_return_ _ACRTIMP long __cdecl lroundl(_In_ long double _X);

    _Check_return_ __inline long double __CRTDECL modfl(_In_ long double _X, _Out_ long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

    _Check_return_ _ACRTIMP long double __cdecl nanl(_In_ char const* _X);
    _Check_return_ _ACRTIMP long double __cdecl nearbyintl(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl nextafterl(_In_ long double _X, _In_ long double _Y);
    _Check_return_ _ACRTIMP long double __cdecl nexttowardl(_In_ long double _X, _In_ long double _Y);

    _Check_return_ __inline long double __CRTDECL powl(_In_ long double _X, _In_ long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

    _Check_return_ _ACRTIMP long double __cdecl remainderl(_In_ long double _X, _In_ long double _Y);
    _Check_return_ _ACRTIMP long double __cdecl remquol(_In_ long double _X, _In_ long double _Y, _Out_ int* _Z);
    _Check_return_ _ACRTIMP long double __cdecl rintl(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl roundl(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl scalblnl(_In_ long double _X, _In_ long _Y);
    _Check_return_ _ACRTIMP long double __cdecl scalbnl(_In_ long double _X, _In_ int _Y);

    _Check_return_ __inline long double __CRTDECL sinhl(_In_ long double _X)
    {
        return sinh((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL sinl(_In_ long double _X)
    {
        return sin((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL sqrtl(_In_ long double _X)
    {
        return sqrt((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL tanhl(_In_ long double _X)
    {
        return tanh((double)_X);
    }

    _Check_return_ __inline long double __CRTDECL tanl(_In_ long double _X)
    {
        return tan((double)_X);
    }

    _Check_return_ _ACRTIMP long double __cdecl tgammal(_In_ long double _X);
    _Check_return_ _ACRTIMP long double __cdecl truncl(_In_ long double _X);

    #ifndef __cplusplus
        #define _matherrl _matherr
    #endif
# 959 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

#endif // _CRT_FUNCTIONS_REQUIRED
# 961 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

#if _CRT_INTERNAL_NONSTDC_NAMES

    #define DOMAIN      _DOMAIN
    #define SING        _SING
    #define OVERFLOW    _OVERFLOW
    #define UNDERFLOW   _UNDERFLOW
    #define TLOSS       _TLOSS
    #define PLOSS       _PLOSS

    #define matherr     _matherr

    #ifndef __assembler
        #ifndef _M_CEE_PURE
            extern double HUGE;
        #else
# 977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
            double const HUGE = _HUGE;
        #endif
# 979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

        _CRT_NONSTDC_DEPRECATE(_j0) _Check_return_ _ACRTIMP double __cdecl j0(_In_ double _X);
        _CRT_NONSTDC_DEPRECATE(_j1) _Check_return_ _ACRTIMP double __cdecl j1(_In_ double _X);
        _CRT_NONSTDC_DEPRECATE(_jn) _Check_return_ _ACRTIMP double __cdecl jn(_In_ int _X, _In_ double _Y);
        _CRT_NONSTDC_DEPRECATE(_y0) _Check_return_ _ACRTIMP double __cdecl y0(_In_ double _X);
        _CRT_NONSTDC_DEPRECATE(_y1) _Check_return_ _ACRTIMP double __cdecl y1(_In_ double _X);
        _CRT_NONSTDC_DEPRECATE(_yn) _Check_return_ _ACRTIMP double __cdecl yn(_In_ int _X, _In_ double _Y);
    #endif // !__assembler
# 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3


#pragma warning(pop)

_CRT_END_C_HEADER
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 2 3

#ifdef _USE_MATH_DEFINES
    #if 0 /* expanded by -frewrite-includes */
#include <corecrt_math_defines.h>
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 3
#endif
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 2 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

// <stdlib.h> has abs(long) and abs(long long)
_Check_return_ inline double abs(_In_ double _Xx) _NOEXCEPT
	{
	return (_CSTD fabs(_Xx));
	}

_Check_return_ inline float abs(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD fabsf(_Xx));
	}

_Check_return_ inline long double abs(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD fabsl(_Xx));
	}

_STD_BEGIN
using _CSTD size_t; using _CSTD div_t; using _CSTD ldiv_t;
using _CSTD abort; using _CSTD abs; using _CSTD atexit;
using _CSTD atof; using _CSTD atoi; using _CSTD atol;
using _CSTD bsearch; using _CSTD calloc; using _CSTD div;
using _CSTD exit; using _CSTD free;
using _CSTD labs; using _CSTD ldiv; using _CSTD malloc;
using _CSTD mblen; using _CSTD mbstowcs; using _CSTD mbtowc;
using _CSTD qsort; using _CSTD rand; using _CSTD realloc;
using _CSTD srand; using _CSTD strtod; using _CSTD strtol;
using _CSTD strtoul;
using _CSTD wcstombs; using _CSTD wctomb;

using _CSTD lldiv_t;

 #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
using _CSTD getenv;
using _CSTD system;
 #endif /* _CRT_USE_WINAPI_FAMILY_DESKTOP_APP */
# 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3

using _CSTD atoll; using _CSTD llabs; using _CSTD lldiv;
using _CSTD strtof; using _CSTD strtold;
using _CSTD strtoll; using _CSTD strtoull;

using _CSTD _Exit; using _CSTD at_quick_exit; using _CSTD quick_exit;
_STD_END

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)

#endif /* RC_INVOKED */
# 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3
#endif /* _CSTDLIB_ */
# 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdlib" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <limits>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 1 3
// limits standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
#ifndef _LIMITS_
#define _LIMITS_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <ymath.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 1 3
/* ymath.h internal header */
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3
#ifndef _YMATH
#define _YMATH
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3
 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")

  #undef new

 #if !defined(MRTDLL) || !defined(_CRTBLD)
 #ifndef _M_CEE_PURE
_EXTERN_C
 #endif /* _M_CEE_PURE */
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3
 #endif /* !MRTDLL || !_CRTBLD */
# 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT	0x20
#define _FE_INVALID	0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

void __CLRCALL_PURE_OR_CDECL _Feraise(int);

typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* double DECLARATIONS */
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Cosh(double, double);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dtest(double *);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Sinh(double, double);

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Exp(double *, double, short);
extern _CRTIMP2_PURE_IMPORT /* const */ _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FCosh(float, float);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDtest(float *);
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FSinh(float, float);

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FExp(float *, float, short);
extern _CRTIMP2_PURE_IMPORT /* const */ _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LCosh(long double, long double);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDtest(long double *);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LSinh(long double, long double);

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LExp(long double *, long double, short);
extern _CRTIMP2_PURE_IMPORT /* const */ _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 #if !defined(MRTDLL) || !defined(_CRTBLD)
 #ifndef _M_CEE_PURE
_END_EXTERN_C
 #endif /* _M_CEE_PURE */
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3
 #endif /* !MRTDLL || !_CRTBLD */
# 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3
#endif /* _YMATH */
# 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ymath.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cfloat>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 1 3
// cfloat standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 3
#ifndef _CFLOAT_
#define _CFLOAT_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 3

#if 0 /* expanded by -frewrite-includes */
#include <float.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 1 3
/*===---- float.h - Characteristics of floating point types ----------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __FLOAT_H
#define __FLOAT_H

/* If we're on MinGW, fall back to the system's float.h, which might have
 * additional definitions provided for Windows.
 * For more details see http://msdn.microsoft.com/en-us/library/y0ybw9fy.aspx
 *
 * Also fall back on Darwin to allow additional definitions and
 * implementation-defined values.
 */
#if (defined(__APPLE__) || (defined(__MINGW32__) || defined(_MSC_VER))) && \
    __STDC_HOSTED__ && (1)/*__has_include_next(<float.h>)*/

/* Prior to Apple's 10.7 SDK, float.h SDK header used to apply an extra level
 * of #include_next<float.h> to keep Metrowerks compilers happy. Avoid this
 * extra indirection.
 */
#ifdef __APPLE__
#define _FLOAT_H_
#endif
# 46 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3

#if 0 /* expanded by -frewrite-includes */
#  include_next <float.h>
#endif /* expanded by -frewrite-includes */
# 47 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 1 3
//
// float.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Implementation-defined values commonly used by sophisticated numerical
// (floating point) programs.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
#define _INC_FLOAT

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _CRT_MANAGED_FP_DEPRECATE
    #ifdef _CRT_MANAGED_FP_NO_DEPRECATE
        #define _CRT_MANAGED_FP_DEPRECATE
    #else
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
        #ifdef _M_CEE
            #define _CRT_MANAGED_FP_DEPRECATE _CRT_DEPRECATE_TEXT("Direct floating point control is not supported or reliable from within managed code. ")
        #else
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
            #define _CRT_MANAGED_FP_DEPRECATE
        #endif
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
    #endif
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
#endif
# 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3


// Define the floating point precision used.
//
// For x86, results are in double precision (unless /arch:sse2 is used, in which
// case results are in source precision.
//
// For x64 and ARM, results are in source precision.
//
// If the compiler is invoked with /fp:fast, the compiler is allowed to use the
// fastest precision and even mix within a single function, so precision is
// indeterminable.
//
// Note that manipulating the floating point behavior using the float_control/
// fenv_access/fp_contract #pragmas may alter the actual floating point evaluation
// method, which may in turn invalidate the value of FLT_EVAL_METHOD.
#ifdef _M_FP_FAST
    #define FLT_EVAL_METHOD -1
#else
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
    #ifdef _M_IX86
        #if _M_IX86_FP >= 2
            #define FLT_EVAL_METHOD 0
        #else
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
            #define FLT_EVAL_METHOD 2
        #endif
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
    #else
# 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
        #define FLT_EVAL_METHOD 0
    #endif
# 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
#endif
# 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Constants
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define DBL_DECIMAL_DIG  17                      // # of decimal digits of rounding precision
#define DBL_DIG          15                      // # of decimal digits of precision
#define DBL_EPSILON      2.2204460492503131e-016 // smallest such that 1.0+DBL_EPSILON != 1.0
#define DBL_HAS_SUBNORM  1                       // type does support subnormal numbers
#define DBL_MANT_DIG     53                      // # of bits in mantissa
#define DBL_MAX          1.7976931348623158e+308 // max value
#define DBL_MAX_10_EXP   308                     // max decimal exponent
#define DBL_MAX_EXP      1024                    // max binary exponent
#define DBL_MIN          2.2250738585072014e-308 // min positive value
#define DBL_MIN_10_EXP   (-307)                  // min decimal exponent
#define DBL_MIN_EXP      (-1021)                 // min binary exponent
#define _DBL_RADIX       2                       // exponent radix
#define DBL_TRUE_MIN     4.9406564584124654e-324 // min positive value

#define FLT_DECIMAL_DIG  9                       // # of decimal digits of rounding precision
#define FLT_DIG          6                       // # of decimal digits of precision
#define FLT_EPSILON      1.192092896e-07F        // smallest such that 1.0+FLT_EPSILON != 1.0
#define FLT_HAS_SUBNORM  1                       // type does support subnormal numbers
#define FLT_GUARD        0
#define FLT_MANT_DIG     24                      // # of bits in mantissa
#define FLT_MAX          3.402823466e+38F        // max value
#define FLT_MAX_10_EXP   38                      // max decimal exponent
#define FLT_MAX_EXP      128                     // max binary exponent
#define FLT_MIN          1.175494351e-38F        // min normalized positive value
#define FLT_MIN_10_EXP   (-37)                   // min decimal exponent
#define FLT_MIN_EXP      (-125)                  // min binary exponent
#define FLT_NORMALIZE    0
#define FLT_RADIX        2                       // exponent radix
#define FLT_TRUE_MIN     1.401298464e-45F        // min positive value

#define LDBL_DIG         DBL_DIG                 // # of decimal digits of precision
#define LDBL_EPSILON     DBL_EPSILON             // smallest such that 1.0+LDBL_EPSILON != 1.0
#define LDBL_HAS_SUBNORM DBL_HAS_SUBNORM         // type does support subnormal numbers
#define LDBL_MANT_DIG    DBL_MANT_DIG            // # of bits in mantissa
#define LDBL_MAX         DBL_MAX                 // max value
#define LDBL_MAX_10_EXP  DBL_MAX_10_EXP          // max decimal exponent
#define LDBL_MAX_EXP     DBL_MAX_EXP             // max binary exponent
#define LDBL_MIN         DBL_MIN                 // min normalized positive value
#define LDBL_MIN_10_EXP  DBL_MIN_10_EXP          // min decimal exponent
#define LDBL_MIN_EXP     DBL_MIN_EXP             // min binary exponent
#define _LDBL_RADIX      _DBL_RADIX              // exponent radix
#define LDBL_TRUE_MIN    DBL_TRUE_MIN            // min positive value

#define DECIMAL_DIG      DBL_DECIMAL_DIG



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define _SW_INEXACT     0x00000001              // Inexact (precision)
#define _SW_UNDERFLOW   0x00000002              // Underflow
#define _SW_OVERFLOW    0x00000004              // Overflow
#define _SW_ZERODIVIDE  0x00000008              // Divide by zero
#define _SW_INVALID     0x00000010              // Invalid
#define _SW_DENORMAL    0x00080000              // Denormal status bit

// New Control Bit that specifies the ambiguity in control word.
#define _EM_AMBIGUIOUS  0x80000000 // For backwards compatibility
#define _EM_AMBIGUOUS   0x80000000

// Abstract User Control Word Mask and bit definitions
#define _MCW_EM         0x0008001f              // Interrupt Exception Masks
#define _EM_INEXACT     0x00000001              //     inexact (precision)
#define _EM_UNDERFLOW   0x00000002              //     underflow
#define _EM_OVERFLOW    0x00000004              //     overflow
#define _EM_ZERODIVIDE  0x00000008              //     zero divide
#define _EM_INVALID     0x00000010              //     invalid
#define _EM_DENORMAL    0x00080000              // Denormal exception mask (_control87 only)

#define _MCW_RC         0x00000300              // Rounding Control
#define _RC_NEAR        0x00000000              //     near
#define _RC_DOWN        0x00000100              //     down
#define _RC_UP          0x00000200              //     up
#define _RC_CHOP        0x00000300              //     chop

// i386 specific definitions
#define _MCW_PC         0x00030000              // Precision Control
#define _PC_64          0x00000000              //     64 bits
#define _PC_53          0x00010000              //     53 bits
#define _PC_24          0x00020000              //     24 bits

#define _MCW_IC         0x00040000              // Infinity Control
#define _IC_AFFINE      0x00040000              //     affine
#define _IC_PROJECTIVE  0x00000000              //     projective

// RISC specific definitions
#define _MCW_DN         0x03000000              // Denormal Control
#define _DN_SAVE        0x00000000              //   save denormal results and operands
#define _DN_FLUSH       0x01000000              //   flush denormal results and operands to zero
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  // flush operands to zero and save results
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  // save operands and flush results to zero



// Invalid subconditions (_SW_INVALID also set)
#define _SW_UNEMULATED          0x0040  // Unemulated instruction
#define _SW_SQRTNEG             0x0080  // Square root of a negative number
#define _SW_STACKOVERFLOW       0x0200  // FP stack overflow
#define _SW_STACKUNDERFLOW      0x0400  // FP stack underflow



// Floating point error signals and return codes
#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c // raise(SIGFPE);

// On x86 with arch:SSE2, the OS returns these exceptions
#define _FPE_MULTIPLE_TRAPS     0x8d
#define _FPE_MULTIPLE_FAULTS    0x8e



#define _FPCLASS_SNAN  0x0001  // signaling NaN
#define _FPCLASS_QNAN  0x0002  // quiet NaN
#define _FPCLASS_NINF  0x0004  // negative infinity
#define _FPCLASS_NN    0x0008  // negative normal
#define _FPCLASS_ND    0x0010  // negative denormal
#define _FPCLASS_NZ    0x0020  // -0
#define _FPCLASS_PZ    0x0040  // +0
#define _FPCLASS_PD    0x0080  // positive denormal
#define _FPCLASS_PN    0x0100  // positive normal
#define _FPCLASS_PINF  0x0200  // positive infinity



// Initial Control Word value
#if defined _M_IX86

    #define _CW_DEFAULT (_RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif defined _M_X64 || defined _M_ARM || defined _M_ARM64
# 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3

    #define _CW_DEFAULT (_RC_NEAR + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#endif
# 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// State Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Note that reading or writing the floating point control or status words is
// not supported in managed code.
_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

_CRT_MANAGED_FP_DEPRECATE _CRT_INSECURE_DEPRECATE(_controlfp_s)
_ACRTIMP unsigned int __cdecl _controlfp(
    _In_ unsigned int _NewValue,
    _In_ unsigned int _Mask
    );

#pragma warning(pop)

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP void __cdecl _set_controlfp(
    _In_ unsigned int _NewValue,
    _In_ unsigned int _Mask
    );

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP errno_t __cdecl _controlfp_s(
    _Out_opt_ unsigned int* _CurrentState,
    _In_      unsigned int  _NewValue,
    _In_      unsigned int  _Mask
    );

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP unsigned int __cdecl _statusfp(void);

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP void __cdecl _fpreset(void);

#ifdef _M_IX86

    _CRT_MANAGED_FP_DEPRECATE
    _ACRTIMP void __cdecl _statusfp2(
        _Out_opt_ unsigned int* _X86Status,
        _Out_opt_ unsigned int* _SSE2Status
        );

#endif
# 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3

#define _clear87        _clearfp
#define _status87       _statusfp

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP unsigned int __cdecl _control87(
    _In_ unsigned int _NewValue,
    _In_ unsigned int _Mask
    );

#ifdef _M_IX86
    _CRT_MANAGED_FP_DEPRECATE
    _ACRTIMP int __cdecl __control87_2(
        _In_      unsigned int  _NewValue,
        _In_      unsigned int  _Mask,
        _Out_opt_ unsigned int* _X86ControlWord,
        _Out_opt_ unsigned int* _Sse2ControlWord
        );
#endif
# 286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3

// Global variable holding floating point error code
_Check_return_
_ACRTIMP int* __cdecl __fpecode(void);

#define _fpecode (*__fpecode())

_Check_return_
_ACRTIMP int __cdecl __fpe_flt_rounds(void);

#define FLT_ROUNDS   (__fpe_flt_rounds())
#define _DBL_ROUNDS  FLT_ROUNDS
#define _LDBL_ROUNDS _DBL_ROUNDS



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// IEEE Recommended Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _ACRTIMP double __cdecl _copysign(_In_ double _Number, _In_ double _Sign);
_Check_return_ _ACRTIMP double __cdecl _chgsign(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _scalb(_In_ double _X, _In_ long _Y);
_Check_return_ _ACRTIMP double __cdecl _logb(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _nextafter(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int    __cdecl _finite(_In_ double _X);
_Check_return_ _ACRTIMP int    __cdecl _isnan(_In_ double _X);
_Check_return_ _ACRTIMP int    __cdecl _fpclass(_In_ double _X);

#ifdef _M_X64
    _Check_return_ _ACRTIMP float __cdecl _scalbf(_In_ float _X, _In_ long _Y);
#endif
# 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Nonstandard Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if _CRT_INTERNAL_NONSTDC_NAMES

    #define clear87   _clear87
    #define status87  _status87
    #define control87 _control87

    _CRT_MANAGED_FP_DEPRECATE
    _ACRTIMP void __cdecl fpreset(void);

    #define DBL_RADIX          _DBL_RADIX
    #define DBL_ROUNDS         _DBL_ROUNDS

    #define LDBL_RADIX         _LDBL_RADIX
    #define LDBL_ROUNDS        _LDBL_ROUNDS

    // For backwards compatibility with the old spelling
    #define EM_AMBIGUIOUS      _EM_AMBIGUOUS
    #define EM_AMBIGUOUS       _EM_AMBIGUOUS

    #define MCW_EM             _MCW_EM
    #define EM_INVALID         _EM_INVALID
    #define EM_DENORMAL        _EM_DENORMAL
    #define EM_ZERODIVIDE      _EM_ZERODIVIDE
    #define EM_OVERFLOW        _EM_OVERFLOW
    #define EM_UNDERFLOW       _EM_UNDERFLOW
    #define EM_INEXACT         _EM_INEXACT

    #define MCW_IC             _MCW_IC
    #define IC_AFFINE          _IC_AFFINE
    #define IC_PROJECTIVE      _IC_PROJECTIVE

    #define MCW_RC             _MCW_RC
    #define RC_CHOP            _RC_CHOP
    #define RC_UP              _RC_UP
    #define RC_DOWN            _RC_DOWN
    #define RC_NEAR            _RC_NEAR

    #define MCW_PC             _MCW_PC
    #define PC_24              _PC_24
    #define PC_53              _PC_53
    #define PC_64              _PC_64

    #define CW_DEFAULT         _CW_DEFAULT

    #define SW_INVALID         _SW_INVALID
    #define SW_DENORMAL        _SW_DENORMAL
    #define SW_ZERODIVIDE      _SW_ZERODIVIDE
    #define SW_OVERFLOW        _SW_OVERFLOW
    #define SW_UNDERFLOW       _SW_UNDERFLOW
    #define SW_INEXACT         _SW_INEXACT

    #define SW_UNEMULATED      _SW_UNEMULATED
    #define SW_SQRTNEG         _SW_SQRTNEG
    #define SW_STACKOVERFLOW   _SW_STACKOVERFLOW
    #define SW_STACKUNDERFLOW  _SW_STACKUNDERFLOW

    #define FPE_INVALID        _FPE_INVALID
    #define FPE_DENORMAL       _FPE_DENORMAL
    #define FPE_ZERODIVIDE     _FPE_ZERODIVIDE
    #define FPE_OVERFLOW       _FPE_OVERFLOW
    #define FPE_UNDERFLOW      _FPE_UNDERFLOW
    #define FPE_INEXACT        _FPE_INEXACT

    #define FPE_UNEMULATED     _FPE_UNEMULATED
    #define FPE_SQRTNEG        _FPE_SQRTNEG
    #define FPE_STACKOVERFLOW  _FPE_STACKOVERFLOW
    #define FPE_STACKUNDERFLOW _FPE_STACKUNDERFLOW

    #define FPE_EXPLICITGEN    _FPE_EXPLICITGEN

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3



_CRT_END_C_HEADER
# 48 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 2 3

/* Undefine anything that we'll be redefining below. */
#  undef FLT_EVAL_METHOD
#  undef FLT_ROUNDS
#  undef FLT_RADIX
#  undef FLT_MANT_DIG
#  undef DBL_MANT_DIG
#  undef LDBL_MANT_DIG
#  if __STDC_VERSION__ >= 199901L || !defined(__STRICT_ANSI__)
#    undef DECIMAL_DIG
#  endif
# 59 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3
#  undef FLT_DIG
#  undef DBL_DIG
#  undef LDBL_DIG
#  undef FLT_MIN_EXP
#  undef DBL_MIN_EXP
#  undef LDBL_MIN_EXP
#  undef FLT_MIN_10_EXP
#  undef DBL_MIN_10_EXP
#  undef LDBL_MIN_10_EXP
#  undef FLT_MAX_EXP
#  undef DBL_MAX_EXP
#  undef LDBL_MAX_EXP
#  undef FLT_MAX_10_EXP
#  undef DBL_MAX_10_EXP
#  undef LDBL_MAX_10_EXP
#  undef FLT_MAX
#  undef DBL_MAX
#  undef LDBL_MAX
#  undef FLT_EPSILON
#  undef DBL_EPSILON
#  undef LDBL_EPSILON
#  undef FLT_MIN
#  undef DBL_MIN
#  undef LDBL_MIN
#  if __STDC_VERSION__ >= 201112L || !defined(__STRICT_ANSI__)
#    undef FLT_TRUE_MIN
#    undef DBL_TRUE_MIN
#    undef LDBL_TRUE_MIN
#    undef FLT_DECIMAL_DIG
#    undef DBL_DECIMAL_DIG
#    undef LDBL_DECIMAL_DIG
#  endif
# 91 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3
#endif
# 92 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3

/* Characteristics of floating point types, C99 5.2.4.2.2 */

#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
#define FLT_ROUNDS (__builtin_flt_rounds())
#define FLT_RADIX __FLT_RADIX__

#define FLT_MANT_DIG __FLT_MANT_DIG__
#define DBL_MANT_DIG __DBL_MANT_DIG__
#define LDBL_MANT_DIG __LDBL_MANT_DIG__

#if __STDC_VERSION__ >= 199901L || !defined(__STRICT_ANSI__)
#  define DECIMAL_DIG __DECIMAL_DIG__
#endif
# 106 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3

#define FLT_DIG __FLT_DIG__
#define DBL_DIG __DBL_DIG__
#define LDBL_DIG __LDBL_DIG__

#define FLT_MIN_EXP __FLT_MIN_EXP__
#define DBL_MIN_EXP __DBL_MIN_EXP__
#define LDBL_MIN_EXP __LDBL_MIN_EXP__

#define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
#define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
#define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__

#define FLT_MAX_EXP __FLT_MAX_EXP__
#define DBL_MAX_EXP __DBL_MAX_EXP__
#define LDBL_MAX_EXP __LDBL_MAX_EXP__

#define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
#define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
#define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__

#define FLT_MAX __FLT_MAX__
#define DBL_MAX __DBL_MAX__
#define LDBL_MAX __LDBL_MAX__

#define FLT_EPSILON __FLT_EPSILON__
#define DBL_EPSILON __DBL_EPSILON__
#define LDBL_EPSILON __LDBL_EPSILON__

#define FLT_MIN __FLT_MIN__
#define DBL_MIN __DBL_MIN__
#define LDBL_MIN __LDBL_MIN__

#if __STDC_VERSION__ >= 201112L || !defined(__STRICT_ANSI__)
#  define FLT_TRUE_MIN __FLT_DENORM_MIN__
#  define DBL_TRUE_MIN __DBL_DENORM_MIN__
#  define LDBL_TRUE_MIN __LDBL_DENORM_MIN__
#  define FLT_DECIMAL_DIG __FLT_DECIMAL_DIG__
#  define DBL_DECIMAL_DIG __DBL_DECIMAL_DIG__
#  define LDBL_DECIMAL_DIG __LDBL_DECIMAL_DIG__
#endif
# 147 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3

#ifdef __STDC_WANT_IEC_60559_TYPES_EXT__
#  define FLT16_MANT_DIG    __FLT16_MANT_DIG__
#  define FLT16_DECIMAL_DIG __FLT16_DECIMAL_DIG__
#  define FLT16_DIG         __FLT16_DIG__
#  define FLT16_MIN_EXP     __FLT16_MIN_EXP__
#  define FLT16_MIN_10_EXP  __FLT16_MIN_10_EXP__
#  define FLT16_MAX_EXP     __FLT16_MAX_EXP__
#  define FLT16_MAX_10_EXP  __FLT16_MAX_10_EXP__
#  define FLT16_MAX         __FLT16_MAX__
#  define FLT16_EPSILON     __FLT16_EPSILON__
#  define FLT16_MIN         __FLT16_MIN__
#  define FLT16_TRUE_MIN    __FLT16_TRUE_MIN__
#endif /* __STDC_WANT_IEC_60559_TYPES_EXT__ */
# 161 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3

#endif /* __FLOAT_H */
# 163 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\float.h" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 2 3
#endif /* _CFLOAT_ */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cfloat" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <climits>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 1 3
// climits standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 3
#ifndef _CLIMITS_
#define _CLIMITS_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 3

#if 0 /* expanded by -frewrite-includes */
#include <limits.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 3
#endif /* _CLIMITS_ */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\climits" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cmath>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 1 3
// cmath standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 3
#ifndef _CMATH_
#define _CMATH_
#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

_Check_return_ inline double pow(_In_ double _Xx, _In_ int _Yx) _NOEXCEPT
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (_CSTD pow(_Xx, static_cast<double>(_Yx)));
	}

_Check_return_ inline float acos(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD acosf(_Xx));
	}

_Check_return_ inline float acosh(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD acoshf(_Xx));
	}

_Check_return_ inline float asin(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD asinf(_Xx));
	}

_Check_return_ inline float asinh(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD asinhf(_Xx));
	}

_Check_return_ inline float atan(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD atanf(_Xx));
	}

_Check_return_ inline float atanh(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD atanhf(_Xx));
	}

_Check_return_ inline float atan2(_In_ float _Yx, _In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD atan2f(_Yx, _Xx));
	}

_Check_return_ inline float cbrt(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD cbrtf(_Xx));
	}

_Check_return_ inline float ceil(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD ceilf(_Xx));
	}

_Check_return_ inline float copysign(_In_ float _Number,
	_In_ float _Sign) _NOEXCEPT
	{
	return (_CSTD copysignf(_Number, _Sign));
	}

_Check_return_ inline float cos(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD cosf(_Xx));
	}

_Check_return_ inline float cosh(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD coshf(_Xx));
	}

_Check_return_ inline float erf(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD erff(_Xx));
	}

_Check_return_ inline float erfc(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD erfcf(_Xx));
	}

_Check_return_ inline float exp(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD expf(_Xx));
	}

_Check_return_ inline float exp2(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD exp2f(_Xx));
	}

_Check_return_ inline float expm1(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD expm1f(_Xx));
	}

_Check_return_ inline float fabs(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD fabsf(_Xx));
	}

_Check_return_ inline float fdim(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD fdimf(_Xx, _Yx));
	}

_Check_return_ inline float floor(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD floorf(_Xx));
	}

_Check_return_ inline float fma(_In_ float _Xx, _In_ float _Yx,
	_In_ float _Zx) _NOEXCEPT
	{
	return (_CSTD fmaf(_Xx, _Yx, _Zx));
	}

_Check_return_ inline float fmax(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD fmaxf(_Xx, _Yx));
	}

_Check_return_ inline float fmin(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD fminf(_Xx, _Yx));
	}

_Check_return_ inline float fmod(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD fmodf(_Xx, _Yx));
	}

_Check_return_ inline float frexp(_In_ float _Xx, _Out_ int* _Yx) _NOEXCEPT
	{
	return (_CSTD frexpf(_Xx, _Yx));
	}

_Check_return_ inline float hypot(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD hypotf(_Xx, _Yx));
	}

_Check_return_ inline int ilogb(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD ilogbf(_Xx));
	}

_Check_return_ inline float ldexp(_In_ float _Xx, _In_ int _Yx) _NOEXCEPT
	{
	return (_CSTD ldexpf(_Xx, _Yx));
	}

_Check_return_ inline float lgamma(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD lgammaf(_Xx));
	}

_Check_return_ inline long long llrint(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD llrintf(_Xx));
	}

_Check_return_ inline long long llround(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD llroundf(_Xx));
	}

_Check_return_ inline float log(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD logf(_Xx));
	}

_Check_return_ inline float log10(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD log10f(_Xx));
	}

_Check_return_ inline float log1p(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD log1pf(_Xx));
	}

_Check_return_ inline float log2(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD log2f(_Xx));
	}

_Check_return_ inline float logb(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD logbf(_Xx));
	}

_Check_return_ inline long lrint(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD lrintf(_Xx));
	}

_Check_return_ inline long lround(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD lroundf(_Xx));
	}

_Check_return_ inline float modf(_In_ float _Xx, _Out_ float* _Yx) _NOEXCEPT
	{
	return (_CSTD modff(_Xx, _Yx));
	}

_Check_return_ inline float nearbyint(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD nearbyintf(_Xx));
	}

_Check_return_ inline float nextafter(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD nextafterf(_Xx, _Yx));
	}

_Check_return_ inline float nexttoward(_In_ float _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD nexttowardf(_Xx, _Yx));
	}

_Check_return_ inline float pow(_In_ float _Xx,
	_In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD powf(_Xx, _Yx));
	}

_Check_return_ inline float pow(_In_ float _Xx, _In_ int _Yx) _NOEXCEPT
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (_CSTD powf(_Xx, static_cast<float>(_Yx)));
	}

_Check_return_ inline float remainder(_In_ float _Xx, _In_ float _Yx) _NOEXCEPT
	{
	return (_CSTD remainderf(_Xx, _Yx));
	}

_Check_return_ inline float remquo(_In_ float _Xx, _In_ float _Yx,
	_Out_ int *_Zx) _NOEXCEPT
	{
	return (_CSTD remquof(_Xx, _Yx, _Zx));
	}

_Check_return_ inline float rint(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD rintf(_Xx));
	}

_Check_return_ inline float round(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD roundf(_Xx));
	}

_Check_return_ inline float scalbln(_In_ float _Xx, _In_ long _Yx) _NOEXCEPT
	{
	return (_CSTD scalblnf(_Xx, _Yx));
	}

_Check_return_ inline float scalbn(_In_ float _Xx, _In_ int _Yx) _NOEXCEPT
	{
	return (_CSTD scalbnf(_Xx, _Yx));
	}

_Check_return_ inline float sin(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD sinf(_Xx));
	}

_Check_return_ inline float sinh(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD sinhf(_Xx));
	}

_Check_return_ inline float sqrt(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD sqrtf(_Xx));
	}

_Check_return_ inline float tan(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD tanf(_Xx));
	}

_Check_return_ inline float tanh(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD tanhf(_Xx));
	}

_Check_return_ inline float tgamma(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD tgammaf(_Xx));
	}

_Check_return_ inline float trunc(_In_ float _Xx) _NOEXCEPT
	{
	return (_CSTD truncf(_Xx));
	}

_Check_return_ inline long double acos(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD acosl(_Xx));
	}

_Check_return_ inline long double acosh(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD acoshl(_Xx));
	}

_Check_return_ inline long double asin(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD asinl(_Xx));
	}

_Check_return_ inline long double asinh(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD asinhl(_Xx));
	}

_Check_return_ inline long double atan(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD atanl(_Xx));
	}

_Check_return_ inline long double atanh(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD atanhl(_Xx));
	}

_Check_return_ inline long double atan2(_In_ long double _Yx,
	_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD atan2l(_Yx, _Xx));
	}

_Check_return_ inline long double cbrt(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD cbrtl(_Xx));
	}

_Check_return_ inline long double ceil(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD ceill(_Xx));
	}

_Check_return_ inline long double copysign(_In_ long double _Number,
	_In_ long double _Sign) _NOEXCEPT
	{
	return (_CSTD copysignl(_Number, _Sign));
	}

_Check_return_ inline long double cos(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD cosl(_Xx));
	}

_Check_return_ inline long double cosh(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD coshl(_Xx));
	}

_Check_return_ inline long double erf(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD erfl(_Xx));
	}

_Check_return_ inline long double erfc(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD erfcl(_Xx));
	}

_Check_return_ inline long double exp(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD expl(_Xx));
	}

_Check_return_ inline long double exp2(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD exp2l(_Xx));
	}

_Check_return_ inline long double expm1(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD expm1l(_Xx));
	}

_Check_return_ inline long double fabs(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD fabsl(_Xx));
	}

_Check_return_ inline long double fdim(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD fdiml(_Xx, _Yx));
	}

_Check_return_ inline long double floor(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD floorl(_Xx));
	}

_Check_return_ inline long double fma(_In_ long double _Xx,
	_In_ long double _Yx, _In_ long double _Zx) _NOEXCEPT
	{
	return (_CSTD fmal(_Xx, _Yx, _Zx));
	}

_Check_return_ inline long double fmax(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD fmaxl(_Xx, _Yx));
	}

_Check_return_ inline long double fmin(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD fminl(_Xx, _Yx));
	}

_Check_return_ inline long double fmod(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD fmodl(_Xx, _Yx));
	}

_Check_return_ inline long double frexp(_In_ long double _Xx,
	_Out_ int* _Yx) _NOEXCEPT
	{
	return (_CSTD frexpl(_Xx, _Yx));
	}

_Check_return_ inline long double hypot(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD hypotl(_Xx, _Yx));
	}

_Check_return_ inline int ilogb(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD ilogbl(_Xx));
	}

_Check_return_ inline long double ldexp(_In_ long double _Xx,
	_In_ int _Yx) _NOEXCEPT
	{
	return (_CSTD ldexpl(_Xx, _Yx));
	}

_Check_return_ inline long double lgamma(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD lgammal(_Xx));
	}

_Check_return_ inline long long llrint(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD llrintl(_Xx));
	}

_Check_return_ inline long long llround(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD llroundl(_Xx));
	}

_Check_return_ inline long double log(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD logl(_Xx));
	}

_Check_return_ inline long double log10(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD log10l(_Xx));
	}

_Check_return_ inline long double log1p(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD log1pl(_Xx));
	}

_Check_return_ inline long double log2(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD log2l(_Xx));
	}

_Check_return_ inline long double logb(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD logbl(_Xx));
	}

_Check_return_ inline long lrint(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD lrintl(_Xx));
	}

_Check_return_ inline long lround(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD lroundl(_Xx));
	}

_Check_return_ inline long double modf(_In_ long double _Xx,
	_Out_ long double* _Yx) _NOEXCEPT
	{
	return (_CSTD modfl(_Xx, _Yx));
	}

_Check_return_ inline long double nearbyint(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD nearbyintl(_Xx));
	}

_Check_return_ inline long double nextafter(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD nextafterl(_Xx, _Yx));
	}

_Check_return_ inline long double nexttoward(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD nexttowardl(_Xx, _Yx));
	}

_Check_return_ inline long double pow(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD powl(_Xx, _Yx));
	}

_Check_return_ inline long double pow(_In_ long double _Xx,
	_In_ int _Yx) _NOEXCEPT
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (_CSTD powl(_Xx, static_cast<long double>(_Yx)));
	}

_Check_return_ inline long double remainder(_In_ long double _Xx,
	_In_ long double _Yx) _NOEXCEPT
	{
	return (_CSTD remainderl(_Xx, _Yx));
	}

_Check_return_ inline long double remquo(_In_ long double _Xx,
	_In_ long double _Yx, _Out_ int *_Zx) _NOEXCEPT
	{
	return (_CSTD remquol(_Xx, _Yx, _Zx));
	}

_Check_return_ inline long double rint(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD rintl(_Xx));
	}

_Check_return_ inline long double round(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD roundl(_Xx));
	}

_Check_return_ inline long double scalbln(_In_ long double _Xx,
	_In_ long _Yx) _NOEXCEPT
	{
	return (_CSTD scalblnl(_Xx, _Yx));
	}

_Check_return_ inline long double scalbn(_In_ long double _Xx,
	_In_ int _Yx) _NOEXCEPT
	{
	return (_CSTD scalbnl(_Xx, _Yx));
	}

_Check_return_ inline long double sin(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD sinl(_Xx));
	}

_Check_return_ inline long double sinh(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD sinhl(_Xx));
	}

_Check_return_ inline long double sqrt(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD sqrtl(_Xx));
	}

_Check_return_ inline long double tan(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD tanl(_Xx));
	}

_Check_return_ inline long double tanh(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD tanhl(_Xx));
	}

_Check_return_ inline long double tgamma(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD tgammal(_Xx));
	}

_Check_return_ inline long double trunc(_In_ long double _Xx) _NOEXCEPT
	{
	return (_CSTD truncl(_Xx));
	}

#if 0 /* expanded by -frewrite-includes */
#include <xtgmath.h>
#endif /* expanded by -frewrite-includes */
# 623 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 1 3
/* xtgmath.h internal header */

 #if defined(__cplusplus)
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3
#ifndef _XTGMATH
#define _XTGMATH
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <xtr1common>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 1 3
// xtr1common internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 3
#ifndef _XTR1COMMON_
#define _XTR1COMMON_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
	// STRUCT TEMPLATE integral_constant
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	// convenient template for integral constant types
	static constexpr _Ty value = _Val;

	using value_type = _Ty;
	using type = integral_constant;

	constexpr operator value_type() const _NOEXCEPT
		{	// return stored value
		return (value);
		}

	constexpr value_type operator()() const _NOEXCEPT
		{	// return stored value
		return (value);
		}
	};

	// ALIAS TEMPLATE bool_constant
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

	// STRUCT TEMPLATE enable_if
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	// type is undefined for assumed !_Test
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	// type is _Ty for _Test
	using type = _Ty;
	};

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

	// STRUCT TEMPLATE conditional
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	// type is _Ty2 for assumed !_Test
	using type = _Ty2;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	// type is _Ty1 for _Test
	using type = _Ty1;
	};

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

	// STRUCT TEMPLATE is_same
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	// determine whether _Ty1 and _Ty2 are the same type
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	// determine whether _Ty1 and _Ty2 are the same type
	};

template<class _Ty,
	class _Uty>
	_INLINE_VAR constexpr bool is_same_v = is_same<_Ty, _Uty>::value;

	// STRUCT TEMPLATE remove_const
template<class _Ty>
	struct remove_const
	{	// remove top level const qualifier
	using type = _Ty;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	// remove top level const qualifier
	using type = _Ty;
	};

template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

	// STRUCT TEMPLATE remove_volatile
template<class _Ty>
	struct remove_volatile
	{	// remove top level volatile qualifier
	using type = _Ty;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	// remove top level volatile qualifier
	using type = _Ty;
	};

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

	// STRUCT TEMPLATE remove_cv
template<class _Ty>
	struct remove_cv
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	struct remove_cv<const _Ty>
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	struct remove_cv<volatile _Ty>
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	struct remove_cv<const volatile _Ty>
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

	// STRUCT TEMPLATE _Is_integral
template<class _Ty>
	struct _Is_integral
		: false_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	// determine whether _Ty is integral
	};

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	// determine whether _Ty is integral
	};
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 3

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<short>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<int>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<long>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned long long>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<long long>
		: true_type
	{	// determine whether _Ty is integral
	};

	// STRUCT TEMPLATE is_integral
template<class _Ty>
	struct is_integral
		: _Is_integral<remove_cv_t<_Ty>>::type
	{	// determine whether _Ty is integral
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_integral_v = is_integral<_Ty>::value;

	// STRUCT TEMPLATE _Is_floating_point
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	// determine whether _Ty is floating point
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	// determine whether _Ty is floating point
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	// determine whether _Ty is floating point
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	// determine whether _Ty is floating point
	};

	// STRUCT TEMPLATE is_floating_point
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<remove_cv_t<_Ty>>::type
	{	// determine whether _Ty is floating point
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;

	// STRUCT TEMPLATE is_arithmetic
template<class _Ty>
	struct is_arithmetic
		: bool_constant<is_integral_v<_Ty>
			|| is_floating_point_v<_Ty>>
	{	// determine whether _Ty is an arithmetic type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;

	// STRUCT TEMPLATE remove_reference
template<class _Ty>
	struct remove_reference
	{	// remove reference
	using type = _Ty;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	// remove reference
	using type = _Ty;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	// remove rvalue reference
	using type = _Ty;
	};

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 341 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 3
#endif /* _XTR1COMMON_ */
# 342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtr1common" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
template<class _Ty1,
	class _Ty2>
	using _Common_float_type_t =
		conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
		conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
		double>>;	// find type for two-argument math function
_STD_END

#define _CRTDEFAULT
#define _CRTSPECIAL	_ACRTIMP

#define _GENERIC_MATH1R(FUN, RET, CRTTYPE) \
extern "C" _Check_return_ CRTTYPE RET __cdecl FUN(_In_ double); \
template<class _Ty, \
	class = _STD enable_if_t<_STD is_integral_v<_Ty>>> inline \
	RET FUN(_Ty _Left) \
	{ \
	return (_CSTD FUN(static_cast<double>(_Left))); \
	}

#define _GENERIC_MATH1(FUN, CRTTYPE) \
	_GENERIC_MATH1R(FUN, double, CRTTYPE)

#define _GENERIC_MATH1X(FUN, ARG2, CRTTYPE) \
extern "C" _Check_return_ CRTTYPE double __cdecl FUN(_In_ double, ARG2); \
template<class _Ty, \
	class = _STD enable_if_t<_STD is_integral_v<_Ty>>> inline \
	double FUN(_Ty _Left, ARG2 _Arg2) \
	{ \
	return (_CSTD FUN(static_cast<double>(_Left), _Arg2)); \
	}

#define _GENERIC_MATH2_CALL(FUN, CRTTYPE, CALL_OPT) \
extern "C" _Check_return_ CRTTYPE double CALL_OPT FUN(_In_ double, _In_ double); \
template<class _Ty1, \
	class _Ty2, \
	class = _STD enable_if_t<_STD is_arithmetic_v<_Ty1> && _STD is_arithmetic_v<_Ty2>>> inline \
	_STD _Common_float_type_t<_Ty1, _Ty2> FUN(_Ty1 _Left, _Ty2 _Right) \
	{ \
	typedef _STD _Common_float_type_t<_Ty1, _Ty2> type; \
	return (_CSTD FUN(static_cast<type>(_Left), static_cast<type>(_Right))); \
	}

#define _GENERIC_MATH2(FUN, CRTTYPE) \
	_GENERIC_MATH2_CALL(FUN, CRTTYPE, __cdecl)

template<class _Ty1,
	class _Ty2,
	class = _STD enable_if_t<_STD is_arithmetic_v<_Ty1> && _STD is_arithmetic_v<_Ty2>>> inline
	_STD _Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right)
	{	// bring mixed types to a common type
	typedef _STD _Common_float_type_t<_Ty1, _Ty2> type;
	return (_CSTD pow(static_cast<type>(_Left), static_cast<type>(_Right)));
	}

//_GENERIC_MATH1(abs, _CRTDEFAULT)	// has integer overloads
_GENERIC_MATH1(acos, _CRTDEFAULT)
_GENERIC_MATH1(asin, _CRTDEFAULT)
_GENERIC_MATH1(atan, _CRTDEFAULT)
_GENERIC_MATH2(atan2, _CRTDEFAULT)
_GENERIC_MATH1(ceil, _CRTSPECIAL)
_GENERIC_MATH1(cos, _CRTDEFAULT)
_GENERIC_MATH1(cosh, _CRTDEFAULT)
_GENERIC_MATH1(exp, _CRTDEFAULT)

_GENERIC_MATH1(fabs, _CRT_JIT_INTRINSIC)

_GENERIC_MATH1(floor, _CRTSPECIAL)
_GENERIC_MATH2(fmod, _CRTDEFAULT)
_GENERIC_MATH1X(frexp, _Out_ int *, _CRTSPECIAL)
_GENERIC_MATH1X(ldexp, _In_ int, _CRTSPECIAL)
_GENERIC_MATH1(log, _CRTDEFAULT)
_GENERIC_MATH1(log10, _CRTDEFAULT)
//_GENERIC_MATH1(modf, _CRTDEFAULT)		// types must match
//_GENERIC_MATH2(pow, _CRTDEFAULT)	// hand crafted
_GENERIC_MATH1(sin, _CRTDEFAULT)
_GENERIC_MATH1(sinh, _CRTDEFAULT)
_GENERIC_MATH1(sqrt, _CRTDEFAULT)
_GENERIC_MATH1(tan, _CRTDEFAULT)
_GENERIC_MATH1(tanh, _CRTDEFAULT)

		// C99 MATH FUNCTIONS

		// FUNCTION TEMPLATE fma

inline float _Fma(float _Left, float _Middle, float _Right)
	{	// call float fma
	return (_CSTD fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	// call double fma
	return (_CSTD fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	// call long double fma
	return (_CSTD fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	_STD _Common_float_type_t<_Ty1, _STD _Common_float_type_t<_Ty2, _Ty3>>
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	// bring mixed types to a common type
	typedef _STD _Common_float_type_t<_Ty1, _STD _Common_float_type_t<_Ty2, _Ty3>> type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		// FUNCTION TEMPLATE remquo

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	// call float remquo
	return (_CSTD remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	// call double remquo
	return (_CSTD remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	// call long double remquo
	return (_CSTD remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	_STD _Common_float_type_t<_Ty1, _Ty2>
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	// bring mixed types to a common type
	typedef _STD _Common_float_type_t<_Ty1, _Ty2> type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

_GENERIC_MATH1(acosh, _CRTSPECIAL)
_GENERIC_MATH1(asinh, _CRTSPECIAL)
_GENERIC_MATH1(atanh, _CRTSPECIAL)
_GENERIC_MATH1(cbrt, _CRTSPECIAL)
_GENERIC_MATH2(copysign, _CRTSPECIAL)
_GENERIC_MATH1(erf, _CRTSPECIAL)
_GENERIC_MATH1(erfc, _CRTSPECIAL)
_GENERIC_MATH1(expm1, _CRTSPECIAL)
_GENERIC_MATH1(exp2, _CRTSPECIAL)
_GENERIC_MATH2(fdim, _CRTSPECIAL)
//_GENERIC_MATH3(fma, _CRTSPECIAL)	// hand crafted
_GENERIC_MATH2(fmax, _CRTSPECIAL)
_GENERIC_MATH2(fmin, _CRTSPECIAL)
_GENERIC_MATH2(hypot, _CRTSPECIAL)
_GENERIC_MATH1R(ilogb, int, _CRTSPECIAL)
_GENERIC_MATH1(lgamma, _CRTSPECIAL)
_GENERIC_MATH1R(llrint, long long, _CRTSPECIAL)
_GENERIC_MATH1R(llround, long long, _CRTSPECIAL)
_GENERIC_MATH1(log1p, _CRTSPECIAL)
_GENERIC_MATH1(log2, _CRTSPECIAL)
_GENERIC_MATH1(logb, _CRTSPECIAL)
_GENERIC_MATH1R(lrint, long, _CRTSPECIAL)
_GENERIC_MATH1R(lround, long, _CRTSPECIAL)
_GENERIC_MATH1(nearbyint, _CRTSPECIAL)
_GENERIC_MATH2(nextafter, _CRTSPECIAL)
_GENERIC_MATH1X(nexttoward, _In_ long double, _CRTSPECIAL)
_GENERIC_MATH2(remainder, _CRTSPECIAL)
//_GENERIC_MATH2X(remquo, _CRTSPECIAL)	// hand crafted
_GENERIC_MATH1(rint, _CRTSPECIAL)
_GENERIC_MATH1(round, _CRTSPECIAL)
_GENERIC_MATH1X(scalbln, _In_ long, _CRTSPECIAL)
_GENERIC_MATH1X(scalbn, _In_ int, _CRTSPECIAL)
_GENERIC_MATH1(tgamma, _CRTSPECIAL)
_GENERIC_MATH1(trunc, _CRTSPECIAL)

#undef _CRTDEFAULT
#undef _CRTSPECIAL
#undef _GENERIC_MATH1R
#undef _GENERIC_MATH1
#undef _GENERIC_MATH1X
#undef _GENERIC_MATH2_CALL
#undef _GENERIC_MATH2

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3
#endif /* _XTGMATH */
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3
 #endif /* defined(__cplusplus) */
# 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xtgmath.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 2 3

_STD_BEGIN
using _CSTD abs; using _CSTD acos; using _CSTD asin;
using _CSTD atan; using _CSTD atan2; using _CSTD ceil;
using _CSTD cos; using _CSTD cosh; using _CSTD exp;
using _CSTD fabs; using _CSTD floor; using _CSTD fmod;
using _CSTD frexp; using _CSTD ldexp; using _CSTD log;
using _CSTD log10; using _CSTD modf; using _CSTD pow;
using _CSTD sin; using _CSTD sinh; using _CSTD sqrt;
using _CSTD tan; using _CSTD tanh;

using _CSTD acosf; using _CSTD asinf;
using _CSTD atanf; using _CSTD atan2f; using _CSTD ceilf;
using _CSTD cosf; using _CSTD coshf; using _CSTD expf;
using _CSTD fabsf; using _CSTD floorf; using _CSTD fmodf;
using _CSTD frexpf; using _CSTD ldexpf; using _CSTD logf;
using _CSTD log10f; using _CSTD modff; using _CSTD powf;
using _CSTD sinf; using _CSTD sinhf; using _CSTD sqrtf;
using _CSTD tanf; using _CSTD tanhf;

using _CSTD acosl; using _CSTD asinl;
using _CSTD atanl; using _CSTD atan2l; using _CSTD ceill;
using _CSTD cosl; using _CSTD coshl; using _CSTD expl;
using _CSTD fabsl; using _CSTD floorl; using _CSTD fmodl;
using _CSTD frexpl; using _CSTD ldexpl; using _CSTD logl;
using _CSTD log10l; using _CSTD modfl; using _CSTD powl;
using _CSTD sinl; using _CSTD sinhl; using _CSTD sqrtl;
using _CSTD tanl; using _CSTD tanhl;

using _CSTD float_t; using _CSTD double_t;

using _CSTD acosh; using _CSTD asinh; using _CSTD atanh;
using _CSTD cbrt; using _CSTD erf; using _CSTD erfc;
using _CSTD expm1; using _CSTD exp2;
using _CSTD hypot; using _CSTD ilogb; using _CSTD lgamma;
using _CSTD log1p; using _CSTD log2; using _CSTD logb;
using _CSTD llrint; using _CSTD lrint; using _CSTD nearbyint;
using _CSTD rint; using _CSTD llround; using _CSTD lround;
using _CSTD fdim; using _CSTD fma; using _CSTD fmax; using _CSTD fmin;
using _CSTD round; using _CSTD trunc;
using _CSTD remainder; using _CSTD remquo;
using _CSTD copysign; using _CSTD nan; using _CSTD nextafter;
using _CSTD scalbn; using _CSTD scalbln;
using _CSTD nexttoward; using _CSTD tgamma;

using _CSTD acoshf; using _CSTD asinhf; using _CSTD atanhf;
using _CSTD cbrtf; using _CSTD erff; using _CSTD erfcf;
using _CSTD expm1f; using _CSTD exp2f;
using _CSTD hypotf; using _CSTD ilogbf; using _CSTD lgammaf;
using _CSTD log1pf; using _CSTD log2f; using _CSTD logbf;
using _CSTD llrintf; using _CSTD lrintf; using _CSTD nearbyintf;
using _CSTD rintf; using _CSTD llroundf; using _CSTD lroundf;
using _CSTD fdimf; using _CSTD fmaf; using _CSTD fmaxf; using _CSTD fminf;
using _CSTD roundf; using _CSTD truncf;
using _CSTD remainderf; using _CSTD remquof;
using _CSTD copysignf; using _CSTD nanf;
using _CSTD nextafterf; using _CSTD scalbnf; using _CSTD scalblnf;
using _CSTD nexttowardf; using _CSTD tgammaf;

using _CSTD acoshl; using _CSTD asinhl; using _CSTD atanhl;
using _CSTD cbrtl; using _CSTD erfl; using _CSTD erfcl;
using _CSTD expm1l; using _CSTD exp2l;
using _CSTD hypotl; using _CSTD ilogbl; using _CSTD lgammal;
using _CSTD log1pl; using _CSTD log2l; using _CSTD logbl;
using _CSTD llrintl; using _CSTD lrintl; using _CSTD nearbyintl;
using _CSTD rintl; using _CSTD llroundl; using _CSTD lroundl;
using _CSTD fdiml; using _CSTD fmal; using _CSTD fmaxl; using _CSTD fminl;
using _CSTD roundl; using _CSTD truncl;
using _CSTD remainderl; using _CSTD remquol;
using _CSTD copysignl; using _CSTD nanl;
using _CSTD nextafterl; using _CSTD scalbnl; using _CSTD scalblnl;
using _CSTD nexttowardl; using _CSTD tgammal;

using _CSTD fpclassify; using _CSTD signbit;
using _CSTD isfinite; using _CSTD isinf;
using _CSTD isnan; using _CSTD isnormal;
using _CSTD isgreater; using _CSTD isgreaterequal;
using _CSTD isless; using _CSTD islessequal;
using _CSTD islessgreater; using _CSTD isunordered;
_STD_END

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)

#endif /* RC_INVOKED */
# 710 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 3
#endif /* _CMATH_ */
# 711 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cmath" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cwchar>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 1 3
// cwchar standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 3
#ifndef _CWCHAR_
#define _CWCHAR_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 3
#if 0 /* expanded by -frewrite-includes */
#include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 1 3
//
// wchar.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// All of the types, macros, and function declarations for all wide-character
// related functionality.  Most of the functionality is in the #included
// <corecrt_wxxxx.h> headers, which are also #included by other public headers.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
#define _INC_WCHAR

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_memcpy_s.h>
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 1 3
//
// corecrt_memcpy_s.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Inline definitions of memcpy_s and memmove_s
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <errno.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 1 3
//
// errno.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// System error numbers for use with errno and errno_t.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3
#define _INC_ERRNO

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3

_CRT_BEGIN_C_HEADER



#if _CRT_FUNCTIONS_REQUIRED
    _ACRTIMP int* __cdecl _errno(void);
    #define errno (*_errno())

    _ACRTIMP errno_t __cdecl _set_errno(_In_ int _Value);
    _ACRTIMP errno_t __cdecl _get_errno(_Out_ int* _Value);

    _ACRTIMP unsigned long* __cdecl __doserrno(void);
    #define _doserrno (*__doserrno())

    _ACRTIMP errno_t __cdecl _set_doserrno(_In_ unsigned long _Value);
    _ACRTIMP errno_t __cdecl _get_doserrno(_Out_ unsigned long * _Value);
#endif // _CRT_FUNCTIONS_REQUIRED
# 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3



// Error codes
#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41

// Error codes used in the Secure CRT functions
#ifndef RC_INVOKED
    #define _SECURECRT_ERRCODE_VALUES_DEFINED
    #define EINVAL          22
    #define ERANGE          34
    #define EILSEQ          42
    #define STRUNCATE       80
#endif
# 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3

// Support EDEADLOCK for compatibility with older Microsoft C versions
#define EDEADLOCK       EDEADLK

// POSIX Supplement
#ifndef _CRT_NO_POSIX_ERROR_CODES
    #define EADDRINUSE      100
    #define EADDRNOTAVAIL   101
    #define EAFNOSUPPORT    102
    #define EALREADY        103
    #define EBADMSG         104
    #define ECANCELED       105
    #define ECONNABORTED    106
    #define ECONNREFUSED    107
    #define ECONNRESET      108
    #define EDESTADDRREQ    109
    #define EHOSTUNREACH    110
    #define EIDRM           111
    #define EINPROGRESS     112
    #define EISCONN         113
    #define ELOOP           114
    #define EMSGSIZE        115
    #define ENETDOWN        116
    #define ENETRESET       117
    #define ENETUNREACH     118
    #define ENOBUFS         119
    #define ENODATA         120
    #define ENOLINK         121
    #define ENOMSG          122
    #define ENOPROTOOPT     123
    #define ENOSR           124
    #define ENOSTR          125
    #define ENOTCONN        126
    #define ENOTRECOVERABLE 127
    #define ENOTSOCK        128
    #define ENOTSUP         129
    #define EOPNOTSUPP      130
    #define EOTHER          131
    #define EOVERFLOW       132
    #define EOWNERDEAD      133
    #define EPROTO          134
    #define EPROTONOSUPPORT 135
    #define EPROTOTYPE      136
    #define ETIME           137
    #define ETIMEDOUT       138
    #define ETXTBSY         139
    #define EWOULDBLOCK     140
#endif // _CRT_NO_POSIX_ERROR_CODES
# 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3



_CRT_END_C_HEADER
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_string.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_string.h" 1 3
//
// vcruntime_string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <string.h> functionality that is implemented in the VCRuntime.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_string.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_string.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_string.h" 2 3

#ifndef __midl

_CRT_BEGIN_C_HEADER



_Check_return_
_VCRTIMP void _CONST_RETURN* __cdecl memchr(
    _In_reads_bytes_opt_(_MaxCount) void const* _Buf,
    _In_                            int         _Val,
    _In_                            size_t      _MaxCount
    );

_Check_return_
int __cdecl memcmp(
    _In_reads_bytes_(_Size) void const* _Buf1,
    _In_reads_bytes_(_Size) void const* _Buf2,
    _In_                    size_t      _Size
    );

_CRT_INSECURE_DEPRECATE_MEMORY(memcpy_s)
_Post_equal_to_(_Dst)
_At_buffer_(
    (unsigned char*)_Dst,
    _Iter_,
    _Size,
    _Post_satisfies_(((unsigned char*)_Dst)[_Iter_] == ((unsigned char*)_Src)[_Iter_])
)
void* __cdecl memcpy(
    _Out_writes_bytes_all_(_Size) void* _Dst,
    _In_reads_bytes_(_Size)       void const* _Src,
    _In_                          size_t      _Size
    );

_CRT_INSECURE_DEPRECATE_MEMORY(memmove_s)
_VCRTIMP void* __cdecl memmove(
    _Out_writes_bytes_all_opt_(_Size) void*       _Dst,
    _In_reads_bytes_opt_(_Size)       void const* _Src,
    _In_                              size_t      _Size
    );

_Post_equal_to_(_Dst)
_At_buffer_(
    (unsigned char*)_Dst,
    _Iter_,
    _Size,
    _Post_satisfies_(((unsigned char*)_Dst)[_Iter_] == _Val)
)
void* __cdecl memset(
    _Out_writes_bytes_all_(_Size) void*  _Dst,
    _In_                          int    _Val,
    _In_                          size_t _Size
    );

_Check_return_
_VCRTIMP char _CONST_RETURN* __cdecl strchr(
    _In_z_ char const* _Str,
    _In_   int         _Val
    );

_Check_return_
_VCRTIMP char _CONST_RETURN* __cdecl strrchr(
    _In_z_ char const* _Str,
    _In_   int         _Ch
    );

_Check_return_ _Ret_maybenull_
_VCRTIMP char _CONST_RETURN* __cdecl strstr(
    _In_z_ char const* _Str,
    _In_z_ char const* _SubStr
    );

_Check_return_
_When_(return != NULL, _Ret_range_(_Str, _Str + _String_length_(_Str) - 1))
_VCRTIMP wchar_t _CONST_RETURN* __cdecl wcschr(
    _In_z_ wchar_t const* _Str,
    _In_   wchar_t        _Ch
    );

_Check_return_
_VCRTIMP wchar_t _CONST_RETURN* __cdecl wcsrchr(
    _In_z_ wchar_t const* _Str,
    _In_   wchar_t        _Ch
    );

_Check_return_ _Ret_maybenull_
_When_(return != NULL, _Ret_range_(_Str, _Str + _String_length_(_Str) - 1))
_VCRTIMP wchar_t _CONST_RETURN* __cdecl wcsstr(
    _In_z_ wchar_t const* _Str,
    _In_z_ wchar_t const* _SubStr
    );



_CRT_END_C_HEADER

#endif // __midl
# 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_string.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 2 3

_CRT_BEGIN_C_HEADER

#ifndef _CRT_MEMCPY_S_INLINE
    #define _CRT_MEMCPY_S_INLINE static __inline
#endif
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3

#define _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(expr, errorcode)                 \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        if (!(_Expr_val))                                                      \
        {                                                                      \
            errno = errorcode;                                                 \
            _invalid_parameter_noinfo();                                       \
            return errorcode;                                                  \
        }                                                                      \
    }

#if !defined RC_INVOKED && !defined __midl && __STDC_WANT_SECURE_LIB__

    _Success_(return == 0)
    _Check_return_opt_
    _CRT_MEMCPY_S_INLINE errno_t __CRTDECL memcpy_s(
        _Out_writes_bytes_to_opt_(_DestinationSize, _SourceSize) void*       const _Destination,
        _In_                                                     rsize_t     const _DestinationSize,
        _In_reads_bytes_opt_(_SourceSize)                        void const* const _Source,
        _In_                                                     rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);
        if (_Source == NULL || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
            _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

            // Unreachable, but required to suppress /analyze warnings:
            return EINVAL;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    _Check_return_wat_
    _CRT_MEMCPY_S_INLINE errno_t __CRTDECL memmove_s(
        _Out_writes_bytes_to_opt_(_DestinationSize, _SourceSize) void*       const _Destination,
        _In_                                                     rsize_t     const _DestinationSize,
        _In_reads_bytes_opt_(_SourceSize)                        void const* const _Source,
        _In_                                                     rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);
        _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
        _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#endif
# 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3

#undef _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE

_CRT_END_C_HEADER
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wconio.h>
#endif /* expanded by -frewrite-includes */
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 1 3
//
// corecrt_wconio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) console I/O functionality,
// shared by both <conio.h> and <wchar.h>
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_stdio_config.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 1 3
//
// corecrt_stdio_config.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Per-module <stdio.h> configuration.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

_CRT_BEGIN_C_HEADER

#if !defined _NO_CRT_STDIO_INLINE && !_CRT_FUNCTIONS_REQUIRED
    #define _NO_CRT_STDIO_INLINE
#endif
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

#if defined _NO_CRT_STDIO_INLINE
    #undef _CRT_STDIO_INLINE
    #define _CRT_STDIO_INLINE
#elif !defined _CRT_STDIO_INLINE
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
    #define _CRT_STDIO_INLINE __inline
#endif
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

#if !defined RC_INVOKED // RC has no target architecture
    #if defined _M_IX86
        #define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX "_"
    #elif defined _M_X64 || defined _M_ARM || defined _M_ARM64
# 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
        #define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX ""
    #else
# 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
        #error Unsupported architecture
    #endif
# 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
#endif
# 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3



// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does
// not use these format specifiers without a length modifier and thus can be
// used with either the legacy (default) or the conforming mode.  (This option
// is intended for use by static libraries).
#if !defined RC_INVOKED // _CRT_STDIO_LEGACY_WIDE_SPECIFIERS et al. are too long for rc
    #if defined _CRT_STDIO_ISO_WIDE_SPECIFIERS
        #if defined _CRT_STDIO_LEGACY_WIDE_SPECIFIERS
            #error _CRT_STDIO_ISO_WIDE_SPECIFIERS and _CRT_STDIO_LEGACY_WIDE_SPECIFIERS cannot be defined together.
        #endif
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

        #if !defined _M_CEE_PURE
            #pragma comment(lib, "iso_stdio_wide_specifiers")
            #pragma comment(linker, "/include:" _CRT_INTERNAL_STDIO_SYMBOL_PREFIX "__PLEASE_LINK_WITH_iso_stdio_wide_specifiers.lib")
        #endif
# 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
    #elif defined _CRT_STDIO_LEGACY_WIDE_SPECIFIERS
# 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
        #if !defined _M_CEE_PURE
            #pragma comment(lib, "legacy_stdio_wide_specifiers")
            #pragma comment(linker, "/include:" _CRT_INTERNAL_STDIO_SYMBOL_PREFIX "__PLEASE_LINK_WITH_legacy_stdio_wide_specifiers.lib")
        #endif
# 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
    #endif
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

    #if defined __cplusplus && !defined _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS
        #ifdef _CRT_STDIO_ISO_WIDE_SPECIFIERS
            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "1")
        #else
# 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #endif
# 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
    #endif
# 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
#endif
# 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

// If we're compiling mixed managed code, make sure these inline functions are
// compiled as native to ensure that there is only one instance of each of the
// function-local static variables.
#if defined _M_CEE && !defined _M_CEE_PURE
    #pragma managed(push, off)
#endif
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

#if _CRT_FUNCTIONS_REQUIRED
    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
    _Check_return_ _Ret_notnull_
    __declspec(noinline) __inline unsigned __int64* __CRTDECL __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
    _Check_return_ _Ret_notnull_
    __declspec(noinline) __inline unsigned __int64* __CRTDECL __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#endif
# 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

#if defined _M_CEE && !defined _M_CEE_PURE
    #pragma managed(pop)
#endif
# 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3

#define _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS (*__local_stdio_printf_options())
#define _CRT_INTERNAL_LOCAL_SCANF_OPTIONS  (*__local_stdio_scanf_options ())



#define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION (1ULL << 0)
#define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR       (1ULL << 1)
#define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS           (1ULL << 2)
#define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY      (1ULL << 3)
#define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS     (1ULL << 4)


#define _CRT_INTERNAL_SCANF_SECURECRT                   (1ULL << 0)
#define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS      (1ULL << 1)
#define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY (1ULL << 2)



_CRT_END_C_HEADER
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 2 3

_CRT_BEGIN_C_HEADER



#define WEOF ((wint_t)(0xFFFF))



#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

    _Check_return_wat_
    _Success_(_BufferCount > 0)
    _DCRTIMP errno_t __cdecl _cgetws_s(
        _Out_writes_to_(_BufferCount, *_SizeRead) wchar_t* _Buffer,
        _In_                                      size_t   _BufferCount,
        _Out_                                     size_t*  _SizeRead
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
        _Success_(return == 0)
        errno_t, _cgetws_s,
        _Out_writes_z_(*_Buffer) wchar_t, _Buffer,
        _In_                     size_t*, _SizeRead
        )

    _Check_return_opt_
    _DCRTIMP int __cdecl _cputws(
        _In_z_ wchar_t const* _Buffer
        );

    _Check_return_     _DCRTIMP wint_t __cdecl _getwch  (void);
    _Check_return_     _DCRTIMP wint_t __cdecl _getwche (void);
    _Check_return_opt_ _DCRTIMP wint_t __cdecl _putwch  (_In_ wchar_t _Character);
    _Check_return_opt_ _DCRTIMP wint_t __cdecl _ungetwch(_In_ wint_t  _Character);

    _Check_return_     _DCRTIMP wint_t __cdecl _getwch_nolock  (void);
    _Check_return_     _DCRTIMP wint_t __cdecl _getwche_nolock (void);
    _Check_return_opt_ _DCRTIMP wint_t __cdecl _putwch_nolock  (_In_ wchar_t _Character);
    _Check_return_opt_ _DCRTIMP wint_t __cdecl _ungetwch_nolock(_In_ wint_t  _Character);



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Check_return_opt_
    _DCRTIMP int __cdecl __conio_common_vcwprintf(
        _In_                                    unsigned __int64 _Options,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _DCRTIMP int __cdecl __conio_common_vcwprintf_s(
        _In_                                    unsigned __int64 _Options,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _DCRTIMP int __cdecl __conio_common_vcwprintf_p(
        _In_                                    unsigned __int64 _Options,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwprintf_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return __conio_common_vcwprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Format, _Locale, _ArgList);
    }
#endif
# 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwprintf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return _vcwprintf_l(_Format, NULL, _ArgList);
    }
#endif
# 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwprintf_s_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return __conio_common_vcwprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Format, _Locale, _ArgList);
    }
#endif
# 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwprintf_s(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return _vcwprintf_s_l(_Format, NULL, _ArgList);
    }
#endif
# 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwprintf_p_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return __conio_common_vcwprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Format, _Locale, _ArgList);
    }
#endif
# 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwprintf_p(
        _In_z_ _Printf_format_string_ const wchar_t* const _Format,
                                      va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return _vcwprintf_p_l(_Format, NULL, _ArgList);
    }
#endif
# 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwprintf_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwprintf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vcwprintf_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwprintf_s_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwprintf_s(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vcwprintf_s_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwprintf_p_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwprintf_p(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vcwprintf_p_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Check_return_opt_
    _DCRTIMP int __cdecl __conio_common_vcwscanf(
        _In_                                   unsigned __int64 _Options,
        _In_z_ _Scanf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                               _locale_t        _Locale,
                                               va_list          _ArgList
        );

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vcwscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _vcwscanf_l(
        _In_z_ _Scanf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
                                               va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return __conio_common_vcwscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Format, _Locale, _ArgList);
    }
#endif
# 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vcwscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL _vcwscanf(
        _In_z_ _Scanf_format_string_params_(1) wchar_t const* const _Format,
                                               va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        return _vcwscanf_l(_Format, NULL, _ArgList);
        #pragma warning(pop)
    }
#endif
# 317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwscanf_s_l(
        _In_z_ _Scanf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
                                               va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return __conio_common_vcwscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Format, _Locale, _ArgList);
    }
#endif
# 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vcwscanf_s(
        _In_z_ _Scanf_format_string_params_(1) wchar_t const* const _Format,
                                               va_list              _ArgList
        )
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        return _vcwscanf_s_l(_Format, NULL, _ArgList);
    }
#endif
# 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cwscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _cwscanf_l(
        _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cwscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL _cwscanf(
        _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vcwscanf_l(_Format, NULL, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwscanf_s_l(
        _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _cwscanf_s(
        _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
        ...)
#if defined _NO_CRT_STDIO_INLINE
;
#else
# 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vcwscanf_s_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
#endif
# 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3

#endif // _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
# 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3



_CRT_END_C_HEADER
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wctype.h>
#endif /* expanded by -frewrite-includes */
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 1 3
//
// corecrt_wctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) classification functionality,
// shared by <ctype.h>, <wchar.h>, and <wctype.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3

_CRT_BEGIN_C_HEADER



#define WEOF ((wint_t)(0xFFFF))



// This declaration allows the user access to the ctype look-up
// array _ctype defined in ctype.obj by simply including ctype.h
#ifndef _CTYPE_DISABLE_MACROS

    #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
        #define __PCTYPE_FUNC  _pctype
    #else
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
        #define __PCTYPE_FUNC __pctype_func()
    #endif
# 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3

    _ACRTIMP const unsigned short* __cdecl __pctype_func(void);
    _ACRTIMP const wctype_t*       __cdecl __pwctype_func(void);

    #ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
        extern const unsigned short* _pctype;
        extern const wctype_t*       _pwctype;
    #else
# 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
        #define _pctype  (__pctype_func())
        #define _pwctype (__pwctype_func())
    #endif
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
#endif
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3

// Bit masks for the possible character types
#define _UPPER   0x01     // uppercase letter
#define _LOWER   0x02     // lowercase letter
#define _DIGIT   0x04     // digit[0-9]
#define _SPACE   0x08     // tab, carriage return, newline, vertical tab, or form feed
#define _PUNCT   0x10     // punctuation character
#define _CONTROL 0x20     // control character
#define _BLANK   0x40     // space char (tab is handled separately)
#define _HEX     0x80     // hexadecimal digit

#define _LEADBYTE 0x8000                    // multibyte leadbyte
#define _ALPHA   (0x0100 | _UPPER | _LOWER) // alphabetic character



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Classification and Conversion Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _ACRTIMP int __cdecl iswalnum  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswalpha  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswascii  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswblank  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswcntrl  (_In_ wint_t _C);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _ACRTIMP int __cdecl iswdigit  (_In_ wint_t _C);

_Check_return_ _ACRTIMP int __cdecl iswgraph  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswlower  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswprint  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswpunct  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswspace  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswupper  (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswxdigit (_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl __iswcsymf(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl __iswcsym (_In_ wint_t _C);

_Check_return_ _ACRTIMP int __cdecl _iswalnum_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswalpha_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswblank_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswcntrl_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswdigit_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswgraph_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswlower_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswprint_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswpunct_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswspace_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswupper_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswcsymf_l (_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswcsym_l  (_In_ wint_t _C, _In_opt_ _locale_t _Locale);


_Check_return_ _ACRTIMP wint_t __cdecl towupper(_In_ wint_t _C);
_Check_return_ _ACRTIMP wint_t __cdecl towlower(_In_ wint_t _C);
_Check_return_ _ACRTIMP int    __cdecl iswctype(_In_ wint_t _C, _In_ wctype_t _Type);

_Check_return_ _ACRTIMP wint_t __cdecl _towupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP wint_t __cdecl _towlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int    __cdecl _iswctype_l(_In_ wint_t _C, _In_ wctype_t _Type, _In_opt_ _locale_t _Locale);


#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
    _Check_return_ _ACRTIMP int __cdecl isleadbyte(_In_ int _C);
    _Check_return_ _ACRTIMP int __cdecl _isleadbyte_l(_In_ int _C, _In_opt_ _locale_t _Locale);

    _CRT_OBSOLETE(iswctype) _DCRTIMP int __cdecl is_wctype(_In_ wint_t _C, _In_ wctype_t _Type);
#endif
# 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macro and Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if !defined __cplusplus || defined _M_CEE_PURE || defined MRTDLL || defined _CORECRT_BUILD
    #ifndef _CTYPE_DISABLE_MACROS

        #define iswalpha(_c)  (iswctype(_c, _ALPHA))
        #define iswupper(_c)  (iswctype(_c, _UPPER))
        #define iswlower(_c)  (iswctype(_c, _LOWER))
        #define iswdigit(_c)  (iswctype(_c, _DIGIT))
        #define iswxdigit(_c) (iswctype(_c, _HEX))
        #define iswspace(_c)  (iswctype(_c, _SPACE))
        #define iswpunct(_c)  (iswctype(_c, _PUNCT))
        #define iswblank(_c)  (((_c) == '\t') ? _BLANK : iswctype(_c,_BLANK) )
        #define iswalnum(_c)  (iswctype(_c, _ALPHA | _DIGIT))
        #define iswprint(_c)  (iswctype(_c, _BLANK | _PUNCT | _ALPHA | _DIGIT))
        #define iswgraph(_c)  (iswctype(_c, _PUNCT | _ALPHA | _DIGIT))
        #define iswcntrl(_c)  (iswctype(_c, _CONTROL))
        #define iswascii(_c)  ((unsigned)(_c) < 0x80)

        #define _iswalpha_l(_c,_p)  (iswctype(_c, _ALPHA))
        #define _iswupper_l(_c,_p)  (iswctype(_c, _UPPER))
        #define _iswlower_l(_c,_p)  (iswctype(_c, _LOWER))
        #define _iswdigit_l(_c,_p)  (iswctype(_c, _DIGIT))
        #define _iswxdigit_l(_c,_p) (iswctype(_c, _HEX))
        #define _iswspace_l(_c,_p)  (iswctype(_c, _SPACE))
        #define _iswpunct_l(_c,_p)  (iswctype(_c, _PUNCT))
        #define _iswblank_l(_c,_p)  (iswctype(_c, _BLANK))
        #define _iswalnum_l(_c,_p)  (iswctype(_c, _ALPHA | _DIGIT))
        #define _iswprint_l(_c,_p)  (iswctype(_c, _BLANK | _PUNCT | _ALPHA | _DIGIT))
        #define _iswgraph_l(_c,_p)  (iswctype(_c, _PUNCT | _ALPHA | _DIGIT))
        #define _iswcntrl_l(_c,_p)  (iswctype(_c, _CONTROL))

        #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
            #define isleadbyte(_c)  (__PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
        #endif
# 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3

    #endif // _CTYPE_DISABLE_MACROS
# 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
// CRT_REFACTOR TODO I've had to remove the inline function definitions because
// they break the debugger build.  These were moved here from <wctype.h> in
// C968560.  We need to figure out what is wrong.
//#else
//    #ifndef _CTYPE_DISABLE_MACROS
//        inline int __cdecl iswalpha (_In_ wint_t _C) { return iswctype(_C, _ALPHA); }
//        inline int __cdecl iswupper (_In_ wint_t _C) { return iswctype(_C, _UPPER); }
//        inline int __cdecl iswlower (_In_ wint_t _C) { return iswctype(_C, _LOWER); }
//        inline int __cdecl iswdigit (_In_ wint_t _C) { return iswctype(_C, _DIGIT); }
//        inline int __cdecl iswxdigit(_In_ wint_t _C) { return iswctype(_C, _HEX); }
//        inline int __cdecl iswspace (_In_ wint_t _C) { return iswctype(_C, _SPACE); }
//        inline int __cdecl iswpunct (_In_ wint_t _C) { return iswctype(_C, _PUNCT); }
//        inline int __cdecl iswblank (_In_ wint_t _C) { return (((_C) == '\t') ? _BLANK : iswctype(_C,_BLANK)); }
//        inline int __cdecl iswalnum (_In_ wint_t _C) { return iswctype(_C, _ALPHA | _DIGIT); }
//        inline int __cdecl iswprint (_In_ wint_t _C) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl iswgraph (_In_ wint_t _C) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl iswcntrl (_In_ wint_t _C) { return iswctype(_C, _CONTROL); }
//        inline int __cdecl iswascii (_In_ wint_t _C) { return (unsigned)(_C) < 0x80; }
//
//        inline int __cdecl _iswalpha_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA); }
//        inline int __cdecl _iswupper_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _UPPER); }
//        inline int __cdecl _iswlower_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _LOWER); }
//        inline int __cdecl _iswdigit_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _DIGIT); }
//        inline int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _HEX); }
//        inline int __cdecl _iswspace_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _SPACE); }
//        inline int __cdecl _iswpunct_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT); }
//        inline int __cdecl _iswblank_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK); }
//        inline int __cdecl _iswalnum_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA | _DIGIT); }
//        inline int __cdecl _iswprint_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl _iswgraph_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl _iswcntrl_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _CONTROL); }
//
//        #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
//        inline int __cdecl isleadbyte(_In_ int _C)
//        {
//            return __pctype_func()[(unsigned char)(_C)] & _LEADBYTE;
//        }
//        #endif
//    #endif
#endif
# 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3



_CRT_END_C_HEADER
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wdirect.h>
#endif /* expanded by -frewrite-includes */
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 1 3
//
// corecrt_wdirect.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) directory functionality, shared
// by <direct.h> and <wchar.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3

_CRT_BEGIN_C_HEADER

#pragma push_macro("_wgetcwd")
#pragma push_macro("_wgetdcwd")
#undef _wgetcwd
#undef _wgetdcwd

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wgetcwd(
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _DstBuf,
    _In_                             int      _SizeInWords
    );

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wgetdcwd(
    _In_                             int      _Drive,
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _DstBuf,
    _In_                             int      _SizeInWords
    );

#define _wgetdcwd_nolock  _wgetdcwd

#pragma pop_macro("_wgetcwd")
#pragma pop_macro("_wgetdcwd")

_Check_return_
_ACRTIMP int __cdecl _wchdir(
    _In_z_ wchar_t const* _Path
    );

_Check_return_
_ACRTIMP int __cdecl _wmkdir(
    _In_z_ wchar_t const* _Path
    );

_Check_return_
_ACRTIMP int __cdecl _wrmdir(
    _In_z_ wchar_t const* _Path
    );



_CRT_END_C_HEADER
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wio.h>
#endif /* expanded by -frewrite-includes */
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 1 3
//
// corecrt_wio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <io.h> and <wchar.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_share.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_share.h" 1 3
//
// corecrt_share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.  These
// declarations are split out to support the Windows build.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_share.h" 3



#define _SH_DENYRW      0x10    // deny read/write mode
#define _SH_DENYWR      0x20    // deny write mode
#define _SH_DENYRD      0x30    // deny read mode
#define _SH_DENYNO      0x40    // deny none mode
#define _SH_SECURE      0x80    // secure mode



#if (defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__)
    #define SH_DENYRW _SH_DENYRW
    #define SH_DENYWR _SH_DENYWR
    #define SH_DENYRD _SH_DENYRD
    #define SH_DENYNO _SH_DENYNO
#endif
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_share.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 2 3

_CRT_BEGIN_C_HEADER


#pragma warning(push)
#pragma warning(disable:4820) /* padding added after data member */


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _USE_32BIT_TIME_T
    #define _wfinddata_t    _wfinddata32_t
    #define _wfinddatai64_t _wfinddata32i64_t
#else
# 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
    #define _wfinddata_t    _wfinddata64i32_t
    #define _wfinddatai64_t _wfinddata64_t
#endif
# 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _USE_32BIT_TIME_T
    #define _wfindfirst     _wfindfirst32
    #define _wfindnext      _wfindnext32
    #define _wfindfirsti64  _wfindfirst32i64
    #define _wfindnexti64   _wfindnext32i64
#else
# 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
    #define _wfindfirst     _wfindfirst64i32
    #define _wfindnext      _wfindnext64i32
    #define _wfindfirsti64  _wfindfirst64
    #define _wfindnexti64   _wfindnext64
#endif
# 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3

_Check_return_
_ACRTIMP int __cdecl _waccess(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _AccessMode
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _waccess_s(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _AccessMode
    );

_Check_return_
_ACRTIMP int __cdecl _wchmod(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _Mode
    );

_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
_ACRTIMP int __cdecl _wcreat(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _PermissionMode
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst32(
    _In_z_ wchar_t const*         _FileName,
    _Out_  struct _wfinddata32_t* _FindData
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext32(
    _In_  intptr_t               _FindHandle,
    _Out_ struct _wfinddata32_t* _FindData
    );

_ACRTIMP int __cdecl _wunlink(
    _In_z_ wchar_t const* _FileName
    );

_Check_return_
_ACRTIMP int __cdecl _wrename(
    _In_z_ wchar_t const* _OldFileName,
    _In_z_ wchar_t const* _NewFileName
    );

_ACRTIMP errno_t __cdecl _wmktemp_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _TemplateName,
    _In_                            size_t   _SizeInWords
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wmktemp_s,
    wchar_t, _TemplateName
    )

_Success_(return != 0)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wmktemp,
    _Inout_z_, wchar_t, _TemplateName
    )

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst32i64(
    _In_z_ wchar_t const*            _FileName,
    _Out_  struct _wfinddata32i64_t* _FindData
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst64i32(
    _In_z_ wchar_t const*            _FileName,
    _Out_  struct _wfinddata64i32_t* _FindData
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst64(
    _In_z_ wchar_t const*         _FileName,
    _Out_  struct _wfinddata64_t* _FindData
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext32i64(
    _In_  intptr_t                  _FindHandle,
    _Out_ struct _wfinddata32i64_t* _FindData
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext64i32(
    _In_  intptr_t                  _FindHandle,
    _Out_ struct _wfinddata64i32_t* _FindData
    );

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext64(
    _In_  intptr_t               _FindHandle,
    _Out_ struct _wfinddata64_t* _FindData
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wsopen_s(
    _Out_  int*           _FileHandle,
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OpenFlag,
    _In_   int            _ShareFlag,
    _In_   int            _PermissionFlag
    );

_ACRTIMP errno_t __cdecl _wsopen_dispatch(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OFlag,
    _In_   int            _ShFlag,
    _In_   int            _PMode,
    _Out_  int*           _PFileHandle,
    _In_   int            _BSecure
    );



#if defined __cplusplus

    // These functions do not validate pmode; use _wsopen_s instead.
    extern "C++" _Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
    inline int __CRTDECL _wopen(
        _In_z_ wchar_t const* _FileName,
        _In_   int            _OFlag,
        _In_   int            _PMode = 0
        )
    {
        int _FileHandle;
        // Last parameter passed as 0 because we don't want to validate pmode from _open
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _SH_DENYNO, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++" _Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
    inline int __CRTDECL _wsopen(
        _In_z_ wchar_t const* _FileName,
        _In_   int            _OFlag,
        _In_   int            _ShFlag,
        _In_   int            _PMode = 0
        )
    {
        int _FileHandle;
        // Last parameter passed as 0 because we don't want to validate pmode from _sopen
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }


#else
# 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
    _ACRTIMP int __cdecl _wopen(
        _In_z_ wchar_t const* _FileName,
        _In_   int            _OpenFlag,
        ...);

    _Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
    _ACRTIMP int __cdecl _wsopen(
        _In_z_ wchar_t const* _FileName,
        _In_   int            _OpenFlag,
        _In_   int            _ShareFlag,
        ...);

#endif
# 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3


#pragma warning(pop)


_CRT_END_C_HEADER
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wprocess.h>
#endif /* expanded by -frewrite-includes */
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 1 3
//
// corecrt_wprocess.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) process functionality, shared
// by <process.h> and <wchar.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3

_CRT_BEGIN_C_HEADER



#if _CRT_FUNCTIONS_REQUIRED
    #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

        _DCRTIMP intptr_t __cdecl _wexecl(
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wexecle(
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wexeclp(
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wexeclpe(
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wexecv(
            _In_z_ wchar_t const*        _FileName,
            _In_z_ wchar_t const* const* _ArgList
            );

        _DCRTIMP intptr_t __cdecl _wexecve(
            _In_z_     wchar_t const*        _FileName,
            _In_z_     wchar_t const* const* _ArgList,
            _In_opt_z_ wchar_t const* const* _Env
            );

        _DCRTIMP intptr_t __cdecl _wexecvp(
            _In_z_ wchar_t const*        _FileName,
            _In_z_ wchar_t const* const* _ArgList
            );

        _DCRTIMP intptr_t __cdecl _wexecvpe(
            _In_z_     wchar_t const*        _FileName,
            _In_z_     wchar_t const* const* _ArgList,
            _In_opt_z_ wchar_t const* const* _Env
            );

        _DCRTIMP intptr_t __cdecl _wspawnl(
            _In_   int            _Mode,
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wspawnle(
            _In_   int            _Mode,
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wspawnlp(
            _In_   int            _Mode,
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wspawnlpe(
            _In_   int            _Mode,
            _In_z_ wchar_t const* _FileName,
            _In_z_ wchar_t const* _ArgList,
            ...);

        _DCRTIMP intptr_t __cdecl _wspawnv(
            _In_   int                   _Mode,
            _In_z_ wchar_t const*        _FileName,
            _In_z_ wchar_t const* const* _ArgList
            );

        _DCRTIMP intptr_t __cdecl _wspawnve(
            _In_       int                   _Mode,
            _In_z_     wchar_t const*        _FileName,
            _In_z_     wchar_t const* const* _ArgList,
            _In_opt_z_ wchar_t const* const* _Env
            );

        _DCRTIMP intptr_t __cdecl _wspawnvp(
            _In_   int                   _Mode,
            _In_z_ wchar_t const*        _FileName,
            _In_z_ wchar_t const* const* _ArgList
            );

        _DCRTIMP intptr_t __cdecl _wspawnvpe(
            _In_       int                   _Mode,
            _In_z_     wchar_t const*        _FileName,
            _In_z_     wchar_t const* const* _ArgList,
            _In_opt_z_ wchar_t const* const* _Env
            );

        _DCRTIMP int __cdecl _wsystem(
            _In_opt_z_ wchar_t const* _Command
            );

    #endif // _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
# 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3
#endif // _CRT_FUNCTIONS_REQUIRED
# 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3



_CRT_END_C_HEADER
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wstdio.h>
#endif /* expanded by -frewrite-includes */
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 1 3
//
// corecrt_wstdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are
// also shared by those two headers.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_stdio_config.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

_CRT_BEGIN_C_HEADER


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Stream I/O Declarations Required by this Header
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _FILE_DEFINED
    #define _FILE_DEFINED
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#endif
# 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned _Ix);

#define stdin  (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))

#define WEOF ((wint_t)(0xFFFF))



#if _CRT_FUNCTIONS_REQUIRED
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Check_return_opt_
    _ACRTIMP wint_t __cdecl fgetwc(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _fgetwchar(void);

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl fputwc(
        _In_    wchar_t _Character,
        _Inout_ FILE*   _Stream);

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _fputwchar(
        _In_ wchar_t _Character
        );

    _Check_return_
    _ACRTIMP wint_t __cdecl getwc(
        _Inout_ FILE* _Stream
        );

    _Check_return_
    _ACRTIMP wint_t __cdecl getwchar(void);


    _Check_return_opt_
    _Success_(return == _Buffer)
    _ACRTIMP wchar_t* __cdecl fgetws(
        _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
        _In_                         int      _BufferCount,
        _Inout_                      FILE*    _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl fputws(
        _In_z_  wchar_t const* _Buffer,
        _Inout_ FILE*          _Stream
        );

    _Check_return_opt_
    _Success_(return != 0)
    _ACRTIMP wchar_t* __cdecl _getws_s(
        _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
        _In_                         size_t   _BufferCount
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
        _Success_(return != 0)
        wchar_t*, _getws_s,
        _Always_(_Post_z_) wchar_t, _Buffer
        )

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl putwc(
        _In_    wchar_t _Character,
        _Inout_ FILE*   _Stream
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl putwchar(
        _In_ wchar_t _Character
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _putws(
        _In_z_ wchar_t const* _Buffer
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl ungetwc(
        _In_    wint_t _Character,
        _Inout_ FILE*  _Stream
        );

    _Check_return_
    _ACRTIMP FILE * __cdecl _wfdopen(
        _In_   int            _FileHandle,
        _In_z_ wchar_t const* _Mode
        );

    _Check_return_ _CRT_INSECURE_DEPRECATE(_wfopen_s)
    _ACRTIMP FILE* __cdecl _wfopen(
        _In_z_ wchar_t const* _FileName,
        _In_z_ wchar_t const* _Mode
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _wfopen_s(
        _Outptr_result_maybenull_ FILE**         _Stream,
        _In_z_                    wchar_t const* _FileName,
        _In_z_                    wchar_t const* _Mode
        );

    _Check_return_
    _CRT_INSECURE_DEPRECATE(_wfreopen_s)
    _ACRTIMP FILE* __cdecl _wfreopen(
        _In_z_  wchar_t const* _FileName,
        _In_z_  wchar_t const* _Mode,
        _Inout_ FILE*          _OldStream
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _wfreopen_s(
        _Outptr_result_maybenull_ FILE**         _Stream,
        _In_z_                    wchar_t const* _FileName,
        _In_z_                    wchar_t const* _Mode,
        _Inout_                   FILE*          _OldStream
        );

    _Check_return_
    _ACRTIMP FILE* __cdecl _wfsopen(
        _In_z_ wchar_t const* _FileName,
        _In_z_ wchar_t const* _Mode,
        _In_   int            _ShFlag
        );

    _ACRTIMP void __cdecl _wperror(
        _In_opt_z_ wchar_t const* _ErrorMessage
        );

    #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

        _Check_return_
        _DCRTIMP FILE* __cdecl _wpopen(
            _In_z_ wchar_t const* _Command,
            _In_z_ wchar_t const* _Mode
            );

    #endif
# 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _ACRTIMP int __cdecl _wremove(
        _In_z_ wchar_t const* _FileName
        );

    #pragma push_macro("_wtempnam")
    #undef _wtempnam

    _Check_return_
    _ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wtempnam(
        _In_opt_z_ wchar_t const* _Directory,
        _In_opt_z_ wchar_t const* _FilePrefix
        );

    #pragma pop_macro("_wtempnam")

    _Success_(return == 0)
    _Check_return_wat_
    _ACRTIMP errno_t __cdecl _wtmpnam_s(
        _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
        _In_                         size_t   _BufferCount
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
        _Success_(return == 0)
        errno_t, _wtmpnam_s,
        _Always_(_Post_z_) wchar_t, _Buffer
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
        _Success_(return != 0)
        wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wtmpnam,
        _Pre_maybenull_ _Always_(_Post_z_), wchar_t, _Buffer
        )



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _fgetwc_nolock(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _fputwc_nolock(
        _In_    wchar_t _Character,
        _Inout_ FILE*   _Stream
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _getwc_nolock(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _putwc_nolock(
        _In_    wchar_t _Character,
        _Inout_ FILE*   _Stream
        );

    _Check_return_opt_
    _ACRTIMP wint_t __cdecl _ungetwc_nolock(
        _In_    wint_t _Character,
        _Inout_ FILE*  _Stream
        );

    #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
        #define fgetwc(stream)     _getwc_nolock(stream)
        #define fputwc(c, stream)  _putwc_nolock(c, stream)
        #define ungetwc(c, stream) _ungetwc_nolock(c, stream)
    #endif
# 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3



    // Variadic functions are not supported in managed code under /clr
    #ifdef _M_CEE_MIXED
        #pragma managed(push, off)
    #endif
# 260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vfwprintf(
        _In_                                    unsigned __int64 _Options,
        _Inout_                                 FILE*            _Stream,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vfwprintf_s(
        _In_                                    unsigned __int64 _Options,
        _Inout_                                 FILE*            _Stream,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vfwprintf_p(
        _In_                                    unsigned __int64 _Options,
        _Inout_                                 FILE*            _Stream,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfwprintf_l(
        _Inout_                                 FILE*          const _Stream,
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vfwprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vfwprintf(
        _Inout_                       FILE*          const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_l(_Stream, _Format, NULL, _ArgList);
    }
    #endif
# 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfwprintf_s_l(
        _Inout_                                 FILE*          const _Stream,
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vfwprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vfwprintf_s(
            _Inout_                       FILE*          const _Stream,
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            return _vfwprintf_s_l(_Stream, _Format, NULL, _ArgList);
        }
    #endif
# 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfwprintf_p_l(
        _Inout_                                 FILE*          const _Stream,
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vfwprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfwprintf_p(
        _Inout_                       FILE*          const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_p_l(_Stream, _Format, NULL, _ArgList);
    }
    #endif
# 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vwprintf_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_l(stdout, _Format, _Locale, _ArgList);
    }
    #endif
# 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vwprintf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_l(stdout, _Format, NULL, _ArgList);
    }
    #endif
# 412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vwprintf_s_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList);
    }
    #endif
# 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vwprintf_s(
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            return _vfwprintf_s_l(stdout, _Format, NULL, _ArgList);
        }
    #endif
# 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vwprintf_p_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_p_l(stdout, _Format, _Locale, _ArgList);
    }
    #endif
# 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vwprintf_p(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwprintf_p_l(stdout, _Format, NULL, _ArgList);
    }
    #endif
# 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fwprintf_l(
        _Inout_                                 FILE*          const _Stream,
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL fwprintf(
        _Inout_                       FILE*          const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l(_Stream, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fwprintf_s_l(
        _Inout_                                 FILE*          const _Stream,
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL fwprintf_s(
            _Inout_                       FILE*          const _Stream,
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwprintf_s_l(_Stream, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fwprintf_p_l(
        _Inout_                                 FILE*          const _Stream,
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fwprintf_p(
        _Inout_                       FILE*          const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l(_Stream, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _wprintf_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l(stdout, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL wprintf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l(stdout, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _wprintf_s_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL wprintf_s(
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwprintf_s_l(stdout, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _wprintf_p_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l(stdout, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _wprintf_p(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l(stdout, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vfwscanf(
        _In_                                   unsigned __int64 _Options,
        _Inout_                                FILE*            _Stream,
        _In_z_ _Scanf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                               _locale_t        _Locale,
                                               va_list          _ArgList
        );

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfwscanf_l(
        _Inout_ FILE*                                const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        _In_opt_                      _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vfwscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vfwscanf(
        _Inout_ FILE*                                const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwscanf_l(_Stream, _Format, NULL, _ArgList);
    }
    #endif
# 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfwscanf_s_l(
        _Inout_                       FILE*          const _Stream,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        _In_opt_                      _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vfwscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vfwscanf_s(
            _Inout_                       FILE*          const _Stream,
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            return _vfwscanf_s_l(_Stream, _Format, NULL, _ArgList);
        }
    #endif
# 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _CRT_STDIO_INLINE int __CRTDECL _vwscanf_l(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        _In_opt_                      _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwscanf_l(stdin, _Format, _Locale, _ArgList);
    }
    #endif
# 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vwscanf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwscanf_l(stdin, _Format, NULL, _ArgList);
    }
    #endif
# 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vwscanf_s_l(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        _In_opt_                      _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vfwscanf_s_l(stdin, _Format, _Locale, _ArgList);
    }
    #endif
# 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vwscanf_s(
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            return _vfwscanf_s_l(stdin, _Format, NULL, _ArgList);
        }
    #endif
# 830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fwscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _fwscanf_l(
        _Inout_                                FILE*          const _Stream,
        _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(fwscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL fwscanf(
        _Inout_                      FILE*          const _Stream,
        _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l(_Stream, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fwscanf_s_l(
        _Inout_                                  FILE*          const _Stream,
        _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                 _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL fwscanf_s(
            _Inout_                        FILE*          const _Stream,
            _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwscanf_s_l(_Stream, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_wscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _wscanf_l(
        _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l(stdin, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(wscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL wscanf(
        _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l(stdin, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _wscanf_s_l(
        _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                 _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l(stdin, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL wscanf_s(
            _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
            ;
    #else
# 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwscanf_s_l(stdin, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    #ifndef _CRT_NON_CONFORMING_SWPRINTFS
        #define _SWPRINTFS_DEPRECATED _CRT_DEPRECATE_TEXT(                       \
                "function has been changed to conform with the ISO C standard, " \
                "adding an extra character count parameter. To use the traditional " \
                "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")
    #else
# 998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        #define _SWPRINTFS_DEPRECATED
    #endif
# 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vswprintf(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_opt_z_(_BufferCount)        wchar_t*         _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vswprintf_s(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_z_(_BufferCount)            wchar_t*         _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vsnwprintf_s(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_opt_z_(_BufferCount)        wchar_t*         _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_                                    size_t           _MaxCount,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl __stdio_common_vswprintf_p(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_z_(_BufferCount)            wchar_t*         _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwprintf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _vsnwprintf_l(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t*       const _Buffer,
        _In_                                         size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)      wchar_t const* const _Format,
        _In_opt_                                     _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vswprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #pragma warning(push)
    #pragma warning(disable: 4793)

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnwprintf_s_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_                                              size_t         const _MaxCount,
        _In_z_ _Printf_format_string_params_(2)           wchar_t const* const _Format,
        _In_opt_                                          _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnwprintf_s(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_                                              size_t         const _MaxCount,
        _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
    }
    #endif
# 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(
        _Success_(return >= 0)
        int, __RETURN_POLICY_SAME, _CRT_STDIO_INLINE, __CRTDECL, _snwprintf, _vsnwprintf,
        _Pre_notnull_ _Post_maybez_                   wchar_t,
        _Out_writes_opt_(_BufferCount) _Post_maybez_, wchar_t,        _Buffer,
        _In_                                          size_t,         _BufferCount,
        _In_z_ _Printf_format_string_                 wchar_t const*, _Format
        )

    #pragma warning(pop)

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwprintf_s)
    _CRT_STDIO_INLINE int __CRTDECL _vsnwprintf(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t*       _Buffer,
        _In_                                         size_t         _BufferCount,
        _In_z_ _Printf_format_string_                wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        #pragma warning(pop)
    }
    #endif
# 1138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
        _Success_(return >= 0)
        int, _vsnwprintf_s,
        _Always_(_Post_z_)            wchar_t,        _Buffer,
        _In_                          size_t,         _BufferCount,
        _In_z_ _Printf_format_string_ wchar_t const*, _Format,
                                      va_list,        _ArgList
        )

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf_c_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)           wchar_t const* const _Format,
        _In_opt_                                          _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vswprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf_c(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    }
    #endif
# 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)           wchar_t const* const _Format,
        _In_opt_                                          _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #endif
# 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL __vswprintf_l(
        _Pre_notnull_ _Always_(_Post_z_)        wchar_t*       const _Buffer,
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #endif
# 1220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf(
        _Pre_notnull_ _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_z_ _Printf_format_string_    wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
    }
    #endif
# 1235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vswprintf(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(1)           wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    }
    #endif
# 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf_s_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                          size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)       wchar_t const* const _Format,
        _In_opt_                                      _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vswprintf_s(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _CRT_STDIO_INLINE int __CRTDECL vswprintf_s(
            _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
            _In_                                          size_t         const _BufferCount,
            _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        }
    #endif
# 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
        _Success_(return >= 0)
        int, vswprintf_s,
        _Always_(_Post_z_)            wchar_t,        _Buffer,
        _In_z_ _Printf_format_string_ wchar_t const*, _Format,
                                      va_list,        _ArgList
        )

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf_p_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                          size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)       wchar_t const* const _Format,
        _In_opt_                                      _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vswprintf_p(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswprintf_p(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                          size_t         const _BufferCount,
        _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    }
    #endif
# 1336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _vscwprintf_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vswprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
            NULL, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _vscwprintf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vscwprintf_l(_Format, NULL, _ArgList);
    }
    #endif
# 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _vscwprintf_p_l(
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int const _Result = __stdio_common_vswprintf_p(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
            NULL, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _vscwprintf_p(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vscwprintf_p_l(_Format, NULL, _ArgList);
    }
    #endif
# 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL __swprintf_l(
        _Pre_notnull_ _Always_(_Post_z_)        wchar_t*       const _Buffer,
        _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)           wchar_t const* const _Format,
        _In_opt_                                          _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf(
        _Pre_notnull_ _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_z_ _Printf_format_string_    wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = __vswprintf_l(_Buffer, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL swprintf(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #pragma warning(push)
    // Warning 4793: The compiler cannot compile function into managed code, even though the /clr compiler option is specified.
    // Warning 4996: 'function': was declared deprecated
    #pragma warning(disable:4793 4996)

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(
        _Success_(return >= 0)
        int, __RETURN_POLICY_SAME, _CRT_STDIO_INLINE, __CRTDECL, __swprintf_l, __vswprintf_l, _vswprintf_s_l,
        _Pre_notnull_ _Always_(_Post_z_)        wchar_t,
        _Pre_notnull_ _Always_(_Post_z_),       wchar_t,        _Buffer,
        _In_z_ _Printf_format_string_params_(2) wchar_t const*, _Format,
        _In_opt_                                _locale_t,      _Locale
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(
        _Success_(return >= 0)
        int, __RETURN_POLICY_SAME, _CRT_STDIO_INLINE, __CRTDECL, _swprintf, swprintf_s, _vswprintf, vswprintf_s,
        _Pre_notnull_ _Always_(_Post_z_), wchar_t,        _Buffer,
        _In_z_ _Printf_format_string_     wchar_t const*, _Format
        )

    #pragma warning(pop)

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf_s_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                          size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)       wchar_t const* const _Format,
        _In_opt_                                      _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _CRT_STDIO_INLINE int __CRTDECL swprintf_s(
            _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
            _In_                                          size_t         const _BufferCount,
            _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 1549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(
        _Success_(return >= 0)
        int, swprintf_s, vswprintf_s,
        _Always_(_Post_z_)            wchar_t,        _Buffer,
        _In_z_ _Printf_format_string_ wchar_t const*, _Format
        )

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf_p_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                          size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)       wchar_t const* const _Format,
        _In_opt_                                      _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf_p(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                          size_t         const _BufferCount,
        _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf_c_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)           wchar_t const* const _Format,
        _In_opt_                                          _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swprintf_c(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwprintf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _snwprintf_l(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t*       const _Buffer,
        _In_                                         size_t         const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)      wchar_t const* const _Format,
        _In_opt_                                     _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snwprintf(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t*       _Buffer,
        _In_                                         size_t         _BufferCount,
        _In_z_ _Printf_format_string_                wchar_t const* _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snwprintf_s_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_                                              size_t         const _MaxCount,
        _In_z_ _Printf_format_string_params_(0)           wchar_t const* const _Format,
        _In_opt_                                          _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snwprintf_s(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t*       const _Buffer,
        _In_                                              size_t         const _BufferCount,
        _In_                                              size_t         const _MaxCount,
        _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(
        _Success_(return >= 0)
        int, _snwprintf_s, _vsnwprintf_s,
        _Always_(_Post_z_)            wchar_t,        _Buffer,
        _In_                          size_t,         _BufferCount,
        _In_z_ _Printf_format_string_ wchar_t const*, _Format
        )

    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _scwprintf_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _scwprintf(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscwprintf_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _scwprintf_p_l(
        _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _scwprintf_p(
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscwprintf_p_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3


    #if !defined RC_INVOKED && !defined __midl && !defined _INC_SWPRINTF_INL_
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        #ifdef __cplusplus

            extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(swprintf_s)
            inline int swprintf(
                _Pre_notnull_ _Post_z_        wchar_t*       const _Buffer,
                _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                __crt_va_start(_ArgList, _Format);
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, _CRT_INT_MAX, _Format, _ArgList);
                __crt_va_end(_ArgList);
                return _Result;
            }

            extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(vswprintf_s)
            inline int __CRTDECL vswprintf(
                _Pre_notnull_ _Post_z_        wchar_t*       const _Buffer,
                _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, _CRT_INT_MAX, _Format, _ArgList);
            }

            extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(_swprintf_s_l)
            inline int _swprintf_l(
                _Pre_notnull_ _Post_z_                  wchar_t*       const _Buffer,
                _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
                _In_opt_                                _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                __crt_va_start(_ArgList, _Locale);
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                __crt_va_end(_ArgList);
                return _Result;
            }

            extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(_vswprintf_s_l)
            inline int __CRTDECL _vswprintf_l(
                _Pre_notnull_ _Post_z_                  wchar_t*       const _Buffer,
                _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
                _In_opt_                                _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #endif  // __cplusplus
# 1874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

        #pragma warning(pop)
    #endif  // !_INC_SWPRINTF_INL_
# 1877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if defined _CRT_NON_CONFORMING_SWPRINTFS && !defined __cplusplus
        #define swprintf     _swprintf
        #define vswprintf    _vswprintf
        #define _swprintf_l  __swprintf_l
        #define _vswprintf_l __vswprintf_l
    #endif
# 1884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Success_(return >= 0)
    _ACRTIMP int __cdecl __stdio_common_vswscanf(
        _In_                                   unsigned __int64 _Options,
        _In_reads_(_BufferCount) _Pre_z_       wchar_t const*   _Buffer,
        _In_                                   size_t           _BufferCount,
        _In_z_ _Scanf_format_string_params_(2) wchar_t const*   _Format,
        _In_opt_                               _locale_t        _Locale,
                                               va_list          _ArgList
        );

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswscanf_l(
        _In_z_                        wchar_t const* const _Buffer,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        _In_opt_                      _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vswscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #endif
# 1918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vswscanf(
        _In_z_                        wchar_t const* _Buffer,
        _In_z_ _Printf_format_string_ wchar_t const* _Format,
                                      va_list        _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return _vswscanf_l(_Buffer, _Format, NULL, _ArgList);
    }
    #endif
# 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vswscanf_s_l(
        _In_z_                        wchar_t const* const _Buffer,
        _In_z_ _Printf_format_string_ wchar_t const* const _Format,
        _In_opt_                      _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vswscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #endif
# 1951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vswscanf_s(
            _In_z_                        wchar_t const* const _Buffer,
            _In_z_ _Printf_format_string_ wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            return _vswscanf_s_l(_Buffer, _Format, NULL, _ArgList);
        }
    #endif
# 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
        _Success_(return >= 0)
        int, vswscanf_s,
        _In_z_                        wchar_t,        _Buffer,
        _In_z_ _Printf_format_string_ wchar_t const*, _Format,
                                      va_list,        _ArgList
        )

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _vsnwscanf_l(
        _In_reads_(_BufferCount) _Pre_z_       wchar_t const* const _Buffer,
        _In_                                   size_t         const _BufferCount,
        _In_z_ _Scanf_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vswscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #endif
# 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnwscanf_s_l(
        _In_reads_(_BufferCount) _Pre_z_         wchar_t const* const _Buffer,
        _In_                                     size_t         const _BufferCount,
        _In_z_ _Scanf_s_format_string_params_(2) wchar_t const* const _Format,
        _In_opt_                                 _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        return __stdio_common_vswscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #endif
# 2016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_swscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _swscanf_l(
        _In_z_                                 wchar_t const* const _Buffer,
        _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                               _locale_t            _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2036 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_ _CRT_INSECURE_DEPRECATE(swscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL swscanf(
        _In_z_                       wchar_t const* const _Buffer,
        _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswscanf_l(_Buffer, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _swscanf_s_l(
        _In_z_                                   wchar_t const* const _Buffer,
        _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                 _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL swscanf_s(
            _In_z_                         wchar_t const* const _Buffer,
            _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vswscanf_s_l(_Buffer, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 2096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #endif
# 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _snwscanf_l(
        _In_reads_(_BufferCount) _Pre_z_       wchar_t const* const _Buffer,
        _In_                                   size_t         const _BufferCount,
        _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                               _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL _snwscanf(
        _In_reads_(_BufferCount) _Pre_z_ wchar_t const* const _Buffer,
        _In_                             size_t         const _BufferCount,
        _In_z_ _Scanf_format_string_     wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snwscanf_s_l(
        _In_reads_(_BufferCount) _Pre_z_         wchar_t const* const _Buffer,
        _In_                                     size_t         const _BufferCount,
        _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
        _In_opt_                                 _locale_t      const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snwscanf_s(
        _In_reads_(_BufferCount) _Pre_z_  wchar_t const* const _Buffer,
        _In_                              size_t         const _BufferCount,
        _In_z_ _Scanf_s_format_string_    wchar_t const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3

    #ifdef _M_CEE_MIXED
        #pragma managed(pop)
    #endif
# 2194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#endif // _CRT_FUNCTIONS_REQUIRED
# 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3



_CRT_END_C_HEADER
# 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wstdlib.h>
#endif /* expanded by -frewrite-includes */
# 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wstring.h>
#endif /* expanded by -frewrite-includes */
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 1 3
//
// corecrt_wstring.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) string functionality, shared
// by <string.h> and <wchar.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_string.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

#ifndef __midl

_CRT_BEGIN_C_HEADER



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Secure Alternatives
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if __STDC_WANT_SECURE_LIB__

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl wcscat_s(
        _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
        _In_ rsize_t _SizeInWords,
        _In_z_ wchar_t const* _Source
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl wcscpy_s(
        _Out_writes_z_(_SizeInWords) wchar_t* _Destination,
        _In_ rsize_t _SizeInWords,
        _In_z_ wchar_t const* _Source
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl wcsncat_s(
        _Inout_updates_z_(_SizeInWords) wchar_t*       _Destination,
        _In_                            rsize_t        _SizeInWords,
        _In_reads_or_z_(_MaxCount)      wchar_t const* _Source,
        _In_                            rsize_t        _MaxCount
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl wcsncpy_s(
        _Out_writes_z_(_SizeInWords) wchar_t*       _Destination,
        _In_                         rsize_t        _SizeInWords,
        _In_reads_or_z_(_MaxCount)   wchar_t const* _Source,
        _In_                         rsize_t        _MaxCount
        );

    _Check_return_
    _ACRTIMP wchar_t* __cdecl wcstok_s(
        _Inout_opt_z_                 wchar_t*       _String,
        _In_z_                        wchar_t const* _Delimiter,
        _Inout_ _Deref_prepost_opt_z_ wchar_t**      _Context
        );

#endif // __STDC_WANT_SECURE_LIB__
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide-Character <string.h> Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
    #pragma push_macro("_wcsdup")
    #undef _wcsdup
#endif
# 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

_Check_return_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wcsdup(
    _In_z_ wchar_t const* _String
    );

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
    #pragma pop_macro("_wcsdup")
#endif
# 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3



__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, wcscat_s,
           wchar_t,        _Destination,
    _In_z_ wchar_t const*, _Source
    )

#ifndef RC_INVOKED

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
        wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcscat,
        _Inout_updates_z_(_String_length_(_Destination) + _String_length_(_Source) + 1), wchar_t,        _Destination,
        _In_z_                                                                           wchar_t const*, _Source
        )
#pragma warning(pop)
#endif
# 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

_Check_return_
_ACRTIMP int __cdecl wcscmp(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, wcscpy_s,
           wchar_t,        _Destination,
    _In_z_ wchar_t const*, _Source
    )

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcscpy,
    _Out_writes_z_(_String_length_(_Source) + 1), wchar_t,        _Destination,
    _In_z_                                        wchar_t const*, _Source
    )
#pragma warning(pop)

_Check_return_
_ACRTIMP size_t __cdecl wcscspn(
    _In_z_ wchar_t const* _String,
    _In_z_ wchar_t const* _Control
    );

_Check_return_
_ACRTIMP size_t __cdecl wcslen(
    _In_z_ wchar_t const* _String
    );

_Check_return_
_When_(
    _MaxCount > _String_length_(_Source),
    _Post_satisfies_(return == _String_length_(_Source))
)
_When_(
    _MaxCount <= _String_length_(_Source),
    _Post_satisfies_(return == _MaxCount)
)
_ACRTIMP size_t __cdecl wcsnlen(
    _In_reads_or_z_(_MaxCount) wchar_t const* _Source,
    _In_                       size_t         _MaxCount
    );

#if __STDC_WANT_SECURE_LIB__ && !defined(__midl)

    _Check_return_
    _When_(
        _MaxCount > _String_length_(_Source),
        _Post_satisfies_(return == _String_length_(_Source))
    )
    _When_(
        _MaxCount <= _String_length_(_Source),
        _Post_satisfies_(return == _MaxCount)
    )
    static __inline size_t __CRTDECL wcsnlen_s(
        _In_reads_or_z_(_MaxCount) wchar_t const* _Source,
        _In_                       size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#endif // __STDC_WANT_SECURE_LIB__ && !defined(__midl)
# 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, wcsncat_s,
    _Prepost_z_             wchar_t,        _Destination,
    _In_reads_or_z_(_Count) wchar_t const*, _Source,
    _In_                    size_t,         _Count
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcsncat, wcsncat_s,
    _Inout_updates_z_(_Size)   wchar_t,
    _Inout_updates_z_(_Count), wchar_t,        _Destination,
    _In_reads_or_z_(_Count)    wchar_t const*, _Source,
    _In_                       size_t,         _Count
    )

_Check_return_
_ACRTIMP int __cdecl wcsncmp(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, wcsncpy_s,
                            wchar_t,        _Destination,
    _In_reads_or_z_(_Count) wchar_t const*, _Source,
    _In_                    size_t,         _Count
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcsncpy, wcsncpy_s,
    _Pre_notnull_ _Post_maybez_         wchar_t,
    _Out_writes_(_Count) _Post_maybez_, wchar_t,        _Destination,
    _In_reads_or_z_(_Count)             wchar_t const*, _Source,
    _In_                                size_t,         _Count
    )

_Check_return_
_ACRTIMP wchar_t _CONST_RETURN* __cdecl wcspbrk(
    _In_z_ wchar_t const* _String,
    _In_z_ wchar_t const* _Control
    );

_Check_return_
_ACRTIMP size_t __cdecl wcsspn(
    _In_z_ wchar_t const* _String,
    _In_z_ wchar_t const* _Control
    );

_Check_return_ _CRT_INSECURE_DEPRECATE(wcstok_s)
_ACRTIMP wchar_t* __cdecl wcstok(
    _Inout_opt_z_                     wchar_t*       _String,
    _In_z_                            wchar_t const* _Delimiter,
    _Inout_opt_ _Deref_prepost_opt_z_ wchar_t**      _Context
    );

#if !defined RC_INVOKED && !defined __midl

    #if defined _CRT_NON_CONFORMING_WCSTOK
        #define _WCSTOK_DEPRECATED _CRT_INSECURE_DEPRECATE(wcstok_s)
    #else
# 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
        #define _WCSTOK_DEPRECATED _CRT_DEPRECATE_TEXT(                           \
                "wcstok has been changed to conform with the ISO C standard, "    \
                "adding an extra context parameter. To use the legacy Microsoft " \
                "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")
    #endif
# 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) // Deprecated function use

    _Check_return_ _CRT_INSECURE_DEPRECATE(wcstok_s)
    static __inline wchar_t* __CRTDECL _wcstok(
        _Inout_opt_z_ wchar_t*       const _String,
        _In_z_        wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    #if defined _CRT_NON_CONFORMING_WCSTOK && !defined __cplusplus
        #define wcstok _wcstok
    #endif
# 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

    #if defined __cplusplus && !defined _CRT_NO_INLINE_DEPRECATED_WCSTOK
        extern "C++" _Check_return_ _WCSTOK_DEPRECATED
        inline wchar_t* __CRTDECL wcstok(
            _Inout_opt_z_ wchar_t*       _String,
            _In_z_        wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #endif
# 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

    #pragma warning(pop)

#endif // !defined RC_INVOKED && !defined __midl
# 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3



_Ret_z_
_Check_return_ _CRT_INSECURE_DEPRECATE(_wcserror_s)
_ACRTIMP wchar_t* __cdecl _wcserror(
    _In_ int _ErrorNumber
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcserror_s(
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _Buffer,
    _In_                             size_t   _SizeInWords,
    _In_                             int      _ErrorNumber
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcserror_s,
         wchar_t, _Buffer,
    _In_ int,     _Error
    )

_Ret_z_
_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(__wcserror_s)
_ACRTIMP wchar_t* __cdecl __wcserror(
    _In_opt_z_ wchar_t const* _String
    );

_Check_return_wat_ _ACRTIMP_ALT errno_t __cdecl __wcserror_s(
    _Out_writes_opt_z_(_SizeInWords) wchar_t*       _Buffer,
    _In_                             size_t         _SizeInWords,
    _In_z_                           wchar_t const* _ErrorMessage
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, __wcserror_s,
           wchar_t,        _Buffer,
    _In_z_ wchar_t const*, _ErrorMessage
    )

_Check_return_ _ACRTIMP int __cdecl _wcsicmp(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
    );

_Check_return_ _ACRTIMP int __cdecl _wcsicmp_l(
    _In_z_   wchar_t const* _String1,
    _In_z_   wchar_t const* _String2,
    _In_opt_ _locale_t      _Locale
    );

_Check_return_ _ACRTIMP int __cdecl _wcsnicmp(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
    );

_Check_return_ _ACRTIMP int __cdecl _wcsnicmp_l(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount,
    _In_opt_                   _locale_t      _Locale
    );

_Check_return_wat_ _ACRTIMP errno_t __cdecl _wcsnset_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
    _In_                            size_t   _SizeInWords,
    _In_                            wchar_t  _Value,
    _In_                            size_t   _MaxCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, _wcsnset_s,
    _Prepost_z_ wchar_t, _Destination,
    _In_        wchar_t, _Value,
    _In_         size_t, _MaxCount
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsnset, _wcsnset_s,
    _Inout_updates_z_(_Size)      wchar_t,
    _Inout_updates_z_(_MaxCount), wchar_t, _String,
    _In_                          wchar_t, _Value,
    _In_                          size_t,  _MaxCount
    )

_ACRTIMP wchar_t* __cdecl _wcsrev(
    _Inout_z_ wchar_t* _String
    );

_Check_return_wat_ _ACRTIMP errno_t __cdecl _wcsset_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
    _In_                            size_t   _SizeInWords,
    _In_                            wchar_t  _Value
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcsset_s,
    _Prepost_z_ wchar_t, _String,
    _In_        wchar_t, _Value
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsset, _wcsset_s,
    _Inout_updates_z_(_Size) wchar_t,
    _Inout_z_,               wchar_t, _String,
    _In_                     wchar_t, _Value
    )

_Check_return_wat_ _ACRTIMP errno_t __cdecl _wcslwr_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _String,
    _In_                            size_t   _SizeInWords
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wcslwr_s,
    _Prepost_z_ wchar_t, _String
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcslwr,
    _Inout_z_, wchar_t, _String
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcslwr_s_l(
    _Inout_updates_z_(_SizeInWords) wchar_t*  _String,
    _In_                            size_t    _SizeInWords,
    _In_opt_                        _locale_t _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcslwr_s_l,
    _Prepost_z_ wchar_t,   _String,
    _In_opt_    _locale_t, _Locale
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcslwr_l, _wcslwr_s_l,
    _Inout_updates_z_(_Size) wchar_t,
    _Inout_z_,               wchar_t,   _String,
    _In_opt_                 _locale_t, _Locale
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcsupr_s(
    _Inout_updates_z_(_Size) wchar_t* _String,
    _In_                     size_t   _Size
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wcsupr_s,
    _Prepost_z_ wchar_t, _String
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsupr,
    _Inout_z_, wchar_t, _String
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcsupr_s_l(
    _Inout_updates_z_(_Size) wchar_t*  _String,
    _In_                     size_t    _Size,
    _In_opt_                 _locale_t _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcsupr_s_l,
    _Prepost_z_ wchar_t,   _String,
    _In_opt_    _locale_t, _Locale
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsupr_l, _wcsupr_s_l,
    _Inout_updates_z_(_Size) wchar_t,
    _Inout_z_,               wchar_t,   _String,
    _In_opt_                 _locale_t, _Locale
    )

_Success_(return < _MaxCount)
_Check_return_opt_
_ACRTIMP size_t __cdecl wcsxfrm(
    _Out_writes_opt_(_MaxCount) _Post_maybez_ wchar_t*       _Destination,
    _In_z_                                    wchar_t const* _Source,
    _In_ _In_range_(<= ,_CRT_INT_MAX)         size_t         _MaxCount
    );

_Success_(return < _MaxCount)
_Check_return_opt_
_ACRTIMP size_t __cdecl _wcsxfrm_l(
    _Out_writes_opt_(_MaxCount) _Post_maybez_ wchar_t*       _Destination,
    _In_z_                                    wchar_t const* _Source,
    _In_ _In_range_(<= ,_CRT_INT_MAX)         size_t         _MaxCount,
    _In_opt_                                  _locale_t      _Locale
    );

_Check_return_
_ACRTIMP int __cdecl wcscoll(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
    );

_Check_return_
_ACRTIMP int __cdecl _wcscoll_l(
    _In_z_   wchar_t const* _String1,
    _In_z_   wchar_t const* _String2,
    _In_opt_ _locale_t      _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _wcsicoll(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
    );

_Check_return_
_ACRTIMP int __cdecl _wcsicoll_l(
    _In_z_   wchar_t const* _String1,
    _In_z_   wchar_t const* _String2,
    _In_opt_ _locale_t      _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _wcsncoll(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _wcsncoll_l(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount,
    _In_opt_                   _locale_t      _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _wcsnicoll(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _wcsnicoll_l(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount,
    _In_opt_                   _locale_t      _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline C++ Overloads
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef __cplusplus
extern "C++" {

    _Check_return_
    _When_(return != NULL, _Ret_range_(_String, _String+_String_length_(_String)-1))
    inline wchar_t* __CRTDECL wcschr(_In_z_ wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

    _Check_return_
    inline wchar_t* __CRTDECL wcspbrk(_In_z_ wchar_t* _String, _In_z_ wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

    _Check_return_
    inline wchar_t* __CRTDECL wcsrchr(_In_z_ wchar_t* _String, _In_ wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

    _Check_return_ _Ret_maybenull_
    _When_(return != NULL, _Ret_range_(_String, _String+_String_length_(_String)-1))
    inline wchar_t* __CRTDECL wcsstr(_In_z_ wchar_t* _String, _In_z_ wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#endif // __cplusplus
# 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-Standard Names
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if _CRT_INTERNAL_NONSTDC_NAMES
    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
        #pragma push_macro("wcsdup")
        #undef wcsdup
    #endif
# 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsdup)
    _ACRTIMP wchar_t* __cdecl wcsdup(
        _In_z_ wchar_t const* _String
        );

    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
        #pragma pop_macro("wcsdup")
    #endif
# 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3

    // Declarations of functions defined in oldnames.lib:
    #define wcswcs wcsstr

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicmp)
    _ACRTIMP int __cdecl wcsicmp(
        _In_z_ wchar_t const* _String1,
        _In_z_ wchar_t const* _String2
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsnicmp)
    _ACRTIMP int __cdecl wcsnicmp(
        _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
        _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
        _In_                       size_t         _MaxCount
        );

    _CRT_NONSTDC_DEPRECATE(_wcsnset)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl wcsnset(
        _Inout_updates_z_(_MaxCount) wchar_t* _String,
        _In_                         wchar_t  _Value,
        _In_                         size_t   _MaxCount
        );

    _CRT_NONSTDC_DEPRECATE(_wcsrev)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl wcsrev(
        _Inout_z_ wchar_t* _String
        );

    _CRT_NONSTDC_DEPRECATE(_wcsset)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl wcsset(
        _Inout_z_ wchar_t* _String,
        _In_      wchar_t  _Value
        );

    _CRT_NONSTDC_DEPRECATE(_wcslwr)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl wcslwr(
        _Inout_z_ wchar_t* _String
        );

    _CRT_NONSTDC_DEPRECATE(_wcsupr)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl wcsupr(
        _Inout_z_ wchar_t* _String
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicoll)
    _ACRTIMP int __cdecl wcsicoll(
        _In_z_ wchar_t const* _String1,
        _In_z_ wchar_t const* _String2
        );

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3



_CRT_END_C_HEADER

#endif // !__midl
# 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wtime.h>
#endif /* expanded by -frewrite-includes */
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 1 3
//
// corecrt_wtime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) time functionality, shared
// by <time.h> and <wchar.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3

_CRT_BEGIN_C_HEADER



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide String Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _CRT_INSECURE_DEPRECATE(_wasctime_s)
_Success_(return != 0)
_Ret_writes_z_(26)
_ACRTIMP wchar_t* __cdecl _wasctime(
    _In_ struct tm const* _Tm
    );

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _wasctime_s(
    _Out_writes_z_(_SizeInWords) _Post_readable_size_(26) wchar_t*         _Buffer,
    _In_range_(>=,26)                                     size_t           _SizeInWords,
    _In_                                                  struct tm const* _Tm
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    _Success_(return == 0)
    errno_t, _wasctime_s,
    _Post_readable_size_(26) wchar_t,          _Buffer,
    _In_                     struct tm const*, _Time
    )

_Success_(return > 0)
_Check_return_wat_
_ACRTIMP size_t __cdecl wcsftime(
    _Out_writes_z_(_SizeInWords)  wchar_t*         _Buffer,
    _In_                          size_t           _SizeInWords,
    _In_z_                        wchar_t const*   _Format,
    _In_                          struct tm const* _Tm
    );

_Success_(return > 0)
_Check_return_wat_
_ACRTIMP size_t __cdecl _wcsftime_l(
    _Out_writes_z_(_SizeInWords)  wchar_t*         _Buffer,
    _In_                          size_t           _SizeInWords,
    _In_z_                        wchar_t const*   _Format,
    _In_                          struct tm const* _Tm,
    _In_opt_                      _locale_t        _Locale
    );

_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(_wctime32_s)
_ACRTIMP wchar_t* __cdecl _wctime32(
    _In_ __time32_t const* _Time
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wctime32_s(
    _Out_writes_z_(_SizeInWords) _Post_readable_size_(26) wchar_t*          _Buffer,
    _In_  _In_range_(>=, 26)                              size_t            _SizeInWords,
    _In_                                                  __time32_t const* _Time
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wctime32_s,
    _Post_readable_size_(26) wchar_t,           _Buffer,
    _In_                     __time32_t const*, _Time
    )

_Success_(return != 0)
_Ret_writes_z_(26)
_Check_return_ _CRT_INSECURE_DEPRECATE(_wctime64_s)
_ACRTIMP wchar_t* __cdecl _wctime64(
    _In_ __time64_t const* _Time
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wctime64_s(
    _Out_writes_z_(_SizeInWords) _Post_readable_size_(26) wchar_t*          _Buffer,
    _In_  _In_range_(>=, 26)                              size_t            _SizeInWords,
    _In_                                                  __time64_t const* _Time);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wctime64_s,
    _Post_readable_size_(26) wchar_t,           _Buffer,
    _In_                     __time64_t const*, _Time
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wstrdate_s(
    _Out_writes_z_(_SizeInWords) _When_(_SizeInWords >=9, _Post_readable_size_(9)) wchar_t* _Buffer,
    _In_                                                                           size_t   _SizeInWords
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wstrdate_s,
    _Post_readable_size_(9) wchar_t, _Buffer
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    _Success_(return != 0) _Ret_writes_z_(9) wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wstrdate,
    _Out_writes_z_(9), wchar_t, _Buffer
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wstrtime_s(
    _Out_writes_z_(_SizeInWords) _When_(_SizeInWords >=9, _Post_readable_size_(9)) wchar_t* _Buffer,
    _In_                                                                           size_t   _SizeInWords
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wstrtime_s,
    _Post_readable_size_(9) wchar_t, _Buffer
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    _Success_(return != 0) _Ret_writes_z_(9) wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wstrtime,
    _Out_writes_z_(9), wchar_t, _Buffer
    )



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if !defined RC_INVOKED && !defined __midl && !defined _INC_WTIME_INL && !defined _CRT_NO_TIME_T
    #pragma warning(push)
    #pragma warning(disable: 4996)

    #ifdef _USE_32BIT_TIME_T

        _Check_return_
        static __inline wchar_t* __CRTDECL _wctime(
            _In_ time_t const* const _Time
            )
        {
            return _wctime32(_Time);
        }

        _Check_return_wat_
        static __inline errno_t __CRTDECL _wctime_s(
            _Pre_notnull_ _Post_z_ _Out_writes_z_(_SizeInWords) wchar_t*      const _Buffer,
            _In_                                                size_t        const _SizeInWords,
            _In_                                                time_t const* const _Time)
        {
            return _wctime32_s(_Buffer, _SizeInWords, _Time);
        }

    #else // ^^^ _USE_32BIT_TIME_T ^^^ // vvv !_USE_32BIT_TIME_T vvv //
# 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3

        _Check_return_
        static __inline wchar_t * __CRTDECL _wctime(
            _In_ time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        _Check_return_wat_
        static __inline errno_t __CRTDECL _wctime_s(
            _Pre_notnull_ _Post_z_ _Out_writes_z_(_SizeInWords) wchar_t*      const _Buffer,
            _In_                                                size_t        const _SizeInWords,
            _In_                                                time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #endif // !_USE_32BIT_TIME_T
# 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3

    #pragma warning(pop)
#endif
# 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3



_CRT_END_C_HEADER
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <sys/stat.h>
#endif /* expanded by -frewrite-includes */
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 1 3
//
// sys/stat.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The _stat() and _fstat() families of functions.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 1 3
//
// sys/types.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Types used for returning file status and time information.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3



#ifndef _INO_T_DEFINED
    #define _INO_T_DEFINED

    typedef unsigned short _ino_t; // inode number (unused on Windows)

    #if (defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__)
        typedef _ino_t ino_t;
    #endif
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
#endif
# 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3



#ifndef _DEV_T_DEFINED
    #define _DEV_T_DEFINED

    typedef unsigned int _dev_t; // device code

    #if (defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__)
        typedef _dev_t dev_t;
    #endif
# 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
#endif
# 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3



#ifndef _OFF_T_DEFINED
    #define _OFF_T_DEFINED

    typedef long _off_t; // file offset value

    #if (defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__)
        typedef _off_t off_t;
    #endif
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
#endif
# 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 2 3

_CRT_BEGIN_C_HEADER


#pragma warning(push)
#pragma warning(disable: 4820) /* padding added after data member */


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

#define __stat64 _stat64 // For legacy compatibility

#if _CRT_INTERNAL_NONSTDC_NAMES && !defined _CRT_NO_TIME_T
    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#endif
# 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define _S_IFMT   0xF000 // File type mask
#define _S_IFDIR  0x4000 // Directory
#define _S_IFCHR  0x2000 // Character special
#define _S_IFIFO  0x1000 // Pipe
#define _S_IFREG  0x8000 // Regular
#define _S_IREAD  0x0100 // Read permission, owner
#define _S_IWRITE 0x0080 // Write permission, owner
#define _S_IEXEC  0x0040 // Execute/search permission, owner

#if _CRT_INTERNAL_NONSTDC_NAMES
    #define S_IFMT   _S_IFMT
    #define S_IFDIR  _S_IFDIR
    #define S_IFCHR  _S_IFCHR
    #define S_IFREG  _S_IFREG
    #define S_IREAD  _S_IREAD
    #define S_IWRITE _S_IWRITE
    #define S_IEXEC  _S_IEXEC
#endif
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _USE_32BIT_TIME_T
    #define _fstat      _fstat32
    #define _fstati64   _fstat32i64
    #define _stat       _stat32
    #define _stati64    _stat32i64
    #define _wstat      _wstat32
    #define _wstati64   _wstat32i64
#else
# 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
    #define _fstat      _fstat64i32
    #define _fstati64   _fstat64
    #define _stat       _stat64i32
    #define _stati64    _stat64
    #define _wstat      _wstat64i32
    #define _wstati64   _wstat64
#endif
# 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3



_ACRTIMP int __cdecl _fstat32(
    _In_  int             _FileHandle,
    _Out_ struct _stat32* _Stat
    );

_ACRTIMP int __cdecl _fstat32i64(
    _In_  int                _FileHandle,
    _Out_ struct _stat32i64* _Stat
    );

_ACRTIMP int __cdecl _fstat64i32(
    _In_  int                _FileHandle,
    _Out_ struct _stat64i32* _Stat
    );

_ACRTIMP int __cdecl _fstat64(
    _In_  int             _FileHandle,
    _Out_ struct _stat64* _Stat
    );

_ACRTIMP int __cdecl _stat32(
    _In_z_ char const*     _FileName,
    _Out_  struct _stat32* _Stat
    );

_ACRTIMP int __cdecl _stat32i64(
    _In_z_ char const*        _FileName,
    _Out_  struct _stat32i64* _Stat
    );

_ACRTIMP int __cdecl _stat64i32(
    _In_z_ char const*        _FileName,
    _Out_  struct _stat64i32* _Stat
    );

_ACRTIMP int __cdecl _stat64(
    _In_z_ char const*     _FileName,
    _Out_  struct _stat64* _Stat
    );

_ACRTIMP int __cdecl _wstat32(
    _In_z_ wchar_t const*  _FileName,
    _Out_  struct _stat32* _Stat
    );

_ACRTIMP int __cdecl _wstat32i64(
    _In_z_ wchar_t const*     _FileName,
    _Out_  struct _stat32i64* _Stat
    );

_ACRTIMP int __cdecl _wstat64i32(
    _In_z_ wchar_t const*     _FileName,
    _Out_  struct _stat64i32* _Stat
    );

_ACRTIMP int __cdecl _wstat64(
    _In_z_ wchar_t const*  _FileName,
    _Out_  struct _stat64* _Stat
    );



#if !defined RC_INVOKED && !defined __midl && _CRT_INTERNAL_NONSTDC_NAMES && !defined _CRT_NO_TIME_T
    #ifdef _USE_32BIT_TIME_T

        static __inline int __CRTDECL fstat(int const _FileHandle, struct stat* const _Stat)
        {
            _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat32));
            return _fstat32(_FileHandle, (struct _stat32*)_Stat);
        }

        static __inline int __CRTDECL stat(char const* const _FileName, struct stat* const _Stat)
        {
            _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat32));
            return _stat32(_FileName, (struct _stat32*)_Stat);
        }

    #else
# 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3

        static __inline int __CRTDECL fstat(int const _FileHandle, struct stat* const _Stat)
        {
            _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __CRTDECL stat(char const* const _FileName, struct stat* const _Stat)
        {
            _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #endif
# 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
#endif
# 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3


#pragma warning(pop)


_CRT_END_C_HEADER
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_string.h>
#endif /* expanded by -frewrite-includes */
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3

_CRT_BEGIN_C_HEADER



#define WCHAR_MIN 0x0000
#define WCHAR_MAX 0xffff



typedef wchar_t _Wint_t;



#if _CRT_FUNCTIONS_REQUIRED

    _Check_return_opt_
    _ACRTIMP wchar_t* __cdecl _wsetlocale(
        _In_       int            _Category,
        _In_opt_z_ wchar_t const* _Locale
        );

    _Check_return_opt_
    _ACRTIMP _locale_t __cdecl _wcreate_locale(
        _In_   int            _Category,
        _In_z_ wchar_t const* _Locale
        );



    _ACRTIMP wint_t __cdecl btowc(
        _In_ int _Ch
        );

    _ACRTIMP size_t __cdecl mbrlen(
        _In_reads_bytes_opt_(_SizeInBytes) _Pre_opt_z_ char const* _Ch,
        _In_                                           size_t      _SizeInBytes,
        _Inout_                                        mbstate_t*  _State
        );

    _ACRTIMP size_t __cdecl mbrtowc(
        _Pre_maybenull_ _Post_z_                       wchar_t*    _DstCh,
        _In_reads_bytes_opt_(_SizeInBytes) _Pre_opt_z_ char const* _SrcCh,
        _In_                                           size_t      _SizeInBytes,
        _Inout_                                        mbstate_t*  _State
        );

    _Success_(return == 0)
    _ACRTIMP errno_t __cdecl mbsrtowcs_s(
        _Out_opt_                         size_t*      _Retval,
        _Out_writes_opt_z_(_Size)         wchar_t*     _Dst,
        _In_                              size_t       _Size,
        _Deref_pre_opt_z_                 char const** _PSrc,
        _In_                              size_t       _N,
        _Inout_                           mbstate_t*   _State
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
        _Success_(return == 0)
        errno_t, mbsrtowcs_s,
        _Out_opt_                         size_t*,      _Retval,
        _Post_z_                          wchar_t,      _Dest,
        _Inout_ _Deref_prepost_opt_valid_ char const**, _PSource,
        _In_                              size_t,       _Count,
        _Inout_                           mbstate_t*,   _State
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(
        _Success_(return == 0) _ACRTIMP, mbsrtowcs,
        _Out_writes_opt_z_(_Count),           wchar_t,      _Dest,
        _Deref_pre_opt_z_                 char const**, _PSrc,
        _In_                              size_t,       _Count,
        _Inout_                           mbstate_t*,   _State
        )

    _Success_(return == 0)
    _ACRTIMP errno_t __cdecl wcrtomb_s(
        _Out_opt_                        size_t*    _Retval,
        _Out_writes_opt_z_(_SizeInBytes) char*      _Dst,
        _In_                             size_t     _SizeInBytes,
        _In_                             wchar_t    _Ch,
        _Inout_opt_                      mbstate_t* _State
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(
        _Success_(return == 0)
        errno_t, wcrtomb_s,
        _Out_opt_                 size_t*,    _Retval,
        _Out_writes_opt_z_(_Size) char,       _Dest,
        _In_                      wchar_t,    _Source,
        _Inout_opt_               mbstate_t*, _State
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(
        _ACRTIMP, wcrtomb,
        _Pre_maybenull_ _Post_z_, char,       _Dest,
        _In_                      wchar_t,    _Source,
        _Inout_opt_              mbstate_t*, _State
        )

    _Success_(return == 0)
    _ACRTIMP errno_t __cdecl wcsrtombs_s(
        _Out_opt_                                         size_t*         _Retval,
        _Out_writes_bytes_to_opt_(_SizeInBytes, *_Retval) char*           _Dst,
        _In_                                              size_t          _SizeInBytes,
        _Inout_ _Deref_prepost_z_                         wchar_t const** _Src,
        _In_                                              size_t          _Size,
        _Inout_opt_                                       mbstate_t*      _State
        );

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
        _Success_(return == 0)
        errno_t, wcsrtombs_s,
        _Out_opt_                 size_t*,         _Retval,
        _Out_writes_opt_z_(_Size) char,            _Dest,
        _Inout_ _Deref_prepost_z_ wchar_t const**, _PSrc,
        _In_                      size_t,          _Count,
        _Inout_opt_               mbstate_t*,      _State
        )

    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(
        _ACRTIMP, wcsrtombs,
        _Pre_maybenull_ _Post_z_, char,            _Dest,
        _Inout_ _Deref_prepost_z_ wchar_t const**, _PSource,
        _In_                      size_t,          _Count,
        _Inout_opt_               mbstate_t*,      _State
        )

    _ACRTIMP int __cdecl wctob(
        _In_ wint_t _WCh
        );

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return == 0)
        errno_t __CRTDECL wmemcpy_s(
            _Out_writes_to_opt_(_N1, _N) wchar_t*       _S1,
            _In_                         rsize_t        _N1,
            _In_reads_opt_(_N)           wchar_t const* _S2,
            _In_                         rsize_t        _N
            );

        _Success_(return == 0)
        errno_t __CRTDECL wmemmove_s(
            _Out_writes_to_opt_(_N1, _N) wchar_t*       _S1,
            _In_                         rsize_t        _N1,
            _In_reads_opt_(_N)           wchar_t const* _S2,
            _In_                         rsize_t        _N
            );

    #endif // __STDC_WANT_SECURE_LIB__
# 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3

    __inline int __CRTDECL fwide(
        _In_opt_ FILE* _F,
        _In_     int   _M
        )
    {
        _CRT_UNUSED(_F);
        return (_M);
    }

    __inline int __CRTDECL mbsinit(
        _In_opt_ mbstate_t const* _P
        )
    {
        return _P == NULL || _P->_Wchar == 0;
    }

    __inline wchar_t _CONST_RETURN* __CRTDECL wmemchr(
        _In_reads_(_N) wchar_t const* _S,
        _In_           wchar_t        _C,
        _In_           size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t _CONST_RETURN*)_S;

        return 0;
    }

    __inline int __CRTDECL wmemcmp(
        _In_reads_(_N) wchar_t const* _S1,
        _In_reads_(_N) wchar_t const* _S2,
        _In_           size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

    _Post_equal_to_(_S1)
    _At_buffer_(_S1, _Iter_, _N, _Post_satisfies_(_S1[_Iter_] == _S2[_Iter_]))
    __inline _CRT_INSECURE_DEPRECATE_MEMORY(wmemcpy_s)
    wchar_t* __CRTDECL wmemcpy(
        _Out_writes_all_(_N) wchar_t*       _S1,
        _In_reads_(_N)       wchar_t const* _S2,
        _In_                 size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline _CRT_INSECURE_DEPRECATE_MEMORY(wmemmove_s)
    wchar_t* __CRTDECL wmemmove(
        _Out_writes_all_opt_(_N) wchar_t*       _S1,
        _In_reads_opt_(_N)       wchar_t const* _S2,
        _In_                     size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    _Post_equal_to_(_S)
    _At_buffer_(_S, _Iter_, _N, _Post_satisfies_(_S[_Iter_] == _C))
    __inline wchar_t* __CRTDECL wmemset(
        _Out_writes_all_(_N) wchar_t* _S,
        _In_                 wchar_t  _C,
        _In_                 size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    #ifdef __cplusplus

        extern "C++" inline wchar_t* __CRTDECL wmemchr(
            _In_reads_(_N) wchar_t* _S,
            _In_           wchar_t  _C,
            _In_           size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #endif // __cplusplus
# 278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3

#endif // _CRT_FUNCTIONS_REQUIRED
# 280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3



_CRT_END_C_HEADER
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 2 3

typedef mbstate_t _Mbstatet;

 #ifndef RC_INVOKED
_STD_BEGIN
#pragma warning(push)
#pragma warning(disable: 4995) // name was marked as #pragma deprecated

using _CSTD _Mbstatet;

using _CSTD mbstate_t; using _CSTD size_t; using _CSTD tm; using _CSTD wint_t;

using _CSTD btowc; using _CSTD fgetwc; using _CSTD fgetws; using _CSTD fputwc;
using _CSTD fputws; using _CSTD fwide; using _CSTD fwprintf;
using _CSTD fwscanf; using _CSTD getwc; using _CSTD getwchar;
using _CSTD mbrlen; using _CSTD mbrtowc; using _CSTD mbsrtowcs;
using _CSTD mbsinit; using _CSTD putwc; using _CSTD putwchar;
using _CSTD swprintf; using _CSTD swscanf; using _CSTD ungetwc;
using _CSTD vfwprintf; using _CSTD vswprintf; using _CSTD vwprintf;
using _CSTD wcrtomb; using _CSTD wprintf; using _CSTD wscanf;
using _CSTD wcsrtombs; using _CSTD wcstol; using _CSTD wcscat;
using _CSTD wcschr; using _CSTD wcscmp; using _CSTD wcscoll;
using _CSTD wcscpy; using _CSTD wcscspn; using _CSTD wcslen;
using _CSTD wcsncat; using _CSTD wcsncmp; using _CSTD wcsncpy;
using _CSTD wcspbrk; using _CSTD wcsrchr; using _CSTD wcsspn;
using _CSTD wcstod; using _CSTD wcstoul; using _CSTD wcsstr;
using _CSTD wcstok; using _CSTD wcsxfrm; using _CSTD wctob;
using _CSTD wmemchr; using _CSTD wmemcmp; using _CSTD wmemcpy;
using _CSTD wmemmove; using _CSTD wmemset; using _CSTD wcsftime;

using _CSTD vfwscanf; using _CSTD vswscanf; using _CSTD vwscanf;
using _CSTD wcstof; using _CSTD wcstold;
using _CSTD wcstoll; using _CSTD wcstoull;

#pragma warning(pop)
_STD_END
 #endif /* RC_INVOKED */
# 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 3

#endif /* _CWCHAR_ */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cwchar" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <xstddef>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 1 3
// xstddef internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
#ifndef _XSTDDEF_
#define _XSTDDEF_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <cstddef>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 1 3
// cstddef standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3
#ifndef _CSTDDEF_
#define _CSTDDEF_
#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3
# 1 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 90 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 93 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#    define NULL 0
#  endif
# 104 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#else
# 105 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#  define NULL ((void*)0)
#endif
# 107 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 113 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
# 119 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#endif
# 120 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3

#endif
# 138 "C:\\Program Files\\LLVM\\lib\\clang\\7.0.0\\include\\stddef.h" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <xtr1common>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

_STD_BEGIN
using _CSTD ptrdiff_t; using _CSTD size_t;
typedef double max_align_t;	// most aligned type

#if _HAS_STD_BYTE
	// ENUM CLASS byte
enum class byte : unsigned char { };

template<class _IntType,
	enable_if_t<is_integral_v<_IntType>, int> = 0>
	_NODISCARD constexpr byte operator<<(const byte _Arg, const _IntType _Shift) _NOEXCEPT
	{	// bitwise LEFT SHIFT, every static_cast is intentional
	return (static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) << _Shift)));
	}

template<class _IntType,
	enable_if_t<is_integral_v<_IntType>, int> = 0>
	_NODISCARD constexpr byte operator>>(const byte _Arg, const _IntType _Shift) _NOEXCEPT
	{	// bitwise RIGHT SHIFT, every static_cast is intentional
	return (static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) >> _Shift)));
	}

_NODISCARD constexpr byte operator|(const byte _Left, const byte _Right) _NOEXCEPT
	{	// bitwise OR, every static_cast is intentional
	return (static_cast<byte>(static_cast<unsigned char>(
		static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right))));
	}

_NODISCARD constexpr byte operator&(const byte _Left, const byte _Right) _NOEXCEPT
	{	// bitwise AND, every static_cast is intentional
	return (static_cast<byte>(static_cast<unsigned char>(
		static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right))));
	}

_NODISCARD constexpr byte operator^(const byte _Left, const byte _Right) _NOEXCEPT
	{	// bitwise XOR, every static_cast is intentional
	return (static_cast<byte>(static_cast<unsigned char>(
		static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right))));
	}

_NODISCARD constexpr byte operator~(const byte _Arg) _NOEXCEPT
	{	// bitwise NOT, every static_cast is intentional
	return (static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg))));
	}

template<class _IntType,
	enable_if_t<is_integral_v<_IntType>, int> = 0>
	constexpr byte& operator<<=(byte& _Arg, const _IntType _Shift) _NOEXCEPT
	{	// bitwise LEFT SHIFT
	return (_Arg = _Arg << _Shift);
	}

template<class _IntType,
	enable_if_t<is_integral_v<_IntType>, int> = 0>
	constexpr byte& operator>>=(byte& _Arg, const _IntType _Shift) _NOEXCEPT
	{	// bitwise RIGHT SHIFT
	return (_Arg = _Arg >> _Shift);
	}

constexpr byte& operator|=(byte& _Left, const byte _Right) _NOEXCEPT
	{	// bitwise OR
	return (_Left = _Left | _Right);
	}

constexpr byte& operator&=(byte& _Left, const byte _Right) _NOEXCEPT
	{	// bitwise AND
	return (_Left = _Left & _Right);
	}

constexpr byte& operator^=(byte& _Left, const byte _Right) _NOEXCEPT
	{	// bitwise XOR
	return (_Left = _Left ^ _Right);
	}

template<class _IntType,
	enable_if_t<is_integral_v<_IntType>, int> = 0>
	_NODISCARD constexpr _IntType to_integer(const byte _Arg) _NOEXCEPT
	{	// convert byte to integer
	return (static_cast<_IntType>(_Arg));
	}
#endif /* _HAS_STD_BYTE */
# 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3

_STD_END

using _STD max_align_t;	// intentional, for historical reasons

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)

#endif /* RC_INVOKED */
# 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3
#endif /* _CSTDDEF_ */
# 108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstddef" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\initializer_list" 1 3
// initializer_list standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\initializer_list" 3
#ifndef _INITIALIZER_LIST_
#define _INITIALIZER_LIST_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <cstddef>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\initializer_list" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\initializer_list" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// CLASS TEMPLATE initializer_list
template<class _Elem>
	class initializer_list
	{	// list of pointers to elements
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() _NOEXCEPT
		: _First(0), _Last(0)
		{	// empty list
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) _NOEXCEPT
		: _First(_First_arg), _Last(_Last_arg)
		{	// construct with pointers
		}

	_NODISCARD constexpr const _Elem * begin() const _NOEXCEPT
		{	// get beginning of list
		return (_First);
		}

	_NODISCARD constexpr const _Elem * end() const _NOEXCEPT
		{	// get end of list
		return (_Last);
		}

	_NODISCARD constexpr size_t size() const _NOEXCEPT
		{	// get length of list
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		// FUNCTION TEMPLATE begin
template<class _Elem>
	_NODISCARD constexpr const _Elem * begin(initializer_list<_Elem> _Ilist) _NOEXCEPT
	{	// get beginning of sequence
	return (_Ilist.begin());
	}

		// FUNCTION TEMPLATE end
template<class _Elem>
	_NODISCARD constexpr const _Elem * end(initializer_list<_Elem> _Ilist) _NOEXCEPT
	{	// get end of sequence
	return (_Ilist.end());
	}
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\initializer_list" 3
#endif /* _INITIALIZER_LIST_ */
# 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\initializer_list" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 2 3

#if 0 /* expanded by -frewrite-includes */
#include <xtr1common>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// EXCEPTION MACROS
 #if _HAS_EXCEPTIONS
 #define _TRY_BEGIN	try {
 #define _CATCH(x)	} catch (x) {
 #define _CATCH_ALL	} catch (...) {
 #define _CATCH_END	}

 #define _RAISE(x)	throw x
 #define _RERAISE	throw

 #if defined(MRTDLL) && defined(_M_CEE) && !defined(_M_CEE_PURE) && defined(_CRTBLD)
  #if defined(_DEBUG)
   #define _THROW(x)	_invoke_watson(_CRT_WIDE(#x), __FUNCTIONW__, __FILEW__, __LINE__, 0)
  #else /* defined(_DEBUG) */
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
   #define _THROW(x)	_invoke_watson(0, 0, 0, 0, 0)
  #endif /* defined(_DEBUG) */
# 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
 #else /* defined(MRTDLL) etc. */
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
  #define _THROW(x)	throw x
 #endif /* defined(MRTDLL) etc. */
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #else /* _HAS_EXCEPTIONS */
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
 #define _TRY_BEGIN	{ if (1) {
 #define _CATCH(x)	} else if (0) {
 #define _CATCH_ALL	} else if (0) {
 #define _CATCH_END	} }

 #if defined(_DEBUG)
  #define _RAISE(x)	_invoke_watson(_CRT_WIDE(#x), __FUNCTIONW__, __FILEW__, __LINE__, 0)
 #else /* defined(_DEBUG) */
# 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
  #define _RAISE(x)	_invoke_watson(0, 0, 0, 0, 0)
 #endif /* defined(_DEBUG) */
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #define _RERAISE
 #define _THROW(x)	x._Raise()
 #endif /* _HAS_EXCEPTIONS */
# 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

		// MISCELLANEOUS MACROS
#define _EMPTY_ARGUMENT		/* for empty macro argument */

		// TYPE DEFINITIONS
template<class _Ty>
	struct _Always_false
		: false_type
	{	// false value attached to a dependent name (for static_assert)
	};

		// FUNCTIONAL STUFF (from <functional>)

 #if _HAS_AUTO_PTR_ETC
		// STRUCT TEMPLATE unary_function
template<class _Arg,
	class _Result>
	struct unary_function
	{	// base class for unary functions
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		// STRUCT TEMPLATE binary_function
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	// base class for binary functions
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
 #endif /* _HAS_AUTO_PTR_ETC */
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

		// STRUCT TEMPLATE plus
template<class _Ty = void>
	struct plus
	{	// functor for operator+
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator+ to operands
		return (_Left + _Right);
		}
	};

		// STRUCT TEMPLATE minus
template<class _Ty = void>
	struct minus
	{	// functor for operator-
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator- to operands
		return (_Left - _Right);
		}
	};

		// STRUCT TEMPLATE multiplies
template<class _Ty = void>
	struct multiplies
	{	// functor for operator*
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator* to operands
		return (_Left * _Right);
		}
	};

		// STRUCT TEMPLATE equal_to
template<class _Ty = void>
	struct equal_to
	{	// functor for operator==
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator== to operands
		return (_Left == _Right);
		}
	};

		// STRUCT TEMPLATE less
template<class _Ty = void>
	struct less
	{	// functor for operator<
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator< to operands
		return (_Left < _Right);
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION plus
template<>
	struct plus<void>
	{	// transparent functor for operator+
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator+ to operands
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION minus
template<>
	struct minus<void>
	{	// transparent functor for operator-
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator- to operands
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION multiplies
template<>
	struct multiplies<void>
	{	// transparent functor for operator*
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator* to operands
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION equal_to
template<>
	struct equal_to<void>
	{	// transparent functor for operator==
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator== to operands
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION less
template<>
	struct less<void>
	{	// transparent functor for operator<
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator< to operands
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};

		// FUNCTION TEMPLATE addressof
template<class _Ty>
	_NODISCARD constexpr _Ty * addressof(_Ty& _Val) _NOEXCEPT
	{	// return address of _Val
	return (__builtin_addressof(_Val));
	}

template<class _Ty>
	const _Ty * addressof(const _Ty&&) = delete;

		// FUNCTION TEMPLATE _Unfancy
template<class _Ptrty> inline
	auto _Unfancy(_Ptrty _Ptr)
	{	// converts from a fancy pointer to a plain pointer
	return (_STD addressof(*_Ptr));
	}

template<class _Ty> inline
	_Ty * _Unfancy(_Ty * _Ptr)
	{	// do nothing for plain pointers
	return (_Ptr);
	}
_STD_END

#define _EMIT_CDECL(FUNC, OPT1, OPT2, OPT3) \
	FUNC(__cdecl, OPT1, OPT2, OPT3)

 #ifdef _M_CEE
#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3) \
	FUNC(__clrcall, OPT1, OPT2, OPT3)

 #else /* _M_CEE */
# 277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* _M_CEE */
# 279 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #if defined(_M_IX86) && !defined(_M_CEE)
#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3) \
	FUNC(__fastcall, OPT1, OPT2, OPT3)

 #else /* defined(_M_IX86) && !defined(_M_CEE) */
# 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* defined(_M_IX86) && !defined(_M_CEE) */
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #ifdef _M_IX86
#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3) \
	FUNC(__stdcall, OPT1, OPT2, OPT3)
#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3) \
	FUNC(__thiscall, OPT1, OPT2, OPT3)

 #else /* _M_IX86 */
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3)
#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* _M_IX86 */
# 298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #if ((defined(_M_IX86) && _M_IX86_FP >= 2) \
	|| defined(_M_X64)) && !defined(_M_CEE)
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3) \
	FUNC(__vectorcall, OPT1, OPT2, OPT3)

 #else /* defined(_M_IX86) && _M_IX86_FP >= 2 etc. */
# 305 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3)
 #endif /* defined(_M_IX86) && _M_IX86_FP >= 2 etc. */
# 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

#define _NON_MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)

#define _NON_MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT) \
	_NON_MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT) \
	_NON_MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT) \
	_NON_MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \
	_NON_MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)

#define _NON_MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \
	_NON_MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT) \
	_NON_MEMBER_CALL_CV(FUNC, &, NOEXCEPT_OPT) \
	_NON_MEMBER_CALL_CV(FUNC, &&, NOEXCEPT_OPT)

#if _HAS_NOEXCEPT_FUNCTION_TYPES
 #define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
	_NON_MEMBER_CALL_CV_REF(FUNC, ) \
	_NON_MEMBER_CALL_CV_REF(FUNC, noexcept)
#else /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
 #define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
	_NON_MEMBER_CALL_CV_REF(FUNC, )
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

#define _MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_THISCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
	_EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)

#define _MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT) \
	_MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT) \
	_MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT) \
	_MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \
	_MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)

#define _MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \
	_MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT) \
	_MEMBER_CALL_CV(FUNC, &, NOEXCEPT_OPT) \
	_MEMBER_CALL_CV(FUNC, &&, NOEXCEPT_OPT)

#if _HAS_NOEXCEPT_FUNCTION_TYPES
 #define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
	_MEMBER_CALL_CV_REF(FUNC, ) \
	_MEMBER_CALL_CV_REF(FUNC, noexcept)
#else /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
 #define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
	_MEMBER_CALL_CV_REF(FUNC, )
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 362 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

#define _CLASS_DEFINE_CONST(CLASS) \
	CLASS(_EMPTY_ARGUMENT) \
	CLASS(const)

#define _CLASS_DEFINE_CV(CLASS) \
	CLASS(_EMPTY_ARGUMENT) \
	CLASS(const) \
	CLASS(volatile) \
	CLASS(const volatile)

#if _HAS_NOEXCEPT_FUNCTION_TYPES
 #define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \
	CLASS(_EMPTY_ARGUMENT) \
	CLASS(const) \
	CLASS(volatile) \
	CLASS(const volatile) \
	CLASS(&) \
	CLASS(const &) \
	CLASS(volatile &) \
	CLASS(const volatile &) \
	CLASS(&&) \
	CLASS(const &&) \
	CLASS(volatile &&) \
	CLASS(const volatile &&) \
	CLASS(noexcept) \
	CLASS(const noexcept) \
	CLASS(volatile noexcept) \
	CLASS(const volatile noexcept) \
	CLASS(& noexcept) \
	CLASS(const & noexcept) \
	CLASS(volatile & noexcept) \
	CLASS(const volatile & noexcept) \
	CLASS(&& noexcept) \
	CLASS(const && noexcept) \
	CLASS(volatile && noexcept) \
	CLASS(const volatile && noexcept)
#else /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 400 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
 #define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \
	CLASS(_EMPTY_ARGUMENT) \
	CLASS(const) \
	CLASS(volatile) \
	CLASS(const volatile) \
	CLASS(&) \
	CLASS(const &) \
	CLASS(volatile &) \
	CLASS(const volatile &) \
	CLASS(&&) \
	CLASS(const &&) \
	CLASS(volatile &&) \
	CLASS(const volatile &&)
#endif /* _HAS_NOEXCEPT_FUNCTION_TYPES */
# 414 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 419 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3
#endif /* _XSTDDEF_ */
# 420 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstddef" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
//	ASSUMES:
//	wraparound 2's complement integer arithmetic w/o traps
//	all CHAR_BITs of each byte used by integers
//	IEC559 (IEEE 754) floating-point arithmetic
//	long double is 53, 64, or 113 bits
//	floating-point errors can trap
//	tinyness detected before floating-point rounding
//	64-bit long long

//	floating-point values:
//	MAX = (1 - 2^-PREC) * 2^MAXEXP
//	MIN = 2^(MINEXP - 1)
//	EPS = 2^(1 - PREC)
//	DEN = 2^(MINEXP - PREC)

 #define _STCONS(ty, name, val)	static constexpr ty name = (ty)(val)

 #define _FLT_MIN	FLT_MIN
 #define _FLT_MAX	FLT_MAX
 #define _FLT_EPSILON	FLT_EPSILON
 #define _FLT_TRUE_MIN	FLT_TRUE_MIN

 #define _DBL_MIN	DBL_MIN
 #define _DBL_MAX	DBL_MAX
 #define _DBL_EPSILON	DBL_EPSILON
 #define _DBL_TRUE_MIN	DBL_TRUE_MIN

 #define _LDBL_MIN	LDBL_MIN
 #define _LDBL_MAX	LDBL_MAX
 #define _LDBL_EPSILON	LDBL_EPSILON
 #define _LDBL_TRUE_MIN	LDBL_TRUE_MIN

		// ENUM float_denorm_style
typedef enum
	{	// constants for different IEEE float denormalization styles
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		// ENUM float_round_style
typedef enum
	{	// constants for different IEEE rounding styles
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		// STRUCT _Num_base
struct _Num_base
	{	// base for all types, with common defaults
	_STCONS(float_denorm_style, has_denorm, denorm_absent);
	_STCONS(bool, has_denorm_loss, false);
	_STCONS(bool, has_infinity, false);
	_STCONS(bool, has_quiet_NaN, false);
	_STCONS(bool, has_signaling_NaN, false);
	_STCONS(bool, is_bounded, false);
	_STCONS(bool, is_exact, false);
	_STCONS(bool, is_iec559, false);
	_STCONS(bool, is_integer, false);
	_STCONS(bool, is_modulo, false);
	_STCONS(bool, is_signed, false);
	_STCONS(bool, is_specialized, false);
	_STCONS(bool, tinyness_before, false);
	_STCONS(bool, traps, false);
	_STCONS(float_round_style, round_style, round_toward_zero);
	_STCONS(int, digits, 0);
	_STCONS(int, digits10, 0);

	_STCONS(int, max_digits10, 0);

	_STCONS(int, max_exponent, 0);
	_STCONS(int, max_exponent10, 0);
	_STCONS(int, min_exponent, 0);
	_STCONS(int, min_exponent10, 0);
	_STCONS(int, radix, 0);
	};

		// CLASS TEMPLATE numeric_limits
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	// numeric limits for arbitrary type _Ty (say little or nothing)
public:
	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (_Ty());
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	// numeric limits for const types
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	// numeric limits for volatile types
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	// numeric limits for const volatile types
	};

		// STRUCT _Num_int_base
struct _Num_int_base
	: public _Num_base
	{	// base for integer types
	_STCONS(bool, is_bounded, true);
	_STCONS(bool, is_exact, true);
	_STCONS(bool, is_integer, true);
	_STCONS(bool, is_modulo, true);
	_STCONS(bool, is_specialized, true);
	_STCONS(int, radix, 2);
	};

		// STRUCT _Num_float_base
struct _Num_float_base
	: public _Num_base
	{	// base for floating-point types
	_STCONS(float_denorm_style, has_denorm, denorm_present);
	_STCONS(bool, has_denorm_loss, true);
	_STCONS(bool, has_infinity, true);
	_STCONS(bool, has_quiet_NaN, true);
	_STCONS(bool, has_signaling_NaN, true);
	_STCONS(bool, is_bounded, true);
	_STCONS(bool, is_exact, false);
	_STCONS(bool, is_iec559, true);
	_STCONS(bool, is_integer, false);
	_STCONS(bool, is_modulo, false);
	_STCONS(bool, is_signed, true);
	_STCONS(bool, is_specialized, true);
	_STCONS(bool, tinyness_before, true);
	_STCONS(bool, traps, false);
	_STCONS(float_round_style, round_style, round_to_nearest);
	_STCONS(int, radix, FLT_RADIX);
	};

		// CLASS numeric_limits<char>
template<> class numeric_limits<char>
	: public _Num_int_base
	{	// limits for type char
public:
	typedef char _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (CHAR_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (CHAR_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, CHAR_MIN != 0);
	_STCONS(int, digits, CHAR_BIT - (CHAR_MIN != 0 ? 1 : 0));
	_STCONS(int, digits10, (CHAR_BIT - (CHAR_MIN != 0 ? 1 : 0))
		* 301L / 1000);
	};

		// CLASS numeric_limits<wchar_t>
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	// limits for type wchar_t
public:
	typedef wchar_t _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return ((_Ty)WCHAR_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return ((_Ty)WCHAR_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, WCHAR_MIN != 0);
	_STCONS(int, digits, CHAR_BIT * sizeof (wchar_t)
		- (WCHAR_MIN != 0 ? 1 : 0));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (wchar_t)
		- (WCHAR_MIN != 0 ? 1 : 0)) * 301L / 1000);
	};

		// CLASS numeric_limits<bool>
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	// limits for type bool
public:
	typedef bool _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (false);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (true);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_modulo, false);
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, 1);
	_STCONS(int, digits10, 0);
	};

		// CLASS numeric_limits<signed char>
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	// limits for type signed char
public:
	typedef signed char _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (SCHAR_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (SCHAR_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT - 1);
	_STCONS(int, digits10, (CHAR_BIT - 1) * 301L / 1000);
	};

		// CLASS numeric_limits<unsigned char>
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	// limits for type unsigned char
public:
	typedef unsigned char _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (UCHAR_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT);
	_STCONS(int, digits10, CHAR_BIT * 301L / 1000);
	};

		// CLASS numeric_limits<short>
template<> class numeric_limits<short>
	: public _Num_int_base
	{	// limits for type short
public:
	typedef short _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (SHRT_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (SHRT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (short) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (short) - 1)
		* 301L / 1000);
	};

 #ifdef _NATIVE_WCHAR_T_DEFINED
		// CLASS numeric_limits<unsigned short>
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	// limits for type unsigned short
public:
	typedef unsigned short _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (USHRT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned short));
	_STCONS(int, digits10, CHAR_BIT * sizeof (unsigned short)
		* 301L / 1000);
	};
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 610 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3

		// CLASS numeric_limits<char16_t>
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	// limits for type char16_t
public:
	typedef char16_t _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (USHRT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (char16_t));
	_STCONS(int, digits10, CHAR_BIT * sizeof (char16_t)
		* 301L / 1000);
	};

		// CLASS numeric_limits<int>
template<> class numeric_limits<int>
	: public _Num_int_base
	{	// limits for type int
public:
	typedef int _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (INT_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (INT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (int) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (int) - 1)
		* 301L / 1000);
	};

		// CLASS numeric_limits<unsigned int>
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	// limits for type unsigned int
public:
	typedef unsigned int _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (UINT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned int));
	_STCONS(int, digits10, CHAR_BIT * sizeof (unsigned int)
		* 301L / 1000);
	};

		// CLASS numeric_limits<long>
template<> class numeric_limits<long>
	: public _Num_int_base
	{	// limits for type long
public:
	typedef long _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (LONG_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (LONG_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (long) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (long) - 1)
		* 301L / 1000);
	};

		// CLASS numeric_limits<unsigned long>
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	// limits for type unsigned long
public:
	typedef unsigned long _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (ULONG_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned long));
	_STCONS(int, digits10, CHAR_BIT * sizeof (unsigned long)
		* 301L / 1000);
	};

		// CLASS numeric_limits<char32_t>
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	// limits for type char32_t
public:
	typedef char32_t _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (UINT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (char32_t));
	_STCONS(int, digits10, CHAR_BIT * sizeof (char32_t)
		* 301L / 1000);
	};

		// CLASS numeric_limits<long long>
template<> class numeric_limits<long long>
	: public _Num_int_base
	{	// limits for type long long
public:
	typedef long long _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (LLONG_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (LLONG_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (long long) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (long long) - 1)
		* 301L / 1000);
	};

		// CLASS numeric_limits<unsigned long long>
template<> class numeric_limits<unsigned long long>
	: public _Num_int_base
	{	// limits for type unsigned long long
public:
	typedef unsigned long long _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (0);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (ULLONG_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return ((min)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (0);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (0);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (0);
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (0);
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (0);
		}

	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned long long));
	_STCONS(int, digits10, CHAR_BIT * sizeof (unsigned long long)
		* 301L / 1000);
	};

		// CLASS numeric_limits<float>
template<> class numeric_limits<float>
	: public _Num_float_base
	{	// limits for type float
public:
	typedef float _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (_FLT_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (_FLT_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return (-(max)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (_FLT_EPSILON);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0.5F);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (_FLT_TRUE_MIN);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (__builtin_huge_valf());
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (__builtin_nanf("0"));
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (__builtin_nansf("1"));
		}

	_STCONS(int, digits, FLT_MANT_DIG);
	_STCONS(int, digits10, FLT_DIG);

	_STCONS(int, max_digits10, 2 + FLT_MANT_DIG * 301L / 1000);

	_STCONS(int, max_exponent, (int)FLT_MAX_EXP);
	_STCONS(int, max_exponent10, (int)FLT_MAX_10_EXP);
	_STCONS(int, min_exponent, (int)FLT_MIN_EXP);
	_STCONS(int, min_exponent10, (int)FLT_MIN_10_EXP);
	};

		// CLASS numeric_limits<double>
template<> class numeric_limits<double>
	: public _Num_float_base
	{	// limits for type double
public:
	typedef double _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (_DBL_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (_DBL_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return (-(max)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (_DBL_EPSILON);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0.5);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (_DBL_TRUE_MIN);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (__builtin_huge_val());
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (__builtin_nan("0"));
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (__builtin_nans("1"));
		}

	_STCONS(int, digits, DBL_MANT_DIG);
	_STCONS(int, digits10, DBL_DIG);

	_STCONS(int, max_digits10, 2 + DBL_MANT_DIG * 301L / 1000);

	_STCONS(int, max_exponent, (int)DBL_MAX_EXP);
	_STCONS(int, max_exponent10, (int)DBL_MAX_10_EXP);
	_STCONS(int, min_exponent, (int)DBL_MIN_EXP);
	_STCONS(int, min_exponent10, (int)DBL_MIN_10_EXP);
	};

		// CLASS numeric_limits<long double>
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	// limits for type long double
public:
	typedef long double _Ty;

	_NODISCARD static constexpr _Ty (min)() _NOEXCEPT
		{	// return minimum value
		return (_LDBL_MIN);
		}

	_NODISCARD static constexpr _Ty (max)() _NOEXCEPT
		{	// return maximum value
		return (_LDBL_MAX);
		}

	_NODISCARD static constexpr _Ty lowest() _NOEXCEPT
		{	// return most negative value
		return (-(max)());
		}

	_NODISCARD static constexpr _Ty epsilon() _NOEXCEPT
		{	// return smallest effective increment from 1.0
		return (_LDBL_EPSILON);
		}

	_NODISCARD static constexpr _Ty round_error() _NOEXCEPT
		{	// return largest rounding error
		return (0.5L);
		}

	_NODISCARD static constexpr _Ty denorm_min() _NOEXCEPT
		{	// return minimum denormalized value
		return (_LDBL_TRUE_MIN);
		}

	_NODISCARD static constexpr _Ty infinity() _NOEXCEPT
		{	// return positive infinity
		return (__builtin_huge_val());
		}

	_NODISCARD static constexpr _Ty quiet_NaN() _NOEXCEPT
		{	// return non-signaling NaN
		return (__builtin_nan("0"));
		}

	_NODISCARD static constexpr _Ty signaling_NaN() _NOEXCEPT
		{	// return signaling NaN
		return (__builtin_nans("1"));
		}

	_STCONS(int, digits, LDBL_MANT_DIG);
	_STCONS(int, digits10, LDBL_DIG);

	_STCONS(int, max_digits10, 2 + LDBL_MANT_DIG * 301L / 1000);

	_STCONS(int, max_exponent, (int)LDBL_MAX_EXP);
	_STCONS(int, max_exponent10, (int)LDBL_MAX_10_EXP);
	_STCONS(int, min_exponent, (int)LDBL_MIN_EXP);
	_STCONS(int, min_exponent10, (int)LDBL_MIN_10_EXP);
	};

  #if !defined(_MSC_EXTENSIONS)
   #undef _STCONS
   #define _STCONS(ty, name, val)	\
		__declspec(selectany) constexpr ty _STCLASS::name

  #undef _STCLASS
  #define _STCLASS	_Num_base
	_STCONS(float_denorm_style, has_denorm, denorm_absent);
	_STCONS(bool, has_denorm_loss, false);
	_STCONS(bool, has_infinity, false);
	_STCONS(bool, has_quiet_NaN, false);
	_STCONS(bool, has_signaling_NaN, false);
	_STCONS(bool, is_bounded, false);
	_STCONS(bool, is_exact, false);
	_STCONS(bool, is_iec559, false);
	_STCONS(bool, is_integer, false);
	_STCONS(bool, is_modulo, false);
	_STCONS(bool, is_signed, false);
	_STCONS(bool, is_specialized, false);
	_STCONS(bool, tinyness_before, false);
	_STCONS(bool, traps, false);
	_STCONS(float_round_style, round_style, round_toward_zero);
	_STCONS(int, digits, 0);
	_STCONS(int, digits10, 0);

	_STCONS(int, max_digits10, 0);

	_STCONS(int, max_exponent, 0);
	_STCONS(int, max_exponent10, 0);
	_STCONS(int, min_exponent, 0);
	_STCONS(int, min_exponent10, 0);
	_STCONS(int, radix, 0);

  #undef _STCLASS
  #define _STCLASS	_Num_int_base
	_STCONS(bool, is_bounded, true);
	_STCONS(bool, is_exact, true);
	_STCONS(bool, is_integer, true);
	_STCONS(bool, is_modulo, true);
	_STCONS(bool, is_specialized, true);
	_STCONS(int, radix, 2);

  #undef _STCLASS
  #define _STCLASS	_Num_float_base
	_STCONS(float_denorm_style, has_denorm, denorm_present);
	_STCONS(bool, has_denorm_loss, true);
	_STCONS(bool, has_infinity, true);
	_STCONS(bool, has_quiet_NaN, true);
	_STCONS(bool, has_signaling_NaN, true);
	_STCONS(bool, is_bounded, true);
	_STCONS(bool, is_exact, false);
	_STCONS(bool, is_iec559, true);
	_STCONS(bool, is_integer, false);
	_STCONS(bool, is_modulo, false);
	_STCONS(bool, is_signed, true);
	_STCONS(bool, is_specialized, true);
	_STCONS(bool, tinyness_before, true);
	_STCONS(bool, traps, false);
	_STCONS(float_round_style, round_style, round_to_nearest);
	_STCONS(int, radix, FLT_RADIX);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<char>
	_STCONS(bool, is_signed, CHAR_MIN != 0);
	_STCONS(int, digits, CHAR_BIT - (CHAR_MIN != 0 ? 1 : 0));
	_STCONS(int, digits10, (CHAR_BIT - (CHAR_MIN != 0 ? 1 : 0) - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<wchar_t>
	_STCONS(bool, is_signed, WCHAR_MIN != 0);
	_STCONS(int, digits, CHAR_BIT * sizeof (wchar_t)
		- (WCHAR_MIN != 0 ? 1 : 0));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (wchar_t)
		- (WCHAR_MIN != 0 ? 1 : 0) - 1) * 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<bool>
	_STCONS(bool, is_modulo, false);
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, 1);
	_STCONS(int, digits10, 0);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<signed char>
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT - 1);
	_STCONS(int, digits10, (CHAR_BIT - 1 - 1) * 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<unsigned char>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT);
	_STCONS(int, digits10, (CHAR_BIT - 1) * 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<short>
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (short) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (short) - 1 - 1)
		* 301L / 1000);

 #ifdef _NATIVE_WCHAR_T_DEFINED
  #undef _STCLASS
  #define _STCLASS	numeric_limits<unsigned short>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned short));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (unsigned short) - 1)
		* 301L / 1000);
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 1374 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3

  #undef _STCLASS
  #define _STCLASS	numeric_limits<char16_t>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (char16_t));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (char16_t) - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<int>
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (int) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (int) - 1 - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<unsigned int>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned int));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (unsigned int) - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<long>
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (long) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (long) - 1 - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<unsigned long>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned long));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (unsigned long) - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<char32_t>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (char32_t));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (char32_t) - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<long long>
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (long long) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (long long) - 1 - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<unsigned long long>
	_STCONS(bool, is_signed, false);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned long long));
	_STCONS(int, digits10, (CHAR_BIT * sizeof (unsigned long long) - 1)
		* 301L / 1000);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<float>
	_STCONS(int, digits, FLT_MANT_DIG);
	_STCONS(int, digits10, FLT_DIG);

	_STCONS(int, max_digits10, 2 + FLT_MANT_DIG * 301L / 1000);

	_STCONS(int, max_exponent, (int)FLT_MAX_EXP);
	_STCONS(int, max_exponent10, (int)FLT_MAX_10_EXP);
	_STCONS(int, min_exponent, (int)FLT_MIN_EXP);
	_STCONS(int, min_exponent10, (int)FLT_MIN_10_EXP);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<double>
	_STCONS(int, digits, DBL_MANT_DIG);
	_STCONS(int, digits10, DBL_DIG);

	_STCONS(int, max_digits10, 2 + DBL_MANT_DIG * 301L / 1000);

	_STCONS(int, max_exponent, (int)DBL_MAX_EXP);
	_STCONS(int, max_exponent10, (int)DBL_MAX_10_EXP);
	_STCONS(int, min_exponent, (int)DBL_MIN_EXP);
	_STCONS(int, min_exponent10, (int)DBL_MIN_10_EXP);

  #undef _STCLASS
  #define _STCLASS	numeric_limits<long double>
	_STCONS(int, digits, LDBL_MANT_DIG);
	_STCONS(int, digits10, LDBL_DIG);

	_STCONS(int, max_digits10, 2 + LDBL_MANT_DIG * 301L / 1000);

	_STCONS(int, max_exponent, (int)LDBL_MAX_EXP);
	_STCONS(int, max_exponent10, (int)LDBL_MAX_10_EXP);
	_STCONS(int, min_exponent, (int)LDBL_MIN_EXP);
	_STCONS(int, min_exponent10, (int)LDBL_MIN_10_EXP);
  #endif /* !defined(_MSC_EXTENSIONS) */
# 1467 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3

 #undef _FLT_MIN
 #undef _FLT_MAX
 #undef _FLT_EPSILON
 #undef _FLT_TRUE_MIN

 #undef _DBL_MIN
 #undef _DBL_MAX
 #undef _DBL_EPSILON
 #undef _DBL_TRUE_MIN

 #undef _LDBL_MIN
 #undef _LDBL_MAX
 #undef _LDBL_EPSILON
 #undef _LDBL_TRUE_MIN
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1487 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3
#endif /* _LIMITS_ */
# 1488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\limits" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <new>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 1 3
// new standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3
#ifndef _NEW_
#define _NEW_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 1 3
// exception standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
#ifndef _EXCEPTION_
#define _EXCEPTION_
#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 1 3
// type_traits standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
#ifndef _TYPE_TRAITS_
#define _TYPE_TRAITS_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xstddef>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

 #pragma warning(disable: 4180)	// qualifier applied to function type has no meaning; ignored

_STD_BEGIN
	// STRUCT TEMPLATE integer_sequence
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	// sequence of integer parameters
	static_assert(is_integral_v<_Ty>,
		"integer_sequence<T, I...> requires T to be an integral type.");

	using value_type = _Ty;

	_NODISCARD static constexpr size_t size() _NOEXCEPT
		{	// get length of parameter list
		return (sizeof...(_Vals));
		}
	};

	// ALIAS TEMPLATE make_integer_sequence
template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

	// VARIABLE TEMPLATES _None_of_v AND _Is_any_of_v
template<bool... _Bools>
	_INLINE_VAR constexpr bool _None_of_v = is_same_v<
		integer_sequence<bool, false, _Bools...>,
		integer_sequence<bool, _Bools..., false>>;	// TRANSITION, fold expressions

template<class _Ty,
	class... _Types>
	_INLINE_VAR constexpr bool _Is_any_of_v = !_None_of_v<is_same<_Ty, _Types>::value...>;	// TRANSITION, VSO#444168

	// STRUCT TEMPLATE _Arg_types
template<class... _Types>
	struct _Arg_types
	{	// provide argument_type, etc. (sometimes)
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	// provide argument_type, etc. (sometimes)
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	// provide argument_type, etc. (sometimes)
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty2 second_argument_type;
	};

	// STRUCT TEMPLATE is_function
template<class _Ty>
	struct _Is_function
	{	// determine whether _Ty is a function
	using _Bool_type = false_type;
	};

#define _IS_FUNCTION(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
template<class _Ret, \
	class... _Types> \
	struct _Is_function<_Ret CALL_OPT (_Types...) CV_OPT REF_OPT NOEXCEPT_OPT> \
		: _Arg_types<_Types...> \
	{	/* determine whether _Ty is a function */ \
	using _Bool_type = true_type; \
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type; \
	};

_NON_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_FUNCTION)
#undef _IS_FUNCTION

#define _IS_FUNCTION_ELLIPSIS(CV_REF_NOEXCEPT_OPT) \
template<class _Ret, \
	class... _Types> \
	struct _Is_function<_Ret (_Types..., ...) CV_REF_NOEXCEPT_OPT> \
	{	/* no calling conventions for ellipsis */ \
	using _Bool_type = true_type; \
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type; \
	};

_CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_FUNCTION_ELLIPSIS)
#undef _IS_FUNCTION_ELLIPSIS

template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	// determine whether _Ty is a function
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_function_v = is_function<_Ty>::value;


template<class _Ty>
	struct _Is_memfunptr
	{	// base class for member function pointer predicates
	using _Bool_type = false_type;
	};

#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
template<class _Ret, \
	class _Arg0, \
	class... _Types> \
	struct _Is_memfunptr<_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT> \
		: _Arg_types<CV_OPT _Arg0 *, _Types...> \
	{	/* base class for member function pointer predicates */ \
	using _Bool_type = true_type; \
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type; \
	using _Class_type = _Arg0; \
	using _Guide_type = enable_if<!is_same_v<int REF_OPT, int&&>, _Ret (_Types...)>; \
	};

_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR

#define _IS_MEMFUNPTR_ELLIPSIS(CV_REF_NOEXCEPT_OPT) \
template<class _Ret, \
	class _Arg0, \
	class... _Types> \
	struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) CV_REF_NOEXCEPT_OPT> \
	{	/* no calling conventions for ellipsis */ \
	using _Bool_type = true_type; \
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type; \
	using _Class_type = _Arg0; \
	using _Guide_type = enable_if<false>; \
	};

_CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_MEMFUNPTR_ELLIPSIS)
#undef _IS_MEMFUNPTR_ELLIPSIS

	// STRUCT TEMPLATE is_void
template<class _Ty>
	struct is_void
		: false_type
	{	// determine whether _Ty is void
	};

#define _IS_VOID(CV_OPT) \
template<> \
	struct is_void<CV_OPT void> \
		: true_type \
	{	/* determine whether _Ty is void */ \
	};

_CLASS_DEFINE_CV(_IS_VOID)
#undef _IS_VOID

template<class _Ty>
	_INLINE_VAR constexpr bool is_void_v = is_void<_Ty>::value;

	// ALIAS TEMPLATE void_t
template<class... _Types>
	using void_t = void;

	// Type modifiers
	// STRUCT TEMPLATE add_const
template<class _Ty>
	struct add_const
	{	// add top level const qualifier
	using type = const _Ty;
	};

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

	// STRUCT TEMPLATE add_volatile
template<class _Ty>
	struct add_volatile
	{	// add top level volatile qualifier
	using type = volatile _Ty;
	};

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

	// STRUCT TEMPLATE add_cv
template<class _Ty>
	struct add_cv
	{	// add top level const and volatile qualifiers
	using type = const volatile _Ty;
	};

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

	// STRUCT TEMPLATE _Add_reference
template<class _Ty,
	class = void>
	struct _Add_reference
	{	// add reference
	using _Lvalue = _Ty;
	using _Rvalue = _Ty;
	};

template<class _Ty>
	struct _Add_reference<_Ty, void_t<_Ty&>>
	{	// add reference
	using _Lvalue = _Ty&;
	using _Rvalue = _Ty&&;
	};

	// STRUCT TEMPLATE add_lvalue_reference
template<class _Ty>
	struct add_lvalue_reference
	{	// add lvalue reference
	using type = typename _Add_reference<_Ty>::_Lvalue;
	};

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

	// STRUCT TEMPLATE add_rvalue_reference
template<class _Ty>
	struct add_rvalue_reference
	{	// add rvalue reference
	using type = typename _Add_reference<_Ty>::_Rvalue;
	};

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

	// FUNCTION TEMPLATE declval
template<class _Ty>
	add_rvalue_reference_t<_Ty> declval() _NOEXCEPT;

	// STRUCT TEMPLATE remove_extent
template<class _Ty>
	struct remove_extent
	{	// remove array extent
	using type = _Ty;
	};

template<class _Ty, size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	// remove array extent
	using type = _Ty;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	// remove array extent
	using type = _Ty;
	};

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

	// STRUCT TEMPLATE remove_all_extents
template<class _Ty>
	struct remove_all_extents
	{	// remove all array extents
	using type = _Ty;
	};

template<class _Ty, size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	// remove all array extents
	using type = typename remove_all_extents<_Ty>::type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	// remove all array extents
	using type = typename remove_all_extents<_Ty>::type;
	};

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

	// STRUCT TEMPLATE remove_pointer
template<class _Ty>
	struct remove_pointer
	{	// remove pointer
	using type = _Ty;
	};

#define _REMOVE_POINTER(CV_OPT) \
template<class _Ty> \
	struct remove_pointer<_Ty *CV_OPT> \
	{	/* remove pointer */ \
	using type = _Ty; \
	};

_CLASS_DEFINE_CV(_REMOVE_POINTER)
#undef _REMOVE_POINTER

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

	// STRUCT TEMPLATE add_pointer
template<class _Ty,
	class = void>
	struct _Add_pointer
	{	// add pointer
	using type = _Ty;
	};

template<class _Ty>
	struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty> *>>
	{	// add pointer
	using type = remove_reference_t<_Ty> *;
	};

template<class _Ty>
	struct add_pointer
	{	// add pointer
	using type = typename _Add_pointer<_Ty>::type;
	};

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

	// TYPE PREDICATES
	// STRUCT TEMPLATE is_array
template<class _Ty>
	struct is_array
		: false_type
	{	// determine whether _Ty is an array
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	// determine whether _Ty is an array
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	// determine whether _Ty is an array
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_array_v = is_array<_Ty>::value;

	// STRUCT TEMPLATE is_lvalue_reference
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	// determine whether _Ty is an lvalue reference
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	// determine whether _Ty is an lvalue reference
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;

	// STRUCT TEMPLATE is_rvalue_reference
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	// determine whether _Ty is an rvalue reference
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	// determine whether _Ty is an rvalue reference
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;

	// STRUCT TEMPLATE is_reference
template<class _Ty>
	struct is_reference
		: bool_constant<is_lvalue_reference_v<_Ty>
		|| is_rvalue_reference_v<_Ty>>
	{	// determine whether _Ty is a reference
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_reference_v = is_reference<_Ty>::value;

	// STRUCT TEMPLATE is_member_object_pointer
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	// determine whether _Ty is a pointer to member object
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	// determine whether _Ty is a pointer to member object
	using _Class_type = _Ty2;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<remove_cv_t<_Ty>>::type
	{	// determine whether _Ty is a pointer to member object
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_member_function_pointer
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type
	{	// determine whether _Ty is a pointer to member function
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_pointer
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: true_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<remove_cv_t<_Ty>>
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_pointer_v = is_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_null_pointer
template<class _Ty>
	struct is_null_pointer
		: bool_constant<is_same_v<remove_cv_t<_Ty>, nullptr_t>>
	{	// determine whether _Ty is nullptr_t
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_union
template<class _Ty>
	struct is_union
		: bool_constant<__is_union(_Ty)>
	{	// determine whether _Ty is a union
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_union_v = is_union<_Ty>::value;

	// STRUCT TEMPLATE is_class
template<class _Ty>
	struct is_class
		: bool_constant<__is_class(_Ty)>
	{	// determine whether _Ty is a class
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_class_v = is_class<_Ty>::value;

	// STRUCT TEMPLATE is_fundamental
template<class _Ty>
	struct is_fundamental
		: bool_constant<is_arithmetic_v<_Ty>
		|| is_void_v<_Ty>
		|| is_null_pointer_v<_Ty>>
	{	// determine whether _Ty is a fundamental type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;

	// STRUCT TEMPLATE is_object
template<class _Ty>
	struct is_object
		: bool_constant<!is_function_v<_Ty>
		&& !is_reference_v<_Ty>
		&& !is_void_v<_Ty>>
	{	// determine whether _Ty is an object type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_object_v = is_object<_Ty>::value;

	// STRUCT TEMPLATE is_convertible
template<class _From,
	class _To>
	struct is_convertible
		: bool_constant<__is_convertible_to(_From, _To)>
	{	// determine whether _From is convertible to _To
	};

template<class _From,
	class _To>
	_INLINE_VAR constexpr bool is_convertible_v = is_convertible<_From, _To>::value;

	// STRUCT TEMPLATE is_enum
template<class _Ty>
	struct is_enum
		: bool_constant<__is_enum(_Ty)>
	{	// determine whether _Ty is an enumerated type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_enum_v = is_enum<_Ty>::value;

	// STRUCT TEMPLATE is_compound
template<class _Ty>
	struct is_compound
		: bool_constant<!is_fundamental_v<_Ty>>
	{	// determine whether _Ty is a compound type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_compound_v = is_compound<_Ty>::value;

	// STRUCT TEMPLATE is_member_pointer
template<class _Ty>
	struct is_member_pointer
		: bool_constant<is_member_object_pointer_v<_Ty>
		|| is_member_function_pointer_v<_Ty>>
	{	// determine whether _Ty is a pointer to member
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_scalar
template<class _Ty>
	struct is_scalar
		: bool_constant<is_arithmetic_v<_Ty>
		|| is_enum_v<_Ty>
		|| is_pointer_v<_Ty>
		|| is_member_pointer_v<_Ty>
		|| is_null_pointer_v<_Ty>>
	{	// determine whether _Ty is a scalar type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_scalar_v = is_scalar<_Ty>::value;

	// STRUCT TEMPLATE is_const
template<class _Ty>
	struct is_const
		: false_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty>
	struct is_const<const _Ty>
		: true_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_const_v = is_const<_Ty>::value;

	// STRUCT TEMPLATE is_volatile
template<class _Ty>
	struct is_volatile
		: false_type
	{	// determine whether _Ty is volatile qualified
	};

template<class _Ty>
	struct is_volatile<volatile _Ty>
		: true_type
	{	// determine whether _Ty is volatile qualified
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_volatile_v = is_volatile<_Ty>::value;

	// STRUCT TEMPLATE is_pod
template<class _Ty>
	struct is_pod
		: bool_constant<__is_pod(_Ty)>
	{	// determine whether _Ty is a POD type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_pod_v = is_pod<_Ty>::value;

	// STRUCT TEMPLATE is_empty
template<class _Ty>
	struct is_empty
		: bool_constant<__is_empty(_Ty)>
	{	// determine whether _Ty is an empty class
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_empty_v = is_empty<_Ty>::value;

	// STRUCT TEMPLATE is_polymorphic
template<class _Ty>
	struct is_polymorphic
		: bool_constant<__is_polymorphic(_Ty)>
	{	// determine whether _Ty is a polymorphic type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_polymorphic_v = is_polymorphic<_Ty>::value;

	// STRUCT TEMPLATE is_abstract
template<class _Ty>
	struct is_abstract
		: bool_constant<__is_abstract(_Ty)>
	{	// determine whether _Ty is an abstract class
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_abstract_v = is_abstract<_Ty>::value;

	// STRUCT TEMPLATE is_final
template<class _Ty>
	struct is_final
		: bool_constant<__is_final(_Ty)>
	{	// determine whether _Ty is a final class
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_final_v = is_final<_Ty>::value;

	// STRUCT TEMPLATE is_standard_layout
template<class _Ty>
	struct is_standard_layout
		: bool_constant<__is_standard_layout(_Ty)>
	{	// determine whether _Ty is standard layout
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_standard_layout_v = is_standard_layout<_Ty>::value;

	// STRUCT TEMPLATE is_literal_type
template<class _Ty>
	struct _CXX17_DEPRECATE_IS_LITERAL_TYPE is_literal_type
		: bool_constant<__is_literal_type(_Ty)>
	{	// determine whether _Ty is a literal type
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	_CXX17_DEPRECATE_IS_LITERAL_TYPE _INLINE_VAR constexpr bool is_literal_type_v = is_literal_type<_Ty>::value;
#pragma warning(pop)

	// STRUCT TEMPLATE is_trivial
template<class _Ty>
	struct is_trivial
		: bool_constant<__is_trivial(_Ty)>
	{	// determine whether _Ty is trivial
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivial_v = is_trivial<_Ty>::value;

	// STRUCT TEMPLATE is_trivially_copyable
template<class _Ty>
	struct is_trivially_copyable
		: bool_constant<__is_trivially_copyable(_Ty)>
	{	// determine whether _Ty is trivially copyable
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Ty>::value;

	// STRUCT TEMPLATE has_virtual_destructor
template<class _Ty>
	struct has_virtual_destructor
		: bool_constant<__has_virtual_destructor(_Ty)>
	{	// determine whether _Ty has a virtual destructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Ty>::value;

#if _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS
	// STRUCT TEMPLATE has_unique_object_representations
template<class _Ty>
	struct has_unique_object_representations
		: bool_constant<__has_unique_object_representations(_Ty)>
	{	// determine whether _Ty has unique object representations
	};

template<class _Ty>
	_INLINE_VAR constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);
#endif /* _HAS_HAS_UNIQUE_OBJECT_REPRESENTATIONS */
# 718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

		// CONSTRUCTIBLE/ASSIGNABLE TRAITS
	// STRUCT TEMPLATE is_constructible
template<class _Ty,
	class... _Args>
	struct is_constructible
		: bool_constant<__is_constructible(_Ty, _Args...)>
	{	// determine whether _Ty(_Args...) is constructible
	};

template<class _Ty,
	class... _Args>
	_INLINE_VAR constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;

	// STRUCT TEMPLATE is_copy_constructible
template<class _Ty>
	struct is_copy_constructible
		: is_constructible<
			_Ty,
			add_lvalue_reference_t<const _Ty>
		>::type
	{	// determine whether _Ty has a copy constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_default_constructible
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	// determine whether _Ty has a default constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_move_constructible
template<class _Ty>
	struct is_move_constructible
		: is_constructible<_Ty, _Ty>::type
	{	// determine whether _Ty has a move constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_move_constructible_v = is_move_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_assignable
template<class _To,
	class _From>
	struct is_assignable
		: bool_constant<__is_assignable(_To, _From)>
	{	// determine whether _From can be assigned to _To
	};

template<class _Ty,
	class _Uty>
	_INLINE_VAR constexpr bool is_assignable_v = is_assignable<_Ty, _Uty>::value;

	// STRUCT TEMPLATE is_copy_assignable
template<class _Ty>
	struct is_copy_assignable
		: is_assignable<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<const _Ty>
		>::type
	{	// determine whether _Ty has a copy assignment operator
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;

	// STRUCT TEMPLATE is_move_assignable
template<class _Ty>
	struct is_move_assignable
		: is_assignable<
			add_lvalue_reference_t<_Ty>,
			_Ty
		>::type
	{	// determine whether _Ty has a move assignment operator
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;

	// STRUCT TEMPLATE is_destructible
template<class _Ty>
	struct is_destructible
		: bool_constant<__is_destructible(_Ty)>
	{	// determine whether _Ty has a destructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_destructible_v = is_destructible<_Ty>::value;

		// TRIVIAL TRAITS
	// STRUCT TEMPLATE is_trivially_constructible
template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: bool_constant<__is_trivially_constructible(_Ty, _Args...)>
	{	// determine whether _Ty(_Args...) is trivially constructible
	};

template<class _Ty,
	class... _Args>
	_INLINE_VAR constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Ty, _Args...>::value;

	// STRUCT TEMPLATE is_trivially_copy_constructible
template<class _Ty>
	struct is_trivially_copy_constructible
		: is_trivially_constructible<
			_Ty,
			add_lvalue_reference_t<const _Ty>
		>::type
	{	// determine whether _Ty has a trivial copy constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_trivially_default_constructible
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	// determine whether _Ty has a trivial default constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_trivially_move_constructible
template<class _Ty>
	struct is_trivially_move_constructible
		: is_trivially_constructible<_Ty, _Ty>::type
	{	// determine whether _Ty has a trivial move constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_trivially_assignable
template<class _To,
	class _From>
	struct is_trivially_assignable
		: bool_constant<__is_trivially_assignable(_To, _From)>
	{	// determine whether _From can be assigned to _To, trivially
	};

template<class _Ty,
	class _Uty>
	_INLINE_VAR constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Ty, _Uty>::value;

	// STRUCT TEMPLATE is_trivially_copy_assignable
template<class _Ty>
	struct is_trivially_copy_assignable
		: is_trivially_assignable<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<const _Ty>
		>::type
	{	// determine whether _Ty has a trivial copy assignment operator
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;

	// STRUCT TEMPLATE is_trivially_move_assignable
template<class _Ty>
	struct is_trivially_move_assignable
		: is_trivially_assignable<
			add_lvalue_reference_t<_Ty>,
			_Ty
		>::type
	{	// determine whether _Ty has a trivial move assignment operator
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;

	// STRUCT TEMPLATE is_trivially_destructible
template<class _Ty>
	struct is_trivially_destructible
		: bool_constant<__is_trivially_destructible(_Ty)>
	{	// determine whether _Ty has a trivial destructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Ty>::value;

		// NOTHROW TRAITS
	// STRUCT TEMPLATE is_nothrow_constructible
template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: bool_constant<__is_nothrow_constructible(_Ty, _Args...)>
	{	// determine whether _Ty(_Args...) is nothrow constructible
	};

template<class _Ty,
	class... _Args>
	_INLINE_VAR constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Ty, _Args...>::value;

	// STRUCT TEMPLATE is_nothrow_copy_constructible
template<class _Ty>
	struct is_nothrow_copy_constructible
		: is_nothrow_constructible<
			_Ty,
			add_lvalue_reference_t<const _Ty>
		>::type
	{	// determine whether _Ty has a nothrow copy constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_nothrow_default_constructible
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	// determine whether _Ty has a nothrow default constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_nothrow_move_constructible
template<class _Ty>
	struct is_nothrow_move_constructible
		: is_nothrow_constructible<_Ty, _Ty>::type
	{	// determine whether _Ty has a nothrow move constructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Ty>::value;

	// STRUCT TEMPLATE is_nothrow_assignable
template<class _To,
	class _From>
	struct is_nothrow_assignable
		: bool_constant<__is_nothrow_assignable(_To, _From)>
	{	// determine whether _From can be assigned to _To, nothrow
	};

template<class _Ty,
	class _Uty>
	_INLINE_VAR constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Ty, _Uty>::value;

	// STRUCT TEMPLATE is_nothrow_copy_assignable
template<class _Ty>
	struct is_nothrow_copy_assignable
		: is_nothrow_assignable<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<const _Ty>
		>::type
	{	// determine whether _Ty has a nothrow copy assignment operator
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;

	// STRUCT TEMPLATE is_nothrow_move_assignable
template<class _Ty>
	struct is_nothrow_move_assignable
		: is_nothrow_assignable<
			add_lvalue_reference_t<_Ty>,
			_Ty
		>::type
	{	// determine whether _Ty has a nothrow move assignment operator
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;

	// STRUCT TEMPLATE is_nothrow_destructible
template<class _Ty>
	struct is_nothrow_destructible
		: bool_constant<__is_nothrow_destructible(_Ty)>
	{	// determine whether _Ty has a nothrow destructor
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Ty>::value;

	// STRUCT TEMPLATE is_signed
#pragma warning(push)
#pragma warning(disable: 4296)	// expression is always false
template<class _Ty,
	bool = is_integral_v<_Ty>>
	struct _Sign_base
	{	// determine whether integral _Ty is a signed or unsigned type
	using _Uty = remove_cv_t<_Ty>;
	using _Signed = bool_constant<_Uty(-1) < _Uty(0)>;
	using _Unsigned = bool_constant<_Uty(0) < _Uty(-1)>;
	};
#pragma warning(pop)

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	// floating-point _Ty is signed
		// non-arithmetic _Ty is neither signed nor unsigned
	using _Signed = typename is_floating_point<_Ty>::type;
	using _Unsigned = false_type;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	// determine whether _Ty is a signed type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_signed_v = is_signed<_Ty>::value;

	// STRUCT TEMPLATE is_unsigned
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	// determine whether _Ty is an unsigned type
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;

	// ALIAS TEMPLATE _Is_nonbool_integral
template<class _Ty>
	using _Is_nonbool_integral =
		bool_constant<is_integral_v<_Ty>
			&& !is_same_v<remove_cv_t<_Ty>, bool>>;

	// STRUCT TEMPLATE _Change_sign
template<class _Ty>
	struct _Change_sign
	{	// signed/unsigned partners to _Ty
	static_assert(_Is_nonbool_integral<_Ty>::value || is_enum_v<_Ty>,
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	using _Signed =
		conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, long,
		conditional_t<sizeof(_Ty) == 1, signed char,
		conditional_t<sizeof(_Ty) == 2, short,
		conditional_t<sizeof(_Ty) == 4, int,
			long long
		>>>>;

	using _Unsigned =
		conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, unsigned long,
		conditional_t<sizeof(_Ty) == 1, unsigned char,
		conditional_t<sizeof(_Ty) == 2, unsigned short,
		conditional_t<sizeof(_Ty) == 4, unsigned int,
			unsigned long long
		>>>>;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	// signed/unsigned partners to _Ty
	using _Signed = const typename _Change_sign<_Ty>::_Signed;
	using _Unsigned = const typename _Change_sign<_Ty>::_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	// signed/unsigned partners to _Ty
	using _Signed = volatile typename _Change_sign<_Ty>::_Signed;
	using _Unsigned = volatile typename _Change_sign<_Ty>::_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	// signed/unsigned partners to _Ty
	using _Signed = const volatile typename _Change_sign<_Ty>::_Signed;
	using _Unsigned = const volatile typename _Change_sign<_Ty>::_Unsigned;
	};

	// STRUCT TEMPLATE make_signed
template<class _Ty>
	struct make_signed
	{	// signed partner to _Ty
	using type = typename _Change_sign<_Ty>::_Signed;
	};

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

	// STRUCT TEMPLATE make_unsigned
template<class _Ty>
	struct make_unsigned
	{	// unsigned partner to _Ty
	using type = typename _Change_sign<_Ty>::_Unsigned;
	};

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

	// FUNCTION TEMPLATE _Unsigned_value
template<class _Rep>
	constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)
	{	// makes _Val unsigned
	return (static_cast<make_unsigned_t<_Rep>>(_Val));
	}

	// STRUCT TEMPLATE alignment_of
template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	// determine alignment of _Ty
	};

template<class _Ty>
	_INLINE_VAR constexpr size_t alignment_of_v = alignof(_Ty);

	// STRUCT TEMPLATE aligned_storage
#define _FITS(_Ty)	_Align <= alignof(_Ty)
#define _NEXT_ALIGN(_Ty)	\
	using type = typename _Aligned<_Len, _Align, _Ty, _FITS(_Ty)>::type

template<class _Ty,
	size_t _Len>
	union _Align_type
	{	// union with size _Len bytes and alignment of _Ty
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	// define type with size _Len and alignment _Ty
	using type = _Align_type<_Ty, _Len>;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	// define type with size _Len and alignment _Ty
	using type = _Align_type<max_align_t, _Len>;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	// define type with size _Len and alignment _Ty
	_NEXT_ALIGN(double);
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	// define type with size _Len and alignment _Ty
	_NEXT_ALIGN(int);
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	// define type with size _Len and alignment _Ty
	_NEXT_ALIGN(short);
	};

template<size_t _Len,
	size_t _Align = alignof(max_align_t)>
	struct aligned_storage
	{	// define type with size _Len and alignment _Align
	using type = typename _Aligned<_Len, _Align, char, _FITS(char)>::type;
	};

#undef _FITS
#undef _NEXT_ALIGN

template<size_t _Len,
	size_t _Align = alignof(max_align_t)>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

	// STRUCT TEMPLATE aligned_union
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
		: integral_constant<size_t, 0>
	{	// maximum of nothing is 0
	};

template<size_t _Val>
	struct _Maximum<_Val>
		: integral_constant<size_t, _Val>
	{	// maximum of _Val is _Val
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type
	{	// find maximum value in _First, _Second, _Rest...
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	// define type with size at least _Len, for storing anything in _Types
	static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value;	// NOT sizeof...(_Types)
	static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;
	using type = aligned_storage_t<_Max_len, alignment_value>;
	};

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

	// STRUCT TEMPLATE underlying_type
template<class _Ty>
	struct underlying_type
	{	// determine type underlying type for enum
	using type = __underlying_type(_Ty);
	};

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

	// STRUCT TEMPLATE rank
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty, size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty>
	_INLINE_VAR constexpr size_t rank_v = rank<_Ty>::value;

	// STRUCT TEMPLATE extent
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx, size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty,
	unsigned int _Ix = 0>
	_INLINE_VAR constexpr size_t extent_v = extent<_Ty, _Ix>::value;

	// STRUCT TEMPLATE is_base_of
template<class _Base,
	class _Der>
	struct is_base_of
		: bool_constant<__is_base_of(_Base, _Der)>
	{	// determine whether _Base is a base of or the same as _Der
	};

template<class _Base,
	class _Derived>
	_INLINE_VAR constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;

	// STRUCT TEMPLATE decay
template<class _Ty>
	struct decay
	{	// determines decayed version of _Ty
	using _Ty1 = remove_reference_t<_Ty>;

	using type = conditional_t<is_array_v<_Ty1>,
		add_pointer_t<remove_extent_t<_Ty1>>,
		conditional_t<is_function_v<_Ty1>,
			add_pointer_t<_Ty1>,
			remove_cv_t<_Ty1>>>;
	};

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

	// STRUCT TEMPLATE conjunction
template<bool _First_value,
	class _First,
	class... _Rest>
	struct _Conjunction
	{	// handle false trait or last trait
	using type = _First;
	};

template<class _True,
	class _Next,
	class... _Rest>
	struct _Conjunction<true, _True, _Next, _Rest...>
	{	// the first trait is true, try the next one
	using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
	};

template<class... _Traits>
	struct conjunction
		: true_type
	{	// If _Traits is empty, true_type
	};

template<class _First,
	class... _Rest>
	struct conjunction<_First, _Rest...>
		: _Conjunction<_First::value, _First, _Rest...>::type
	{	// Otherwise, if any of _Traits are false, the first false trait
		// Otherwise, the last trait in _Traits
	};

template<class... _Traits>
	_INLINE_VAR constexpr bool conjunction_v = conjunction<_Traits...>::value;

template<class... _Traits>
	using _Conjunction_t = typename conjunction<_Traits...>::type;

	// STRUCT TEMPLATE disjunction
template<bool _First_value,
	class _First,
	class... _Rest>
	struct _Disjunction
	{	// handle true trait or last trait
	using type = _First;
	};

template<class _False,
	class _Next,
	class... _Rest>
	struct _Disjunction<false, _False, _Next, _Rest...>
	{	// first trait is false, try the next trait
	using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
	};

template<class... _Traits>
	struct disjunction
		: false_type
	{	// If _Traits is empty, false_type
	};

template<class _First,
	class... _Rest>
	struct disjunction<_First, _Rest...>
		: _Disjunction<_First::value, _First, _Rest...>::type
	{	// Otherwise, if any of _Traits are true, the first true trait
		// Otherwise, the last trait in _Traits
	};

template<class... _Traits>
	_INLINE_VAR constexpr bool disjunction_v = disjunction<_Traits...>::value;

template<class... _Traits>
	using _Disjunction_t = typename disjunction<_Traits...>::type;

	// STRUCT TEMPLATE negation
template<class _Trait>
	struct negation
		: bool_constant<!static_cast<bool>(_Trait::value)>
	{	// The negated result of _Trait
	};

template<class _Trait>
	_INLINE_VAR constexpr bool negation_v = negation<_Trait>::value;

		// STRUCT TEMPLATE common_type
struct _Unique_tag_common_type
	{	// TRANSITION, C1XX
	};

template<class _Ty1,
	class _Ty2,
	class = void>
	struct _Decayed_cond_oper
	{
	};

template<class _Ty1,
	class _Ty2>
	struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<
		_Unique_tag_common_type,
		decltype(false ? _STD declval<_Ty1>() : _STD declval<_Ty2>())>>
	{
	using type = decay_t<decltype(false ? _STD declval<_Ty1>() : _STD declval<_Ty2>())>;
	};

template<class... _Ty>
	struct common_type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<>
	struct common_type<>
	{
	};

template<class _Ty1>
	struct common_type<_Ty1>
		: common_type<_Ty1, _Ty1>
	{
	};

template<class _Ty1,
	class _Ty2,
	class _Decayed1 = decay_t<_Ty1>,
	class _Decayed2 = decay_t<_Ty2>>
	struct _Common_type2
		: common_type<_Decayed1, _Decayed2>
	{
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2>
		: _Decayed_cond_oper<_Ty1, _Ty2>
	{
	};

template<class _Ty1,
	class _Ty2>
	struct common_type<_Ty1, _Ty2>
		: _Common_type2<_Ty1, _Ty2>
	{
	};

template<class _Void,
	class _Ty1,
	class _Ty2,
	class... _Rest>
	struct _Common_type3
	{
	};

template<class _Ty1,
	class _Ty2,
	class... _Rest>
	struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
		: common_type<common_type_t<_Ty1, _Ty2>, _Rest...>
	{
	};

template<class _Ty1,
	class _Ty2,
	class... _Rest>
	struct common_type<_Ty1, _Ty2, _Rest...>
		: _Common_type3<void, _Ty1, _Ty2, _Rest...>
	{
	};

#if _HAS_IDENTITY_STRUCT
	// STRUCT TEMPLATE identity
template<class _Ty>
	struct _DEPRECATE_IDENTITY_STRUCT identity
	{	// map _Ty to type unchanged
	using type = _Ty;

	const _Ty& operator()(const _Ty& _Left) const
		{	// apply identity operator to operand
		return (_Left);
		}
	};
#endif /* _HAS_IDENTITY_STRUCT */
# 1513 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

	// STRUCT TEMPLATE _Identity
template<class _Ty>
	struct _Identity
	{	// the identity transformation trait
	using type = _Ty;
	};
template<class _Ty>
	using _Identity_t = typename _Identity<_Ty>::type;

	// TRAIT _Is_specialization: TRUE IFF _Type IS A SPECIALIZATION OF _Template
	// TRANSITION, VSO#452240
template<class _Type,
	template <class...> class _Template>
	struct _Is_specialization
		: false_type
	{};
template<template <class...> class _Template,
	class... _Types>
	struct _Is_specialization<_Template<_Types...>, _Template>
		: true_type
	{};

	// FUNCTION TEMPLATE forward
template<class _Ty>
	_NODISCARD constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) _NOEXCEPT
	{	// forward an lvalue as either an lvalue or an rvalue
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty>
	_NODISCARD constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) _NOEXCEPT
	{	// forward an rvalue as an rvalue
	static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		// FUNCTION TEMPLATE move
template<class _Ty>
	_NODISCARD constexpr remove_reference_t<_Ty>&&
		move(_Ty&& _Arg) _NOEXCEPT
	{	// forward _Arg as movable
	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
	}

		// FUNCTION TEMPLATE move_if_noexcept
template<class _Ty>
	_NODISCARD constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>,
		const _Ty&, _Ty&&>
	move_if_noexcept(_Ty& _Arg) _NOEXCEPT
	{	// forward _Arg as movable, sometimes
	return (_STD move(_Arg));
	}

template<class _Ty>
	struct _Unrefwrap;

#define _CONCATX(x, y) x ## y
#define _CONCAT(x, y) _CONCATX(x, y)

#define _IMPLEMENT_INVOKE(NAME_PREFIX, CONSTEXPR) \
	/* FUNCTION TEMPLATE invoke */ \
struct _CONCAT(NAME_PREFIX, _Invoker_pmf_object) \
	{	/* INVOKE a pointer to member function on an object */ \
	template<class _Decayed, \
		class _Ty1, \
		class... _Types2> \
		static CONSTEXPR auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER((_STD forward<_Ty1>(_Arg1).*_Pmf)(_STD forward<_Types2>(_Args2)...))) \
		-> decltype((_STD forward<_Ty1>(_Arg1).*_Pmf)(_STD forward<_Types2>(_Args2)...)) \
		{	/* INVOKE a pointer to member function on an object */ \
		return ((_STD forward<_Ty1>(_Arg1).*_Pmf)(_STD forward<_Types2>(_Args2)...)); \
		} \
	}; \
 \
struct _CONCAT(NAME_PREFIX, _Invoker_pmf_refwrap) \
	{	/* INVOKE a pointer to member function on a reference_wrapper */ \
	template<class _Decayed, \
		class _Ty1, \
		class... _Types2> \
		static CONSTEXPR auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER((_STD forward<_Ty1>(_Arg1).get().*_Pmf)(_STD forward<_Types2>(_Args2)...))) \
		-> decltype((_STD forward<_Ty1>(_Arg1).get().*_Pmf)(_STD forward<_Types2>(_Args2)...)) \
		{	/* INVOKE a pointer to member function on a reference_wrapper */ \
		return ((_STD forward<_Ty1>(_Arg1).get().*_Pmf)(_STD forward<_Types2>(_Args2)...)); \
		} \
	}; \
 \
struct _CONCAT(NAME_PREFIX, _Invoker_pmf_pointer) \
	{	/* INVOKE a pointer to member function on a [smart] pointer */ \
	template<class _Decayed, \
		class _Ty1, \
		class... _Types2> \
		static CONSTEXPR auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER(((*_STD forward<_Ty1>(_Arg1)).*_Pmf)(_STD forward<_Types2>(_Args2)...))) \
		-> decltype(((*_STD forward<_Ty1>(_Arg1)).*_Pmf)(_STD forward<_Types2>(_Args2)...)) \
		{	/* INVOKE a pointer to member function on a [smart] pointer */ \
		return (((*_STD forward<_Ty1>(_Arg1)).*_Pmf)(_STD forward<_Types2>(_Args2)...)); \
		} \
	}; \
 \
struct _CONCAT(NAME_PREFIX, _Invoker_pmd_object) \
	{	/* INVOKE a pointer to member data on an object */ \
	template<class _Decayed, \
		class _Ty1> \
		static CONSTEXPR auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_STD forward<_Ty1>(_Arg1).*_Pmd)) \
		-> decltype(_STD forward<_Ty1>(_Arg1).*_Pmd) \
		{	/* INVOKE a pointer to member data on an object */ \
		return (_STD forward<_Ty1>(_Arg1).*_Pmd); \
		} \
	}; \
 \
struct _CONCAT(NAME_PREFIX, _Invoker_pmd_refwrap) \
	{	/* INVOKE a pointer to member data on a reference_wrapper */ \
	template<class _Decayed, \
		class _Ty1> \
		static CONSTEXPR auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_STD forward<_Ty1>(_Arg1).get().*_Pmd)) \
		-> decltype(_STD forward<_Ty1>(_Arg1).get().*_Pmd) \
		{	/* INVOKE a pointer to member data on a reference_wrapper */ \
		return (_STD forward<_Ty1>(_Arg1).get().*_Pmd); \
		} \
	}; \
 \
struct _CONCAT(NAME_PREFIX, _Invoker_pmd_pointer) \
	{	/* INVOKE a pointer to member data on a [smart] pointer */ \
	template<class _Decayed, \
		class _Ty1> \
		static CONSTEXPR auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER((*_STD forward<_Ty1>(_Arg1)).*_Pmd)) \
		-> decltype((*_STD forward<_Ty1>(_Arg1)).*_Pmd) \
		{	/* INVOKE a pointer to member data on a [smart] pointer */ \
		return ((*_STD forward<_Ty1>(_Arg1)).*_Pmd); \
		} \
	}; \
 \
struct _CONCAT(NAME_PREFIX, _Invoker_functor) \
	{	/* INVOKE a function object */ \
	template<class _Callable, \
		class... _Types> \
		static CONSTEXPR auto _Call(_Callable&& _Obj, _Types&&... _Args) \
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_STD forward<_Callable>(_Obj)(_STD forward<_Types>(_Args)...))) \
		-> decltype(_STD forward<_Callable>(_Obj)(_STD forward<_Types>(_Args)...)) \
		{	/* INVOKE a function object */ \
		return (_STD forward<_Callable>(_Obj)(_STD forward<_Types>(_Args)...)); \
		} \
	}; \
 \
template<class _Callable, \
	class _Ty1, \
	class _Decayed = decay_t<_Callable>, \
	bool _Is_pmf = is_member_function_pointer_v<_Decayed>, \
	bool _Is_pmd = is_member_object_pointer_v<_Decayed>> \
	struct _CONCAT(NAME_PREFIX, _Invoker1); \
 \
template<class _Callable, \
	class _Ty1, \
	class _Decayed> \
	struct _CONCAT(NAME_PREFIX, _Invoker1)<_Callable, _Ty1, _Decayed, true, false> \
		: conditional_t<is_base_of_v< \
			typename _Is_memfunptr<_Decayed>::_Class_type, \
			decay_t<_Ty1>>, \
		_CONCAT(NAME_PREFIX, _Invoker_pmf_object), \
		conditional_t<_Unrefwrap<_Ty1>::_Is_refwrap, \
			_CONCAT(NAME_PREFIX, _Invoker_pmf_refwrap), \
			_CONCAT(NAME_PREFIX, _Invoker_pmf_pointer) \
		>> \
	{	/* pointer to member function */ \
	}; \
 \
template<class _Callable, \
	class _Ty1, \
	class _Decayed> \
	struct _CONCAT(NAME_PREFIX, _Invoker1)<_Callable, _Ty1, _Decayed, false, true> \
		: conditional_t<is_base_of_v< \
			typename _Is_member_object_pointer<_Decayed>::_Class_type, \
			decay_t<_Ty1>>, \
		_CONCAT(NAME_PREFIX, _Invoker_pmd_object), \
		conditional_t<_Unrefwrap<_Ty1>::_Is_refwrap, \
			_CONCAT(NAME_PREFIX, _Invoker_pmd_refwrap), \
			_CONCAT(NAME_PREFIX, _Invoker_pmd_pointer) \
		>> \
	{	/* pointer to member data */ \
	}; \
 \
template<class _Callable, \
	class _Ty1, \
	class _Decayed> \
	struct _CONCAT(NAME_PREFIX, _Invoker1)<_Callable, _Ty1, _Decayed, false, false> \
		: _CONCAT(NAME_PREFIX, _Invoker_functor) \
	{	/* function object */ \
	}; \
 \
template<class _Callable, \
	class... _Types> \
	struct _CONCAT(NAME_PREFIX, _Invoker); \
 \
template<class _Callable> \
	struct _CONCAT(NAME_PREFIX, _Invoker)<_Callable> \
		: _CONCAT(NAME_PREFIX, _Invoker_functor) \
	{	/* zero arguments */ \
	}; \
 \
template<class _Callable, \
	class _Ty1, \
	class... _Types2> \
	struct _CONCAT(NAME_PREFIX, _Invoker)<_Callable, _Ty1, _Types2...> \
		: _CONCAT(NAME_PREFIX, _Invoker1)<_Callable, _Ty1> \
	{	/* one or more arguments */ \
	}; \
 \
template<class _Callable, \
	class... _Types> \
	CONSTEXPR auto _CONCAT(NAME_PREFIX, invoke)(_Callable&& _Obj, _Types&&... _Args) \
	_NOEXCEPT_COND(_NOEXCEPT_OPER(_CONCAT(NAME_PREFIX, _Invoker)<_Callable, _Types...>::_Call( \
		_STD forward<_Callable>(_Obj), _STD forward<_Types>(_Args)...))) \
	-> decltype(_CONCAT(NAME_PREFIX, _Invoker)<_Callable, _Types...>::_Call( \
		_STD forward<_Callable>(_Obj), _STD forward<_Types>(_Args)...)) \
	{	/* INVOKE a callable object */ \
	return (_CONCAT(NAME_PREFIX, _Invoker)<_Callable, _Types...>::_Call( \
		_STD forward<_Callable>(_Obj), _STD forward<_Types>(_Args)...)); \
	}

template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
	_NOEXCEPT_COND(_NOEXCEPT_OPER(_Invoker<_Callable, _Types...>::_Call(
		_STD forward<_Callable>(_Obj), _STD forward<_Types>(_Args)...)))
	-> decltype(_Invoker<_Callable, _Types...>::_Call(
		_STD forward<_Callable>(_Obj), _STD forward<_Types>(_Args)...));

struct _Unforced
	{	// tag to distinguish bind() from bind<R>()
	};

	// TYPE TRAITS FOR invoke()
template<class _To>
	void _Implicitly_convert_to(_To) _NOEXCEPT;

template<class _From,
	class _To,
	bool = is_convertible_v<_From, _To>>
	struct _Is_nothrow_convertible
		: bool_constant<_NOEXCEPT_OPER(_Implicitly_convert_to<_To>(_STD declval<_From>()))>
	{	// determine whether _From is nothrow-convertible to _To
	};

template<class _From,
	class _To>
	struct _Is_nothrow_convertible<_From, _To, false>
		: false_type
	{	// determine whether _From is nothrow-convertible to _To
	};

struct _Unique_tag_invoke_traits
	{	// TRANSITION, C1XX
	};

template<class _Void,
	class... _Types>
	struct _Invoke_traits
	{	// selected when _Callable isn't callable with _Args
	using _Is_invocable = false_type;
	using _Is_nothrow_invocable = false_type;
	template<class _Rx>
		using _Is_invocable_r = false_type;
	template<class _Rx>
		using _Is_nothrow_invocable_r = false_type;
	};

template<class... _Types>
	struct _Invoke_traits<
		void_t<
			_Unique_tag_invoke_traits,
			decltype(_STD invoke(_STD declval<_Types>()...))>,
		_Types...>
	{	// selected when _Callable is callable with _Args
	using type = decltype(_STD invoke(_STD declval<_Types>()...));
	using _Is_invocable = true_type;
	using _Is_nothrow_invocable = bool_constant<_NOEXCEPT_OPER(_STD invoke(_STD declval<_Types>()...))>;
	template<class _Rx>
		using _Is_invocable_r = _Disjunction_t<is_void<_Rx>, is_convertible<type, _Rx>>;
	template<class _Rx>
		using _Is_nothrow_invocable_r = _Conjunction_t<
			_Is_nothrow_invocable,
			disjunction<is_void<_Rx>, _Is_nothrow_convertible<type, _Rx>>>;
	};

	// STRUCT TEMPLATE result_of
template<class _Fty>
	struct _CXX17_DEPRECATE_RESULT_OF result_of
	{	// explain usage
	static_assert(_Always_false<_Fty>::value,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};

#define _RESULT_OF(CALL_OPT, X1, X2, X3) \
template<class _Callable, \
	class... _Args> \
	struct _CXX17_DEPRECATE_RESULT_OF result_of<_Callable CALL_OPT (_Args...)> \
		: _Invoke_traits<void, _Callable, _Args...> \
	{	/* template to determine result of call operation */ \
	};

_NON_MEMBER_CALL(_RESULT_OF, X1, X2, X3)
#undef _RESULT_OF

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	using result_of_t _CXX17_DEPRECATE_RESULT_OF = typename result_of<_Ty>::type;
#pragma warning(pop)

template<class _Callable,
	class... _Args>
	using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;

template<class _Rx,
	class _Callable,
	class... _Args>
	using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::template _Is_invocable_r<_Rx>;

template<class _Rx,
	class _Callable,
	class... _Args>
	struct _Is_invocable_r
		: _Is_invocable_r_<_Rx, _Callable, _Args...>
	{	// determines whether _Callable is callable with _Args and return type _Rx
	};

#if _HAS_CXX17
	// STRUCT TEMPLATE invoke_result
template<class _Callable,
	class... _Args>
	struct invoke_result
		: _Invoke_traits<void, _Callable, _Args...>
	{	// determine the result type of invoking _Callable with _Args
	};

template<class _Callable,
	class... _Args>
	using invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;

	// STRUCT TEMPLATE is_invocable
template<class _Callable,
	class... _Args>
	struct is_invocable
		: _Invoke_traits<void, _Callable, _Args...>::_Is_invocable
	{	// determines whether _Callable is callable with _Args
	};

template<class _Callable,
	class... _Args>
	_INLINE_VAR constexpr bool is_invocable_v = _Invoke_traits<void, _Callable, _Args...>::_Is_invocable::value;

	// STRUCT TEMPLATE is_nothrow_invocable
template<class _Callable,
	class... _Args>
	struct is_nothrow_invocable
		: _Invoke_traits<void, _Callable, _Args...>::_Is_nothrow_invocable
	{	// determines whether _Callable is nothrow-callable with _Args
	};

template<class _Callable,
	class... _Args>
	_INLINE_VAR constexpr bool is_nothrow_invocable_v =
		_Invoke_traits<void, _Callable, _Args...>::_Is_nothrow_invocable::value;

	// STRUCT TEMPLATE is_invocable_r
template<class _Rx,
	class _Callable,
	class... _Args>
	struct is_invocable_r
		: _Is_invocable_r_<_Rx, _Callable, _Args...>
	{	// determines whether _Callable is callable with _Args and return type _Rx
	};

template<class _Rx,
	class _Callable,
	class... _Args>
	_INLINE_VAR constexpr bool is_invocable_r_v = _Is_invocable_r_<_Rx, _Callable, _Args...>::value;

	// STRUCT TEMPLATE is_nothrow_invocable_r
template<class _Rx,
	class _Callable,
	class... _Args>
	struct is_nothrow_invocable_r
		: _Invoke_traits<void, _Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>
	{	// determines whether _Callable is nothrow-callable with _Args and return type _Rx
	};

template<class _Rx,
	class _Callable,
	class... _Args>
	_INLINE_VAR constexpr bool is_nothrow_invocable_r_v =
		_Invoke_traits<void, _Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>::value;
#endif /* _HAS_CXX17 */
# 1916 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3


	// STRUCT TEMPLATE _Weak_types
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	// default definition
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Weak_result_type<_Ty, void_t<
		typename _Ty::result_type>>
	{	// defined if _Ty::result_type exists
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::result_type result_type;
	};
#pragma warning(pop)

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	// default definition
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Weak_argument_type<_Ty, void_t<
		typename _Ty::argument_type>>
		: _Weak_result_type<_Ty>
	{	// defined if _Ty::argument_type exists
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::argument_type argument_type;
	};
#pragma warning(pop)

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	// default definition
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Weak_binary_args<_Ty, void_t<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type>>
		: _Weak_argument_type<_Ty>
	{	// defined if both types exist
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::first_argument_type first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::second_argument_type second_argument_type;
	};
#pragma warning(pop)

template<class _Ty>
	struct _Weak_types
	{	// provide nested types (sometimes)
	using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty>>;
	using _Is_pmf = _Is_memfunptr<remove_cv_t<_Ty>>;
	using type = conditional_t<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		conditional_t<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty>>>;
	};

	// CLASS TEMPLATE reference_wrapper
template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	// stand-in for an assignable reference
public:
	static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
		"reference_wrapper<T> requires T to be an object type "
		"or a function type.");

	using type = _Ty;

	reference_wrapper(_Ty& _Val) _NOEXCEPT
		: _Ptr(_STD addressof(_Val))
		{	// construct
		}

	operator _Ty&() const _NOEXCEPT
		{	// return reference
		return (*_Ptr);
		}

	_NODISCARD _Ty& get() const _NOEXCEPT
		{	// return reference
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(_STD invoke(get(), _STD forward<_Types>(_Args)...))
		{	// invoke object/function
		return (_STD invoke(get(), _STD forward<_Types>(_Args)...));
		}

	reference_wrapper(_Ty&&) = delete;

private:
	_Ty *_Ptr;
	};

#if _HAS_DEDUCTION_GUIDES
template<class _Ty>
	reference_wrapper(reference_wrapper<_Ty>) -> reference_wrapper<_Ty>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 2027 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

	// FUNCTION TEMPLATES ref AND cref
template<class _Ty>
	_NODISCARD inline reference_wrapper<_Ty> ref(_Ty& _Val) _NOEXCEPT
	{	// create reference_wrapper<_Ty> object
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty>
	_NODISCARD inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) _NOEXCEPT
	{	// create reference_wrapper<_Ty> object
	return (_STD ref(_Val.get()));
	}

template<class _Ty>
	_NODISCARD inline reference_wrapper<const _Ty> cref(const _Ty& _Val) _NOEXCEPT
	{	// create reference_wrapper<const _Ty> object
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty>
	_NODISCARD inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) _NOEXCEPT
	{	// create reference_wrapper<const _Ty> object
	return (_STD cref(_Val.get()));
	}

	// STRUCT TEMPLATE _Unrefwrap
template<class _Ty>
	struct _Unrefwrap_helper
	{	// leave unchanged if not a reference_wrapper
	using type = _Ty;
	static constexpr bool _Is_refwrap = false;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty>>
	{	// make a reference from a reference_wrapper
	using type = _Ty&;
	static constexpr bool _Is_refwrap = true;
	};

template<class _Ty>
	struct _Unrefwrap
	{	// decay, then unwrap a reference_wrapper
	using _Ty1 = decay_t<_Ty>;
	using type = typename _Unrefwrap_helper<_Ty1>::type;
	static constexpr bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
	};

		// STRUCT TEMPLATE _Is_swappable
template<class _Ty>
	struct _Is_swappable;

		// STRUCT TEMPLATE _Is_nothrow_swappable
template<class _Ty>
	struct _Is_nothrow_swappable;

		// FUNCTION TEMPLATE swap
#if _HAS_CXX17
template<class _Ty,
	class = enable_if_t<is_move_constructible_v<_Ty>
		&& is_move_assignable_v<_Ty>>> inline
#else /* _HAS_CXX17 */
# 2096 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
template<class _Ty,
	class = void> inline
#endif /* _HAS_CXX17 */
# 2099 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
	void swap(_Ty&, _Ty&)
		_NOEXCEPT_COND(is_nothrow_move_constructible_v<_Ty>
			&& is_nothrow_move_assignable_v<_Ty>);

template<class _Ty,
	size_t _Size,
	class = enable_if_t<_Is_swappable<_Ty>::value>> inline
	void swap(_Ty (&)[_Size], _Ty (&)[_Size])
		_NOEXCEPT_COND(_Is_nothrow_swappable<_Ty>::value);

		// STRUCT TEMPLATE _Swappable_with_helper
template<class _Ty1,
	class _Ty2,
	class = void>
	struct _Swappable_with_helper
		: false_type
	{	// swap(declval<_Ty1>(), declval<_Ty2>()) is not valid
	};

struct _Swappable_with_helper_unique_type
	{	// TRANSITION, C1XX
	};

template<class _Ty1,
	class _Ty2>
	struct _Swappable_with_helper<_Ty1, _Ty2, void_t<
		_Swappable_with_helper_unique_type,
		decltype(swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))>>
		: true_type
	{	// swap(declval<_Ty1>(), declval<_Ty2>()) is valid
	};

		// STRUCT TEMPLATE _Is_swappable_with
template<class _Ty1,
	class _Ty2>
	struct _Is_swappable_with
		: _Conjunction_t<
			_Swappable_with_helper<_Ty1, _Ty2>,
			_Swappable_with_helper<_Ty2, _Ty1>>
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// can be swapped (and vice versa)
	};

		// STRUCT TEMPLATE _Is_swappable
template<class _Ty>
	struct _Is_swappable
		: _Is_swappable_with<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<_Ty>>::type
	{	// Determine if _Ty lvalues satisfy is_swappable_with
	};

		// STRUCT TEMPLATE _Swap_cannot_throw
template<class _Ty1,
	class _Ty2>
	struct _Swap_cannot_throw
		: bool_constant<_NOEXCEPT_OPER(swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))
					&& _NOEXCEPT_OPER(swap(_STD declval<_Ty2>(), _STD declval<_Ty1>()))>
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// (presumed to satisfy is_swappable_with) can be swapped without
		// emitting exceptions
	};

		// STRUCT TEMPLATE _Is_nothrow_swappable_with
template<class _Ty1,
	class _Ty2>
	struct _Is_nothrow_swappable_with
		: _Conjunction_t<
			_Is_swappable_with<_Ty1, _Ty2>,
			_Swap_cannot_throw<_Ty1, _Ty2>>
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// satisfy is_swappable_with, and can be swapped without emitting exceptions
	};

		// STRUCT TEMPLATE _Is_nothrow_swappable
template<class _Ty>
	struct _Is_nothrow_swappable
		: _Is_nothrow_swappable_with<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<_Ty>>::type
	{	// Determine if _Ty lvalues satisfy is_nothrow_swappable_with
	};

#if _HAS_CXX17
		// STRUCT TEMPLATE is_swappable_with
template<class _Ty1,
	class _Ty2>
	struct is_swappable_with
		: _Is_swappable_with<_Ty1, _Ty2>::type
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// can be swapped (and vice versa)
	};

template<class _Ty1,
	class _Ty2>
	_INLINE_VAR constexpr bool is_swappable_with_v = is_swappable_with<_Ty1, _Ty2>::value;

		// STRUCT TEMPLATE is_swappable
template<class _Ty>
	struct is_swappable
		: _Is_swappable<_Ty>::type
	{	// Determine if _Ty lvalues satisfy is_swappable_with
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_swappable_v = is_swappable<_Ty>::value;

		// STRUCT TEMPLATE is_nothrow_swappable_with
template<class _Ty1,
	class _Ty2>
	struct is_nothrow_swappable_with
		: _Is_nothrow_swappable_with<_Ty1, _Ty2>::type
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// satisfy is_swappable_with, and can be swapped without emitting exceptions
	};

template<class _Ty1,
	class _Ty2>
	_INLINE_VAR constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Ty1, _Ty2>::value;

		// STRUCT TEMPLATE is_nothrow_swappable
template<class _Ty>
	struct is_nothrow_swappable
		: _Is_nothrow_swappable<_Ty>::type
	{	// Determine if _Ty lvalues satisfy is_nothrow_swappable_with
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Ty>::value;
#endif /* _HAS_CXX17 */
# 2229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

	// TYPE TRAIT _Is_trivially_swappable
namespace _Has_ADL_swap_detail {
	void swap(); // undefined (deliberate shadowing)

	struct _Has_ADL_swap_unique_type
		{	// TRANSITION, C1XX
		};

	template<class,
		class = void>
		struct _Has_ADL_swap
			: false_type
		{};
	template<class _Ty>
		struct _Has_ADL_swap<_Ty,
			void_t<_Has_ADL_swap_unique_type,
				decltype(swap(_STD declval<_Ty&>(), _STD declval<_Ty&>()))>>
			: true_type
		{};
} // namespace _Has_ADL_swap_detail
using _Has_ADL_swap_detail::_Has_ADL_swap;

template<class _Ty>
	struct _Is_trivially_swappable
		: _Conjunction_t<
			is_trivially_destructible<_Ty>,
			is_trivially_move_constructible<_Ty>,
			is_trivially_move_assignable<_Ty>,
			negation<_Has_ADL_swap<_Ty>>>
	{	// true_type if it is valid to swap two _Ty lvalues by exchanging
		// object representations.
	};

template<class _Ty>
	_INLINE_VAR constexpr bool _Is_trivially_swappable_v = _Is_trivially_swappable<_Ty>::value;

		// BITMASK OPERATIONS
 #define _BITMASK_OPS(_BITMASK) \
_NODISCARD constexpr _BITMASK operator&(_BITMASK _Left, _BITMASK _Right) _NOEXCEPT \
	{	/* return _Left & _Right */ \
	using _IntTy = underlying_type_t<_BITMASK>; \
	return (static_cast<_BITMASK>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right))); \
	} \
\
_NODISCARD constexpr _BITMASK operator|(_BITMASK _Left, _BITMASK _Right) _NOEXCEPT \
	{	/* return _Left | _Right */ \
	using _IntTy = underlying_type_t<_BITMASK>; \
	return (static_cast<_BITMASK>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right))); \
	} \
\
_NODISCARD constexpr _BITMASK operator^(_BITMASK _Left, _BITMASK _Right) _NOEXCEPT \
	{	/* return _Left ^ _Right */ \
	using _IntTy = underlying_type_t<_BITMASK>; \
	return (static_cast<_BITMASK>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right))); \
	} \
\
constexpr _BITMASK& operator&=(_BITMASK& _Left, _BITMASK _Right) _NOEXCEPT \
	{	/* return _Left &= _Right */ \
	return (_Left = _Left & _Right); \
	} \
\
constexpr _BITMASK& operator|=(_BITMASK& _Left, _BITMASK _Right) _NOEXCEPT \
	{	/* return _Left |= _Right */ \
	return (_Left = _Left | _Right); \
	} \
\
constexpr _BITMASK& operator^=(_BITMASK& _Left, _BITMASK _Right) _NOEXCEPT \
	{	/* return _Left ^= _Right */ \
	return (_Left = _Left ^ _Right); \
	} \
\
_NODISCARD constexpr _BITMASK operator~(_BITMASK _Left) _NOEXCEPT \
	{	/* return ~_Left */ \
	using _IntTy = underlying_type_t<_BITMASK>; \
	return (static_cast<_BITMASK>(~static_cast<_IntTy>(_Left))); \
	}

	// FUNCTION _Hash_bytes
inline size_t _Hash_bytes(const unsigned char *_First, size_t _Count) _NOEXCEPT
	{	// FNV-1a hash function for bytes in [_First, _First + _Count)
 #if defined(_WIN64)
	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
	const size_t _FNV_offset_basis = 14695981039346656037ULL;
	const size_t _FNV_prime = 1099511628211ULL;

 #else /* defined(_WIN64) */
# 2316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
	const size_t _FNV_offset_basis = 2166136261U;
	const size_t _FNV_prime = 16777619U;
 #endif /* defined(_WIN64) */
# 2320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	// fold in another byte
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}
	return (_Val);
	}

	// FUNCTION TEMPLATE _Hash_representation
template<class _Kty> inline
	size_t _Hash_representation(const _Kty& _Keyval) _NOEXCEPT
	{	// bitwise hashes the representation of a key
	return (_Hash_bytes(&reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty)));
	}

	// FUNCTION TEMPLATE _Hash_array_representation
template<class _Kty> inline
	size_t _Hash_array_representation(const _Kty * const _First, const size_t _Count) _NOEXCEPT
	{	// bitwise hashes the representation of an array
	return (_Hash_bytes(reinterpret_cast<const unsigned char *>(_First), _Count * sizeof(_Kty)));
	}

	// STRUCT TEMPLATE _Conditionally_enabled_hash
template<class _Kty>
	struct hash;

template<class _Kty,
	bool _Enabled>
	struct _Conditionally_enabled_hash
	{	// conditionally enabled hash base
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Kty argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const _Kty& _Keyval) const
		_NOEXCEPT_COND(_NOEXCEPT_OPER(hash<_Kty>::_Do_hash(_Keyval)))
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<_Kty>::_Do_hash(_Keyval));
		}
	};

template<class _Kty>
	struct _Conditionally_enabled_hash<_Kty, false>
	{	// conditionally disabled hash base
	_Conditionally_enabled_hash() = delete;
	_Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
	_Conditionally_enabled_hash(_Conditionally_enabled_hash&&) = delete;
	_Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
	_Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
	};

	// STRUCT TEMPLATE hash
template<class _Kty>
	struct hash
		: _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
			&& (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)>
	{	// hash functor primary template (handles enums, integrals, and pointers)
	static size_t _Do_hash(const _Kty& _Keyval) _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval));
		}
	};

template<>
	struct hash<float>
	{	// hash functor for float
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef float argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
	_NODISCARD size_t operator()(const float _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval));	// map -0 to 0
		}
	};

template<>
	struct hash<double>
	{	// hash functor for double
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef double argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
	_NODISCARD size_t operator()(const double _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval));	// map -0 to 0
		}
	};

template<>
	struct hash<long double>
	{	// hash functor for long double
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef long double argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
	_NODISCARD size_t operator()(const long double _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval));	// map -0 to 0
		}
	};

template<>
	struct hash<nullptr_t>
	{	// hash functor for nullptr_t
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef nullptr_t argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
	_NODISCARD size_t operator()(nullptr_t) const _NOEXCEPT
		{	// hash nullptr_t to size_t value by pseudorandomizing transform
		void * _Null{};
		return (_Hash_representation(_Null));
		}
	};

		// STRUCT TEMPLATE _Is_nothrow_hashable
struct _Unique_tag_is_nothrow_hashable
	{	// TRANSITION, C1XX
	};

template<class _Kty,
	class = void>
	struct _Is_nothrow_hashable
		: false_type
	{	// tests if std::hash can hash _Kty with noexcept
	};

template<class _Kty>
	struct _Is_nothrow_hashable<_Kty, void_t<
		_Unique_tag_is_nothrow_hashable,
		decltype(hash<_Kty>{}(_STD declval<const _Kty&>()))>>
		: bool_constant<_NOEXCEPT_OPER(hash<_Kty>{}(_STD declval<const _Kty&>()))>
	{	// tests if std::hash can hash _Kty with noexcept
	};

#if _HAS_TR1_NAMESPACE
#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _STD add_const;
using _STD add_cv;
using _STD add_pointer;
using _STD add_volatile;
using _STD aligned_storage;
using _STD alignment_of;
using _STD conditional;
using _STD decay;
using _STD enable_if;
using _STD extent;
using _STD false_type;
using _STD has_virtual_destructor;
using _STD integral_constant;
using _STD is_abstract;
using _STD is_arithmetic;
using _STD is_array;
using _STD is_base_of;
using _STD is_class;
using _STD is_compound;
using _STD is_const;
using _STD is_convertible;
using _STD is_empty;
using _STD is_enum;
using _STD is_floating_point;
using _STD is_function;
using _STD is_fundamental;
using _STD is_integral;
using _STD is_member_function_pointer;
using _STD is_member_object_pointer;
using _STD is_member_pointer;
using _STD is_object;
using _STD is_pod;
using _STD is_pointer;
using _STD is_polymorphic;
using _STD is_reference;
using _STD is_same;
using _STD is_scalar;
using _STD is_signed;
using _STD is_union;
using _STD is_unsigned;
using _STD is_void;
using _STD is_volatile;
using _STD make_signed;
using _STD make_unsigned;
using _STD rank;
using _STD remove_all_extents;
using _STD remove_const;
using _STD remove_cv;
using _STD remove_extent;
using _STD remove_pointer;
using _STD remove_reference;
using _STD remove_volatile;
using _STD true_type;
using _STD cref;
using _STD ref;
using _STD reference_wrapper;
using _STD result_of;
using _STD hash;
}
#pragma warning(pop)
#endif /* _HAS_TR1_NAMESPACE */
# 2514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3


// EVERYTHING BELOW WILL HAVE STRANGE LINE NUMBERS

#define _DEBUGGER_STEP_OVER 15732479 // 0xf00f00 - 1
#define _DEBUGGER_STEP_INTO 16707565 // 0xfeefee - 1

#ifndef _DEBUG_FUNCTIONAL_MACHINERY
 #line _DEBUGGER_STEP_INTO
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
_IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

#if _HAS_CXX17
	// constexpr IMPLEMENTATION OF invoke
 #ifndef _DEBUG_FUNCTIONAL_MACHINERY
  #line _DEBUGGER_STEP_INTO
 #endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2531 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
_IMPLEMENT_INVOKE(_C_, constexpr)
#endif /* _HAS_CXX17 */
# 2533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

#undef _IMPLEMENT_INVOKE

template<class _Rx,
	bool = is_void_v<_Rx>>
	struct _Invoker_ret
	{	// helper to give INVOKE an explicit return type; avoids undesirable Expression SFINAE
	};

template<class _Cv_void>
	struct _Invoker_ret<_Cv_void, true>
	{	// selected for _Rx being cv void
	template<class... _Valtys>
		static void _Call(_Valtys&&... _Vals)
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_OVER
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2550 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		{	// INVOKE, "implicitly" converted to void
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_INTO
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2554 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		_STD invoke(_STD forward<_Valtys>(_Vals)...);
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_OVER
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2558 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		}
	};

template<class _Rx>
	struct _Invoker_ret<_Rx, false>
	{	// selected for all _Rx other than cv void and _Unforced
	template<class... _Valtys>
		static _Rx _Call(_Valtys&&... _Vals)
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_OVER
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		{	// INVOKE, implicitly converted to _Rx
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_INTO
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2573 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		return (_STD invoke(_STD forward<_Valtys>(_Vals)...));
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_OVER
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		}
	};

template<>
	struct _Invoker_ret<_Unforced, false>
	{	// selected for _Rx being _Unforced
	template<class... _Valtys>
		static auto _Call(_Valtys&&... _Vals)
		-> decltype(_STD invoke(_STD forward<_Valtys>(_Vals)...))
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_OVER
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2589 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		{	// INVOKE, unchanged
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_INTO
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2593 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		return (_STD invoke(_STD forward<_Valtys>(_Vals)...));
#ifndef _DEBUG_FUNCTIONAL_MACHINERY
#line _DEBUGGER_STEP_OVER
#endif /* _DEBUG_FUNCTIONAL_MACHINERY */
# 2597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
		}
	};

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 2606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3
#endif /* _TYPE_TRAITS_ */
# 2607 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\type_traits" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN

_CXX17_DEPRECATE_UNCAUGHT_EXCEPTION _CRTIMP2_PURE bool __CLRCALL_PURE_OR_CDECL uncaught_exception() _NOEXCEPT;
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL uncaught_exceptions() _NOEXCEPT;

_STD_END

 #if _HAS_EXCEPTIONS

#if 0 /* expanded by -frewrite-includes */
#include <malloc.h>
#endif /* expanded by -frewrite-includes */
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 1 3
//
// malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
#define _INC_MALLOC

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_malloc.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

_CRT_BEGIN_C_HEADER



// Maximum heap request the heap manager will attempt
#ifdef _WIN64
    #define _HEAP_MAXREQ 0xFFFFFFFFFFFFFFE0
#else
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
    #define _HEAP_MAXREQ 0xFFFFFFE0
#endif
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3



// Constants for _heapchk and _heapwalk routines
#define _HEAPEMPTY    (-1)
#define _HEAPOK       (-2)
#define _HEAPBADBEGIN (-3)
#define _HEAPBADNODE  (-4)
#define _HEAPEND      (-5)
#define _HEAPBADPTR   (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1



typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;



#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b) _aligned_malloc(a, b)



_Ret_notnull_ _Post_writable_byte_size_(_Size)
void* __cdecl _alloca(_In_ size_t _Size);



#if !defined __midl && !defined RC_INVOKED

    _ACRTIMP intptr_t __cdecl _get_heap_handle(void);

    _Check_return_
    _DCRTIMP int __cdecl _heapmin(void);

    #if defined _DEBUG || defined _CRT_USE_WINAPI_FAMILY_DESKTOP_APP || defined _CORECRT_BUILD
        _ACRTIMP int __cdecl _heapwalk(_Inout_ _HEAPINFO* _EntryInfo);
    #endif
# 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

    #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
        _Check_return_ _DCRTIMP int __cdecl _heapchk(void);
    #endif
# 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

    _DCRTIMP int __cdecl _resetstkoflw(void);

    #define _ALLOCA_S_THRESHOLD     1024
    #define _ALLOCA_S_STACK_MARKER  0xCCCC
    #define _ALLOCA_S_HEAP_MARKER   0xDDDD

    #ifdef _WIN64
        #define _ALLOCA_S_MARKER_SIZE 16
    #else
# 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
        #define _ALLOCA_S_MARKER_SIZE 8
    #endif
# 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

    _STATIC_ASSERT(sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE);


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(_Out_opt_ __crt_typefix(unsigned int*) void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#endif
# 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3



#ifdef _DEBUG

    #ifndef _CRTDBG_MAP_ALLOC
        #undef _malloca
        #define _malloca(size)                                                           \
            __pragma(warning(suppress: 6255 6386))                                       \
            (_MallocaComputeSize(size) != 0                                              \
                ? _MarkAllocaS(malloc(_MallocaComputeSize(size)), _ALLOCA_S_HEAP_MARKER) \
                : NULL)
    #endif
# 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

#else
# 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

    #undef _malloca
    #define _malloca(size)                                                                 \
        __pragma(warning(suppress: 6255 6386))                                             \
        (_MallocaComputeSize(size) != 0                                                    \
            ? (((_MallocaComputeSize(size) <= _ALLOCA_S_THRESHOLD)                         \
                ? _MarkAllocaS(_alloca(_MallocaComputeSize(size)), _ALLOCA_S_STACK_MARKER) \
                : _MarkAllocaS(malloc(_MallocaComputeSize(size)), _ALLOCA_S_HEAP_MARKER))) \
            : NULL)

#endif
# 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3



#if defined __midl && !defined RC_INVOKED
#elif defined _DEBUG && defined _CRTDBG_MAP_ALLOC
# 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
#else
# 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3

    #undef _freea

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __CRTDECL _freea(_Pre_maybenull_ _Post_invalid_ void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - _ALLOCA_S_MARKER_SIZE;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == _ALLOCA_S_HEAP_MARKER)
            {
                free(_Memory);
            }
            #ifdef _ASSERTE
            else if (_Marker != _ALLOCA_S_STACK_MARKER)
            {
                _ASSERTE(("Corrupted pointer passed to _freea" && 0));
            }
            #endif
# 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
        }
    }
    #pragma warning(pop)

#endif
# 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3



#if _CRT_INTERNAL_NONSTDC_NAMES
    #define alloca _alloca
#endif
# 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3



_CRT_END_C_HEADER
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_exception.h>
#endif /* expanded by -frewrite-includes */
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 1 3
//
// vcruntime_exception.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <exception> functionality that is implemented in the VCRuntime.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <eh.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 1 3
//
// eh.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// User-includable header for exception handling.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 3
#define _INC_EH

#if 0 /* expanded by -frewrite-includes */
#include <corecrt_terminate.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 1 3
//
// corecrt_terminate.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The terminate handler
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3

#ifndef RC_INVOKED

_CRT_BEGIN_C_HEADER

// terminate_handler is the standard name; terminate_function is defined for
// source compatibility.
typedef void (__CRTDECL* terminate_handler )();
typedef void (__CRTDECL* terminate_function)();

#ifdef _M_CEE
    typedef void (__clrcall* __terminate_function_m)();
    typedef void (__clrcall* __terminate_handler_m )();
#endif
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3

#ifdef __cplusplus

    _ACRTIMP __declspec(noreturn) void __cdecl abort();
    _ACRTIMP __declspec(noreturn) void __cdecl terminate() throw();

    #ifndef _M_CEE_PURE

        _ACRTIMP terminate_handler __cdecl set_terminate(
            _In_opt_ terminate_handler _NewTerminateHandler
            ) throw();

        _ACRTIMP terminate_handler __cdecl _get_terminate();

    #endif
# 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3

#endif // __cplusplus
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3

_CRT_END_C_HEADER

#endif // RC_INVOKED
# 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 2 3

#ifndef RC_INVOKED

_CRT_BEGIN_C_HEADER

// unexpected_handler is the standard name; unexpected_function is defined for
// source compatibility.
typedef void (__CRTDECL* unexpected_handler )();
typedef void (__CRTDECL* unexpected_function)();

#ifdef _M_CEE
    typedef void (__clrcall* __unexpected_function_m)();
    typedef void (__clrcall* __unexpected_handler_m)();
#endif
# 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 3

struct _EXCEPTION_POINTERS;

#ifdef __cplusplus

    _VCRTIMP __declspec(noreturn) void __cdecl unexpected() noexcept(false);

    #ifndef _M_CEE_PURE

        _VCRTIMP unexpected_handler __cdecl set_unexpected(
            _In_opt_ unexpected_handler _NewUnexpectedHandler
            ) throw();

        _VCRTIMP unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

        _VCRTIMP _se_translator_function __cdecl _set_se_translator(
            _In_opt_ _se_translator_function _NewSETranslator
            );

    #endif
# 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 3

    class type_info;

    _VCRTIMP int __cdecl _is_exception_typeof(
        _In_ type_info const&     _Type,
        _In_ _EXCEPTION_POINTERS* _ExceptionPtr
        );

    _VCRTIMP bool __cdecl __uncaught_exception();
    _VCRTIMP int  __cdecl __uncaught_exceptions();

#endif
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 3

_CRT_END_C_HEADER

#endif // RC_INVOKED
# 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\eh.h" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 2 3

#ifdef _M_CEE_PURE
    #if 0 /* expanded by -frewrite-includes */
#include <vcruntime_new.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 3
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 3
#endif
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 3

#pragma pack(push, _CRT_PACKING)
#if !defined RC_INVOKED && _HAS_EXCEPTIONS

_CRT_BEGIN_C_HEADER

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

_VCRTIMP void __cdecl __std_exception_copy(
    _In_  __std_exception_data const* _From,
    _Out_ __std_exception_data*       _To
    );

_VCRTIMP void __cdecl __std_exception_destroy(
    _Inout_ __std_exception_data* _Data
    );

_CRT_END_C_HEADER



namespace std {

class exception
{
public:

    exception() throw()
        : _Data()
    {
    }

    explicit exception(char const* const _Message) throw()
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) throw()
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) throw()
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) throw()
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

} // namespace std

#endif // !RC_INVOKED && _HAS_EXCEPTIONS
# 142 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_exception.h" 3
#pragma pack(pop)

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
  V6.00:0009 */
# 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 2 3

_STD_BEGIN

using ::terminate;

#ifndef _M_CEE_PURE
using ::set_terminate;
using ::terminate_handler;

_NODISCARD inline terminate_handler __CRTDECL get_terminate() _NOEXCEPT
	{	// get current terminate handler
	return (_get_terminate());
	}
#endif /* _M_CEE_PURE */
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

#if _HAS_UNEXPECTED
using ::unexpected;

 #ifndef _M_CEE_PURE
using ::set_unexpected;
using ::unexpected_handler;

_NODISCARD inline unexpected_handler __CRTDECL get_unexpected() _NOEXCEPT
	{	// get current unexpected handler
	return (_get_unexpected());
	}
 #endif /* _M_CEE_PURE */
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
#endif /* _HAS_UNEXPECTED */
# 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

_STD_END

 #else /* _HAS_EXCEPTIONS */
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

		// CLASS exception
_STDEXT_BEGIN
class exception;
_STDEXT_END

_STD_BEGIN

using _STDEXT exception;

typedef void (__cdecl *_Prhand)(const exception&);
extern _CRTIMP2_NCEEPURE_IMPORT _Prhand _Raise_handler;	// pointer to raise handler

_STD_END

_STDEXT_BEGIN
class exception
	{	// base of all library exceptions
public:

	static _STD _Prhand _Set_raise_handler(_STD _Prhand _Pnew)
		{	// register a handler for _Raise calls
		const _STD _Prhand _Pold = _STD _Raise_handler;
		_STD _Raise_handler = _Pnew;
		return (_Pold);
		}

	// this constructor is necessary to compile
	// successfully header new for _HAS_EXCEPTIONS==0 scenario
	explicit __CLR_OR_THIS_CALL exception(const char *_Message = "unknown", int = 1) _NOEXCEPT
		: _Ptr(_Message)
		{	// construct from message string
		}

	__CLR_OR_THIS_CALL exception(const exception& _Right) _NOEXCEPT
		: _Ptr(_Right._Ptr)
		{	// construct by copying _Right
		}

	exception& __CLR_OR_THIS_CALL operator=(const exception& _Right) _NOEXCEPT
		{	// assign _Right
		_Ptr = _Right._Ptr;
		return (*this);
		}

	virtual __CLR_OR_THIS_CALL ~exception() _NOEXCEPT
		{	// destroy the object
		}

	_NODISCARD virtual const char * __CLR_OR_THIS_CALL what() const _NOEXCEPT
		{	// return pointer to message string
		return (_Ptr != 0 ? _Ptr : "unknown exception");
		}

	void __CLR_OR_THIS_CALL _Raise() const
		{	// raise the exception
		if (_STD _Raise_handler != 0)
			(*_STD _Raise_handler)(*this);	// call raise handler if present

		_Doraise();	// call the protected virtual
		_RAISE(*this);	// raise this exception
		}

protected:
	virtual void __CLR_OR_THIS_CALL _Doraise() const
		{	// perform class-specific exception handling
		}

protected:
	const char *_Ptr;	// the message pointer
	};

	// CLASS bad_exception
class bad_exception : public exception
	{	// base of all bad exceptions
public:
	__CLR_OR_THIS_CALL bad_exception(const char *_Message = "bad exception") _NOEXCEPT
		: exception(_Message)
		{	// construct from message string
		}

	virtual __CLR_OR_THIS_CALL ~bad_exception() _NOEXCEPT
		{	// destroy the object
		}

protected:
	virtual void __CLR_OR_THIS_CALL _Doraise() const
		{	// raise this exception
		_RAISE(*this);
		}
	};

	// CLASS bad_alloc
class bad_alloc : public exception
	{	// base of all bad allocation exceptions
public:
	__CLR_OR_THIS_CALL bad_alloc() _NOEXCEPT
		: exception("bad allocation", 1)
		{	// construct from message string with no memory allocation
		}

	virtual __CLR_OR_THIS_CALL ~bad_alloc() _NOEXCEPT
		{	// destroy the object
		}

private:
	friend class bad_array_new_length;

	__CLR_OR_THIS_CALL bad_alloc(const char *_Message) _NOEXCEPT
		: exception(_Message, 1)
		{	// construct from message string with no memory allocation
		}

protected:
	virtual void __CLR_OR_THIS_CALL _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
	};

_STDEXT_END

_STD_BEGIN
		// DUMMY FUNCTION DECLARATIONS
typedef void (__cdecl *terminate_handler)();

inline terminate_handler __CRTDECL set_terminate(terminate_handler) _NOEXCEPT
	{	// register a terminate handler
	return 0;
	}

inline void __CRTDECL terminate() _NOEXCEPT
	{	// handle exception termination
	}

_NODISCARD inline terminate_handler __CRTDECL get_terminate() _NOEXCEPT
	{	// get current terminate handler
	return (0);
	}

#if _HAS_UNEXPECTED
typedef void (__cdecl *unexpected_handler)();

inline unexpected_handler __CRTDECL set_unexpected(unexpected_handler) _NOEXCEPT
	{	// register an unexpected handler
	return 0;
	}

inline void __CRTDECL unexpected()
	{	// handle unexpected exception
	}

_NODISCARD inline unexpected_handler __CRTDECL get_unexpected() _NOEXCEPT
	{	// get current unexpected handler
	return (0);
	}
#endif /* _HAS_UNEXPECTED */
# 215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

using _STDEXT bad_alloc;
using _STDEXT bad_exception;

_STD_END

 #endif /* _HAS_EXCEPTIONS */
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCreate(_Out_ void*);
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrDestroy(_Inout_ void*);
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCopy(_Out_ void*, _In_ const void*);
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrAssign(_Inout_ void*, _In_ const void*);
_CRTIMP2_PURE bool __CLRCALL_PURE_OR_CDECL __ExceptionPtrCompare(_In_ const void*, _In_ const void*);
_CRTIMP2_PURE bool __CLRCALL_PURE_OR_CDECL __ExceptionPtrToBool(_In_ const void*);
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrSwap(_Inout_ void*, _Inout_ void*);
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCurrentException(_Out_ void*);
[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrRethrow(_In_ const void*);
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCopyException(
	_Inout_ void*, _In_ const void*, _In_ const void*);

_STD_BEGIN

class exception_ptr
	{
public:
	exception_ptr() _NOEXCEPT
		{
		__ExceptionPtrCreate(this);
		}

	exception_ptr(nullptr_t) _NOEXCEPT
		{
		__ExceptionPtrCreate(this);
		}

	~exception_ptr() _NOEXCEPT
		{
		__ExceptionPtrDestroy(this);
		}

	exception_ptr(const exception_ptr& _Rhs) _NOEXCEPT
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}

	exception_ptr& operator=(const exception_ptr& _Rhs) _NOEXCEPT
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}

	exception_ptr& operator=(nullptr_t) _NOEXCEPT
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	explicit operator bool() const _NOEXCEPT
		{
		return __ExceptionPtrToBool(this);
		}

	[[noreturn]] void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception() _NOEXCEPT
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}

	static exception_ptr _Copy_exception(_In_ void* _Except, _In_ const void* _Ptr)
		{
		exception_ptr _Retval;
		if (!_Ptr)
			{
			// unsupported exceptions
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}

private:
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wunused-private-field"
#endif /* __clang__ */
# 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
	void* _Data1;
	void* _Data2;
#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) _NOEXCEPT
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

_NODISCARD inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) _NOEXCEPT
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

_NODISCARD inline bool operator==(nullptr_t, const exception_ptr& _Rhs) _NOEXCEPT
	{
	return !_Rhs;
	}

_NODISCARD inline bool operator==(const exception_ptr& _Lhs, nullptr_t) _NOEXCEPT
	{
	return !_Lhs;
	}

_NODISCARD inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) _NOEXCEPT
	{
	return !(_Lhs == _Rhs);
	}

_NODISCARD inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) _NOEXCEPT
	{
	return !(_Lhs == _Rhs);
	}

_NODISCARD inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) _NOEXCEPT
	{
	return !(_Lhs == _Rhs);
	}

_NODISCARD inline exception_ptr current_exception() _NOEXCEPT
	{
	return exception_ptr::_Current_exception();
	}

[[noreturn]] inline void rethrow_exception(_In_ exception_ptr _Ptr)
	{
	_Ptr._RethrowException();
	}

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> _NODISCARD exception_ptr make_exception_ptr(_Ex _Except) _NOEXCEPT
	{
	return exception_ptr::_Copy_exception(_STD addressof(_Except), __GetExceptionInfo(_Except));
	}

	// CLASS nested_exception
class nested_exception
	{	// wrap an exception_ptr
public:
	nested_exception() _NOEXCEPT
		: _Exc(_STD current_exception())
		{	// default construct
		}

	nested_exception(const nested_exception&) _NOEXCEPT = default;
	nested_exception& operator=(const nested_exception&) _NOEXCEPT = default;
	virtual ~nested_exception() _NOEXCEPT
		{
		}

	[[noreturn]] void rethrow_nested() const
		{	// throw wrapped exception_ptr
		if (_Exc)
			_STD rethrow_exception(_Exc);
		else
			_STD terminate();
		}

	_NODISCARD exception_ptr nested_ptr() const _NOEXCEPT
		{	// return wrapped exception_ptr
		return (_Exc);
		}

private:
	exception_ptr _Exc;
	};

	// FUNCTION TEMPLATE throw_with_nested
template<class _Ty,
	class _Uty>
	struct _With_nested
		: _Uty, nested_exception
	{	// glue user exception to nested_exception
	explicit _With_nested(_Ty&& _Arg)
		: _Uty(_STD forward<_Ty>(_Arg)), nested_exception()
		{	// store user exception and current_exception()
		}
	};

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type)
	{	// throw user exception glued to nested_exception
	using _Uty = decay_t<_Ty>;
	using _Glued = _With_nested<_Ty, _Uty>;

	_THROW(_Glued(_STD forward<_Ty>(_Arg)));
	}

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type)
	{	// throw user exception by itself
	_THROW(_STD forward<_Ty>(_Arg));
	}

template<class _Ty>
	[[noreturn]] inline void throw_with_nested(_Ty&& _Arg)
	{	// throw user exception, glued to nested_exception if possible
	typedef decay_t<_Ty> _Uty;

	bool_constant<
		is_class_v<_Uty>
		&& !is_base_of_v<nested_exception, _Uty>
		&& !is_final_v<_Uty>> _Tag;

	_Throw_with_nested(_STD forward<_Ty>(_Arg), _Tag);
	}

#ifdef _CPPRTTI
	// FUNCTION TEMPLATE rethrow_if_nested
template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
	{	// use dynamic_cast
	const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

	if (_Nested)
		_Nested->rethrow_nested();
	}

template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *, false_type)
	{	// can't use dynamic_cast
	}

template<class _Ty> inline
	void rethrow_if_nested(const _Ty& _Arg)
	{	// detect nested_exception inheritance
	bool_constant<is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty>
		|| is_convertible_v<_Ty *, nested_exception *>)> _Tag;

	_Rethrow_if_nested(_STD addressof(_Arg), _Tag);
	}
#else /* _CPPRTTI */
# 463 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
template<class _Ty>
	void rethrow_if_nested(const _Ty&) = delete;	// requires /GR option
#endif /* _CPPRTTI */
# 466 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)

#endif /* RC_INVOKED */
# 474 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3
#endif /* _EXCEPTION_ */
# 475 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\exception" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_new.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 1 3
//
// vcruntime_new.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of memory management functions in the VCRuntime.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 2 3

#ifdef __cplusplus
extern "C++" {

#pragma pack(push, _CRT_PACKING)

#pragma warning(push)
#pragma warning(disable: 4985) // attributes not present on previous declaration

#pragma push_macro("new")
#undef new

// C++17 or greater only
#ifndef _HAS_ALIGNED_NEW
 #ifdef _MSVC_LANG
  #if _MSVC_LANG > 201402
   #define _HAS_ALIGNED_NEW	1
  #else
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
   #define _HAS_ALIGNED_NEW	0
  #endif
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
 #else
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
  #if __cplusplus > 201402
   #define _HAS_ALIGNED_NEW	1
  #else
# 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
   #define _HAS_ALIGNED_NEW	0
  #endif
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
 #endif
# 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
#endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

#if _HAS_ALIGNED_NEW
namespace std
{
    enum class align_val_t : size_t {};
}
#endif
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
    namespace std
    {
        struct nothrow_t { };

        #ifdef _CRT_ENABLE_SELECTANY_NOTHROW
            extern __declspec(selectany) nothrow_t const nothrow;
        #else
# 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
            extern nothrow_t const nothrow;
        #endif
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
    }
#endif
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

_Ret_notnull_ _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new(
    size_t _Size
    );

_Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new(
    size_t _Size,
    std::nothrow_t const&
    ) throw();

_Ret_notnull_ _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new[](
    size_t _Size
    );

_Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) throw();

void __CRTDECL operator delete(
    void* _Block
    ) throw();

void __CRTDECL operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __CRTDECL operator delete[](
    void* _Block
    ) throw();

void __CRTDECL operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __CRTDECL operator delete(
    void*  _Block,
    size_t _Size
    ) throw();

void __CRTDECL operator delete[](
    void* _Block,
    size_t _Size
    ) throw();

#if _HAS_ALIGNED_NEW
_Ret_notnull_ _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new(
    size_t           _Size,
    std::align_val_t _Al
    );

_Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new(
    size_t                _Size,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) throw();


_Ret_notnull_ _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new[](
    size_t           _Size,
    std::align_val_t _Al
    );

_Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size)
_VCRT_ALLOCATOR void* __CRTDECL operator new[](
    size_t                _Size,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) throw();

void __CRTDECL operator delete(
    void*            _Block,
    std::align_val_t _Al
    ) throw();

void __CRTDECL operator delete(
    void*                 _Block,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) throw();

void __CRTDECL operator delete[](
    void*            _Block,
    std::align_val_t _Al
    ) throw();

void __CRTDECL operator delete[](
    void*                 _Block,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) throw();

void __CRTDECL operator delete(
    void*            _Block,
    size_t           _Size,
    std::align_val_t _Al
    ) throw();

void __CRTDECL operator delete[](
    void*            _Block,
    size_t           _Size,
    std::align_val_t _Al
    ) throw();
#endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

#ifndef __PLACEMENT_NEW_INLINE
    #define __PLACEMENT_NEW_INLINE
    _Ret_notnull_ _Post_writable_byte_size_(_Size)
    inline void* __CRTDECL operator new(size_t _Size, _Writable_bytes_(_Size) void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __CRTDECL operator delete(void*, void*) throw()
    {
        return;
    }
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

#ifndef __PLACEMENT_VEC_NEW_INLINE
    #define __PLACEMENT_VEC_NEW_INLINE
    _Ret_notnull_ _Post_writable_byte_size_(_Size)
    inline void* __CRTDECL operator new[](size_t _Size, _Writable_bytes_(_Size) void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __CRTDECL operator delete[](void*, void*) throw()
    {
    }
#endif
# 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3

#pragma pop_macro("new")

#pragma warning(pop)
#pragma pack(pop)

} // extern "C++"
#endif // __cplusplus
# 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new.h" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 2 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")

#undef new

_STD_BEGIN
#if _HAS_CXX17

 #if defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM) || defined(_M_ARM64)
_INLINE_VAR constexpr size_t hardware_constructive_interference_size = 64;
_INLINE_VAR constexpr size_t hardware_destructive_interference_size = 64;
 #else /* ^^^ supported hardware ^^^ // vvv unsupported hardware vvv */
# 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3
  #error Unsupported architecture
 #endif /* hardware */
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3

#endif /* _HAS_CXX17 */
# 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3

		// SUPPORT TYPES
#if !defined(_INC_NEW) || !defined(_MSC_EXTENSIONS)
// handler for operator new failures
typedef void (__CLRCALL_PURE_OR_CDECL * new_handler) ();
#endif /* !defined(_INC_NEW) || !defined(_MSC_EXTENSIONS) */
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3

		// FUNCTION AND OBJECT DECLARATIONS
_CRTIMP2 new_handler __cdecl set_new_handler(_In_opt_ new_handler) _NOEXCEPT;
_NODISCARD _CRTIMP2 new_handler __cdecl get_new_handler() _NOEXCEPT;
_STD_END

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)

#endif /* RC_INVOKED */
# 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3
#endif /* _NEW_ */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\new" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <xutility>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 1 3
// xutility internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#ifndef _XUTILITY_
#define _XUTILITY_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <climits>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#if 0 /* expanded by -frewrite-includes */
#include <utility>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 1 3
// utility standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3
#ifndef _UTILITY_
#define _UTILITY_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xstddef>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3
#if 0 /* expanded by -frewrite-includes */
#include <iosfwd>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 1 3
// iosfwd standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
#ifndef _IOSFWD_
#define _IOSFWD_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <cstdio>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 1 3
// cstdio standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 3
#ifndef _CSTDIO_
#define _CSTDIO_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 1 3
//
// stdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdio.h> header.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#define _INC_STDIO

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wstdio.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

_CRT_BEGIN_C_HEADER

/* Buffered I/O macros */

#define BUFSIZ  512



/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 3

#define EOF    (-1)

#define _IOFBF 0x0000
#define _IOLBF 0x0040
#define _IONBF 0x0004



#define L_tmpnam   260 // _MAX_PATH
#if __STDC_WANT_SECURE_LIB__
    #define L_tmpnam_s L_tmpnam
#endif
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3



/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         _CRT_INT_MAX
#if __STDC_WANT_SECURE_LIB__
    #define TMP_MAX_S       TMP_MAX
    #define _TMP_MAX_S      TMP_MAX
#endif
# 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3


typedef __int64 fpos_t;



#if _CRT_FUNCTIONS_REQUIRED

    _Check_return_opt_
    _ACRTIMP errno_t __cdecl _get_stream_buffer_pointers(
        _In_      FILE*   _Stream,
        _Out_opt_ char*** _Base,
        _Out_opt_ char*** _Pointer,
        _Out_opt_ int**   _Count
        );


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    #if __STDC_WANT_SECURE_LIB__

        _Check_return_wat_
        _ACRTIMP errno_t __cdecl clearerr_s(
            _Inout_ FILE* _Stream
            );

        _Check_return_wat_
        _ACRTIMP errno_t __cdecl fopen_s(
            _Outptr_result_maybenull_ FILE**      _Stream,
            _In_z_                    char const* _FileName,
            _In_z_                    char const* _Mode
            );

        _Check_return_opt_
        _Success_(return != 0)
        _ACRTIMP size_t __cdecl fread_s(
            _Out_writes_bytes_to_(_BufferSize, _ElementSize * _ElementCount)   void*  _Buffer,
            _In_range_(>=, _ElementSize * _ElementCount)                       size_t _BufferSize,
            _In_                                                               size_t _ElementSize,
            _In_                                                               size_t _ElementCount,
            _Inout_                                                            FILE*  _Stream
            );

        _Check_return_wat_
        _ACRTIMP errno_t __cdecl freopen_s(
            _Outptr_result_maybenull_ FILE**      _Stream,
            _In_z_                    char const* _FileName,
            _In_z_                    char const* _Mode,
            _Inout_                   FILE*       _OldStream
            );

        _Success_(return != 0)
        _ACRTIMP char* __cdecl gets_s(
            _Out_writes_z_(_Size) char*   _Buffer,
            _In_                  rsize_t _Size
            );

        _Check_return_wat_
        _ACRTIMP errno_t __cdecl tmpfile_s(
            _Out_opt_ _Deref_post_valid_ FILE** _Stream
            );

        _Success_(return == 0)
        _Check_return_wat_
        _ACRTIMP errno_t __cdecl tmpnam_s(
            _Out_writes_z_(_Size) char*   _Buffer,
            _In_                  rsize_t _Size
            );

    #endif
# 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _ACRTIMP void __cdecl clearerr(
        _Inout_ FILE* _Stream
        );

    _Success_(return != -1)
    _Check_return_opt_
    _ACRTIMP int __cdecl fclose(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _fcloseall(void);

    _Check_return_
    _ACRTIMP FILE* __cdecl _fdopen(
        _In_   int         _FileHandle,
        _In_z_ char const* _Mode
        );

    _Check_return_
    _ACRTIMP int __cdecl feof(
        _In_ FILE* _Stream
        );

    _Check_return_
    _ACRTIMP int __cdecl ferror(
        _In_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl fflush(
        _Inout_opt_ FILE* _Stream
        );

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl fgetc(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _fgetchar(void);

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl fgetpos(
        _Inout_ FILE*   _Stream,
        _Out_   fpos_t* _Position
        );

    _Success_(return == _Buffer)
    _Check_return_opt_
    _ACRTIMP char* __cdecl fgets(
        _Out_writes_z_(_MaxCount) char* _Buffer,
        _In_                      int   _MaxCount,
        _Inout_                   FILE* _Stream
        );

    _Check_return_
    _ACRTIMP int __cdecl _fileno(
        _In_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _flushall(void);

    _Check_return_ _CRT_INSECURE_DEPRECATE(fopen_s)
    _ACRTIMP FILE* __cdecl fopen(
        _In_z_ char const* _FileName,
        _In_z_ char const* _Mode
        );


    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl fputc(
        _In_    int   _Character,
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _fputchar(
        _In_ int _Character
        );

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl fputs(
        _In_z_  char const* _Buffer,
        _Inout_ FILE*       _Stream
        );

    _Check_return_opt_
    _ACRTIMP size_t __cdecl fread(
        _Out_writes_bytes_(_ElementSize * _ElementCount) void*  _Buffer,
        _In_                                             size_t _ElementSize,
        _In_                                             size_t _ElementCount,
        _Inout_                                          FILE*  _Stream
        );

    _Success_(return != 0)
    _Check_return_ _CRT_INSECURE_DEPRECATE(freopen_s)
    _ACRTIMP FILE* __cdecl freopen(
        _In_z_  char const* _FileName,
        _In_z_  char const* _Mode,
        _Inout_ FILE*       _Stream
        );

    _Check_return_
    _ACRTIMP FILE* __cdecl _fsopen(
        _In_z_ char const* _FileName,
        _In_z_ char const* _Mode,
        _In_   int         _ShFlag
        );

    _Success_(return == 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl fsetpos(
        _Inout_ FILE*         _Stream,
        _In_    fpos_t const* _Position
        );

    _Success_(return == 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl fseek(
        _Inout_ FILE* _Stream,
        _In_    long  _Offset,
        _In_    int   _Origin
        );

    _Success_(return == 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl _fseeki64(
        _Inout_ FILE*   _Stream,
        _In_    __int64 _Offset,
        _In_    int     _Origin
        );

    _Success_(return != -1)
    _Check_return_
    _ACRTIMP long __cdecl ftell(
        _Inout_ FILE* _Stream
        );

    _Success_(return != -1)
    _Check_return_
    _ACRTIMP __int64 __cdecl _ftelli64(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP size_t __cdecl fwrite(
        _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,
        _In_                                           size_t      _ElementSize,
        _In_                                           size_t      _ElementCount,
        _Inout_                                        FILE*       _Stream
        );

    _Success_(return != EOF)
    _Check_return_
    _ACRTIMP int __cdecl getc(
        _Inout_ FILE* _Stream
        );

    _Check_return_
    _ACRTIMP int __cdecl getchar(void);

    _Check_return_
    _ACRTIMP int __cdecl _getmaxstdio(void);

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
        char*, gets_s,
        char, _Buffer)

    _Check_return_
    _ACRTIMP int __cdecl _getw(
        _Inout_ FILE* _Stream
        );

    _ACRTIMP void __cdecl perror(
        _In_opt_z_ char const* _ErrorMessage
        );

    #if defined _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

        _Success_(return != -1)
        _Check_return_opt_
        _DCRTIMP int __cdecl _pclose(
            _Inout_ FILE* _Stream
            );

        _Check_return_
        _DCRTIMP FILE* __cdecl _popen(
            _In_z_ char const* _Command,
            _In_z_ char const* _Mode
            );

    #endif
# 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl putc(
        _In_    int   _Character,
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl putchar(
        _In_ int _Character
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl puts(
        _In_z_ char const* _Buffer
        );

    _Success_(return != -1)
    _Check_return_opt_
    _ACRTIMP int __cdecl _putw(
        _In_    int   _Word,
        _Inout_ FILE* _Stream
        );

    _ACRTIMP int __cdecl remove(
        _In_z_ char const* _FileName
        );

    _Check_return_
    _ACRTIMP int __cdecl rename(
        _In_z_ char const* _OldFileName,
        _In_z_ char const* _NewFileName
        );

    _ACRTIMP int __cdecl _unlink(
        _In_z_ char const* _FileName
        );

    #if _CRT_INTERNAL_NONSTDC_NAMES

        _CRT_NONSTDC_DEPRECATE(_unlink)
        _ACRTIMP int __cdecl unlink(
            _In_z_ char const* _FileName
            );

    #endif
# 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _ACRTIMP void __cdecl rewind(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _rmtmp(void);

    _CRT_INSECURE_DEPRECATE(setvbuf)
    _ACRTIMP void __cdecl setbuf(
        _Inout_                                             FILE* _Stream,
        _Inout_updates_opt_(BUFSIZ) _Post_readable_size_(0) char* _Buffer
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _setmaxstdio(
        _In_ int _Maximum
        );

    _Success_(return == 0)
    _Check_return_opt_
    _ACRTIMP int __cdecl setvbuf(
        _Inout_                      FILE*  _Stream,
        _Inout_updates_opt_(_Size)   char*  _Buffer,
        _In_                         int    _Mode,
        _In_                         size_t _Size
        );

    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
        #pragma push_macro("_tempnam")
        #undef _tempnam
    #endif
# 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_
    _ACRTIMP _CRTALLOCATOR char* __cdecl _tempnam(
        _In_opt_z_ char const* _DirectoryName,
        _In_opt_z_ char const* _FilePrefix
        );

    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
        #pragma pop_macro("_tempnam")
    #endif
# 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(tmpfile_s)
    _ACRTIMP FILE* __cdecl tmpfile(void);

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
        _Success_(return == 0)
        errno_t, tmpnam_s,
        _Always_(_Post_z_) char, _Buffer
        )

#pragma warning(push)
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
        _Success_(return != 0)
        char*, __RETURN_POLICY_DST, _ACRTIMP, tmpnam,
        _Pre_maybenull_ _Always_(_Post_z_), char, _Buffer
        )
#pragma warning(pop)

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl ungetc(
        _In_    int   _Character,
        _Inout_ FILE* _Stream
        );



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _ACRTIMP void __cdecl _lock_file(
        _Inout_ FILE* _Stream
        );

    _ACRTIMP void __cdecl _unlock_file(
        _Inout_ FILE* _Stream
        );

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl _fclose_nolock(
        _Inout_ FILE* _Stream
        );

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl _fflush_nolock(
        _Inout_opt_ FILE* _Stream
        );

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl _fgetc_nolock(
        _Inout_ FILE* _Stream
        );

    _Success_(return != EOF)
    _Check_return_opt_
    _ACRTIMP int __cdecl _fputc_nolock(
        _In_    int   _Character,
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP size_t __cdecl _fread_nolock(
        _Out_writes_bytes_(_ElementSize * _ElementCount) void*  _Buffer,
        _In_                                             size_t _ElementSize,
        _In_                                             size_t _ElementCount,
        _Inout_                                          FILE*  _Stream
        );

    _Check_return_opt_
    _Success_(return != 0)
    _ACRTIMP size_t __cdecl _fread_nolock_s(
        _Out_writes_bytes_to_(_BufferSize, _ElementSize * _ElementCount) void*  _Buffer,
        _In_range_(>=, _ElementSize * _ElementCount)                     size_t _BufferSize,
        _In_                                                             size_t _ElementSize,
        _In_                                                             size_t _ElementCount,
        _Inout_                                                          FILE*  _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _fseek_nolock(
        _Inout_ FILE* _Stream,
        _In_    long  _Offset,
        _In_    int   _Origin
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _fseeki64_nolock(
        _Inout_ FILE*   _Stream,
        _In_    __int64 _Offset,
        _In_    int     _Origin
        );

    _Check_return_
    _ACRTIMP long __cdecl _ftell_nolock(
        _Inout_ FILE* _Stream
        );

    _Check_return_
    _ACRTIMP __int64 __cdecl _ftelli64_nolock(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP size_t __cdecl _fwrite_nolock(
        _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,
        _In_                                           size_t      _ElementSize,
        _In_                                           size_t      _ElementCount,
        _Inout_                                        FILE*       _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _getc_nolock(
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _putc_nolock(
        _In_    int   _Character,
        _Inout_ FILE* _Stream
        );

    _Check_return_opt_
    _ACRTIMP int __cdecl _ungetc_nolock(
        _In_    int   _Character,
        _Inout_ FILE* _Stream
        );

    #define _getchar_nolock()     _getc_nolock(stdin)
    #define _putchar_nolock(_Ch)  _putc_nolock(_Ch, stdout)
    #define _getwchar_nolock()    _getwc_nolock(stdin)
    #define _putwchar_nolock(_Ch) _putwc_nolock(_Ch, stdout)



    #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
        #define fclose(_Stream)                                           _fclose_nolock(_Stream)
        #define fflush(_Stream)                                           _fflush_nolock(_Stream)
        #define fgetc(_Stream)                                            _fgetc_nolock(_Stream)
        #define fread(_DstBuf, _ElementSize, _Count, _Stream)             _fread_nolock(_DstBuf, _ElementSize, _Count, _Stream)
        #define fread_s(_DstBuf, _DstSize, _ElementSize, _Count, _Stream) _fread_nolock_s(_DstBuf, _DstSize, _ElementSize, _Count, _Stream)
        #define fseek(_Stream, _Offset, _Origin)                          _fseek_nolock(_Stream, _Offset, _Origin)
        #define _fseeki64(_Stream, _Offset, _Origin)                      _fseeki64_nolock(_Stream, _Offset, _Origin)
        #define ftell(_Stream)                                            _ftell_nolock(_Stream)
        #define _ftelli64(_Stream)                                        _ftelli64_nolock(_Stream)
        #define fwrite(_SrcBuf, _ElementSize, _Count, _Stream)            _fwrite_nolock(_SrcBuf, _ElementSize, _Count, _Stream)
        #define getc(_Stream)                                             _getc_nolock(_Stream)
        #define putc(_Ch, _Stream)                                        _fputc(_Ch, _Stream)
        #define ungetc(_Ch, _Stream)                                      _ungetc_nolock(_Ch, _Stream)
    #endif
# 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3



    _ACRTIMP int* __cdecl __p__commode(void);

    #ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
        extern int _commode;
    #else
# 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        #define _commode (*__p__commode())
    #endif
# 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3



    // Variadic functions are not supported in managed code under /clr
    #if defined _M_CEE_MIXED
        #pragma managed(push, off)
    #endif
# 599 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _ACRTIMP int __cdecl __stdio_common_vfprintf(
        _In_                                    unsigned __int64 _Options,
        _Inout_                                 FILE*            _Stream,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _ACRTIMP int __cdecl __stdio_common_vfprintf_s(
        _In_                                    unsigned __int64 _Options,
        _Inout_                                 FILE*            _Stream,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _ACRTIMP int __cdecl __stdio_common_vfprintf_p(
        _In_                                    unsigned __int64 _Options,
        _Inout_                                 FILE*            _Stream,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_l(
        _Inout_  FILE*       const _Stream,
        _In_z_   char const* const _Format,
        _In_opt_ _locale_t   const _Locale,
                 va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vfprintf(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_l(_Stream, _Format, NULL, _ArgList);
    }
    #endif
# 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_s_l(
        _Inout_  FILE*       const _Stream,
        _In_z_   char const* const _Format,
        _In_opt_ _locale_t   const _Locale,
                 va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vfprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vfprintf_s(
            _Inout_                       FILE*       const _Stream,
            _In_z_ _Printf_format_string_ char const* const _Format,
                                          va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vfprintf_s_l(_Stream, _Format, NULL, _ArgList);
        }
    #endif
# 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_p_l(
        _Inout_  FILE*       const _Stream,
        _In_z_   char const* const _Format,
        _In_opt_ _locale_t   const _Locale,
                 va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vfprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_p(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 716 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_p_l(_Stream, _Format, NULL, _ArgList);
    }
    #endif
# 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vprintf_l(
        _In_z_ _Printf_format_string_params_(2) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_l(stdout, _Format, _Locale, _ArgList);
    }
    #endif
# 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vprintf(
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_l(stdout, _Format, NULL, _ArgList);
    }
    #endif
# 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vprintf_s_l(
        _In_z_ _Printf_format_string_params_(2) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);
    }
    #endif
# 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vprintf_s(
            _In_z_ _Printf_format_string_ char const* const _Format,
                                          va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vfprintf_s_l(stdout, _Format, NULL, _ArgList);
        }
    #endif
# 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vprintf_p_l(
        _In_z_ _Printf_format_string_params_(2) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);
    }
    #endif
# 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vprintf_p(
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfprintf_p_l(stdout, _Format, NULL, _ArgList);
    }
    #endif
# 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fprintf_l(
        _Inout_                                 FILE*       const _Stream,
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 824 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL fprintf(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _ACRTIMP int __cdecl _set_printf_count_output(
        _In_ int _Value
        );

    _ACRTIMP int __cdecl _get_printf_count_output(void);

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fprintf_s_l(
        _Inout_                                 FILE*       const _Stream,
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 858 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL fprintf_s(
            _Inout_                       FILE*       const _Stream,
            _In_z_ _Printf_format_string_ char const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfprintf_s_l(_Stream, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 887 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fprintf_p_l(
        _Inout_                                 FILE*       const _Stream,
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fprintf_p(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 917 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l(_Stream, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _printf_l(
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l(stdout, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 944 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL printf(
        _In_z_ _Printf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 952 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 961 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _printf_s_l(
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL printf_s(
            _In_z_ _Printf_format_string_ char const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfprintf_s_l(stdout, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _printf_p_l(
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _printf_p(
        _In_z_ _Printf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l(stdout, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _ACRTIMP int __cdecl __stdio_common_vfscanf(
        _In_                                   unsigned __int64 _Options,
        _Inout_                                FILE*            _Stream,
        _In_z_ _Scanf_format_string_params_(2) char const*      _Format,
        _In_opt_                               _locale_t        _Locale,
                                               va_list          _Arglist
        );

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfscanf_l(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
        _In_opt_                      _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vfscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vfscanf(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfscanf_l(_Stream, _Format, NULL, _ArgList);
    }
    #endif
# 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vfscanf_s_l(
        _Inout_                       FILE*       const _Stream,
        _In_z_ _Printf_format_string_ char const* const _Format,
        _In_opt_                      _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vfscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Stream, _Format, _Locale, _ArgList);
    }
    #endif
# 1097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3


    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vfscanf_s(
            _Inout_                       FILE*       const _Stream,
            _In_z_ _Printf_format_string_ char const* const _Format,
                                          va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vfscanf_s_l(_Stream, _Format, NULL, _ArgList);
        }
    #endif
# 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vscanf_l(
        _In_z_ _Printf_format_string_ char const* const _Format,
        _In_opt_                      _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfscanf_l(stdin, _Format, _Locale, _ArgList);
    }
    #endif
# 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vscanf(
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfscanf_l(stdin, _Format, NULL, _ArgList);
    }
    #endif
# 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vscanf_s_l(
        _In_z_ _Printf_format_string_ char const* const _Format,
        _In_opt_                      _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vfscanf_s_l(stdin, _Format, _Locale, _ArgList);
    }
    #endif
# 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vscanf_s(
            _In_z_ _Printf_format_string_ char const* const _Format,
                                          va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vfscanf_s_l(stdin, _Format, NULL, _ArgList);
        }
    #endif
# 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _fscanf_l(
        _Inout_                                FILE*       const _Stream,
        _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
        _In_opt_                               _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(fscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL fscanf(
        _Inout_                      FILE*       const _Stream,
        _In_z_ _Scanf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfscanf_l(_Stream, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _fscanf_s_l(
        _Inout_                                  FILE*       const _Stream,
        _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
        _In_opt_                                 _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL fscanf_s(
            _Inout_                        FILE*       const _Stream,
            _In_z_ _Scanf_s_format_string_ char const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfscanf_s_l(_Stream, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 1250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 1252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_scanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _scanf_l(
        _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
        _In_opt_                               _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l(stdin, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(scanf_s)
    _CRT_STDIO_INLINE int __CRTDECL scanf(
        _In_z_ _Scanf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfscanf_l(stdin, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _scanf_s_l(
        _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
        _In_opt_                                 _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l(stdin, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL scanf_s(
            _In_z_ _Scanf_s_format_string_ char const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 1315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfscanf_s_l(stdin, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 1326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _Success_(return >= 0)
    _ACRTIMP int __cdecl __stdio_common_vsprintf(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_opt_z_(_BufferCount)        char*            _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _ACRTIMP int __cdecl __stdio_common_vsprintf_s(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_z_(_BufferCount)            char*            _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _ACRTIMP int __cdecl __stdio_common_vsnprintf_s(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_opt_z_(_BufferCount)        char*            _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_                                    size_t           _MaxCount,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _ACRTIMP int __cdecl __stdio_common_vsprintf_p(
        _In_                                    unsigned __int64 _Options,
        _Out_writes_z_(_BufferCount)            char*            _Buffer,
        _In_                                    size_t           _BufferCount,
        _In_z_ _Printf_format_string_params_(2) char const*      _Format,
        _In_opt_                                _locale_t        _Locale,
                                                va_list          _ArgList
        );

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnprintf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_l(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ char*       const _Buffer,
        _In_                                         size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)      char const* const _Format,
        _In_opt_                                     _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnprintf(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ char*       const _Buffer,
        _In_                                        size_t      const _BufferCount,
        _In_z_ _Printf_format_string_               char const* const _Format,
                                                    va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        #pragma warning(pop)
    }
    #endif
# 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if defined vsnprintf
        // This definition of vsnprintf will generate "warning C4005: 'vsnprintf': macro
        // redefinition" with a subsequent line indicating where the previous definition
        // of vsnprintf was.  This makes it easier to find where vsnprintf was defined.
        #pragma warning(push, 1)
        #pragma warning(1: 4005)
        #define vsnprintf Do not define vsnprintf as a macro
        #pragma warning(pop)
        #error Macro definition of vsnprintf conflicts with Standard Library function declaration
    #endif
# 1425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vsnprintf(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                              size_t      const _BufferCount,
        _In_z_ _Printf_format_string_                     char const* const _Format,
                                                          va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
            _Buffer, _BufferCount, _Format, NULL, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsprintf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _vsprintf_l(
        _Pre_notnull_ _Always_(_Post_z_) char*       const _Buffer,
        _In_z_                           char const* const _Format,
        _In_opt_                         _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #endif
# 1464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(vsprintf_s)
    _CRT_STDIO_INLINE int __CRTDECL vsprintf(
        _Pre_notnull_ _Always_(_Post_z_) char*       const _Buffer,
        _In_z_ _Printf_format_string_    char const* const _Format,
                                         va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
        #pragma warning(pop)
    }
    #endif
# 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsprintf_s_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                          size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)       char const* const _Format,
        _In_opt_                                      _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf_s(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
            _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
            _In_                                          size_t      const _BufferCount,
            _In_z_ _Printf_format_string_                 char const* const _Format,
                                                          va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        }
    #endif
# 1521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
            _Success_(return >= 0)
            int, vsprintf_s,
            _Always_(_Post_z_)            char,        _Buffer,
            _In_z_ _Printf_format_string_ char const*, _Format,
                                          va_list,     _ArgList
            )

    #endif
# 1531 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                          size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(2)       char const* const _Format,
        _In_opt_                                      _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf_p(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1552 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                          size_t      const _BufferCount,
        _In_z_ _Printf_format_string_                 char const* const _Format,
                                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    }
    #endif
# 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                              size_t      const _BufferCount,
        _In_                                              size_t      const _MaxCount,
        _In_z_ _Printf_format_string_params_(2)           char const* const _Format,
        _In_opt_                                          _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsnprintf_s(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                              size_t      const _BufferCount,
        _In_                                              size_t      const _MaxCount,
        _In_z_ _Printf_format_string_                     char const* const _Format,
                                                          va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
    }
    #endif
# 1607 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
        _Success_(return >= 0)
        int, _vsnprintf_s,
        _Always_(_Post_z_)            char,        _Buffer,
        _In_                          size_t,      _BufferCount,
        _In_z_ _Printf_format_string_ char const*, _Format,
                                      va_list,     _ArgList
        )

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
            _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
            _In_                                              size_t      const _BufferCount,
            _In_                                              size_t      const _MaxCount,
            _In_z_ _Printf_format_string_                     char const* const _Format,
                                                              va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1631 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
        }
    #endif
# 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
            _Success_(return >= 0)
            int, vsnprintf_s,
            _Always_(_Post_z_)            char,        _Buffer,
            _In_                          size_t,      _BufferCount,
            _In_z_ _Printf_format_string_ char const*, _Format,
                                          va_list,     _ArgList
            )

    #endif
# 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
        _In_z_ _Printf_format_string_params_(2) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
            NULL, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _vscprintf(
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vscprintf_l(_Format, NULL, _ArgList);
    }
    #endif
# 1677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
        _In_z_ _Printf_format_string_params_(2) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf_p(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
            NULL, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vscprintf_p_l(_Format, NULL, _ArgList);
    }
    #endif
# 1708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
        _Out_writes_opt_(_BufferCount)          char*       const _Buffer,
        _In_                                    size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(2) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int const _Result = __stdio_common_vsprintf(
            _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #endif
# 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
        _Out_writes_opt_(_BufferCount) char*       const _Buffer,
        _In_                           size_t      const _BufferCount,
        _In_z_ _Printf_format_string_  char const* const _Format,
                                       va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    }
    #endif
# 1744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
        _Pre_notnull_ _Always_(_Post_z_)        char*       const _Buffer,
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL sprintf(
        _Pre_notnull_ _Always_(_Post_z_) char*       const _Buffer,
        _In_z_ _Printf_format_string_    char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
    #pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
        _Success_(return >= 0)
        int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
        _Pre_notnull_ _Always_(_Post_z_), char,        _Buffer,
        _In_z_ _Printf_format_string_     char const*, _Format
        )
    #pragma warning(pop)

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                          size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)       char const* const _Format,
        _In_opt_                                      _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Success_(return >= 0)
        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL sprintf_s(
            _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
            _In_                                          size_t      const _BufferCount,
            _In_z_ _Printf_format_string_                 char const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1839 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 1848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 1850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(
        _Success_(return >= 0)
        int, sprintf_s, vsprintf_s,
        _Always_(_Post_z_)            char,        _Buffer,
        _In_z_ _Printf_format_string_ char const*, _Format
        )

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _sprintf_p_l(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                          size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)       char const* const _Format,
        _In_opt_                                      _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _sprintf_p(
        _Out_writes_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                          size_t      const _BufferCount,
        _In_z_ _Printf_format_string_                 char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1898 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snprintf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _snprintf_l(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ char*       const _Buffer,
        _In_                                         size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(0)      char const* const _Format,
        _In_opt_                                     _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        #pragma warning(push)
        #pragma warning(disable: 4996) // Deprecation
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if defined snprintf
        // This definition of snprintf will generate "warning C4005: 'snprintf': macro
        // redefinition" with a subsequent line indicating where the previous definition
        // of snprintf was.  This makes it easier to find where snprintf was defined.
        #pragma warning(push, 1)
        #pragma warning(1: 4005)
        #define snprintf Do not define snprintf as a macro
        #pragma warning(pop)
        #error Macro definition of snprintf conflicts with Standard Library function declaration
    #endif
# 1935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL snprintf(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                              size_t      const _BufferCount,
        _In_z_ _Printf_format_string_                     char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
    #pragma warning(suppress:28719)    // 28719
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snprintf(
        _Out_writes_opt_(_BufferCount) _Post_maybez_ char*       const _Buffer,
        _In_                                         size_t      const _BufferCount,
        _In_z_ _Printf_format_string_                char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
    #pragma warning(suppress:28719)    // 28719
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(
        _Success_(return >= 0)
        int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, _snprintf, _vsnprintf,
        _Pre_notnull_ _Post_maybez_                   char,
        _Out_writes_opt_(_BufferCount) _Post_maybez_, char,        _Buffer,
        _In_                                          size_t,      _BufferCount,
        _In_z_ _Printf_format_string_                 char const*, _Format
        )

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snprintf_c_l(
        _Out_writes_opt_(_BufferCount)          char*       const _Buffer,
        _In_                                    size_t      const _BufferCount,
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 1998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snprintf_c(
        _Out_writes_opt_(_BufferCount) char*       const _Buffer,
        _In_                           size_t      const _BufferCount,
        _In_z_ _Printf_format_string_  char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snprintf_s_l(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                              size_t      const _BufferCount,
        _In_                                              size_t      const _MaxCount,
        _In_z_ _Printf_format_string_params_(0)           char const* const _Format,
        _In_opt_                                          _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Success_(return >= 0)
    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snprintf_s(
        _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char*       const _Buffer,
        _In_                                              size_t      const _BufferCount,
        _In_                                              size_t      const _MaxCount,
        _In_z_ _Printf_format_string_                     char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(
        _Success_(return >= 0)
        int, _snprintf_s, _vsnprintf_s,
        _Always_(_Post_z_)            char,        _Buffer,
        _In_                          size_t,      _BufferCount,
        _In_z_ _Printf_format_string_ char const*, _Format
        )

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _scprintf_l(
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _scprintf(
        _In_z_ _Printf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscprintf_l(_Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _scprintf_p_l(
        _In_z_ _Printf_format_string_params_(0) char const* const _Format,
        _In_opt_                                _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_
    _CRT_STDIO_INLINE int __CRTDECL _scprintf_p(
        _In_z_ _Printf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscprintf_p(_Format, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    _ACRTIMP int __cdecl __stdio_common_vsscanf(
        _In_                                   unsigned __int64 _Options,
        _In_reads_(_BufferCount) _Pre_z_       char const*      _Buffer,
        _In_                                   size_t           _BufferCount,
        _In_z_ _Scanf_format_string_params_(2) char const*      _Format,
        _In_opt_                               _locale_t        _Locale,
                                               va_list          _ArgList
        );

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsscanf_l(
        _In_z_                        char const* const _Buffer,
        _In_z_ _Printf_format_string_ char const* const _Format,
        _In_opt_                      _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vsscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #endif
# 2179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL vsscanf(
        _In_z_                        char const* const _Buffer,
        _In_z_ _Printf_format_string_ char const* const _Format,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
    }
    #endif
# 2193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _vsscanf_s_l(
        _In_z_                        char const* const _Buffer,
        _In_z_ _Printf_format_string_ char const* const _Format,
        _In_opt_                      _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        return __stdio_common_vsscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #endif
# 2210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        #pragma warning(push)
        #pragma warning(disable:6530)

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL vsscanf_s(
            _In_z_                        char const* const _Buffer,
            _In_z_ _Printf_format_string_ char const* const _Format,
                                          va_list           _ArgList
            )
    #if defined _NO_CRT_STDIO_INLINE
    ;
    #else
# 2225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            return _vsscanf_s_l(_Buffer, _Format, NULL, _ArgList);
        }
    #endif
# 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

        __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
            int, vsscanf_s,
            _In_z_                        char const,  _Buffer,
            _In_z_ _Printf_format_string_ char const*, _Format,
                                          va_list,     _ArgList
            )

        #pragma warning(pop)

    #endif
# 2240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _sscanf_l(
        _In_z_                                 char const* const _Buffer,
        _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
        _In_opt_                               _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_ _CRT_INSECURE_DEPRECATE(sscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL sscanf(
        _In_z_                       char const* const _Buffer,
        _In_z_ _Scanf_format_string_ char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _sscanf_s_l(
        _In_z_                                   char const* const _Buffer,
        _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
        _In_opt_                                 _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #if __STDC_WANT_SECURE_LIB__

        _Check_return_opt_
        _CRT_STDIO_INLINE int __CRTDECL sscanf_s(
            _In_z_                         char const* const _Buffer,
            _In_z_ _Scanf_s_format_string_ char const* const _Format,
            ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
            ;
    #else
# 2307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);

            #pragma warning(push)
            #pragma warning(disable: 4996) // Deprecation
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            __crt_va_end(_ArgList);
            return _Result;
        }
    #endif
# 2321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #endif
# 2323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #pragma warning(push)
    #pragma warning(disable:6530)

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snscanf_s_l)
    _CRT_STDIO_INLINE int __CRTDECL _snscanf_l(
        _In_reads_bytes_(_BufferCount) _Pre_z_ char const* const _Buffer,
        _In_                                   size_t      const _BufferCount,
        _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
        _In_opt_                               _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        _Result = __stdio_common_vsscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snscanf_s)
    _CRT_STDIO_INLINE int __CRTDECL _snscanf(
        _In_reads_bytes_(_BufferCount) _Pre_z_ char const* const _Buffer,
        _In_                                   size_t      const _BufferCount,
        _In_z_ _Scanf_format_string_           char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        _Result = __stdio_common_vsscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
            _Buffer, _BufferCount, _Format, NULL, _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3


    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snscanf_s_l(
        _In_reads_bytes_(_BufferCount) _Pre_z_   char const* const _Buffer,
        _In_                                     size_t      const _BufferCount,
        _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
        _In_opt_                                 _locale_t   const _Locale,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        _Result = __stdio_common_vsscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    _Check_return_opt_
    _CRT_STDIO_INLINE int __CRTDECL _snscanf_s(
        _In_reads_bytes_(_BufferCount) _Pre_z_ char const* const _Buffer,
        _In_                                   size_t      const _BufferCount,
        _In_z_ _Scanf_s_format_string_         char const* const _Format,
        ...)
    #if defined _NO_CRT_STDIO_INLINE // SCANF
        ;
    #else
# 2408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        _Result = __stdio_common_vsscanf(
            _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
            _Buffer, _BufferCount, _Format, NULL, _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }
    #endif
# 2421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

    #pragma warning(pop)

    #if defined _M_CEE_MIXED
        #pragma managed(pop)
    #endif
# 2427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Non-ANSI Names for Compatibility
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    #if _CRT_INTERNAL_NONSTDC_NAMES

        #define SYS_OPEN  _SYS_OPEN

        #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
            #pragma push_macro("tempnam")
            #undef tempnam
        #endif
# 2443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

        _CRT_NONSTDC_DEPRECATE(_tempnam)
        _ACRTIMP char* __cdecl tempnam(
            _In_opt_z_ char const* _Directory,
            _In_opt_z_ char const* _FilePrefix
            );

        #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
            #pragma pop_macro("tempnam")
        #endif
# 2453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3

        _Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fcloseall) _ACRTIMP int   __cdecl fcloseall(void);
        _Check_return_     _CRT_NONSTDC_DEPRECATE(_fdopen)    _ACRTIMP FILE* __cdecl fdopen(_In_ int _FileHandle, _In_z_ char const* _Format);
        _Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fgetchar)  _ACRTIMP int   __cdecl fgetchar(void);
        _Check_return_     _CRT_NONSTDC_DEPRECATE(_fileno)    _ACRTIMP int   __cdecl fileno(_In_ FILE* _Stream);
        _Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_flushall)  _ACRTIMP int   __cdecl flushall(void);
        _Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fputchar)  _ACRTIMP int   __cdecl fputchar(_In_ int _Ch);
        _Check_return_     _CRT_NONSTDC_DEPRECATE(_getw)      _ACRTIMP int   __cdecl getw(_Inout_ FILE* _Stream);
        _Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_putw)      _ACRTIMP int   __cdecl putw(_In_ int _Ch, _Inout_ FILE* _Stream);
        _Check_return_     _CRT_NONSTDC_DEPRECATE(_rmtmp)     _ACRTIMP int   __cdecl rmtmp(void);

    #endif // _CRT_INTERNAL_NONSTDC_NAMES
# 2465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#endif // _CRT_FUNCTIONS_REQUIRED
# 2466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3



_CRT_END_C_HEADER
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 2 3

// undef common macro overrides
 #undef clearerr
 #undef feof
 #undef ferror
 #undef getc
 #undef getchar
 #undef putc
 #undef putchar

// TRANSITION: Boost nonconformingly uses this macro
#define _FPOSOFF(fp)  ((long long)(fp))

typedef FILE _Filet;

 #ifndef RC_INVOKED
_STD_BEGIN
#pragma warning(push)
#pragma warning(disable: 4995) // name was marked as #pragma deprecated

using _CSTD _Filet; using _CSTD _Mbstatet;

using _CSTD size_t; using _CSTD fpos_t; using _CSTD FILE;
using _CSTD clearerr; using _CSTD fclose; using _CSTD feof;
using _CSTD ferror; using _CSTD fflush; using _CSTD fgetc;
using _CSTD fgetpos; using _CSTD fgets; using _CSTD fopen;
using _CSTD fprintf; using _CSTD fputc; using _CSTD fputs;
using _CSTD fread; using _CSTD freopen; using _CSTD fscanf;
using _CSTD fseek; using _CSTD fsetpos; using _CSTD ftell;
using _CSTD fwrite; using _CSTD getc; using _CSTD getchar;
using _CSTD perror;
using _CSTD putc; using _CSTD putchar;
using _CSTD printf; using _CSTD puts; using _CSTD remove;
using _CSTD rename; using _CSTD rewind; using _CSTD scanf;
using _CSTD setbuf; using _CSTD setvbuf; using _CSTD sprintf;
using _CSTD sscanf; using _CSTD tmpfile; using _CSTD tmpnam;
using _CSTD ungetc; using _CSTD vfprintf; using _CSTD vprintf;
using _CSTD vsprintf;

using _CSTD snprintf; using _CSTD vsnprintf;
using _CSTD vfscanf; using _CSTD vscanf; using _CSTD vsscanf;

#pragma warning(pop)
_STD_END
 #endif /* RC_INVOKED */
# 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 3

#endif /* _CSTDIO_ */
# 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstdio" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cstring>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 1 3
// cstring standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 3
#ifndef _CSTRING_
#define _CSTRING_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 3
#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 1 3
//
// string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <string.h> header.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
#define _INC_STRING

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_memory.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 1 3
//
// corecrt_memory.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The buffer (memory) manipulation library.  These declarations are split out
// so that they may be included by both <string.h> and <memory.h>.  <string.h>
// does not include <memory.h> to avoid introducing conflicts with other user
// headers named <memory.h>.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_memcpy_s.h>
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_string.h>
#endif /* expanded by -frewrite-includes */
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3

#ifndef __midl

_CRT_BEGIN_C_HEADER



_Check_return_
_ACRTIMP int __cdecl _memicmp(
    _In_reads_bytes_opt_(_Size) void const* _Buf1,
    _In_reads_bytes_opt_(_Size) void const* _Buf2,
    _In_                        size_t      _Size
    );

_Check_return_
_ACRTIMP int __cdecl _memicmp_l(
    _In_reads_bytes_opt_(_Size) void const* _Buf1,
    _In_reads_bytes_opt_(_Size) void const* _Buf2,
    _In_                        size_t      _Size,
    _In_opt_                    _locale_t   _Locale
    );



#if !defined RC_INVOKED && __STDC_WANT_SECURE_LIB__

    #if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
    extern "C++"
    {
        template <size_t _Size, typename _DstType>
        inline typename _CrtEnableIf<(_Size > 1), void *>::_Type __cdecl memcpy(
            _DstType (&_Dst)[_Size],
            _In_reads_bytes_opt_(_SrcSize) void const* _Src,
            _In_                           size_t      _SrcSize
            ) _CRT_SECURE_CPP_NOTHROW
        {
            return memcpy_s(_Dst, _Size * sizeof(_DstType), _Src, _SrcSize) == 0 ? _Dst : 0;
        }
    }
    #endif
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3

    #if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
    extern "C++"
    {
        template <size_t _Size, typename _DstType>
        inline errno_t __CRTDECL memcpy_s(
            _DstType (&_Dst)[_Size],
            _In_reads_bytes_opt_(_SrcSize) void const* _Src,
            _In_                           rsize_t     _SrcSize
            ) _CRT_SECURE_CPP_NOTHROW
        {
            return memcpy_s(_Dst, _Size * sizeof(_DstType), _Src, _SrcSize);
        }
    }
    #endif
# 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3

#endif // !defined RC_INVOKED && __STDC_WANT_SECURE_LIB__
# 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3



#if _CRT_INTERNAL_NONSTDC_NAMES

    _CRT_NONSTDC_DEPRECATE(_memccpy)
    _ACRTIMP void* __cdecl memccpy(
        _Out_writes_bytes_opt_(_Size) void*       _Dst,
        _In_reads_bytes_opt_(_Size)   void const* _Src,
        _In_                          int         _Val,
        _In_                          size_t      _Size
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_memicmp)
    _ACRTIMP int __cdecl memicmp(
        _In_reads_bytes_opt_(_Size) void const* _Buf1,
        _In_reads_bytes_opt_(_Size) void const* _Buf2,
        _In_                        size_t      _Size
        );

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3



#if defined __cplusplus

    extern "C++" _Check_return_
    inline void* __CRTDECL memchr(
        _In_reads_bytes_opt_(_N) void*  _Pv,
        _In_                     int    _C,
        _In_                     size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#endif
# 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3



_CRT_END_C_HEADER

#endif // !__midl
# 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wstring.h>
#endif /* expanded by -frewrite-includes */
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_string.h>
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

#ifndef __midl

_CRT_BEGIN_C_HEADER



#define _NLSCMPERROR _CRT_INT_MAX // currently == INT_MAX

#if __STDC_WANT_SECURE_LIB__

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl strcpy_s(
        _Out_writes_z_(_SizeInBytes) char*       _Destination,
        _In_                         rsize_t     _SizeInBytes,
        _In_z_                       char const* _Source
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl strcat_s(
        _Inout_updates_z_(_SizeInBytes) char*       _Destination,
        _In_                            rsize_t     _SizeInBytes,
        _In_z_                          char const* _Source
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl strerror_s(
        _Out_writes_z_(_SizeInBytes) char*  _Buffer,
        _In_                         size_t _SizeInBytes,
        _In_                         int    _ErrorNumber);

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl strncat_s(
        _Inout_updates_z_(_SizeInBytes) char*       _Destination,
        _In_                            rsize_t     _SizeInBytes,
        _In_reads_or_z_(_MaxCount)      char const* _Source,
        _In_                            rsize_t     _MaxCount
        );

    _Check_return_wat_
    _ACRTIMP errno_t __cdecl strncpy_s(
        _Out_writes_z_(_SizeInBytes) char*       _Destination,
        _In_                         rsize_t     _SizeInBytes,
        _In_reads_or_z_(_MaxCount)   char const* _Source,
        _In_                         rsize_t     _MaxCount
        );

    _Check_return_
    _ACRTIMP char*  __cdecl strtok_s(
        _Inout_opt_z_                 char*       _String,
        _In_z_                        char const* _Delimiter,
        _Inout_ _Deref_prepost_opt_z_ char**      _Context
        );

#endif // __STDC_WANT_SECURE_LIB__
# 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

_ACRTIMP void* __cdecl _memccpy(
    _Out_writes_bytes_opt_(_MaxCount) void*       _Dst,
    _In_                              void const* _Src,
    _In_                              int         _Val,
    _In_                              size_t      _MaxCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, strcat_s,
           char,        _Destination,
    _In_z_ char const*, _Source
    )

#ifndef RC_INVOKED

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
        char*, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcat,
        _Inout_updates_z_(_String_length_(_Destination) + _String_length_(_Source) + 1), char,        _Destination,
        _In_z_                                                                           char const*, _Source
        )
#pragma warning(pop)

#endif // RC_INVOKED
# 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

_Check_return_
int __cdecl strcmp(
    _In_z_ char const* _Str1,
    _In_z_ char const* _Str2
    );

_Check_return_
_ACRTIMP int __cdecl _strcmpi(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
    );

_Check_return_
_ACRTIMP int __cdecl strcoll(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
    );

_Check_return_
_ACRTIMP int __cdecl _strcoll_l(
    _In_z_   char const* _String1,
    _In_z_   char const* _String2,
    _In_opt_ _locale_t   _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, strcpy_s,
    _Post_z_ char,        _Destination,
    _In_z_   char const*, _Source
    )

#pragma warning(push)
#pragma warning(disable: 28719) // __WARNING_BANNED_API_USAGE
#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    char*, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcpy,
    _Out_writes_z_(_String_length_(_Source) + 1), char,        _Destination,
    _In_z_                                        char const*, _Source
    )
#pragma warning(pop)

_Check_return_
_ACRTIMP size_t __cdecl strcspn(
    _In_z_ char const* _Str,
    _In_z_ char const* _Control
    );

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
    #pragma push_macro("_strdup")
    #undef _strdup
#endif
# 149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

_Check_return_
_ACRTIMP _CRTALLOCATOR char* __cdecl _strdup(
    _In_opt_z_ char const* _Source
    );

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
    #pragma pop_macro("_strdup")
#endif
# 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

_Ret_z_
_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(_strerror_s)
_ACRTIMP char*  __cdecl _strerror(
    _In_opt_z_ char const* _ErrorMessage
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strerror_s(
    _Out_writes_z_(_SizeInBytes) char*       _Buffer,
    _In_                         size_t      _SizeInBytes,
    _In_opt_z_                   char const* _ErrorMessage
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strerror_s,
               char,        _Buffer,
    _In_opt_z_ char const*, _ErrorMessage
    )

_Ret_z_
_Check_return_ _CRT_INSECURE_DEPRECATE(strerror_s)
_ACRTIMP char* __cdecl strerror(
    _In_ int _ErrorMessage
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, strerror_s,
        char, _Buffer,
    _In_ int, _ErrorMessage
    )

_Check_return_
_ACRTIMP int __cdecl _stricmp(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
    );

_Check_return_
_ACRTIMP int __cdecl _stricoll(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
    );

_Check_return_
_ACRTIMP int __cdecl _stricoll_l(
    _In_z_   char const* _String1,
    _In_z_   char const* _String2,
    _In_opt_ _locale_t   _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _stricmp_l(
    _In_z_   char const* _String1,
    _In_z_   char const* _String2,
    _In_opt_ _locale_t   _Locale
    );

_Check_return_
size_t __cdecl strlen(
    _In_z_ char const* _Str
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strlwr_s(
    _Inout_updates_z_(_Size) char*  _String,
    _In_                     size_t _Size
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _strlwr_s,
    _Prepost_z_ char, _String
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strlwr,
    _Inout_z_, char, _String
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strlwr_s_l(
    _Inout_updates_z_(_Size) char*     _String,
    _In_                     size_t    _Size,
    _In_opt_                 _locale_t _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strlwr_s_l,
    _Prepost_z_ char,      _String,
    _In_opt_    _locale_t, _Locale
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strlwr_l, _strlwr_s_l,
    _Inout_updates_z_(_Size) char,
    _Inout_z_,               char,      _String,
    _In_opt_                 _locale_t, _Locale
    )

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, strncat_s,
    _Prepost_z_             char,        _Destination,
    _In_reads_or_z_(_Count) char const*, _Source,
    _In_                    size_t,      _Count
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, strncat, strncat_s,
    _Inout_updates_z_(_Size)   char,
    _Inout_updates_z_(_Count), char,        _Destination,
    _In_reads_or_z_(_Count)    char const*, _Source,
    _In_                       size_t,      _Count
    )

_Check_return_
_ACRTIMP int __cdecl strncmp(
    _In_reads_or_z_(_MaxCount) char const* _Str1,
    _In_reads_or_z_(_MaxCount) char const* _Str2,
    _In_                       size_t      _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _strnicmp(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _strnicmp_l(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount,
    _In_opt_                   _locale_t   _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _strnicoll(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _strnicoll_l(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount,
    _In_opt_                   _locale_t   _Locale
    );

_Check_return_
_ACRTIMP int __cdecl _strncoll(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
    );

_Check_return_
_ACRTIMP int __cdecl _strncoll_l(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount,
    _In_opt_                   _locale_t   _Locale
    );

_ACRTIMP size_t __cdecl __strncnt(
    _In_reads_or_z_(_Count) char const* _String,
    _In_                    size_t      _Count
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, strncpy_s,
                            char,        _Destination,
    _In_reads_or_z_(_Count) char const*, _Source,
    _In_                    size_t,      _Count
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, strncpy, strncpy_s,
    _Out_writes_z_(_Size)               char,
    _Out_writes_(_Count) _Post_maybez_, char,        _Destination,
    _In_reads_or_z_(_Count)             char const*, _Source,
    _In_                                size_t,      _Count
    )

_Check_return_
_When_(
    _MaxCount > _String_length_(_String),
    _Post_satisfies_(return == _String_length_(_String))
)
_When_(
    _MaxCount <= _String_length_(_String),
    _Post_satisfies_(return == _MaxCount)
)
_ACRTIMP size_t __cdecl strnlen(
    _In_reads_or_z_(_MaxCount) char const* _String,
    _In_                       size_t      _MaxCount
    );

#if __STDC_WANT_SECURE_LIB__ && !defined __midl

    _Check_return_
    _When_(
        _MaxCount > _String_length_(_String),
        _Post_satisfies_(return == _String_length_(_String))
    )
    _When_(
        _MaxCount <= _String_length_(_String),
        _Post_satisfies_(return == _MaxCount)
    )
    static __inline size_t __CRTDECL strnlen_s(
        _In_reads_or_z_(_MaxCount) char const* _String,
        _In_                       size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#endif
# 379 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strnset_s(
    _Inout_updates_z_(_SizeInBytes) char*  _String,
    _In_                            size_t _SizeInBytes,
    _In_                            int    _Value,
    _In_                            size_t _MaxCount
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, _strnset_s,
    _Prepost_z_ char,   _Destination,
    _In_        int,    _Value,
    _In_        size_t, _Count
    )

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strnset, _strnset_s,
    _Inout_updates_z_(_Size)   char,
    _Inout_updates_z_(_Count), char,   _Destination,
    _In_                       int,    _Value,
    _In_                       size_t, _Count
    )

_Check_return_
_ACRTIMP char _CONST_RETURN* __cdecl strpbrk(
    _In_z_ char const* _Str,
    _In_z_ char const* _Control
    );

_ACRTIMP char* __cdecl _strrev(
    _Inout_z_ char* _Str
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strset_s(
    _Inout_updates_z_(_DestinationSize) char*  _Destination,
    _In_                                size_t _DestinationSize,
    _In_                                int    _Value
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strset_s,
    _Prepost_z_ char, _Destination,
    _In_        int,  _Value
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    char*, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, _strset,
    _Inout_z_, char, _Destination,
    _In_       int,  _Value
    )

_Check_return_
_ACRTIMP size_t __cdecl strspn(
    _In_z_ char const* _Str,
    _In_z_ char const* _Control
    );

_Check_return_ _CRT_INSECURE_DEPRECATE(strtok_s)
_ACRTIMP char* __cdecl strtok(
    _Inout_opt_z_ char*       _String,
    _In_z_        char const* _Delimiter
    );

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strupr_s(
    _Inout_updates_z_(_Size) char*  _String,
    _In_                     size_t _Size
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _strupr_s,
    _Prepost_z_ char, _String
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strupr,
    _Inout_z_, char, _String
    )

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strupr_s_l(
    _Inout_updates_z_(_Size) char*     _String,
    _In_                     size_t    _Size,
    _In_opt_                 _locale_t _Locale
    );

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strupr_s_l,
    _Prepost_z_ char,      _String,
    _In_opt_    _locale_t, _Locale
    )

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strupr_l, _strupr_s_l,
    _Inout_updates_z_(_Size) char,
    _Inout_z_,               char,      _String,
    _In_opt_                 _locale_t, _Locale
    )

_Success_(return < _MaxCount)
_Check_return_opt_
_ACRTIMP size_t __cdecl strxfrm(
    _Out_writes_opt_(_MaxCount) _Post_maybez_ char*       _Destination,
    _In_z_                                    char const* _Source,
    _In_ _In_range_(<=,_CRT_INT_MAX)          size_t      _MaxCount
    );

_Success_(return < _MaxCount)
_Check_return_opt_
_ACRTIMP size_t __cdecl _strxfrm_l(
    _Out_writes_opt_(_MaxCount) _Post_maybez_ char*       _Destination,
    _In_z_                                    char const* _Source,
    _In_ _In_range_(<=,_CRT_INT_MAX)          size_t      _MaxCount,
    _In_opt_                                  _locale_t   _Locale
    );



#ifdef __cplusplus
extern "C++"
{
    _Check_return_
    inline char* __CRTDECL strchr(_In_z_ char* const _String, _In_ int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

    _Check_return_
    inline char* __CRTDECL strpbrk(_In_z_ char* const _String, _In_z_ char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

    _Check_return_
    inline char* __CRTDECL strrchr(_In_z_ char* const _String, _In_ int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

    _Check_return_ _Ret_maybenull_
    inline char* __CRTDECL strstr(_In_z_ char* const _String, _In_z_ char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#endif // __cplusplus
# 527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3



#if _CRT_INTERNAL_NONSTDC_NAMES

    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
        #pragma push_macro("strdup")
        #undef strdup
    #endif
# 536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_strdup)
    _ACRTIMP char* __cdecl strdup(
        _In_opt_z_ char const* _String
        );

    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
        #pragma pop_macro("strdup")
    #endif
# 545 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3

    // Declarations of functions defined in oldnames.lib:
    _Check_return_ _CRT_NONSTDC_DEPRECATE(_strcmpi)
    _ACRTIMP int __cdecl strcmpi(
        _In_z_ char const* _String1,
        _In_z_ char const* _String2
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_stricmp)
    _ACRTIMP int __cdecl stricmp(
        _In_z_ char const* _String1,
        _In_z_ char const* _String2
        );

    _CRT_NONSTDC_DEPRECATE(_strlwr)
    _ACRTIMP char* __cdecl strlwr(
        _Inout_z_ char* _String
        );

    _Check_return_ _CRT_NONSTDC_DEPRECATE(_strnicmp)
    _ACRTIMP int __cdecl strnicmp(
        _In_reads_or_z_(_MaxCount) char const* _String1,
        _In_reads_or_z_(_MaxCount) char const* _String2,
        _In_                       size_t      _MaxCount
        );

    _CRT_NONSTDC_DEPRECATE(_strnset)
    _ACRTIMP char* __cdecl strnset(
        _Inout_updates_z_(_MaxCount) char*  _String,
        _In_                         int    _Value,
        _In_                         size_t _MaxCount
        );

    _CRT_NONSTDC_DEPRECATE(_strrev)
    _ACRTIMP char* __cdecl strrev(
        _Inout_z_ char* _String
        );

    _CRT_NONSTDC_DEPRECATE(_strset)
    char* __cdecl strset(
        _Inout_z_ char* _String,
        _In_      int   _Value);

    _CRT_NONSTDC_DEPRECATE(_strupr)
    _ACRTIMP char* __cdecl strupr(
        _Inout_z_ char* _String
        );

#endif // _CRT_INTERNAL_NONSTDC_NAMES
# 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3



_CRT_END_C_HEADER

#endif // !__midl
# 600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 2 3

 #ifndef RC_INVOKED
_STD_BEGIN
#pragma warning(push)
#pragma warning(disable: 4995) // name was marked as #pragma deprecated

using _CSTD size_t; using _CSTD memchr; using _CSTD memcmp;
using _CSTD memcpy; using _CSTD memmove; using _CSTD memset;
using _CSTD strcat; using _CSTD strchr; using _CSTD strcmp;
using _CSTD strcoll; using _CSTD strcpy; using _CSTD strcspn;
using _CSTD strerror; using _CSTD strlen; using _CSTD strncat;
using _CSTD strncmp; using _CSTD strncpy; using _CSTD strpbrk;
using _CSTD strrchr; using _CSTD strspn; using _CSTD strstr;
using _CSTD strtok; using _CSTD strxfrm;

#pragma warning(pop)
_STD_END
 #endif /* RC_INVOKED */
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 3

#endif /* _CSTRING_ */
# 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cstring" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cwchar>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
#if 0 /* expanded by -frewrite-includes */
#include <xstddef>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3

#if 0 /* expanded by -frewrite-includes */
#include <crtdbg.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 1 3
//
// crtdbg.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Public debugging facilities for the CRT
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
#define _INC_CRTDBG

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_new_debug.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new_debug.h" 1 3
//
// vcruntime_new_debug.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of the debug operators new and delete.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new_debug.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_new.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new_debug.h" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new_debug.h" 3

#ifdef __cplusplus
extern "C++" {

#pragma pack(push, _CRT_PACKING)

#pragma push_macro("new")
#undef new

#ifndef _MFC_OVERRIDES_NEW

    _Check_return_ _Ret_notnull_ _Post_writable_byte_size_(_Size)
    _VCRT_ALLOCATOR void* __CRTDECL operator new(
        _In_   size_t      _Size,
        _In_   int         _BlockUse,
        _In_z_ char const* _FileName,
        _In_   int         _LineNumber
        );

    _Check_return_ _Ret_notnull_ _Post_writable_byte_size_(_Size)
    _VCRT_ALLOCATOR void* __CRTDECL operator new[](
        _In_   size_t      _Size,
        _In_   int         _BlockUse,
        _In_z_ char const* _FileName,
        _In_   int         _LineNumber
        );

    void __CRTDECL operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

    void __CRTDECL operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

#endif
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new_debug.h" 3

#pragma pop_macro("new")

#pragma pack(pop)

} // extern "C++"
#endif // __cplusplus
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_new_debug.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 2 3

_CRT_BEGIN_C_HEADER



typedef void* _HFILE; // file handle pointer

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)(intptr_t)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)(intptr_t)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)(intptr_t)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)(intptr_t)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)(intptr_t)-6)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Client-defined reporting and allocation hooks
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

typedef int (__CRTDECL* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__CRTDECL* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1


typedef int (__CRTDECL* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);

#ifdef _M_CEE
    typedef int (__clrcall* _CRT_ALLOC_HOOK_M)(int, void*, size_t, int, long, unsigned char const*, int);
#endif
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Memory Management and State Tracking
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

// Bit values for _crtDbgFlag flag. These bitflags control debug heap behavior.
#define _CRTDBG_ALLOC_MEM_DF        0x01  // Turn on debug allocation
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  // Don't actually free memory
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  // Check heap every alloc/dealloc
#define _CRTDBG_RESERVED_DF         0x08  // Reserved - do not use
#define _CRTDBG_CHECK_CRT_DF        0x10  // Leak check/diff CRT blocks
#define _CRTDBG_LEAK_CHECK_DF       0x20  // Leak check at program exit

// Some bit values for _crtDbgFlag which correspond to frequencies for checking
// the heap.
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000 // Check heap every 16 heap ops
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000 // Check heap every 128 heap ops
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000 // Check heap every 1024 heap ops

// We do not check the heap by default at this point because the cost was too
// high for some applications. You can still turn this feature on manually.
#define _CRTDBG_CHECK_DEFAULT_DF    0

#define _CRTDBG_REPORT_FLAG         -1 // Query bitflag status

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)

// Memory block identification
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

// _UNKNOWN_BLOCK is a sentinel value that may be passed to some functions that
// expect a block type as an argument.  If this value is passed, those functions
// will use the block type specified in the block header instead.  This is used
// in cases where the heap lock cannot be acquired to compute the block type
// before calling the function (e.g. when the caller is outside of the CoreCRT).
#define _UNKNOWN_BLOCK (-1)

typedef void (__CRTDECL* _CRT_DUMP_CLIENT)(void*, size_t);

#ifdef _M_CEE
    typedef void (__clrcall* _CRT_DUMP_CLIENT_M)(void*, size_t);
#endif
# 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[_MAX_BLOCKS];
    size_t lSizes[_MAX_BLOCKS];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;

#ifndef _DEBUG

    #define _CrtGetAllocHook()                  ((_CRT_ALLOC_HOOK)0)
    #define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

    #define _CrtGetDumpClient()                 ((_CRT_DUMP_CLIENT)0)
    #define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

    #define _CrtCheckMemory()                   ((int)1)
    #define _CrtDoForAllClientObjects(f, c)     ((void)0)
    #define _CrtDumpMemoryLeaks()               ((int)0)
    #define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
    #define _CrtIsValidHeapPointer(p)           ((int)1)
    #define _CrtIsValidPointer(p, n, r)         ((int)1)
    #define _CrtMemCheckpoint(s)                ((void)0)
    #define _CrtMemDifference(s1, s2, s3)       ((int)0)
    #define _CrtMemDumpAllObjectsSince(s)       ((void)0)
    #define _CrtMemDumpStatistics(s)            ((void)0)
    #define _CrtReportBlockType(p)              ((int)-1)
    #define _CrtSetBreakAlloc(a)                ((long)0)
    #define _CrtSetDbgFlag(f)                   ((int)0)


#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //
# 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #ifndef _M_CEE_PURE

        _ACRTIMP int*  __cdecl __p__crtDbgFlag(void);
        _ACRTIMP long* __cdecl __p__crtBreakAlloc(void);

        #define _crtDbgFlag    (*__p__crtDbgFlag())
        #define _crtBreakAlloc (*__p__crtBreakAlloc())

        _ACRTIMP _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        _ACRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
            _In_opt_ _CRT_ALLOC_HOOK _PfnNewHook
            );

        _ACRTIMP _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        _ACRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
            _In_opt_ _CRT_DUMP_CLIENT _PFnNewDump
            );

    #endif // _M_CEE_PURE
# 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    _ACRTIMP int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    _ACRTIMP void __cdecl _CrtDoForAllClientObjects(
        _In_ _CrtDoForAllClientObjectsCallback _Callback,
        _In_ void*                             _Context
        );

    _ACRTIMP int __cdecl _CrtDumpMemoryLeaks(void);

    _ACRTIMP int __cdecl _CrtIsMemoryBlock(
        _In_opt_  void const*  _Block,
        _In_      unsigned int _Size,
        _Out_opt_ long*        _RequestNumber,
        _Out_opt_ char**       _FileName,
        _Out_opt_ int*         _LineNumber
        );

    _Check_return_
    _ACRTIMP int __cdecl _CrtIsValidHeapPointer(
        _In_opt_ void const* _Pointer
        );

    _Check_return_
    _ACRTIMP int __cdecl _CrtIsValidPointer(
        _In_opt_ void const*  _Pointer,
        _In_     unsigned int _Size,
        _In_     int          _ReadWrite
        );

    _ACRTIMP void __cdecl _CrtMemCheckpoint(
        _Out_ _CrtMemState* _State
        );

    _ACRTIMP int __cdecl _CrtMemDifference(
        _Out_ _CrtMemState*       _State,
        _In_  _CrtMemState const* _OldState,
        _In_  _CrtMemState const* _NewState
        );

    _ACRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        _In_opt_ _CrtMemState const* _State
        );

    _ACRTIMP void __cdecl _CrtMemDumpStatistics(
        _In_ _CrtMemState const* _State
        );

    _Check_return_
    _ACRTIMP int __cdecl _CrtReportBlockType(
        _In_opt_ void const* _Block
        );

    _ACRTIMP long __cdecl _CrtSetBreakAlloc(
        _In_ long _NewValue
        );

    _ACRTIMP int __cdecl _CrtSetDbgFlag(
        _In_ int _NewFlag
        );

#endif // _DEBUG
# 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Heap Routines
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _DEBUG

    #define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
    #define _expand_dbg(p, s, t, f, l)      _expand(p, s)
    #define _free_dbg(p, t)                 free(p)
    #define _malloc_dbg(s, t, f, l)         malloc(s)
    #define _msize_dbg(p, t)                _msize(p)
    #define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
    #define _recalloc_dbg(p, c, s, t, f, l) _recalloc(p, c, s)

    #define _aligned_free_dbg(p)                              _aligned_free(p)
    #define _aligned_malloc_dbg(s, a, f, l)                   _aligned_malloc(s, a)
    #define _aligned_msize_dbg(p, a, o)                       _aligned_msize(p, a, o)
    #define _aligned_offset_malloc_dbg(s, a, o, f, l)         _aligned_offset_malloc(s, a, o)
    #define _aligned_offset_realloc_dbg(p, s, a, o, f, l)     _aligned_offset_realloc(p, s, a, o)
    #define _aligned_offset_recalloc_dbg(p, c, s, a, o, f, l) _aligned_offset_recalloc(p, c, s, a, o)
    #define _aligned_realloc_dbg(p, s, a, f, l)               _aligned_realloc(p, s, a)
    #define _aligned_recalloc_dbg(p, c, s, a, f, l)           _aligned_recalloc(p, c, s, a)

    #define _freea_dbg(p, t)         _freea(p)
    #define _malloca_dbg(s, t, f, l) _malloca(s)

    #define _dupenv_s_dbg(ps1, size, s2, t, f, l)  _dupenv_s(ps1, size, s2)
    #define _fullpath_dbg(s1, s2, le, t, f, l)     _fullpath(s1, s2, le)
    #define _getcwd_dbg(s, le, t, f, l)            _getcwd(s, le)
    #define _getdcwd_dbg(d, s, le, t, f, l)        _getdcwd(d, s, le)
    #define _getdcwd_lk_dbg(d, s, le, t, f, l)     _getdcwd(d, s, le)
    #define _mbsdup_dbg(s, t, f, l)                _mbsdup(s)
    #define _strdup_dbg(s, t, f, l)                _strdup(s)
    #define _tempnam_dbg(s1, s2, t, f, l)          _tempnam(s1, s2)
    #define _wcsdup_dbg(s, t, f, l)                _wcsdup(s)
    #define _wdupenv_s_dbg(ps1, size, s2, t, f, l) _wdupenv_s(ps1, size, s2)
    #define _wfullpath_dbg(s1, s2, le, t, f, l)    _wfullpath(s1, s2, le)
    #define _wgetcwd_dbg(s, le, t, f, l)           _wgetcwd(s, le)
    #define _wgetdcwd_dbg(d, s, le, t, f, l)       _wgetdcwd(d, s, le)
    #define _wgetdcwd_lk_dbg(d, s, le, t, f, l)    _wgetdcwd(d, s, le)
    #define _wtempnam_dbg(s1, s2, t, f, l)         _wtempnam(s1, s2)

#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //
# 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #ifdef _CRTDBG_MAP_ALLOC

        #define calloc(c, s)       _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _expand(p, s)      _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define free(p)            _free_dbg(p, _NORMAL_BLOCK)
        #define malloc(s)          _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _msize(p)          _msize_dbg(p, _NORMAL_BLOCK)
        #define realloc(p, s)      _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _recalloc(p, c, s) _recalloc_dbg(p, c, s, _NORMAL_BLOCK, __FILE__, __LINE__)

        #define _aligned_free(p)                        _aligned_free_dbg(p)
        #define _aligned_malloc(s, a)                   _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
        #define _aligned_msize(p, a, o)                 _aligned_msize_dbg(p, a, o)
        #define _aligned_offset_malloc(s, a, o)         _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
        #define _aligned_offset_realloc(p, s, a, o)     _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
        #define _aligned_offset_recalloc(p, c, s, a, o) _aligned_offset_recalloc_dbg(p, c, s, a, o, __FILE__, __LINE__)
        #define _aligned_realloc(p, s, a)               _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
        #define _aligned_recalloc(p, c, s, a)           _aligned_recalloc_dbg(p, c, s, a, __FILE__, __LINE__)

        #define _freea(p)   _freea_dbg(p, _NORMAL_BLOCK)
        #define _malloca(s) _malloca_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)

        #define _dupenv_s(ps1, size, s2)  _dupenv_s_dbg(ps1, size, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _fullpath(s1, s2, le)     _fullpath_dbg(s1, s2, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _getcwd(s, le)            _getcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _getdcwd(d, s, le)        _getdcwd_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _mbsdup(s)                _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _strdup(s)                _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _tempnam(s1, s2)          _tempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _wcsdup(s)                _wcsdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _wdupenv_s(ps1, size, s2) _wdupenv_s_dbg(ps1, size, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _wfullpath(s1, s2, le)    _wfullpath_dbg(s1, s2, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _wgetcwd(s, le)           _wgetcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _wgetdcwd(d, s, le)       _wgetdcwd_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #define _wtempnam(s1, s2)         _wtempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)

        #if _CRT_INTERNAL_NONSTDC_NAMES
            #define   strdup(s)          _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
            #define   wcsdup(s)          _wcsdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
            #define   tempnam(s1, s2)    _tempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
            #define   getcwd(s, le)      _getcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
        #endif
# 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #endif // _CRTDBG_MAP_ALLOC
# 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    _ACRTIMP void __cdecl _aligned_free_dbg(
        _Pre_maybenull_ _Post_invalid_ void* _Block
        );

    _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_malloc_dbg(
        _In_       size_t      _Size,
        _In_       size_t      _Alignment,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber
        );

    _ACRTIMP size_t __cdecl _aligned_msize_dbg(
        _Pre_notnull_ void*  _Block,
        _In_          size_t _Alignment,
        _In_          size_t _Offset
        );

    _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_offset_malloc_dbg(
        _In_       size_t      _Size,
        _In_       size_t      _Alignment,
        _In_       size_t      _Offset,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber
        );

    _Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_offset_realloc_dbg(
        _Pre_maybenull_ _Post_invalid_ void*       _Block,
        _In_                           size_t      _Size,
        _In_                           size_t      _Alignment,
        _In_                           size_t      _Offset,
        _In_opt_z_                     char const* _FileName,
        _In_                           int         _LineNumber
        );

    _Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_offset_recalloc_dbg(
        _Pre_maybenull_ _Post_invalid_ void*       _Block,
        _In_                           size_t      _Count,
        _In_                           size_t      _Size,
        _In_                           size_t      _Alignment,
        _In_                           size_t      _Offset,
        _In_opt_z_                     char const* _FileName,
        _In_                           int         _LineNumber
        );

    _Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_realloc_dbg(
        _Pre_maybenull_ _Post_invalid_ void*       _Block,
        _In_                           size_t      _Size,
        _In_                           size_t      _Alignment,
        _In_opt_z_                     char const* _FileName,
        _In_                           int         _LineNumber
        );

    _Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_recalloc_dbg(
        _Pre_maybenull_ _Post_invalid_ void*       _Block,
        _In_                           size_t      _Count,
        _In_                           size_t      _Size,
        _In_                           size_t      _Alignment,
        _In_opt_z_                     char const* _FileName,
        _In_                           int         _LineNumber
        );

    _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _calloc_dbg(
        _In_       size_t      _Count,
        _In_       size_t      _Size,
        _In_       int         _BlockUse,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber
        );

    _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _expand_dbg(
        _Pre_notnull_ void*       _Block,
        _In_          size_t      _Size,
        _In_          int         _BlockUse,
        _In_opt_z_    char const* _FileName,
        _In_          int         _LineNumber
        );

    _ACRTIMP void __cdecl _free_dbg(
        _Pre_maybenull_ _Post_invalid_ void* _Block,
        _In_                           int   _BlockUse
        );

    _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _malloc_dbg(
        _In_       size_t      _Size,
        _In_       int         _BlockUse,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber
        );

    _ACRTIMP size_t __cdecl _msize_dbg(
        _Pre_notnull_ void* _Block,
        _In_          int   _BlockUse
        );

    _Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _realloc_dbg(
        _Pre_maybenull_ _Post_invalid_ void*       _Block,
        _In_                           size_t      _Size,
        _In_                           int         _BlockUse,
        _In_opt_z_                     char const* _FileName,
        _In_                           int         _LineNumber
        );

    _Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
    _ACRTIMP _CRTALLOCATOR void* __cdecl _recalloc_dbg(
        _Pre_maybenull_ _Post_invalid_ void*       _Block,
        _In_                           size_t      _Count,
        _In_                           size_t      _Size,
        _In_                           int         _BlockUse,
        _In_opt_z_                     char const* _FileName,
        _In_                           int         _LineNumber
        );

    _Success_(return == 0)
    _Check_return_wat_
    _DCRTIMP errno_t __cdecl _dupenv_s_dbg(
        _Outptr_result_buffer_maybenull_(*_PBufferSizeInBytes) char** _PBuffer,
        _Out_opt_                      size_t*     _PBufferSizeInBytes,
        _In_z_                         char const* _VarName,
        _In_                           int          _BlockType,
        _In_opt_z_                     char const* _FileName,
        _In_                           int          _LineNumber
        );

    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _ACRTIMP _CRTALLOCATOR char* __cdecl _fullpath_dbg(
        _Out_writes_opt_z_(_SizeInBytes) char*       _FullPath,
        _In_z_                           char const* _Path,
        _In_                             size_t      _SizeInBytes,
        _In_                             int         _BlockType,
        _In_opt_z_                       char const* _FileName,
        _In_                             int         _LineNumber
        );

    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _DCRTIMP _CRTALLOCATOR char* __cdecl _getcwd_dbg(
        _Out_writes_opt_z_(_SizeInBytes) char*       _DstBuf,
        _In_                             int         _SizeInBytes,
        _In_                             int         _BlockType,
        _In_opt_z_                       char const* _FileName,
        _In_                             int         _LineNumber
        );


    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _DCRTIMP _CRTALLOCATOR char* __cdecl _getdcwd_dbg(
        _In_                             int         _Drive,
        _Out_writes_opt_z_(_SizeInBytes) char*       _DstBuf,
        _In_                             int         _SizeInBytes,
        _In_                             int         _BlockType,
        _In_opt_z_                       char const* _FileName,
        _In_                             int         _LineNumber
        );

    _Check_return_ _Ret_maybenull_z_
    _ACRTIMP _CRTALLOCATOR char* __cdecl _strdup_dbg(
        _In_opt_z_ char const* _String,
        _In_       int         _BlockUse,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber
        );

    _Check_return_ _Ret_maybenull_z_
    _ACRTIMP _CRTALLOCATOR char* __cdecl _tempnam_dbg(
        _In_opt_z_ char const* _DirName,
        _In_opt_z_ char const* _FilePrefix,
        _In_       int         _BlockType,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber
        );

    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wcsdup_dbg(
        _In_opt_z_ wchar_t const* _String,
        _In_       int            _BlockUse,
        _In_opt_z_ char const*    _FileName,
        _In_       int            _LineNumber
        );

    _Success_(return == 0)
    _Check_return_wat_
    _DCRTIMP errno_t __cdecl _wdupenv_s_dbg(
        _Outptr_result_buffer_maybenull_(*_PBufferSizeInWords) wchar_t** _PBuffer,
        _Out_opt_                        size_t*         _PBufferSizeInWords,
        _In_z_                           wchar_t const* _VarName,
        _In_                             int             _BlockType,
        _In_opt_z_                       char const*    _FileName,
        _In_                             int             _LineNumber
        );

    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wfullpath_dbg(
        _Out_writes_opt_z_(_SizeInWords) wchar_t*       _FullPath,
        _In_z_                           wchar_t const* _Path,
        _In_                             size_t         _SizeInWords,
        _In_                             int            _BlockType,
        _In_opt_z_                       char const*    _FileName,
        _In_                             int            _LineNumber
        );

    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _DCRTIMP _CRTALLOCATOR wchar_t* __cdecl _wgetcwd_dbg(
        _Out_writes_opt_z_(_SizeInWords) wchar_t*    _DstBuf,
        _In_                             int         _SizeInWords,
        _In_                             int         _BlockType,
        _In_opt_z_                       char const* _FileName,
        _In_                             int         _LineNumber
        );

    _Success_(return != 0)
    _Check_return_ _Ret_maybenull_z_
    _DCRTIMP _CRTALLOCATOR wchar_t* __cdecl _wgetdcwd_dbg(
        _In_                             int         _Drive,
        _Out_writes_opt_z_(_SizeInWords) wchar_t*    _DstBuf,
        _In_                             int         _SizeInWords,
        _In_                             int         _BlockType,
        _In_opt_z_                       char const* _FileName,
        _In_                             int         _LineNumber
        );

    _Check_return_ _Ret_maybenull_z_
    _ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wtempnam_dbg(
        _In_opt_z_ wchar_t const* _DirName,
        _In_opt_z_ wchar_t const* _FilePrefix,
        _In_       int            _BlockType,
        _In_opt_z_ char const*    _FileName,
        _In_       int            _LineNumber
        );

    #define _malloca_dbg(s, t, f, l) _malloc_dbg(s, t, f, l)
    #define _freea_dbg(p, t)         _free_dbg(p, t)

    #if defined __cplusplus && defined _CRTDBG_MAP_ALLOC
    namespace std
    {
        using ::_calloc_dbg;
        using ::_free_dbg;
        using ::_malloc_dbg;
        using ::_realloc_dbg;
    }
    #endif
# 583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

#endif // _DEBUG
# 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Reporting
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

#ifndef _DEBUG

    #define _CrtSetDebugFillThreshold(t)        ((size_t)0)
    #define _CrtSetReportFile(t, f)             ((_HFILE)0)
    #define _CrtSetReportMode(t, f)             ((int)0)
    #define _CrtGetReportHook()                 ((_CRT_REPORT_HOOK)0)
    #define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
    #define _CrtSetReportHook2(t, f)            ((int)0)
    #define _CrtSetReportHookW2(t, f)           ((int)0)

#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //
# 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    _ACRTIMP int __cdecl _CrtDbgReport(
        _In_       int         _ReportType,
        _In_opt_z_ char const* _FileName,
        _In_       int         _Linenumber,
        _In_opt_z_ char const* _ModuleName,
        _In_opt_z_ char const* _Format,
        ...);

    _ACRTIMP int __cdecl _CrtDbgReportW(
        _In_       int            _ReportType,
        _In_opt_z_ wchar_t const* _FileName,
        _In_       int            _LineNumber,
        _In_opt_z_ wchar_t const* _ModuleName,
        _In_opt_z_ wchar_t const* _Format,
        ...);


    _ACRTIMP int __cdecl _VCrtDbgReportA(
        _In_       int         _ReportType,
        _In_opt_   void*       _ReturnAddress,
        _In_opt_z_ char const* _FileName,
        _In_       int         _LineNumber,
        _In_opt_z_ char const* _ModuleName,
        _In_opt_z_ char const* _Format,
                   va_list     _ArgList
        );

    _ACRTIMP int __cdecl _VCrtDbgReportW(
        _In_       int            _ReportType,
        _In_opt_   void*          _ReturnAddress,
        _In_opt_z_ wchar_t const* _FileName,
        _In_       int            _LineNumber,
        _In_opt_z_ wchar_t const* _ModuleName,
        _In_opt_z_ wchar_t const* _Format,
                   va_list        _ArgList
        );

    _ACRTIMP size_t __cdecl _CrtSetDebugFillThreshold(
        _In_ size_t _NewDebugFillThreshold
        );

    _ACRTIMP size_t __cdecl _CrtGetDebugFillThreshold(void);

    _ACRTIMP _HFILE __cdecl _CrtSetReportFile(
        _In_     int    _ReportType,
        _In_opt_ _HFILE _ReportFile
        );

    _ACRTIMP int __cdecl _CrtSetReportMode(
        _In_ int _ReportType,
        _In_ int _ReportMode
        );

    #ifndef _M_CEE_PURE

        extern long _crtAssertBusy;

        _ACRTIMP _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        // _CrtSetReportHook[[W]2]:
        // For IJW, we need two versions:  one for clrcall and one for cdecl.
        // For pure and native, we just need clrcall and cdecl, respectively.
        _ACRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
            _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
            );

        _ACRTIMP int __cdecl _CrtSetReportHook2(
            _In_     int              _Mode,
            _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
            );

        _ACRTIMP int __cdecl _CrtSetReportHookW2(
            _In_     int               _Mode,
            _In_opt_ _CRT_REPORT_HOOKW _PFnNewHook
            );

    #endif // !_M_CEE_PURE
# 683 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

#endif // _DEBUG
# 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Assertions and Error Reporting Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _DEBUG

    #define _CrtDbgBreak() ((void)0)

    #ifndef _ASSERT_EXPR
        #define _ASSERT_EXPR(expr, msg) ((void)0)
    #endif
# 701 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #ifndef _ASSERT
        #define _ASSERT(expr) ((void)0)
    #endif
# 705 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #ifndef _ASSERTE
        #define _ASSERTE(expr) ((void)0)
    #endif
# 709 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #define _RPT0(rptno, msg)
    #define _RPTN(rptno, msg, ...)

    #define _RPTW0(rptno, msg)
    #define _RPTWN(rptno, msg, ...)

    #define _RPTF0(rptno, msg)
    #define _RPTFN(rptno, msg, ...)

    #define _RPTFW0(rptno, msg)
    #define _RPTFWN(rptno, msg, ...)

#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //
# 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #define _CrtDbgBreak() __debugbreak()

    // !! is used to ensure that any overloaded operators used to evaluate expr
    // do not end up at &&.
    #ifndef _ASSERT_EXPR
        #define _ASSERT_EXPR(expr, msg) \
            (void)(                                                                                     \
                (!!(expr)) ||                                                                           \
                (1 != _CrtDbgReportW(_CRT_ASSERT, _CRT_WIDE(__FILE__), __LINE__, NULL, L"%ls", msg)) || \
                (_CrtDbgBreak(), 0)                                                                     \
            )
    #endif
# 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #ifndef _ASSERT
        #define _ASSERT(expr) _ASSERT_EXPR((expr), NULL)
    #endif
# 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #ifndef _ASSERTE
        #define _ASSERTE(expr) _ASSERT_EXPR((expr), _CRT_WIDE(#expr))
    #endif
# 744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

    #define _RPT_BASE(...)                           \
        (void) ((1 != _CrtDbgReport(__VA_ARGS__)) || \
                (_CrtDbgBreak(), 0))

    #define _RPT_BASE_W(...)                          \
        (void) ((1 != _CrtDbgReportW(__VA_ARGS__)) || \
                (_CrtDbgBreak(), 0))

    #define _RPT0(rptno, msg)      _RPT_BASE(rptno, NULL, 0, NULL, "%s", msg)
    #define _RPTN(rptno, msg, ...) _RPT_BASE(rptno, NULL, 0, NULL, msg, __VA_ARGS__)

    #define _RPTW0(rptno, msg)      _RPT_BASE_W(rptno, NULL, 0, NULL, L"%ls", msg)
    #define _RPTWN(rptno, msg, ...) _RPT_BASE_W(rptno, NULL, 0, NULL, msg, __VA_ARGS__)

    #define _RPTF0(rptno, msg)      _RPT_BASE(rptno, __FILE__, __LINE__, NULL, "%s", msg)
    #define _RPTFN(rptno, msg, ...) _RPT_BASE(rptno, __FILE__, __LINE__, NULL, msg, __VA_ARGS__)

    #define _RPTFW0(rptno, msg)      _RPT_BASE_W(rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, L"%ls", msg)
    #define _RPTFWN(rptno, msg, ...) _RPT_BASE_W(rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, __VA_ARGS__)

#endif // _DEBUG
# 766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

// Asserts in debug.  Invokes Watson in both debug and release
#define _ASSERT_AND_INVOKE_WATSON(expr)                                              \
    {                                                                                \
        _ASSERTE((expr));                                                            \
        if (!(expr))                                                                 \
        {                                                                            \
            _invoke_watson(_CRT_WIDE(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0); \
        }                                                                            \
    }

// _ASSERT_BASE is provided only for backwards compatibility.
#ifndef _ASSERT_BASE
    #define _ASSERT_BASE _ASSERT_EXPR
#endif
# 781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3

#define _RPT1 _RPTN
#define _RPT2 _RPTN
#define _RPT3 _RPTN
#define _RPT4 _RPTN
#define _RPT5 _RPTN

#define _RPTW1 _RPTWN
#define _RPTW2 _RPTWN
#define _RPTW3 _RPTWN
#define _RPTW4 _RPTWN
#define _RPTW5 _RPTWN

#define _RPTF1 _RPTFN
#define _RPTF2 _RPTFN
#define _RPTF3 _RPTFN
#define _RPTF4 _RPTFN
#define _RPTF5 _RPTFN

#define _RPTFW1 _RPTFWN
#define _RPTFW2 _RPTFWN
#define _RPTFW3 _RPTFWN
#define _RPTFW4 _RPTFWN
#define _RPTFW5 _RPTFWN



_CRT_END_C_HEADER
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// STREAM POSITIONING TYPES (from <streambuf>)
using streamoff = long long;
using streamsize = long long;

  #ifdef _M_CEE_PURE
extern const streamoff _BADOFF;

  #else /* _M_CEE_PURE */
# 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
extern _CRTDATA2_IMPORT _PGLOBAL const streamoff _BADOFF;
  #endif /* _M_CEE_PURE */
# 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3

		// CLASS TEMPLATE fpos (from <streambuf>)
template<class _Statetype>
	class fpos
	{	// store arbitrary file position
public:
	__CLR_OR_THIS_CALL fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	// construct with stream offset
		}

	__CLR_OR_THIS_CALL fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	// construct with conversion state and C file position
		}

	_NODISCARD _Statetype __CLR_OR_THIS_CALL state() const
		{	// return conversion state
		return (_Mystate);
		}

	void __CLR_OR_THIS_CALL state(_Statetype _State)
		{	// set conversion state
		_Mystate = _State;
		}

	_NODISCARD fpos_t __CLR_OR_THIS_CALL seekpos() const
		{	// return C file position
		return (_Fpos);
		}

	__CLR_OR_THIS_CALL operator streamoff() const
		{	// return offset
		return (_Myoff + _Fpos);
		}

	_NODISCARD streamoff __CLR_OR_THIS_CALL operator-(const fpos& _Right) const
		{	// return difference of file positions as an offset
		return ((streamoff)*this - (streamoff)_Right);
		}

	fpos& __CLR_OR_THIS_CALL operator+=(streamoff _Off)
		{	// add offset
		_Myoff += _Off;
		return (*this);
		}

	fpos& __CLR_OR_THIS_CALL operator-=(streamoff _Off)
		{	// subtract offset
		_Myoff -= _Off;
		return (*this);
		}

	_NODISCARD fpos __CLR_OR_THIS_CALL operator+(streamoff _Off) const
		{	// return this + offset
		fpos _Tmp = *this;
		return (_Tmp += _Off);
		}

	_NODISCARD fpos __CLR_OR_THIS_CALL operator-(streamoff _Off) const
		{	// return this - offset
		fpos _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD bool __CLR_OR_THIS_CALL operator==(const fpos& _Right) const
		{	// test for file position equality
		return ((streamoff)*this == (streamoff)_Right);
		}

	_NODISCARD bool __CLR_OR_THIS_CALL operator==(streamoff _Right) const
		{	// test for file position equality with streamoff
		return ((streamoff)*this == _Right);
		}

	_NODISCARD bool __CLR_OR_THIS_CALL operator!=(const fpos& _Right) const
		{	// test for file position inequality
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	// stream offset
	fpos_t _Fpos;	// C file position
	_Statetype _Mystate;	// current conversion state
	};

 #define _POS_TYPE_FROM_STATE(postype, state, position) postype(state, position)
 #define _POS_TYPE_TO_FPOS_T(pos) pos.seekpos()
 #define _POS_TYPE_TO_STATE(pos) pos.state()

using streampos = fpos<_Mbstatet>;

using wstreampos = streampos;

		// STRUCT TEMPLATE _Char_traits (FROM <string>)
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	// properties of a string or stream element
	using char_type = _Elem;
	using int_type = _Int_type;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR int compare(_In_reads_(_Count) const _Elem * _First1,
		_In_reads_(_Count) const _Elem * _First2, size_t _Count) _NOEXCEPT // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			{
			if (*_First1 != *_First2)
				{
				return (*_First1 < *_First2 ? -1 : +1);
				}
			}

		return (0);
		}

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR size_t length(_In_z_ const _Elem * _First) _NOEXCEPT // strengthened
		{	// find length of null-terminated sequence
		size_t _Count = 0;
		while (*_First != _Elem())
			{
			++_Count;
			++_First;
			}

		return (_Count);
		}

	static _Elem * copy(_Out_writes_all_(_Count) _Elem * const _First1,
		_In_reads_(_Count) const _Elem * _First2, size_t _Count) _NOEXCEPT // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast<_Elem *>(_CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem))));
		}

	_Pre_satisfies_(_Dest_size >= _Count) static _Elem * _Copy_s(
		_Out_writes_all_(_Dest_size) _Elem * const _First1, const size_t _Dest_size,
		_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) _NOEXCEPT
		{	// copy [_First2, _First2 + _Count) to [_First1, _First1 + _Dest_size)
		_SCL_SECURE_CRT_VALIDATE(_Count <= _Dest_size, nullptr);
		return (copy(_First1, _First2, _Count));
		}

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR const _Elem * find(_In_reads_(_Count) const _Elem * _First,
		size_t _Count, const _Elem& _Ch) _NOEXCEPT // strengthened
		{	// look for _Ch in [_First, _First + _Count)
		for (; 0 < _Count; --_Count, ++_First)
			{
			if (*_First == _Ch)
				{
				return (_First);
				}
			}

		return (nullptr);
		}

	static _Elem * move(_Out_writes_all_(_Count) _Elem * const _First1,
		_In_reads_(_Count) const _Elem * _First2, size_t _Count) _NOEXCEPT // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
		return (static_cast<_Elem *>(_CSTD memmove(_First1, _First2, _Count * sizeof(_Elem))));
		}

	static _Elem * assign(_Out_writes_all_(_Count) _Elem * const _First,
		size_t _Count, const _Elem _Ch) _NOEXCEPT // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		_Elem * _Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			{
			*_Next = _Ch;
			}

		return (_First);
		}

	static _CHAR_TRAITS_CONSTEXPR void assign(_Elem& _Left, const _Elem& _Right) _NOEXCEPT
		{	// assign an element
		_Left = _Right;
		}

	_NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) _NOEXCEPT
		{	// test for element equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) _NOEXCEPT
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	_NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) _NOEXCEPT
		{	// convert metacharacter to character
		return (static_cast<_Elem>(_Meta));
		}

	_NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) _NOEXCEPT
		{	// convert character to metacharacter
		return (static_cast<int_type>(_Ch));
		}

	_NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) _NOEXCEPT
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr int_type not_eof(const int_type& _Meta) _NOEXCEPT
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	_NODISCARD static constexpr int_type eof() _NOEXCEPT
		{	// return end-of-file metacharacter
		return (static_cast<int_type>(EOF));
		}
	};

		// STRUCT TEMPLATE _WChar_traits
template<class _Elem>
	struct _WChar_traits
	{	// char_traits for the char16_t-likes: char16_t, wchar_t, unsigned short
	using char_type = _Elem;
	using int_type = unsigned short;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR int compare(_In_reads_(_Count) const _Elem * const _First1,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) _NOEXCEPT // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
#if _HAS_CONSTEXPR_CHAR_TRAITS
		if constexpr (is_same_v<_Elem, wchar_t>)
			{
			return (__builtin_wmemcmp(_First1, _First2, _Count));
			}
		else
			{
			return (_Char_traits<_Elem, unsigned short>::compare(_First1, _First2, _Count));
			}
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		return (_CSTD wmemcmp(reinterpret_cast<const wchar_t *>(_First1),
			reinterpret_cast<const wchar_t *>(_First2), _Count));
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		}

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR size_t length(_In_z_ const _Elem * _First) _NOEXCEPT // strengthened
		{	// find length of null-terminated sequence
#if _HAS_CONSTEXPR_CHAR_TRAITS
		if constexpr (is_same_v<_Elem, wchar_t>)
			{
			return (__builtin_wcslen(_First));
			}
		else
			{
			return (_Char_traits<_Elem, unsigned short>::length(_First));
			}
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		return (_CSTD wcslen(reinterpret_cast<const wchar_t *>(_First)));
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		}

	static _Elem * copy(_Out_writes_all_(_Count) _Elem * const _First1,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) _NOEXCEPT // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (reinterpret_cast<_Elem *>(_CSTD wmemcpy(reinterpret_cast<wchar_t *>(_First1),
			reinterpret_cast<const wchar_t *>(_First2), _Count)));
		}

	_Pre_satisfies_(_Size_in_words >= _Count) static _Elem * _Copy_s(
			_Out_writes_all_(_Size_in_words) _Elem * const _First1, const size_t _Size_in_words,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) _NOEXCEPT
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		_CRT_SECURE_WMEMCPY(reinterpret_cast<wchar_t *>(_First1), _Size_in_words,
			reinterpret_cast<const wchar_t *>(_First2), _Count);
		return (_First1);
		}

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR const _Elem * find(_In_reads_(_Count) const _Elem * _First,
			const size_t _Count, const _Elem& _Ch) _NOEXCEPT // strengthened
		{	// look for _Ch in [_First, _First + _Count)
#if _HAS_CONSTEXPR_CHAR_TRAITS
		if constexpr (is_same_v<_Elem, wchar_t>)
			{
			return (__builtin_wmemchr(_First, _Ch, _Count));
			}
		else
			{
			return (_Char_traits<_Elem, unsigned short>::find(_First, _Count, _Ch));
			}
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 321 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(
			reinterpret_cast<const wchar_t *>(_First), _Ch, _Count)));
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		}

	static _Elem * move(_Out_writes_all_(_Count) _Elem * const _First1,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) _NOEXCEPT // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (reinterpret_cast<_Elem *>(_CSTD wmemmove(reinterpret_cast<wchar_t *>(_First1),
			reinterpret_cast<const wchar_t *>(_First2), _Count)));
		}

	static _Elem * assign(_Out_writes_all_(_Count) _Elem * const _First, size_t _Count, _Elem _Ch)
			_NOEXCEPT // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		return (reinterpret_cast<_Elem *>(_CSTD wmemset(reinterpret_cast<wchar_t *>(_First), _Ch, _Count)));
		}

	static _CHAR_TRAITS_CONSTEXPR void assign(_Elem& _Left, const _Elem& _Right) _NOEXCEPT
		{	// assign an element
		_Left = _Right;
		}

	_NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) _NOEXCEPT
		{	// test for element equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) _NOEXCEPT
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	_NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) _NOEXCEPT
		{	// convert metacharacter to character
		return (_Meta);
		}

	_NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) _NOEXCEPT
		{	// convert character to metacharacter
		return (_Ch);
		}

	_NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) _NOEXCEPT
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr int_type not_eof(const int_type& _Meta) _NOEXCEPT
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	_NODISCARD static constexpr int_type eof() _NOEXCEPT
		{	// return end-of-file metacharacter
		return (WEOF);
		}
	};

		// STRUCT TEMPLATE char_traits
template<class _Elem>
	struct char_traits
		: _Char_traits<_Elem, long>
	{	// properties of a string or stream unknown element
	};

		// STRUCT char_traits<char16_t>
template<>
	struct char_traits<char16_t>
		: _WChar_traits<char16_t>
	{	// properties of a string or stream char16_t element
	};

using u16streampos = streampos;

		// STRUCT char_traits<char32_t>
template<>
	struct char_traits<char32_t>
		: _Char_traits<char32_t, unsigned int>
	{	// properties of a string or stream char32_t element
	};

using u32streampos = streampos;

		// STRUCT char_traits<wchar_t>
template<>
	struct char_traits<wchar_t>
		: _WChar_traits<wchar_t>
	{	// properties of a string or stream wchar_t element
	};

 #ifdef _NATIVE_WCHAR_T_DEFINED
		// STRUCT char_traits<unsigned short>
template<>
	struct char_traits<unsigned short>
		: _WChar_traits<unsigned short>
	{	// properties of a string or stream unsigned short element
	};
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 420 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3

		// STRUCT char_traits<char> (FROM <string>)
template<>
	struct char_traits<char>
	{	// properties of a string or stream char element
	using char_type = char;
	using int_type = int;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR int compare(_In_reads_(_Count) const char * const _First1,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) _NOEXCEPT // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
#if _HAS_CONSTEXPR_CHAR_TRAITS
		return (__builtin_memcmp(_First1, _First2, _Count));
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 437 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		return (_CSTD memcmp(_First1, _First2, _Count));
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 439 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		}

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR size_t length(_In_z_ const char * const _First) _NOEXCEPT // strengthened
		{	// find length of null-terminated string
#if _HAS_CONSTEXPR_CHAR_TRAITS
		return (__builtin_strlen(_First));
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		return (_CSTD strlen(_First));
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 448 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		}

	static char * copy(_Out_writes_(_Count) char * const _First1,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) _NOEXCEPT // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));
		}

	_Pre_satisfies_(_Size_in_bytes >= _Count) static char * _Copy_s(
		_Out_writes_all_(_Size_in_bytes) char * const _First1, const size_t _Size_in_bytes,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) _NOEXCEPT
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);
		return (_First1);
		}

	_NODISCARD static _CHAR_TRAITS_CONSTEXPR const char * find(_In_reads_(_Count) const char * const _First,
		const size_t _Count, const char& _Ch) _NOEXCEPT // strengthened
		{	// look for _Ch in [_First, _First + _Count)
#if _HAS_CONSTEXPR_CHAR_TRAITS
		return (__builtin_char_memchr(_First, _Ch, _Count));
#else /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 470 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		return (static_cast<const char *>(_CSTD memchr(_First, _Ch, _Count)));
#endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
# 472 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
		}

	static char * move(_Out_writes_all_(_Count) char * const _First1,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) _NOEXCEPT // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));
		}

	static char * assign(_Out_writes_all_(_Count) char * const _First,
		const size_t _Count, const char _Ch) _NOEXCEPT // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));
		}

	static _CHAR_TRAITS_CONSTEXPR void assign(char& _Left, const char& _Right) _NOEXCEPT
		{	// assign an element
		_Left = _Right;
		}

	_NODISCARD static constexpr bool eq(const char& _Left, const char& _Right) _NOEXCEPT
		{	// test for element equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr bool lt(const char& _Left, const char& _Right) _NOEXCEPT
		{	// test if _Left precedes _Right
		return (static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right));
		}

	_NODISCARD static constexpr char to_char_type(const int_type& _Meta) _NOEXCEPT
		{	// convert metacharacter to character
		return (static_cast<char>(_Meta));
		}

	_NODISCARD static constexpr int_type to_int_type(const char& _Ch) _NOEXCEPT
		{	// convert character to metacharacter
		return (static_cast<unsigned char>(_Ch));
		}

	_NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) _NOEXCEPT
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr int_type not_eof(const int_type& _Meta) _NOEXCEPT
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	_NODISCARD static constexpr int_type eof() _NOEXCEPT
		{	// return end-of-file metacharacter
		return (EOF);
		}
	};

		// FORWARD REFERENCES
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_fstream;

 #if defined(_DLL_CPPLIB)
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 #endif /* defined(_DLL_CPPLIB) */
# 591 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3

		// char TYPEDEFS
using ios = basic_ios<char, char_traits<char>>;
using streambuf = basic_streambuf<char, char_traits<char>>;
using istream = basic_istream<char, char_traits<char>>;
using ostream = basic_ostream<char, char_traits<char>>;
using iostream = basic_iostream<char, char_traits<char>>;
using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf = basic_filebuf<char, char_traits<char>>;
using ifstream = basic_ifstream<char, char_traits<char>>;
using ofstream = basic_ofstream<char, char_traits<char>>;
using fstream = basic_fstream<char, char_traits<char>>;

		// wchar_t TYPEDEFS
using wios = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream = basic_fstream<wchar_t, char_traits<wchar_t>>;

 #if defined(_CRTBLD)
		// unsigned short TYPEDEFS
using ushistream = basic_istream<unsigned short, char_traits<unsigned short>>;
using ushostream = basic_ostream<unsigned short, char_traits<unsigned short>>;
using ushfilebuf = basic_filebuf<unsigned short, char_traits<unsigned short>>;
 #endif /* defined(_CRTBLD) */
# 628 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3
#endif /* _IOSFWD_ */
# 635 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iosfwd" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// FUNCTION TEMPLATE _Min_value
template<class _Ty>
	_Post_equal_to_(_Right < _Left ? _Right : _Left)
	constexpr const _Ty& _Min_value(const _Ty& _Left, const _Ty& _Right)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_Right < _Left))
	{	// return smaller of _Left and _Right
	return (_Right < _Left ? _Right : _Left);
	}

		// FUNCTION TEMPLATE _Max_value
template<class _Ty>
	_Post_equal_to_(_Left < _Right ? _Right : _Left)
	constexpr const _Ty& _Max_value(const _Ty& _Left, const _Ty& _Right)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_Left < _Right))
	{	// return larger of _Left and _Right
	return (_Left < _Right ? _Right : _Left);
	}

		// FUNCTION TEMPLATE iter_swap (from <algorithm>)
template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	// swap *_Left and *_Right
	swap(*_Left, *_Right);
	}

		// FUNCTION TEMPLATE swap
template<class _Ty,
	size_t _Size,
	class> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		_NOEXCEPT_COND(_Is_nothrow_swappable<_Ty>::value)
	{	// exchange arrays stored at _Left and _Right
	if (&_Left != &_Right)
		{	// worth swapping, swap ranges
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			_STD iter_swap(_First1, _First2);
		}
	}

template<class _Ty,
	class> inline
	void swap(_Ty& _Left, _Ty& _Right)
		_NOEXCEPT_COND(is_nothrow_move_constructible_v<_Ty>
			&& is_nothrow_move_assignable_v<_Ty>)
	{	// exchange values stored at _Left and _Right
	_Ty _Tmp = _STD move(_Left);
	_Left = _STD move(_Right);
	_Right = _STD move(_Tmp);
	}

		// FUNCTION TEMPLATE _Swap_adl
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
		_NOEXCEPT_COND(_Is_nothrow_swappable<_Ty>::value)
	{	// exchange values stored at _Left and _Right, using ADL
	swap(_Left, _Right);
	}

		// STRUCT piecewise_construct_t
struct piecewise_construct_t
	{	// tag type for pair tuple arguments
	};

_INLINE_VAR constexpr piecewise_construct_t piecewise_construct{};

		// STRUCT TEMPLATE pair
template<class...>
	class tuple;

template<class _Ty1,
	class _Ty2>
	struct pair
	{	// store a pair of values
	using first_type = _Ty1;
	using second_type = _Ty2;

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_default_constructible<_Uty1>,
			is_default_constructible<_Uty2>
		>, int> = 0>
		constexpr pair()
		: first(), second()
		{	// default construct
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_copy_constructible<_Uty1>,
			is_copy_constructible<_Uty2>,
			is_convertible<const _Uty1&, _Uty1>,
			is_convertible<const _Uty2&, _Uty2>
		>, int> = 0>
		constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	// construct from specified values
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_copy_constructible<_Uty1>,
			is_copy_constructible<_Uty2>,
			negation<conjunction<
				is_convertible<const _Uty1&, _Uty1>,
				is_convertible<const _Uty2&, _Uty2>>>
		>, int> = 0>
		constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	// construct from specified values
		}

	pair(const pair&) = default;
	pair(pair&&) = default;

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, const _Other1&>,
			is_constructible<_Ty2, const _Other2&>,
			is_convertible<const _Other1&, _Ty1>,
			is_convertible<const _Other2&, _Ty2>
		>, int> = 0>
		constexpr pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	// construct from compatible pair
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, const _Other1&>,
			is_constructible<_Ty2, const _Other2&>,
			negation<conjunction<
				is_convertible<const _Other1&, _Ty1>,
				is_convertible<const _Other2&, _Ty2>>>
		>, int> = 0>
		constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	// construct from compatible pair
		}

	template<class _Other1,
		class _Other2>
		pair& operator=(const pair<_Other1, _Other2>& _Right)
		{	// assign from compatible pair
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			index_sequence<_Indexes1...>,
			index_sequence<_Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2);

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			is_convertible<_Other1, _Ty1>,
			is_convertible<_Other2, _Ty2>
		>, int> = 0>
		constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
			_NOEXCEPT_COND(is_nothrow_constructible_v<_Ty1, _Other1>
				&& is_nothrow_constructible_v<_Ty2, _Other2>)
		: first(_STD forward<_Other1>(_Val1)),
				second(_STD forward<_Other2>(_Val2))
		{	// construct from moved values
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			negation<conjunction<
				is_convertible<_Other1, _Ty1>,
				is_convertible<_Other2, _Ty2>>>
		>, int> = 0>
		constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2)
			_NOEXCEPT_COND(is_nothrow_constructible_v<_Ty1, _Other1>
				&& is_nothrow_constructible_v<_Ty2, _Other2>)
		: first(_STD forward<_Other1>(_Val1)),
				second(_STD forward<_Other2>(_Val2))
		{	// construct from moved values
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			is_convertible<_Other1, _Ty1>,
			is_convertible<_Other2, _Ty2>
		>, int> = 0>
		constexpr pair(pair<_Other1, _Other2>&& _Right)
			_NOEXCEPT_COND(is_nothrow_constructible_v<_Ty1, _Other1>
				&& is_nothrow_constructible_v<_Ty2, _Other2>)
		: first(_STD forward<_Other1>(_Right.first)),
			second(_STD forward<_Other2>(_Right.second))
		{	// construct from moved compatible pair
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			negation<conjunction<
				is_convertible<_Other1, _Ty1>,
				is_convertible<_Other2, _Ty2>>>
		>, int> = 0>
		constexpr explicit pair(pair<_Other1, _Other2>&& _Right)
			_NOEXCEPT_COND(is_nothrow_constructible_v<_Ty1, _Other1>
				&& is_nothrow_constructible_v<_Ty2, _Other2>)
		: first(_STD forward<_Other1>(_Right.first)),
			second(_STD forward<_Other2>(_Right.second))
		{	// construct from moved compatible pair
		}

	template<class _Other1,
		class _Other2>
		pair& operator=(pair<_Other1, _Other2>&& _Right)
		{	// assign from moved compatible pair
		first = _STD forward<_Other1>(_Right.first);
		second = _STD forward<_Other2>(_Right.second);
		return (*this);
		}

	pair& operator=(pair&& _Right)
		_NOEXCEPT_COND(is_nothrow_move_assignable_v<_Ty1>
			&& is_nothrow_move_assignable_v<_Ty2>)
		{	// assign from moved pair
		first = _STD forward<_Ty1>(_Right.first);
		second = _STD forward<_Ty2>(_Right.second);
		return (*this);
		}

	pair& operator=(const pair& _Right)
		{	// assign from copied pair
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	void swap(pair& _Right)
		_NOEXCEPT_COND(_Is_nothrow_swappable<_Ty1>::value
			&& _Is_nothrow_swappable<_Ty2>::value)
		{	// exchange contents with _Right
		if (this != _STD addressof(_Right))
			{	// different, worth swapping
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}

	_Ty1 first;		// the first stored value
	_Ty2 second;	// the second stored value
	};

#if _HAS_DEDUCTION_GUIDES
template<class _Ty1,
	class _Ty2>
	pair(_Ty1, _Ty2) -> pair<_Ty1, _Ty2>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3

template<class _Ty1,
	class _Ty2,
	class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_Left.swap(_Right)))
	{	// swap _Left and _Right pairs
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test for pair equality
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test for pair inequality
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left < _Right for pairs
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left > _Right for pairs
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left <= _Right for pairs
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left >= _Right for pairs
	return (!(_Left < _Right));
	}

	// FUNCTION TEMPLATE make_pair
template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr pair<typename _Unrefwrap<_Ty1>::type, typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	// return pair composed from arguments
	using _Mypair = pair<typename _Unrefwrap<_Ty1>::type, typename _Unrefwrap<_Ty2>::type>;
	return (_Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2)));
	}

	namespace rel_ops
		{	// nested namespace to hide relational operators from std
template<class _Ty>
	_NODISCARD inline bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	// test for inequality, in terms of equality
	return (!(_Left == _Right));
	}

template<class _Ty>
	_NODISCARD inline bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left > _Right, in terms of operator<
	return (_Right < _Left);
	}

template<class _Ty>
	_NODISCARD inline bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left <= _Right, in terms of operator<
	return (!(_Right < _Left));
	}

template<class _Ty>
	_NODISCARD inline bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left >= _Right, in terms of operator<
	return (!(_Left < _Right));
	}
		}
_STD_END

_STD_BEGIN
	// STRUCTS FOR STRUCTURED BINDINGS tuple_size AND tuple_element
template<class _Tuple>
	struct tuple_size;

struct _Unique_tag_tuple_size_sfinae
	{	// TRANSITION, C1XX
	};

template<class _Tuple,
	class = void>
	struct _Tuple_size_sfinae
	{	// selected when tuple_size<_Tuple>::value isn't well-formed
	};

template<class _Tuple>
	struct _Tuple_size_sfinae<_Tuple,
		void_t<
			_Unique_tag_tuple_size_sfinae,
			decltype(tuple_size<_Tuple>::value)>>
		: integral_constant<size_t, tuple_size<_Tuple>::value>
	{	// selected when tuple_size<_Tuple>::value is well-formed
	};

template<class _Tuple>
	struct tuple_size<const _Tuple>
	: _Tuple_size_sfinae<_Tuple>
	{	// size of const tuple
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: _Tuple_size_sfinae<_Tuple>
	{	// size of volatile tuple
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: _Tuple_size_sfinae<_Tuple>
	{	// size of const volatile tuple
	};

template<class _Ty>
	_INLINE_VAR constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

template<size_t _Index,
	class _Tuple>
	struct tuple_element;

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	// tuple_element for const
	using _Mybase = tuple_element<_Index, _Tuple>;
	using type = add_const_t<typename _Mybase::type>;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	// tuple_element for volatile
	using _Mybase = tuple_element<_Index, _Tuple>;
	using type = add_volatile_t<typename _Mybase::type>;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	// tuple_element for const volatile
	using _Mybase = tuple_element<_Index, _Tuple>;
	using type = add_cv_t<typename _Mybase::type>;
	};

template<size_t _Index,
	class _Tuple>
	using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

	// TUPLE INTERFACE TO array
template<class _Ty,
	size_t _Size>
	class array;

template<class _Ty,
	size_t _Size>
	struct tuple_size<array<_Ty, _Size> >
		: integral_constant<size_t, _Size>
	{	// struct to determine number of elements in array
	};

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	struct tuple_element<_Idx, array<_Ty, _Size>>
	{	// struct to determine type of element _Idx in array
	static_assert(_Idx < _Size, "array index out of bounds");

	using type = _Ty;
	};


	// TUPLE INTERFACE TO tuple
template<class... _Types>
	struct tuple_size<tuple<_Types...>>
	: integral_constant<size_t, sizeof...(_Types)>
	{	// size of tuple
	};

template<size_t _Index>
	struct tuple_element<_Index, tuple<>>
	{	// enforce bounds checking
	static_assert(_Always_false<integral_constant<size_t, _Index>>::value,
		"tuple index out of bounds");
	};

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...>>
	{	// select first element
	using type = _This;
	using _Ttype = tuple<_This, _Rest...>;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...>>
		: public tuple_element<_Index - 1, tuple<_Rest...>>
	{	// recursive tuple_element definition
	};

	// TUPLE INTERFACE TO pair
template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2>>
	: integral_constant<size_t, 2>
	{	// size of pair
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2>>
	{	// struct to determine type of element 0 in pair
	using type = _Ty1;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2>>
	{	// struct to determine type of element 1 in pair
	using type = _Ty2;
	};

template<class _Ret,
	class _Pair>
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 0>) _NOEXCEPT
	{	// get reference to element 0 in pair _Pr
	return (_Pr.first);
	}

template<class _Ret,
	class _Pair>
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 1>) _NOEXCEPT
	{	// get reference to element 1 in pair _Pr
	return (_Pr.second);
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	_NODISCARD constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&
		get(pair<_Ty1, _Ty2>& _Pr) _NOEXCEPT
	{	// get reference to element at _Idx in pair _Pr
	using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
	return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) _NOEXCEPT
	{	// get reference to element _Ty1 in pair _Pr
	return (_STD get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1>
	_NODISCARD constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) _NOEXCEPT
	{	// get reference to element _Ty2 in pair _Pr
	return (_STD get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	_NODISCARD constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&
		get(const pair<_Ty1, _Ty2>& _Pr) _NOEXCEPT
	{	// get const reference to element at _Idx in pair _Pr
	using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
	return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) _NOEXCEPT
	{	// get const reference to element _Ty1 in pair _Pr
	return (_STD get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1>
	_NODISCARD constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) _NOEXCEPT
	{	// get const reference to element _Ty2 in pair _Pr
	return (_STD get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	_NODISCARD constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&
		get(pair<_Ty1, _Ty2>&& _Pr) _NOEXCEPT
	{	// get rvalue reference to element at _Idx in pair _Pr
	using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
	return (_STD forward<_RRtype>(_STD get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) _NOEXCEPT
	{	// get rvalue reference to element _Ty1 in pair _Pr
	return (_STD get<0>(_STD move(_Pr)));
	}

template<class _Ty2,
	class _Ty1>
	_NODISCARD constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) _NOEXCEPT
	{	// get rvalue reference to element _Ty2 in pair _Pr
	return (_STD get<1>(_STD move(_Pr)));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	_NODISCARD constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&
		get(const pair<_Ty1, _Ty2>&& _Pr) _NOEXCEPT
	{	// get const rvalue reference to element at _Idx in pair _Pr
	using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
	return (_STD forward<_RRtype>(_STD get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) _NOEXCEPT
	{	// get const rvalue reference to element _Ty1 in pair _Pr
	return (_STD get<0>(_STD move(_Pr)));
	}

template<class _Ty2,
	class _Ty1>
	_NODISCARD constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) _NOEXCEPT
	{	// get const rvalue reference to element _Ty2 in pair _Pr
	return (_STD get<1>(_STD move(_Pr)));
	}

	// FUNCTION TEMPLATE exchange
template<class _Ty,
	class _Other = _Ty> inline
	_Ty exchange(_Ty& _Val, _Other&& _New_val)
	{	// assign _New_val to _Val, return previous _Val
	_Ty _Old_val = _STD move(_Val);
	_Val = _STD forward<_Other>(_New_val);
	return (_Old_val);
	}

	// FUNCTION TEMPLATE as_const
template<class _Ty>
	_NODISCARD constexpr add_const_t<_Ty>& as_const(_Ty& _Val) _NOEXCEPT
	{	// view _Val through const lenses
	return (_Val);
	}

template<class _Ty>
	void as_const(const _Ty&&) = delete;

#if _HAS_CXX17
	// in_place TAG TYPE TEMPLATES
struct in_place_t
	{	// tag used to select a constructor which initializes a contained object in place
	explicit in_place_t() = default;
	};
_INLINE_VAR constexpr in_place_t in_place{};

template<class>
	struct in_place_type_t
	{	// tag that selects a type to construct in place
	explicit in_place_type_t() = default;
	};
template<class _Ty>
	_INLINE_VAR constexpr in_place_type_t<_Ty> in_place_type{};

template<size_t>
	struct in_place_index_t
	{	// tag that selects the index of a type to construct in place
	explicit in_place_index_t() = default;
	};
template<size_t _Idx>
	_INLINE_VAR constexpr in_place_index_t<_Idx> in_place_index{};
#endif /* _HAS_CXX17 */
# 708 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _STD get;
using _STD tuple_element;
using _STD tuple_size;
}
#endif /* _HAS_TR1_NAMESPACE */
# 716 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 723 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3
#endif /* _UTILITY_ */
# 724 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\utility" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

#if (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID)
_EXTERN_C
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void * _First, void * _Last) _NOEXCEPT;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void * _First, void * _Last) _NOEXCEPT;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void * _First, void * _Last) _NOEXCEPT;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void * _First, void * _Last) _NOEXCEPT;
_END_EXTERN_C
#endif /* (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID) */
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

_STD_BEGIN
		// MACRO _DEBUG_ERROR
 #ifdef _DEBUG
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const wchar_t *,
	const wchar_t *, unsigned int);
 #endif /* _DEBUG */
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

 #if _ITERATOR_DEBUG_LEVEL == 2
  #define _DEBUG_ERROR(mesg)	\
	_DEBUG_ERROR2(mesg, __FILEW__, __LINE__)

  #define _DEBUG_ERROR2(mesg, file, line)	\
	_STD _Debug_message(L ## mesg, file, line),	\
	_SCL_SECURE_INVALID_PARAMETER(mesg)

using _Dbfile_t = const wchar_t *;
using _Dbline_t = unsigned int;
 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
  #define _DEBUG_ERROR(mesg)
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3


		// MACRO _IDL_VERIFY
#if _ITERATOR_DEBUG_LEVEL == 2
 #define _IDL_VERIFY(assertion, message) if (!(assertion)) { _DEBUG_ERROR2(message, __FILEW__, __LINE__); }
#elif _ITERATOR_DEBUG_LEVEL == 1
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
 #define _IDL_VERIFY(assertion, message) _SCL_SECURE_VALIDATE(assertion)
#else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
 #define _IDL_VERIFY(assertion, message)
#endif /* _ITERATOR_DEBUG_LEVEL */
# 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3


		// MACRO _IDL_VERIFY_ALWAYS
#if _ITERATOR_DEBUG_LEVEL == 2
 #define _IDL_VERIFY_ALWAYS(assertion, message) if (!(assertion)) { _DEBUG_ERROR2(message, __FILEW__, __LINE__); }
#else /* ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv */
# 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
 #define _IDL_VERIFY_ALWAYS(assertion, message) _SCL_SECURE_ALWAYS_VALIDATE(assertion)
#endif /* _ITERATOR_DEBUG_LEVEL */
# 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3


		// CLASSES _Container_base*, _Iterator_base*
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
	{	// base of all containers
	void _Orphan_all() _NOEXCEPT
		{	// orphan all iterators
		}

	void _Swap_all(_Container_base0&) _NOEXCEPT
		{	// swap all iterators
		}
	};

struct _Iterator_base0
	{	// base of all iterators
	void _Adopt(const void *) _NOEXCEPT
		{	// adopt this iterator by parent
		}

	const _Container_base0 *_Getcont() const _NOEXCEPT
		{	// get owning container
		return (0);
		}
	};

		// CLASS _Container_proxy
struct _Container_proxy
	{	// store head of iterator chain and back pointer
	_Container_proxy() _NOEXCEPT
		: _Mycont(0), _Myfirstiter(0)
		{	// construct from pointers
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _Container_base12
	{	// store pointer to _Container_proxy
public:
	_Container_base12()
		: _Myproxy(0)
		{	// construct childless container
		}

	_Container_base12(const _Container_base12&) _NOEXCEPT
		: _Myproxy(0)
		{	// copy a container
		}

	_Container_base12& operator=(const _Container_base12&) _NOEXCEPT
		{	// assign a container
		return (*this);
		}

	~_Container_base12() _NOEXCEPT
		{	// destroy the container
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const _NOEXCEPT
		{	// get address of iterator chain
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all() _NOEXCEPT;	// orphan all iterators
	void _Swap_all(_Container_base12&) _NOEXCEPT;	// swap all iterators

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	// store links to container proxy, next iterator
public:
	_Iterator_base12() _NOEXCEPT
		: _Myproxy(0), _Mynextiter(0)
		{	// construct orphaned iterator
		}

	_Iterator_base12(const _Iterator_base12& _Right) _NOEXCEPT
		: _Myproxy(0), _Mynextiter(0)
		{	// copy an iterator
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right) _NOEXCEPT
		{	// assign an iterator
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	// becoming invalid, disown current parent
 #if _ITERATOR_DEBUG_LEVEL == 2
			_Lockit _Lock(_LOCK_DEBUG);
			_Orphan_me();
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
			}

		return (*this);
		}

	~_Iterator_base12() _NOEXCEPT
		{	// destroy the iterator
 #if _ITERATOR_DEBUG_LEVEL == 2
		_Lockit _Lock(_LOCK_DEBUG);
		_Orphan_me();
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
		}

	void _Adopt(const _Container_base12 *_Parent) _NOEXCEPT
		{	// adopt this iterator by parent
		if (_Parent == 0)
			{	// no future parent, just disown current parent
 #if _ITERATOR_DEBUG_LEVEL == 2
			_Lockit _Lock(_LOCK_DEBUG);
			_Orphan_me();
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 186 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
			}
		else
			{	// have a parent, do adoption
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 #if _ITERATOR_DEBUG_LEVEL == 2
			if (_Myproxy != _Parent_proxy)
				{	// change parentage
				_Lockit _Lock(_LOCK_DEBUG);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
			_Myproxy = _Parent_proxy;
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
			}
		}

	void _Clrcont() _NOEXCEPT
		{	// disown owning container
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const _NOEXCEPT
		{	// get owning container
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext() _NOEXCEPT
		{	// get address of remaining iterator chain
		return (&_Mynextiter);
		}

	void _Orphan_me() _NOEXCEPT
		{	// cut ties with parent
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Myproxy != 0)
			{	// adopted, remove self from list
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				{
				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");
				}

			*_Pnext = _Mynextiter;
			_Myproxy = 0;
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		// MEMBER FUNCTIONS FOR _Container_base12
inline void _Container_base12::_Orphan_all() _NOEXCEPT
	{	// orphan all iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	if (_Myproxy != 0)
		{	// proxy allocated, drain it
		_Lockit _Lock(_LOCK_DEBUG);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = 0;
		_Myproxy->_Myfirstiter = 0;
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right) _NOEXCEPT
	{	// swap all iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	_Lockit _Lock(_LOCK_DEBUG);
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
using _Container_base = _Container_base0;
using _Iterator_base = _Iterator_base0;

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

	// CLASS TEMPLATE _Compressed_pair
struct _Zero_then_variadic_args_t
	{	// tag type for value-initializing first,
	};	// constructing second from remaining args

struct _One_then_variadic_args_t
	{	// tag type for constructing first from one arg,
	};	// constructing second from remaining args

template<class _Ty1,
	class _Ty2,
	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
	class _Compressed_pair final
		: private _Ty1
	{	// store a pair of values, deriving from empty first
private:
	_Ty2 _Myval2;

	using _Mybase = _Ty1;	// for visualization

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Ty1(_STD forward<_Other1>(_Val1)),
			_Myval2(_STD forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}


	_Ty1& _Get_first() _NOEXCEPT
		{	// return reference to first
		return (*this);
		}

	const _Ty1& _Get_first() const _NOEXCEPT
		{	// return const reference to first
		return (*this);
		}

	volatile _Ty1& _Get_first() volatile _NOEXCEPT
		{	// return volatile reference to first
		return (*this);
		}

	const volatile _Ty1& _Get_first() const volatile _NOEXCEPT
		{	// return const volatile reference to first
		return (*this);
		}

	_Ty2& _Get_second() _NOEXCEPT
		{	// return reference to second
		return (_Myval2);
		}

	const _Ty2& _Get_second() const _NOEXCEPT
		{	// return const reference to second
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile _NOEXCEPT
		{	// return volatile reference to second
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile _NOEXCEPT
		{	// return const volatile reference to second
		return (_Myval2);
		}
	};

template<class _Ty1,
	class _Ty2>
	class _Compressed_pair<_Ty1, _Ty2, false> final
	{	// store a pair of values, not deriving from first
private:
	_Ty1 _Myval1;
	_Ty2 _Myval2;

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Myval1(), _Myval2(_STD forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Myval1(_STD forward<_Other1>(_Val1)),
			_Myval2(_STD forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}


	_Ty1& _Get_first() _NOEXCEPT
		{	// return reference to first
		return (_Myval1);
		}

	const _Ty1& _Get_first() const _NOEXCEPT
		{	// return const reference to first
		return (_Myval1);
		}

	volatile _Ty1& _Get_first() volatile _NOEXCEPT
		{	// return volatile reference to first
		return (_Myval1);
		}

	const volatile _Ty1& _Get_first() const volatile _NOEXCEPT
		{	// return const volatile reference to first
		return (_Myval1);
		}

	_Ty2& _Get_second() _NOEXCEPT
		{	// return reference to second
		return (_Myval2);
		}

	const _Ty2& _Get_second() const _NOEXCEPT
		{	// return const reference to second
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile _NOEXCEPT
		{	// return volatile reference to second
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile _NOEXCEPT
		{	// return const volatile reference to second
		return (_Myval2);
		}
	};

		// STRUCT TEMPLATE _Is_checked_helper
template<class _Ty,
	class = void>
	struct _Is_checked_helper
		: false_type
	{	// default definition
	};

template<class _Ty>
	struct _Is_checked_helper<_Ty, void_t<
		typename _Ty::_Unchecked_type>>
		: true_type
	{	// defined if _Ty::_Unchecked_type exists
	};

		// FUNCTION TEMPLATE _Is_checked
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	// return type is true_type if iterator is checked
	return {};
	}

		// FUNCTION TEMPLATE _Unchecked
template<class _Iter>
	constexpr _Iter _Unchecked(_Iter _Src)
	{	// construct unchecked from checked, generic
	return (_Src);
	}

		// ALIAS TEMPLATE _Unchecked_t
template<class _Iter>
	using _Unchecked_t = decltype(_Unchecked(_STD declval<_Iter>()));

		// FUNCTION TEMPLATE _Unchecked_idl0
 #if _ITERATOR_DEBUG_LEVEL == 0

template<class _Iter> inline
	_Unchecked_t<_Iter> _Unchecked_idl0(_Iter _Src)
	{	// uncheck _Src in IDL == 0 only
	return (_Unchecked(_Src));
	}

 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 476 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _Iter> inline
	_Iter _Unchecked_idl0(_Iter _Src)
	{	// don't uncheck _Src for IDL > 0
	return (_Src);
	}

 #endif /* _ITERATOR_DEBUG_LEVEL */
# 484 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE _Rechecked
template<class _Iter,
	class _UIter>
	constexpr _Iter& _Rechecked(_Iter& _Dest, const _UIter _Src)
	{	// reset checked from unchecked, generic
	_Dest = _Src;
	return (_Dest);
	}

		// MACRO _DEPRECATE_UNCHECKED AND FRIENDS
#define _DEFINE_DEPRECATE_UNCHECKED(_Func) \
struct _Unchecked_iterators \
	{	/* Warns about unchecked iterators */ \
	static void _SCL_INSECURE_DEPRECATE_FN(_Func) _Deprecate(false_type) \
		{	/* Detected unchecked iterator, warn */ \
		} \
	\
	static void _Deprecate(true_type) \
		{	/* Detected checked iterator, do not warn */ \
		} \
	}

#define _USE_DEPRECATE_UNCHECKED(_Iter) \
	(_Unchecked_iterators::_Deprecate(_Is_checked(_Iter)))

#define _DEPRECATE_UNCHECKED(_Func, _Iter) \
	_DEFINE_DEPRECATE_UNCHECKED(_Func); \
	_USE_DEPRECATE_UNCHECKED(_Iter)


		// FUNCTION TEMPLATE _Pass_fn
		// TRANSITION, VSO#386225
template<class _Fx>
	struct _Ref_fn
	{	// pass function object by value as a reference
	template<class... _Args>
		constexpr decltype(auto) operator()(_Args&&... _Vals)
		{	// forward function call operator
		return (_Fn(_STD forward<_Args>(_Vals)...));
		}

	_Fx& _Fn;
	};

template<class _Fn>
	_INLINE_VAR constexpr bool _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void *)
		&& conjunction_v<
			is_trivially_copy_constructible<_Fn>,
			is_trivially_destructible<_Fn>>;

template<class _Fn,
	enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0>
	constexpr _Fn _Pass_fn(_Fn _Val)
	{	// pass functor by value
	return (_Val);
	}

template<class _Fn,
	enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
	constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val)
	{	// pass functor by "reference"
	return {_Val};
	}

		// ITERATOR STUFF (from <iterator>)
		// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag
	{	// identifying tag for input iterators
	};

struct output_iterator_tag
	{	// identifying tag for output iterators
	};

struct forward_iterator_tag
	: input_iterator_tag
	{	// identifying tag for forward iterators
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	// identifying tag for bidirectional iterators
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	// identifying tag for random-access iterators
	};

		// POINTER ITERATOR TAGS
struct _General_ptr_iterator_tag
	{	// general case, no special optimizations
	};

struct _Trivially_copyable_ptr_iterator_tag
	: _General_ptr_iterator_tag
	{	// iterator is a pointer to a trivially copyable type
	};

struct _Really_trivial_ptr_iterator_tag
	: _Trivially_copyable_ptr_iterator_tag
	{	// iterator is a pointer to a trivial type
	};

		// STRUCT _Unused_parameter
struct _Unused_parameter
	{	// generic unused parameter struct
	constexpr _Unused_parameter() _NOEXCEPT = default;
	template<class _Ty>
		constexpr _Unused_parameter(_Ty&&) _NOEXCEPT {}
	};

		// ALIAS _Any_tag
using _Any_tag = _Unused_parameter; // generic fallback/default/"other" target for tag dispatch

		// ALIAS TEMPLATE _Algorithm_int_t
template<class _Ty>
	using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;

		// STRUCT TEMPLATE iterator_traits
template<class,
	class = void>
	struct _Iterator_traits_base
	{	// empty for non-iterators
	};

template<class _Iter>
	struct _Iterator_traits_base<_Iter, void_t<
		typename _Iter::iterator_category,
		typename _Iter::value_type,
		typename _Iter::difference_type,
		typename _Iter::pointer,
		typename _Iter::reference
		>>
	{	// defined if _Iter::* types exist
	using iterator_category = typename _Iter::iterator_category;
	using value_type = typename _Iter::value_type;
	using difference_type = typename _Iter::difference_type;

	using pointer = typename _Iter::pointer;
	using reference = typename _Iter::reference;
	};

template<class _Ty,
	bool = is_object_v<_Ty>>
	struct _Iterator_traits_pointer_base
	{	// iterator properties for pointers to object
	using iterator_category = random_access_iterator_tag;
	using value_type = remove_cv_t<_Ty>;
	using difference_type = ptrdiff_t;

	using pointer = _Ty *;
	using reference = _Ty&;
	};

template<class _Ty>
	struct _Iterator_traits_pointer_base<_Ty, false>
	{	// iterator properties for pointers to non-object
		// not actually iterators, as no arithmetic is possible -> no members
	};

template<class _Iter>
	struct iterator_traits
		: _Iterator_traits_base<_Iter>
	{	// get traits from iterator _Iter, if possible
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
		: _Iterator_traits_pointer_base<_Ty>
	{	// get traits from pointer, if possible
	};

		// ALIAS TEMPLATE _Iter_value_t
template<class _Iter>
	using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

		// ALIAS TEMPLATE _Iter_diff_t
template<class _Iter>
	using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

		// ALIAS TEMPLATE _Common_diff_t
template<class... _Iters>
	using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

		// ALIAS TEMPLATE _Iter_cat_t
template<class _Iter>
	using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

		// VARIABLE TEMPLATE _Is_iterator_v
template<class _Ty,
	class = void>
	_INLINE_VAR constexpr bool _Is_iterator_v = false;

template<class _Ty>
	_INLINE_VAR constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

		// TRAIT _Is_iterator
template<class _Ty>
	struct _Is_iterator
		: bool_constant<_Is_iterator_v<_Ty>>
	{
	};

		// VARIABLE TEMPLATE _Is_fwdit_v
template<class _Iter>
	_INLINE_VAR constexpr bool _Is_fwdit_v = is_base_of_v<forward_iterator_tag, _Iter_cat_t<_Iter>>;

		// VARIABLE TEMPLATE _Is_ranit_v
template<class _Iter>
	_INLINE_VAR constexpr bool _Is_ranit_v = is_base_of_v<random_access_iterator_tag, _Iter_cat_t<_Iter>>;

#if _HAS_DEDUCTION_GUIDES
		// STRUCT TEMPLATE _Is_allocator
struct _Unique_tag_is_allocator
	{	// TRANSITION, C1XX
	};

template<class _Ty,
	class = void>
	struct _Is_allocator
		: false_type
	{	// selected when _Ty can't possibly be an allocator
	};

template<class _Ty>
	struct _Is_allocator<_Ty, void_t<
		_Unique_tag_is_allocator,
		typename _Ty::value_type,
		decltype(_STD declval<_Ty&>().deallocate(_STD declval<_Ty&>().allocate(size_t{1}), size_t{1}))
	>>
		: true_type
	{	// selected when _Ty resembles an allocator, N4687 26.2.1 [container.requirements.general]/17
	};

		// ALIAS TEMPLATES FOR DEDUCTION GUIDES, N4687 26.4.1 [associative.general]/2
template<class _Iter>
	using _Guide_key_t = remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;

template<class _Iter>
	using _Guide_val_t = typename iterator_traits<_Iter>::value_type::second_type;

template<class _Iter>
	using _Guide_pair_t = pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
		typename iterator_traits<_Iter>::value_type::second_type>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 731 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

#if _HAS_CXX17
		// STRUCT TEMPLATE is_execution_policy
template<class _Ty>
	struct is_execution_policy
		: false_type
	{
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;

		// STRUCT TEMPLATE _Priority_tag
template<size_t _Value>
	struct _Priority_tag
		: _Priority_tag<_Value - 1>
	{	// priority tag for tag dispatch
	};

template<>
	struct _Priority_tag<0>
	{	// base case priority tag for tag dispatch
	};

		// EXECUTION POLICIES
using _Sequenced_policy_tag = _Priority_tag<0>;
using _Parallel_policy_tag = _Priority_tag<1>;
using _Parallel_unsequenced_policy_tag = _Priority_tag<2>;

		// ALIAS TEMPLATE _Enable_if_execution_policy_t
template<class _ExPo>
	using _Enable_if_execution_policy_t = enable_if_t<is_execution_policy_v<decay_t<_ExPo>>, int>;

#define _REQUIRE_PARALLEL_ITERATOR(_Iter) static_assert(_Is_fwdit_v<_Iter>, \
	"Parallel algorithms require forward iterators or stronger.")

#endif /* _HAS_CXX17 */
# 768 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE _Idl_distance
struct _Distance_unknown {};

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _Checked,
	class _Iter> inline
	_Distance_unknown _Idl_distance(const _Iter&, const _Iter&)
	{	// always give up under IDL0 because _Unchecked_n blindly unwraps there
	return {};
	}
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 780 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
template<class _Checked,
	class _Iter> inline
	_Distance_unknown _Idl_distance1(const _Iter&, const _Iter&, input_iterator_tag)
	{	// _Idl_distance for non-random-access iterators
	return {};
	}

template<class _Checked,
	class _Iter> inline
	_Iter_diff_t<_Checked> _Idl_distance1(const _Iter& _First, const _Iter& _Last, random_access_iterator_tag)
	{	// _Idl_distance for random-access iterators
	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));
	}

template<class _Checked,
	class _Iter> inline
	auto _Idl_distance(const _Iter& _First, const _Iter& _Last)
	{	// tries to get the distance between _First and _Last if they are random-access iterators
	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3


		// FUNCTION TEMPLATE _Unchecked_n
 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n(_Iter _Src, _Diff)
	{	// blindly unwrap _Src under IDL == 0
	return (_Unchecked(_Src));
	}
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 812 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
template<class _Diff>
	constexpr _Diff _Get_max_possible()
	{	// gets the maximum possible value of _Diff (without creating circular dependencies by including <limits>)
	return (static_cast<_Diff>(static_cast<make_unsigned_t<_Diff>>(-1) >> 1));
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n1(_Iter _Src, _Diff, false_type)
	{	// checking range [_Src, _Src + _Diff) not possible; leave _Src wrapped
	return (_Src);
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n1(_Iter _Src, _Diff _Count, true_type)
	{	// check range [_Src, _Src + _Count) and unwrap _Src
	if (0 < _Count)
		{
		// checks that the range [_Src, _Src + _Count) is valid by forming the end iterator
		constexpr auto _Max_possible = _Get_max_possible<_Iter_diff_t<_Iter>>();
		_IDL_VERIFY(_Count <= _Max_possible, "integer overflow");
		static_cast<void>(_Src + static_cast<_Iter_diff_t<_Iter>>(_Count));
		}

	return (_Unchecked(_Src));
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n(_Iter _Src, _Diff _Count)
	{	// if possible, checks the range [_Src, _Src + _Count) and unwraps _Src; otherwise, returns _Src unchanged
	return (_Unchecked_n1(_Src, _Count, is_base_of<random_access_iterator_tag, _Iter_cat_t<_Iter>>()));
	}

template<class _Iter> inline
	auto _Unchecked_n(_Iter _Src, _Distance_unknown)
	{	// always returns _Src unchanged because range size is unknown
	return (_Src);
	}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 853 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3


		// FUNCTION TEMPLATE _Unchecked_n_backward
 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n_backward(_Iter _Src, _Diff)
	{	// blindly unwrap _Src under IDL == 0
	return (_Unchecked(_Src));
	}
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 864 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n_backward1(_Iter _Src, _Diff, bidirectional_iterator_tag)
	{	// checking range [_Src - _Count, _Src) not possible; leave _Src wrapped
	return (_Src);
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n_backward1(_Iter _Src, _Diff _Count, random_access_iterator_tag)
	{	// check range [_Src - _Count, _Src) and unwrap _Src
	if (0 < _Count)
		{
		constexpr auto _Max_possible = _Get_max_possible<_Iter_diff_t<_Iter>>();
		_IDL_VERIFY(_Count <= _Max_possible, "integer overflow");
		// checks that the range [_Src - _Count, _Src) is valid by forming the begin iterator
		static_cast<void>(_Src - static_cast<_Iter_diff_t<_Iter>>(_Count));
		}

	return (_Unchecked(_Src));
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n_backward(_Iter _Src, _Diff _Count)
	{	// if possible, checks the range [_Src - _Count, _Src) and unwraps _Src; otherwise, returns _Src unchanged
	return (_Unchecked_n_backward1(_Src, _Count, _Iter_cat_t<_Iter>()));
	}

template<class _Iter> inline
	auto _Unchecked_n_backward(_Iter _Src, _Distance_unknown)
	{	// always returns _Src unchanged because range size is unknown
	return (_Src);
	}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3


		// STRUCT TEMPLATE _Is_same_size
template<class _Ty1,
	class _Ty2>
	struct _Is_same_size
		: bool_constant<sizeof(_Ty1) == sizeof(_Ty2)>
	{	// determine whether two types have the same size
	};

		// STRUCT TEMPLATE _Unwrap_enum AND ALIAS
template<class _Elem,
	bool _Is_enum = is_enum_v<_Elem>>
	struct _Unwrap_enum
	{	// if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
	using type = underlying_type_t<_Elem>;
	};

template<class _Elem>
	struct _Unwrap_enum<_Elem, false>
	{	// passthrough non-enum type
	using type = _Elem;
	};

template<class _Elem>
	using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;

		// STRUCT TEMPLATE _Both_or_neither_bool
template<class _Ty1,
	class _Ty2>
	struct _Both_or_neither_bool
		: bool_constant<is_same_v<bool, _Ty1> == is_same_v<bool, _Ty2>>
	{	// determines if both _Ty1 and _Ty2 are exactly bool, or neither are
	};

		// FUNCTION TEMPLATES _Ptr_copy_cat AND _Ptr_move_cat
template<class _Source,
	class _Dest>
	struct _Ptr_cat_helper
	{	// determines _Ptr_cat's result in the most general case
	using _USource = _Unwrap_enum_t<_Source>;
	using _UDest = _Unwrap_enum_t<_Dest>;
	using type = conditional_t<conjunction_v<
			_Is_same_size<_USource, _UDest>,
			is_integral<_USource>,
			is_integral<_UDest>,
			_Both_or_neither_bool<_USource, _UDest>
		>, _Really_trivial_ptr_iterator_tag, _General_ptr_iterator_tag>;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	// determines _Ptr_cat's result when the types are the same
	using type = conditional_t<
		is_trivially_copyable_v<_Elem>,
		conditional_t<is_trivial_v<_Elem>,
			_Really_trivial_ptr_iterator_tag,
			_Trivially_copyable_ptr_iterator_tag>,
		_General_ptr_iterator_tag>;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	// determines _Ptr_cat's result when all we do is add const to a pointer
	using type = _Really_trivial_ptr_iterator_tag;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, volatile _Anything *>
	{	// determines _Ptr_cat's result when all we do is add volatile to a pointer
	using type = _Really_trivial_ptr_iterator_tag;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const volatile _Anything *>
	{	// determines _Ptr_cat's result when all we do is add cv to a pointer
	using type = _Really_trivial_ptr_iterator_tag;
	};

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_copy_cat(const _Source&, const _Dest&)
	{	// return pointer copy optimization category for arbitrary iterators
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable_v<_Dest&, _Source&>,
		typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>::type,
		_General_ptr_iterator_tag>
		_Ptr_copy_cat(_Source * const&, _Dest * const&)
	{	// return pointer copy optimization category for pointers
	return {};
	}

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_move_cat(const _Source&, const _Dest&)
	{	// return pointer move optimization category for arbitrary iterators
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable_v<_Dest&, _Source>,
		typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>::type,
		_General_ptr_iterator_tag>
		_Ptr_move_cat(_Source * const&, _Dest * const&)
	{	// return pointer move optimization category for pointers
	return {};
	}

		// DEBUG TESTING MACROS

 #if _ITERATOR_DEBUG_LEVEL < 2
  #define _DEBUG_LT(x, y)	((x) < (y))
  #define _DEBUG_LT_PRED(pred, x, y)	pred(x, y)
  #define _DEBUG_ORDER_UNCHECKED(first, last, pred)
  #define _DEBUG_RANGE(first, last)
  #define _DEBUG_RANGE2(first, last, file, line)

 #else /* _ITERATOR_DEBUG_LEVEL < 2 */
# 1022 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

  #define _FILENAME	__FILEW__

  #ifndef _DEBUG_LT_IMPL
   #define _DEBUG_LT_IMPL	_Debug_lt
  #endif /* _DEBUG_LT_IMPL */
# 1028 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

  #define _DEBUG_LT(x, y) \
	_DEBUG_LT_IMPL(x, y, _FILENAME, __LINE__)

  #ifndef _DEBUG_LT_PRED_IMPL
   #define _DEBUG_LT_PRED_IMPL	_Debug_lt_pred
  #endif /* _DEBUG_LT_PRED_IMPL */
# 1035 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

  #define _DEBUG_LT_PRED(pred, x, y)	\
	_DEBUG_LT_PRED_IMPL(pred, x, y, _FILENAME, __LINE__)

  #ifndef _DEBUG_ORDER_UNCHECKED_IMPL
   #define _DEBUG_ORDER_UNCHECKED_IMPL	_Debug_order_unchecked
  #endif /* _DEBUG_ORDER_IMPL */
# 1042 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

  #define _DEBUG_ORDER_UNCHECKED(first, last, pred)	\
	_DEBUG_ORDER_UNCHECKED_IMPL(first, last, pred, _FILENAME, __LINE__)

  #ifndef _DEBUG_RANGE_IMPL
   #define _DEBUG_RANGE_IMPL	_Debug_range
  #endif /* _DEBUG_RANGE_IMPL */
# 1049 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

  #define _DEBUG_RANGE(first, last)	\
	_DEBUG_RANGE_IMPL(first, last, _FILENAME, __LINE__)
  #define _DEBUG_RANGE2(first, last, file, line)	\
	_DEBUG_RANGE_IMPL(first, last, file, line)

		// FUNCTION TEMPLATE _Debug_lt_pred
template<class _Pr,
	class _Ty1,
	class _Ty2>
	constexpr bool _Debug_lt_pred(_Pr&& _Pred,
		_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_Pred(_Left, _Right)) && _NOEXCEPT_OPER(_Pred(_Right, _Left)))
	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering
	return (_Pred(_Left, _Right)
		? (_Pred(_Right, _Left)
			? (_DEBUG_ERROR2("invalid comparator", _File, _Line), true)
			: true)
		: false);
	}

		// FUNCTION TEMPLATE _Debug_lt
template<class _Ty1,
	class _Ty2>
	constexpr bool _Debug_lt(_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_Left < _Right) && _NOEXCEPT_OPER(_Right < _Left))
	{	// test if _Left < _Right and operator< is strict weak ordering
	return (_Debug_lt_pred(less<>(),
		_STD forward<_Ty1>(_Left), _STD forward<_Ty2>(_Right), _File, _Line));
	}

		// FUNCTION TEMPLATE _Debug_range
template<class _InIt>
	constexpr void _Debug_range2(_InIt _First, _InIt _Last,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	// test iterator pair for valid range, arbitrary iterators
	static_cast<void>(_First == _Last);	// make sure they're comparable
	}

template<class _RanIt>
	constexpr void _Debug_range2(_RanIt _First, _RanIt _Last,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	// test iterator pair for valid range, random-access iterators
	if (_Last < _First)
		{
		_DEBUG_ERROR2("invalid iterator range", _File, _Line);
		}
	}

template<class _InIt>
	constexpr void _Debug_range(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test iterator pair for valid range
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat_t<_InIt>());
	}

		// FUNCTION TEMPLATE _Debug_order_unchecked WITH PRED
template<class _InIt,
	class _Sentinel,
	class _Pr> inline
	void _Debug_order_unchecked2(_InIt, _Sentinel, _Pr&,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	// test if range is ordered by predicate, input iterators
	}

template<class _FwdIt,
	class _Sentinel,
	class _Pr> inline
	void _Debug_order_unchecked2(_FwdIt _First, _Sentinel _Last, _Pr& _Pred,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	// test if range is ordered by predicate, forward iterators
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		{
		if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
			{
			_DEBUG_ERROR2("sequence not ordered", _File, _Line);
			}
		}
	}

template<class _InIt,
	class _Sentinel,
	class _Pr> inline
	void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if range is ordered by predicate
	_Debug_order_unchecked2(_First, _Last, _Pred, _File, _Line, _Iter_cat_t<_InIt>());
	}
 #endif /* _ITERATOR_DEBUG_LEVEL < 2 */
# 1140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

 #if _ITERATOR_DEBUG_LEVEL == 0
  #define _DEBUG_ARRAY_SIZE(_Array, _Desired)
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1144 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
template<class _Ty,
	size_t _Actual,
	class _Diff> inline
	void _Debug_array_size1(_Ty (&)[_Actual], _Diff _Desired)
	{	// verify that _Actual is >= _Desired
	_SCL_SECURE_VALIDATE_RANGE(_Actual >= _Desired);
	}
  #define _DEBUG_ARRAY_SIZE(_Array, _Desired) _Debug_array_size1(_Array, _Desired)
 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
template<class _Ty,
	size_t _Actual,
	class _Diff> inline
	void _Debug_array_size2(_Ty (&)[_Actual], _Diff _Desired,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// verify that _Actual is >= _Desired
	if (_Actual < static_cast<common_type_t<size_t, _Diff>>(_Desired))
		{
		_DEBUG_ERROR2("array too small", _File, _Line);
		}
	}
  #define _DEBUG_ARRAY_SIZE(_Array, _Desired) _Debug_array_size2(_Array, _Desired, _FILENAME, __LINE__)
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// MORE ITERATOR STUFF (from <iterator>)
		// FUNCTION TEMPLATE advance
template<class _InIt,
	class _Diff>
	_CONSTEXPR17 void _Advance1(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	// increment iterator by offset, input iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	if (_Off < 0)
		{
		_DEBUG_ERROR("negative offset in advance");
		}

 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

	for (; 0 < _Off; --_Off)
		{
		++_Where;
		}
	}

template<class _BidIt,
	class _Diff>
	_CONSTEXPR17 void _Advance1(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	// increment iterator by offset, bidirectional iterators
	for (; 0 < _Off; --_Off)
		{
		++_Where;
		}

	// the following warning is triggered if _Diff is unsigned
#pragma warning(suppress: 6294)	// Ill-defined for-loop: initial condition does not satisfy test.
								// Loop body not executed.
	for (; _Off < 0; ++_Off)
		{
		--_Where;
		}
	}

template<class _RanIt,
	class _Diff>
	_CONSTEXPR17 void _Advance1(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	// increment iterator by offset, random-access iterators
	_Where += _Off;
	}

template<class _InIt,
	class _Diff>
	_CONSTEXPR17 void advance(_InIt& _Where, _Diff _Off)
	{	// increment iterator by offset, arbitrary iterators
		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
	}

		// FUNCTION TEMPLATE distance
template<class _InIt>
	_CONSTEXPR17 _Iter_diff_t<_InIt> _Distance1(_InIt _First, _InIt _Last, input_iterator_tag)
	{	// return distance between iterators; input
	_Iter_diff_t<_InIt> _Off = 0;
	for (; _First != _Last; ++_First)
		++_Off;

	return (_Off);
	}

template<class _RanIt>
	_CONSTEXPR17 _Iter_diff_t<_RanIt> _Distance1(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{	// return distance between iterators; random-access
	return (_Last - _First);
	}

template<class _InIt>
	_NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)
	{	// return distance between iterators
	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
	}

		// FUNCTION TEMPLATE _Next_iter
template<class _InIt>
	constexpr _InIt _Next_iter(_InIt _First)
	{	// increment iterator
	return (++_First);
	}

		// FUNCTION TEMPLATE next
template<class _InIt>
	_NODISCARD _CONSTEXPR17 _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
	{	// increment iterator
	static_assert(is_base_of_v<input_iterator_tag, _Iter_cat_t<_InIt>>,
		"next requires input iterator");

	_STD advance(_First, _Off);
	return (_First);
	}

		// FUNCTION TEMPLATE _Prev_iter
template<class _BidIt>
	constexpr _BidIt _Prev_iter(_BidIt _First)
	{	// decrement iterator
	return (--_First);
	}

		// FUNCTION TEMPLATE prev
template<class _BidIt>
	_NODISCARD _CONSTEXPR17 _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
	{	// decrement iterator
	static_assert(is_base_of_v<bidirectional_iterator_tag, _Iter_cat_t<_BidIt>>,
		"prev requires bidirectional iterator");

	_STD advance(_First, -_Off);
	return (_First);
	}

		// CLASS TEMPLATE reverse_iterator
template<class _Ty>
	struct pointer_traits;

template<class _Iterator>
	constexpr _Iterator _Operator_arrow(_Iterator _Target, true_type)
	{	// return operator-> where _Iterator is a pointer
	return (_Target);
	}

template<class _Iterator>
	constexpr decltype(auto) _Operator_arrow(_Iterator&& _Target, false_type)
	{	// return operator-> where _Iterator is a class type
	return (_STD forward<_Iterator>(_Target).operator->());
	}

template<class _RanIt>
	class reverse_iterator
	{	// wrap iterator to run it backwards
public:
	using iterator_category = typename iterator_traits<_RanIt>::iterator_category;
	using value_type = typename iterator_traits<_RanIt>::value_type;
	using difference_type = typename iterator_traits<_RanIt>::difference_type;
	using pointer = typename iterator_traits<_RanIt>::pointer;
	using reference = typename iterator_traits<_RanIt>::reference;

	using iterator_type = _RanIt;

	_CONSTEXPR17 reverse_iterator()
		: current()
		{	// construct with value-initialized wrapped iterator
		}

	_CONSTEXPR17 explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _Other>
		_CONSTEXPR17 reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	template<class _Other>
		_CONSTEXPR17 reverse_iterator& operator=(const reverse_iterator<_Other>& _Right)
		{	// assign from compatible base
		current = _Right.base();
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 _RanIt base() const
		{	// return wrapped iterator
		return (current);
		}

	_NODISCARD _CONSTEXPR17 reference operator*() const
		{	// return designated value
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	_NODISCARD _CONSTEXPR17 pointer operator->() const
		{	// return pointer to class object
		_RanIt _Tmp = current;
		--_Tmp;
		return (_Operator_arrow(_Tmp, is_pointer<_RanIt>()));
		}

	_CONSTEXPR17 reverse_iterator& operator++()
		{	// preincrement
		--current;
		return (*this);
		}

	_CONSTEXPR17 reverse_iterator operator++(int)
		{	// postincrement
		reverse_iterator _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_CONSTEXPR17 reverse_iterator& operator--()
		{	// predecrement
		++current;
		return (*this);
		}

	_CONSTEXPR17 reverse_iterator operator--(int)
		{	// postdecrement
		reverse_iterator _Tmp = *this;
		++current;
		return (_Tmp);
		}

// N.B. functions valid for random-access iterators only beyond this point

	_CONSTEXPR17 reverse_iterator& operator+=(difference_type _Off)
		{	// increment by integer
		current -= _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 reverse_iterator operator+(difference_type _Off) const
		{	// return this + integer
		return (reverse_iterator(current - _Off));
		}

	_CONSTEXPR17 reverse_iterator& operator-=(difference_type _Off)
		{	// decrement by integer
		current += _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 reverse_iterator operator-(difference_type _Off) const
		{	// return this - integer
		return (reverse_iterator(current + _Off));
		}

	_NODISCARD _CONSTEXPR17 reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

protected:
	_RanIt current;	// the wrapped iterator
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt>>
		: public _Is_checked_helper<_RanIt>
	{	// mark reverse_iterator as checked if its wrapped iterator is checked
	};

template<class _RanIt>
	_NODISCARD _CONSTEXPR17 reverse_iterator<_RanIt> operator+(
		typename reverse_iterator<_RanIt>::difference_type _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	// return reverse_iterator + integer
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 auto operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	// return difference of reverse_iterators
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator equality
	return (_Left.base() == _Right.base());
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator inequality
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator < reverse_iterator
	return (_Right.base() < _Left.base());
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator > reverse_iterator
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator <= reverse_iterator
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator >= reverse_iterator
	return (!(_Left < _Right));
	}

		// FUNCTION TEMPLATE make_reverse_iterator
template<class _RanIt>
	_NODISCARD _CONSTEXPR17 reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
	{	// make reverse_iterator from iterator
	return (reverse_iterator<_RanIt>(_Iter));
	}

		// FUNCTION TEMPLATES begin AND end
template<class _Container>
	_NODISCARD _CONSTEXPR17 auto begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	// get beginning of sequence
	return (_Cont.begin());
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	// get beginning of sequence
	return (_Cont.begin());
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto end(_Container& _Cont) -> decltype(_Cont.end())
	{	// get end of sequence
	return (_Cont.end());
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto end(const _Container& _Cont) -> decltype(_Cont.end())
	{	// get end of sequence
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty *begin(_Ty (&_Array)[_Size]) _NOEXCEPT
	{	// get beginning of array
	return (_Array);
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty *end(_Ty (&_Array)[_Size]) _NOEXCEPT
	{	// get end of array
	return (_Array + _Size);
	}

		// FUNCTION TEMPLATES cbegin AND cend
template<class _Container>
	_NODISCARD constexpr auto cbegin(const _Container& _Cont)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_STD begin(_Cont)))
		-> decltype(_STD begin(_Cont))
	{	// get beginning of sequence
	return (_STD begin(_Cont));
	}

template<class _Container>
	_NODISCARD constexpr auto cend(const _Container& _Cont)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_STD end(_Cont)))
		-> decltype(_STD end(_Cont))
	{	// get end of sequence
	return (_STD end(_Cont));
	}

		// FUNCTION TEMPLATES rbegin AND rend
template<class _Container>
	_NODISCARD _CONSTEXPR17 auto rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	// get beginning of reversed sequence
	return (_Cont.rbegin());
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	// get beginning of reversed sequence
	return (_Cont.rbegin());
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	// get end of reversed sequence
	return (_Cont.rend());
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	// get end of reversed sequence
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD _CONSTEXPR17 reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	// get beginning of reversed array
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD _CONSTEXPR17 reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	// get end of reversed array
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem>
	_NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem *>
		rbegin(initializer_list<_Elem> _Ilist)
	{	// get beginning of reversed sequence
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem>
	_NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem *>
		rend(initializer_list<_Elem> _Ilist)
	{	// get end of reversed sequence
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		// FUNCTION TEMPLATES crbegin AND crend
template<class _Container>
	_NODISCARD _CONSTEXPR17 auto crbegin(const _Container& _Cont)
		-> decltype(_STD rbegin(_Cont))
	{	// get beginning of reversed sequence
	return (_STD rbegin(_Cont));
	}

template<class _Container>
	_NODISCARD _CONSTEXPR17 auto crend(const _Container& _Cont)
		-> decltype(_STD rend(_Cont))
	{	// get end of reversed sequence
	return (_STD rend(_Cont));
	}


template<class _Container>
	_NODISCARD constexpr auto size(const _Container& _Cont)
		-> decltype(_Cont.size())
	{	// get size() for container
	return (_Cont.size());
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD constexpr size_t size(const _Ty(&)[_Size]) _NOEXCEPT
	{	// get dimension for array
	return (_Size);
	}

template<class _Container>
	_NODISCARD constexpr auto empty(const _Container& _Cont)
		-> decltype(_Cont.empty())
	{	// get empty() for container
	return (_Cont.empty());
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD constexpr bool empty(const _Ty(&)[_Size]) _NOEXCEPT
	{	// get dimension==0 for array (can't happen)
	return (false);
	}

template<class _Elem>
	_NODISCARD constexpr bool empty(
		initializer_list<_Elem> _Ilist) _NOEXCEPT
	{	// get dimension==0 for initializer_list
	return (_Ilist.size() == 0);
	}

template<class _Container>
	_NODISCARD constexpr auto data(_Container& _Cont)
		-> decltype(_Cont.data())
	{	// get data() for container
	return (_Cont.data());
	}

template<class _Container>
	_NODISCARD constexpr auto data(const _Container& _Cont)
		-> decltype(_Cont.data())
	{	// get pointer to data of const container
	return (_Cont.data());
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty *data(_Ty(&_Array)[_Size]) _NOEXCEPT
	{	// get pointer to data of array
	return (_Array);
	}

template<class _Elem>
	_NODISCARD constexpr const _Elem *data(
		initializer_list<_Elem> _Ilist) _NOEXCEPT
	{	// get pointer to data of initializer_list
	return (_Ilist.begin());
	}


		// CLASS TEMPLATE _Array_const_iterator
#if _ITERATOR_DEBUG_LEVEL != 0
struct _Iterator_base12_compatible
	{	// TRANSITION, for binary compatibility
	_Container_proxy * _Myproxy{};
	_Iterator_base12 * _Mynextiter{};
	};
#endif /* _ITERATOR_DEBUG_LEVEL != 0 */
# 1682 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
#if _ITERATOR_DEBUG_LEVEL != 0
		: private _Iterator_base12_compatible
#endif /* _ITERATOR_DEBUG_LEVEL != 0 */
# 1689 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	{	// iterator for nonmutable array
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = _Ty;
	using difference_type = ptrdiff_t;
	using pointer = const _Ty *;
	using reference = const _Ty&;
	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
 #if _ITERATOR_DEBUG_LEVEL == 0
	_CONSTEXPR17 _Array_const_iterator()
		: _Ptr()
		{	// construct with null pointer
		}

	_CONSTEXPR17 explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		: _Ptr(_Parg + _Off)
		{	// construct with pointer and offset
		}

	using _Unchecked_type = pointer;

	_NODISCARD _CONSTEXPR17 reference operator*() const
		{	// return designated object
		return (*_Ptr);
		}

	_NODISCARD _CONSTEXPR17 pointer operator->() const
		{	// return pointer to class object
		return (_Ptr);
		}

	_CONSTEXPR17 _Array_const_iterator& operator++()
		{	// preincrement
		++_Ptr;
		return (*this);
		}

	_CONSTEXPR17 _Array_const_iterator operator++(int)
		{	// postincrement
		_Array_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_CONSTEXPR17 _Array_const_iterator& operator--()
		{	// predecrement
		--_Ptr;
		return (*this);
		}

	_CONSTEXPR17 _Array_const_iterator operator--(int)
		{	// postdecrement
		_Array_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_CONSTEXPR17 _Array_const_iterator& operator+=(ptrdiff_t _Off)
		{	// increment by integer
		_Ptr += _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 _Array_const_iterator operator+(ptrdiff_t _Off) const
		{	// return this + integer
		_Array_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_CONSTEXPR17 _Array_const_iterator& operator-=(ptrdiff_t _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _CONSTEXPR17 _Array_const_iterator operator-(ptrdiff_t _Off) const
		{	// return this - integer
		_Array_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD _CONSTEXPR17 ptrdiff_t operator-(const _Array_const_iterator& _Right) const
		{	// return difference of iterators
		return (_Ptr - _Right._Ptr);
		}

	_NODISCARD _CONSTEXPR17 reference operator[](ptrdiff_t _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD _CONSTEXPR17 bool operator==(const _Array_const_iterator& _Right) const
		{	// test for iterator equality
		return (_Ptr == _Right._Ptr);
		}

	_NODISCARD _CONSTEXPR17 bool operator!=(const _Array_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD _CONSTEXPR17 bool operator<(const _Array_const_iterator& _Right) const
		{	// test if this < _Right
		return (_Ptr < _Right._Ptr);
		}

	_NODISCARD _CONSTEXPR17 bool operator>(const _Array_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD _CONSTEXPR17 bool operator<=(const _Array_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD _CONSTEXPR17 bool operator>=(const _Array_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	pointer _Ptr;	// beginning of array

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 1813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	_CONSTEXPR17 _Array_const_iterator()
		: _Ptr(),
		_Idx(0)
		{	// construct with null pointer
		}

	_CONSTEXPR17 explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		: _Ptr(_Parg),
		_Idx(_Off)
		{	// construct with pointer and offset
		}

	using _Unchecked_type = pointer;

	_NODISCARD _CONSTEXPR17 reference operator*() const
		{	// return designated object
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	// report error
			_DEBUG_ERROR("array iterator not dereferencable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1837 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
		_SCL_SECURE_VALIDATE(_Ptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1840 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		_Analysis_assume_(_Ptr != 0);

		return (_Ptr[_Idx]);
		}

	_NODISCARD _CONSTEXPR17 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_CONSTEXPR17 _Array_const_iterator& operator++()
		{	// preincrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	// report error
			_DEBUG_ERROR("array iterator not incrementable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1861 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
		_SCL_SECURE_VALIDATE(_Ptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1864 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		++_Idx;
		return (*this);
		}

	_CONSTEXPR17 _Array_const_iterator operator++(int)
		{	// postincrement
		_Array_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_CONSTEXPR17 _Array_const_iterator& operator--()
		{	// predecrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Ptr == 0
			|| _Idx <= 0)
			{	// report error
			_DEBUG_ERROR("array iterator not decrementable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1886 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
		_SCL_SECURE_VALIDATE(_Ptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(0 < _Idx);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1889 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		--_Idx;
		return (*this);
		}

	_CONSTEXPR17 _Array_const_iterator operator--(int)
		{	// postdecrement
		_Array_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_CONSTEXPR17 _Array_const_iterator& operator+=(ptrdiff_t _Off)
		{	// increment by integer
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Size < _Idx + _Off)
			{	// report error
			_DEBUG_ERROR("array iterator + offset out of range");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1910 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
		_SCL_SECURE_VALIDATE_RANGE(_Idx + _Off <= _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1912 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		_Idx += _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 _Array_const_iterator operator+(ptrdiff_t _Off) const
		{	// return this + integer
		_Array_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_CONSTEXPR17 _Array_const_iterator& operator-=(ptrdiff_t _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _CONSTEXPR17 _Array_const_iterator operator-(ptrdiff_t _Off) const
		{	// return this - integer
		_Array_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD _CONSTEXPR17 ptrdiff_t operator-(const _Array_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (static_cast<ptrdiff_t>(_Idx - _Right._Idx));
		}

	_NODISCARD _CONSTEXPR17 reference operator[](ptrdiff_t _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD _CONSTEXPR17 bool operator==(const _Array_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	_NODISCARD _CONSTEXPR17 bool operator!=(const _Array_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD _CONSTEXPR17 bool operator<(const _Array_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	_NODISCARD _CONSTEXPR17 bool operator>(const _Array_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD _CONSTEXPR17 bool operator<=(const _Array_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD _CONSTEXPR17 bool operator>=(const _Array_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

 #if _ITERATOR_DEBUG_LEVEL == 2
	_CONSTEXPR17 void _Compat(const _Array_const_iterator& _Right) const
		{	// test for compatible iterator pair
		if (_Ptr != _Right._Ptr)
			{	// report error
			_DEBUG_ERROR("array iterators incompatible");
			}
		}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1987 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	_CONSTEXPR17 void _Compat(const _Array_const_iterator& _Right) const
		{	// test for compatible iterator pair
		_SCL_SECURE_VALIDATE_RANGE(_Ptr == _Right._Ptr);
		}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1992 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

	pointer _Ptr;	// beginning of array
	size_t _Idx;	// offset into array
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 1996 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	};

template<class _Ty,
	size_t _Size>
	_NODISCARD _CONSTEXPR17 _Array_const_iterator<_Ty, _Size> operator+(
		ptrdiff_t _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Ty,
	size_t _Size>
	_CONSTEXPR17 _Array_const_iterator<_Ty, _Size>& _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
		const typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
 #if _ITERATOR_DEBUG_LEVEL == 0
	_Iter._Ptr = _Right;
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 2015 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	_Iter._Idx = _Right - _Iter._Ptr;
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	return (_Iter);
	}

template<class _Ty,
	size_t _Size>
	_CONSTEXPR17 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type _Unchecked(
		const _Array_const_iterator<_Ty, _Size>& _Iter)
	{	// make an unchecked iterator
 #if _ITERATOR_DEBUG_LEVEL == 0
	return (_Iter._Ptr);
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 2028 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	return (_Iter._Ptr + _Iter._Idx);
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2030 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	}

		// CLASS TEMPLATE _Array_iterator
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	// iterator for mutable array
public:
	using _Mybase = _Array_const_iterator<_Ty, _Size>;
	using iterator_category = random_access_iterator_tag;

	using value_type = _Ty;
	using difference_type = ptrdiff_t;
	using pointer = _Ty *;
	using reference = _Ty&;

	_CONSTEXPR17 _Array_iterator()
		{	// construct with null pointer
		}

	_CONSTEXPR17 explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	// construct with pointer and offset
		}
	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
	using _Unchecked_type = pointer;

	_NODISCARD _CONSTEXPR17 reference operator*() const
		{	// return designated object
		return (const_cast<reference>(_Mybase::operator*()));
		}

	_NODISCARD _CONSTEXPR17 pointer operator->() const
		{	// return pointer to class object
		return (const_cast<pointer>(_Mybase::operator->()));
		}

	_CONSTEXPR17 _Array_iterator& operator++()
		{	// preincrement
		++*static_cast<_Mybase *>(this);
		return (*this);
		}

	_CONSTEXPR17 _Array_iterator operator++(int)
		{	// postincrement
		_Array_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_CONSTEXPR17 _Array_iterator& operator--()
		{	// predecrement
		--*static_cast<_Mybase *>(this);
		return (*this);
		}

	_CONSTEXPR17 _Array_iterator operator--(int)
		{	// postdecrement
		_Array_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_CONSTEXPR17 _Array_iterator& operator+=(ptrdiff_t _Off)
		{	// increment by integer
		*static_cast<_Mybase *>(this) += _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 _Array_iterator operator+(ptrdiff_t _Off) const
		{	// return this + integer
		_Array_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_CONSTEXPR17 _Array_iterator& operator-=(ptrdiff_t _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _CONSTEXPR17 _Array_iterator operator-(ptrdiff_t _Off) const
		{	// return this - integer
		_Array_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD _CONSTEXPR17 ptrdiff_t operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*static_cast<const _Mybase *>(this) - _Right);
		}

	_NODISCARD _CONSTEXPR17 reference operator[](ptrdiff_t _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size>
	_NODISCARD _CONSTEXPR17 _Array_iterator<_Ty, _Size> operator+(
		ptrdiff_t _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Ty,
	size_t _Size>
	_CONSTEXPR17 _Array_iterator<_Ty, _Size>& _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
		const typename _Array_iterator<_Ty, _Size>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
 #if _ITERATOR_DEBUG_LEVEL == 0
	_Iter._Ptr = _Right;
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 2145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	_Iter._Idx = _Right - _Iter._Ptr;
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	return (_Iter);
	}

template<class _Ty,
	size_t _Size>
	_CONSTEXPR17 typename _Array_iterator<_Ty, _Size>::_Unchecked_type _Unchecked(
		const _Array_iterator<_Ty, _Size>& _Iter)
	{	// make an unchecked iterator
 #if _ITERATOR_DEBUG_LEVEL == 0
	return (const_cast<_Ty *>(_Iter._Ptr));
 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 2158 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	return (const_cast<_Ty *>(_Iter._Ptr + _Iter._Idx));
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2160 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	}

		// CLASS TEMPLATE move_iterator
template<class _RanIt>
	class move_iterator
	{	// wrap iterator to move rvalues
public:
	using iterator_category = typename iterator_traits<_RanIt>::iterator_category;
	using value_type = typename iterator_traits<_RanIt>::value_type;
	using difference_type = typename iterator_traits<_RanIt>::difference_type;
	using pointer = _RanIt;
	using _Ref0 = typename iterator_traits<_RanIt>::reference;
	using reference = conditional_t<is_reference_v<_Ref0>, remove_reference_t<_Ref0>&&, _Ref0>;
	using iterator_type = _RanIt;

	_CONSTEXPR17 move_iterator()
		: current()
		{	// construct with value-initialized wrapped iterator
		}

	_CONSTEXPR17 explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _RanIt2>
		_CONSTEXPR17 move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	template<class _RanIt2>
		_CONSTEXPR17 move_iterator& operator=(const move_iterator<_RanIt2>& _Right)
		{	// assign with compatible base
		current = _Right.base();
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 _RanIt base() const
		{	// return wrapped iterator
		return (current);
		}

	_NODISCARD _CONSTEXPR17 reference operator*() const
		{	// return designated value
		return (static_cast<reference>(*current));
		}

	_NODISCARD _CONSTEXPR17 pointer operator->() const
		{	// return pointer to class object
		return (current);
		}

	_CONSTEXPR17 move_iterator& operator++()
		{	// preincrement
		++current;
		return (*this);
		}

	_CONSTEXPR17 move_iterator operator++(int)
		{	// postincrement
		move_iterator _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_CONSTEXPR17 move_iterator& operator--()
		{	// predecrement
		--current;
		return (*this);
		}

	_CONSTEXPR17 move_iterator operator--(int)
		{	// postdecrement
		move_iterator _Tmp = *this;
		--current;
		return (_Tmp);
		}

// N.B. functions valid for random-access iterators only beyond this point

	_CONSTEXPR17 move_iterator& operator+=(difference_type _Off)
		{	// increment by integer
		current += _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 move_iterator operator+(difference_type _Off) const
		{	// return this + integer
		return (move_iterator(current + _Off));
		}

	_CONSTEXPR17 move_iterator& operator-=(difference_type _Off)
		{	// decrement by integer
		current -= _Off;
		return (*this);
		}

	_NODISCARD _CONSTEXPR17 move_iterator operator-(difference_type _Off) const
		{	// return this - integer
		return (move_iterator(current - _Off));
		}

	_NODISCARD _CONSTEXPR17 reference operator[](difference_type _Off) const
		{	// subscript
		return (_STD move(current[_Off]));
		}

protected:
	iterator_type current;	// the wrapped iterator
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt>>
		: public _Is_checked_helper<_RanIt>
	{	// mark move_iterator as checked if its wrapped iterator is checked
	};

template<class _RanIt>
	_NODISCARD _CONSTEXPR17 move_iterator<_RanIt> operator+(
		typename move_iterator<_RanIt>::difference_type _Off,
		const move_iterator<_RanIt>& _Right)
	{	// return move_iterator + integer
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 auto operator-(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	// return difference of move_iterators
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator equality
	return (_Left.base() == _Right.base());
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator inequality
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator < move_iterator
	return (_Left.base() < _Right.base());
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator > move_iterator
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator <= move_iterator
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2>
	_NODISCARD _CONSTEXPR17 bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator >= move_iterator
	return (!(_Left < _Right));
	}

		// FUNCTION TEMPLATE make_move_iterator
template<class _RanIt>
	_NODISCARD _CONSTEXPR17 move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	// make move_iterator from iterator
	return (move_iterator<_RanIt>(_Iter));
	}

		// STRUCT TEMPLATE _Char_traits_eq
template<class _Traits>
	struct _Char_traits_eq
	{
	using _Elem = typename _Traits::char_type;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::eq(_Left, _Right));
		}
	};

		// STRUCT TEMPLATE _Char_traits_lt
template<class _Traits>
	struct _Char_traits_lt
	{
	using _Elem = typename _Traits::char_type;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::lt(_Left, _Right));
		}
	};

		// FUNCTION TEMPLATE copy
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// implement copy-like function as memmove
	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
	const size_t _Count = _Last_ch - _First_ch;
	_CSTD memmove(_Dest_ch, _First_ch, _Count);
	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
		// note: _Copy_unchecked is called directly from elsewhere in the STL
	return (_Copy_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	return (_Rechecked(_Dest,
		_Copy_unchecked(_UFirst, _ULast, _UDest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
	_DEPRECATE_UNCHECKED(copy, _Dest);
	return (_Copy_no_deprecate(_First, _Last, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize])
	{	// copy [_First, _Last) to [_Dest, ...)
	return (_Unchecked(
		_Copy_no_deprecate(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2455 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) _NOEXCEPT // Enforces termination
	{	// copy [_First, _Last) to [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD copy(_First, _Last, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _DestTy,
	size_t _DestSize,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy *copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
		_DestTy (&_Dest)[_DestSize]) _NOEXCEPT // Enforces termination
	{	// copy [_First, _Last) to [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	return (_STD copy(_First, _Last, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2483 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#endif /* _HAS_CXX17 */
# 2484 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE copy_n
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), input iterators
	if (0 < _Count)
		{
		*_Dest = *_First;
		while (0 < --_Count)
			*++_Dest = *++_First;
		return (++_Dest);
		}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), forward iterators
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), no special optimization
		// note that we must dispatch on iterator power here to avoid incrementing
		// istream_iterator too many times; see LWG# 2471
	return (_Copy_n_unchecked2(_First, _Count,
		_Dest, _Iter_cat_t<_InIt>()));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), memmove optimization
	if (0 < _Count)
		return (_Copy_memmove(_First, _First + _Count, _Dest));
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), choose optimization
	return (_Copy_n_unchecked1(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
		// Note that we _DEPRECATE_UNCHECKED _Dest because _Count logically goes with _First
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEPRECATE_UNCHECKED(copy_n, _Dest);
	return (_Rechecked(_Dest,
		_Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), array source
		// Note that we _DEPRECATE_UNCHECKED _Dest because _Count logically goes with _First
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEPRECATE_UNCHECKED(copy_n, _Dest);
	_DEBUG_ARRAY_SIZE(_First, _Count);
	return (_Rechecked(_Dest,
		_Copy_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *copy_n(_InIt _First, _Diff _Count_raw, _DestTy (&_Dest)[_DestSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	return (_Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest));
	}

template<class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _DestTy (&_Dest)[_DestSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array source/dest
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEBUG_ARRAY_SIZE(_First, _Count);
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	return (_Copy_n_unchecked(_First, _Count, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2598 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

#if _HAS_CXX17
 template<class _ExPo,
	class _FwdIt1,
	class _Diff,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) _NOEXCEPT // Enforces termination
	{	// copy [_First, _First + _Count) to [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD copy_n(_First, _Count_raw, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 copy_n(_ExPo&&, _SourceTy (&_First)[_SourceSize], _Diff _Count_raw,
		_FwdIt2 _Dest) _NOEXCEPT // Enforces termination
	{	// copy [_First, _First + _Count) to [_Dest, ...), array source
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD copy_n(_First, _Count_raw, _Dest));
	}

template<class _ExPo,
	class _FwdIt1,
	class _Diff,
	class _DestTy,
	size_t _DestSize,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy *copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw,
		_DestTy (&_Dest)[_DestSize]) _NOEXCEPT // Enforces termination
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	return (_STD copy_n(_First, _Count_raw, _Dest));
	}

template<class _ExPo,
	class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _DestTy,
	size_t _DestSize,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy *copy_n(_ExPo&&, _SourceTy (&_First)[_SourceSize], _Diff _Count_raw,
		_DestTy (&_Dest)[_DestSize]) _NOEXCEPT // Enforces termination
	{	// copy [_First, _First + _Count) to [_Dest, ...), array source/dest
		// not parallelized as benchmarks show it isn't worth it
	return (_STD copy_n(_First, _Count_raw, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2656 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#endif /* _HAS_CXX17 */
# 2657 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE copy_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	// implement copy_backward-like function as memmove
	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
	const size_t _Count = _Last_ch - _First_ch;
	return (static_cast<_BidIt2>(
		_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), no special optimization
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), memmove optimization
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// copy [_First, _Last) backwards to [..., _Dest)
	_DEPRECATE_UNCHECKED(copy_backward, _Dest);
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked_n_backward(_Dest, _Idl_distance<_BidIt1>(_UFirst, _ULast));
	return (_Rechecked(_Dest,
		_Copy_backward_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest))));
	}

		// FUNCTION TEMPLATE move
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), no special optimization
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = _STD move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...), choose optimization
		// note: _Move_unchecked is called directly from elsewhere in the STL
	return (_Move_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings
		// note: _Move_no_deprecate is called directly from elsewhere in the STL
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	return (_Rechecked(_Dest,
		_Move_unchecked(_UFirst, _ULast, _UDest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...)
	_DEPRECATE_UNCHECKED(move, _Dest);
	return (_Move_no_deprecate(_First, _Last, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *move(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize])
	{	// move [_First, _Last) to [_Dest, ...)
	return (_Unchecked(
		_Move_no_deprecate(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2766 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) _NOEXCEPT // Enforces termination
	{	// move [_First, _Last) to [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD move(_First, _Last, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _DestTy,
	size_t _DestSize,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy *move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
		_DestTy (&_Dest)[_DestSize]) _NOEXCEPT // Enforces termination
	{	// move [_First, _Last) to [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	return (_STD move(_First, _Last, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2794 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#endif /* _HAS_CXX17 */
# 2795 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE move_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) backwards to [..., _Dest), no special optimization
	while (_First != _Last)
		*--_Dest = _STD move(*--_Last);
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// move [_First, _Last) backwards to [..., _Dest), memmove optimization
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization
		// note: _Move_backward_unchecked is called directly from elsewhere in the STL
	return (_Move_backward_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest)
	_DEPRECATE_UNCHECKED(move_backward, _Dest);
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked_n_backward(_Dest, _Idl_distance<_BidIt1>(_UFirst, _ULast));
	return (_Rechecked(_Dest,
		_Move_backward_unchecked(_UFirst, _ULast, _UDest)));
	}

		// FUNCTION TEMPLATE fill
template<class _Ty>
	struct _Is_character
		: false_type
		{	// by default, not a character type
		};

template<>
	struct _Is_character<char>
		: true_type
		{	// chars are characters
		};

template<>
	struct _Is_character<signed char>
		: true_type
		{	// signed chars are also characters
		};

template<>
	struct _Is_character<unsigned char>
		: true_type
		{	// unsigned chars are also characters
		};

template<class _FwdIt,
	class _Ty>
	struct _Fill_memset_is_safe_helper
	{	// determines if _FwdIt and _Ty are eligible for memset optimization in fill
	using _Value_type = _Iter_value_t<_FwdIt>;

	using _Raw_ty = _Unwrap_enum_t<_Ty>;
	using _Raw_value_type = _Unwrap_enum_t<_Value_type>;

	using type = _Conjunction_t<
		is_pointer<_FwdIt>,
		disjunction<
			conjunction<
				_Is_character<_Raw_ty>,
				_Is_character<_Raw_value_type>>,
			conjunction<
				is_same<bool, _Raw_ty>,
				is_same<bool, _Raw_value_type>>>,
		is_convertible<_Ty, _Value_type>>;
	};

template<class _FwdIt,
	class _Ty> inline
	typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
	_Fill_memset_is_safe(const _FwdIt&, const _Ty&)
	{	// type deduction for _Fill_memset_is_safe_helper
	return {};
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, false_type)
	{	// copy _Val through [_First, _Last), no special optimization
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type)
	{	// copy _Val through [_First, _Last), memset optimization
	_CSTD memset(_First, static_cast<unsigned char>(_Val), _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last), choose optimization
	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

 #if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) _NOEXCEPT // Enforces termination
	{	// copy _Val through [_First, _Last)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt);
	return (_STD fill(_First, _Last, _Val));
	}
 #endif /* _HAS_CXX17 */
# 2935 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE fill_n
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, false_type)
	{	// copy _Val _Count times through [_Dest, ...), no special optimization
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, true_type)
	{	// copy _Val _Count times through [_Dest, ...), memset optimization
	if (0 < _Count)
		{
		_CSTD memset(_Dest, static_cast<unsigned char>(_Val), _Count);
		return (_Dest + _Count);
		}

	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...), choose optimization
		// note: _Fill_n_unchecked is called directly from elsewhere in the STL
	return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count_raw, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...)
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	return (_Rechecked(_Dest,
		_Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
	}

 #if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Diff,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) _NOEXCEPT // Enforces termination
	{	// copy _Val _Count times through [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt);
	return (_STD fill_n(_Dest, _Count_raw, _Val));
	}
 #endif /* _HAS_CXX17 */
# 2993 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE equal WITH PRED
template<class _Elem1,
	class _Elem2>
	struct _Value_equality_is_bitwise_equality
		: bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
	{	// Tests whether the usual arithmetic conversions will preserve the bit-pattern
		// when promoting to int
		// e.g. short == unsigned short -> false
		//      int == unsigned int -> true
	};

template<class _Elem1,
	class _Elem2,
	class _Pr>
	struct _Equal_memcmp_is_safe_helper
		: false_type
	{	// determines whether it is safe to call memcmp to compare things;
		// defaults to false
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
		: _Conjunction_t<
			_Is_same_size<_Elem1, _Elem2>,
			_Is_nonbool_integral<_Elem1>,
			_Is_nonbool_integral<_Elem2>,
			negation<is_volatile<_Elem1>>,
			negation<is_volatile<_Elem2>>,
			// note that order matters here, as being integral is a precondition
			// of _Value_equality_is_bitwise_equality
			_Value_equality_is_bitwise_equality<_Elem1, _Elem2>
		>
	{	// allow memcmping same-size integral non-bool non-volatile bitwise types using equal_to<>
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1 *, _Elem2 *, equal_to<>>
		: is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
	{	// allow memcmping pointers-to-cv-T with equal_to<>
	};

#if _HAS_STD_BYTE
template<>
	struct _Equal_memcmp_is_safe_helper<byte, byte, equal_to<>>
		: true_type
	{	// allow memcmping std::byte
	};
#endif // _HAS_STD_BYTE
# 3044 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	// builtin char_traits::eq behaves like equal_to<>
	};

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	// treat equal_to with exact T as equal_to<>
		// this is safe because we only activate the optimization for builtin _Elem (and std::byte)
	};

template<class _Iter1,
	class _Iter2,
	class _Pr> inline
	false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
	{	// return equal optimization category for arbitrary iterators
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _Pr> inline
	typename _Equal_memcmp_is_safe_helper<
		remove_const_t<_Obj1>,
		remove_const_t<_Obj2>,
		_Pr>::type
		_Equal_memcmp_is_safe(_Obj1 * const&, _Obj2 * const&, const _Pr&)
	{	// return equal optimization category for pointers
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(_InIt1 _First1, const _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, false_type)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred, no special optimization
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{
			return (false);
			}
		}

	return (true);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _Pr, true_type)
	{	// compare [_First1, _Last1) to [_First2, ...), memcmp optimization
	const auto _First1_ch = reinterpret_cast<const char *>(_First1);
	const auto _First2_ch = reinterpret_cast<const char *>(_First2);
	const size_t _Count = reinterpret_cast<const char *>(_Last1) - _First1_ch;
	return (_CSTD memcmp(_First1_ch, _First2_ch, _Count) == 0);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred, choose optimization
	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,
		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	_NODISCARD inline bool equal(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
	_DEPRECATE_UNCHECKED(equal, _First2);
	_DEBUG_RANGE(_First1, _Last1);
	const auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _UFirst2 = _Unchecked_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
	return (_Equal_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	enable_if_t<!is_same_v<_RightTy *, _Pr>, int> = 0>
	_NODISCARD inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize], _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
	return (_STD equal(_First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, _Pr _Pred) _NOEXCEPT;

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	enable_if_t<is_execution_policy_v<decay_t<_ExPo>> && !is_same_v<_RightTy *, _Pr>, int> = 0>
	_NODISCARD inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _Pr _Pred) _NOEXCEPT;
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#endif /* _HAS_CXX17 */
# 3164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE equal
template<class _InIt1,
	class _InIt2>
	_NODISCARD inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)
	{	// compare [_First1, _Last1) to [_First2, ...)
	return (_STD equal(_First1, _Last1, _First2, equal_to<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _RightTy,
	size_t _RightSize>
	_NODISCARD inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize])
	{	// compare [_First1, _Last1) to [_First2, ...)
	return (_STD equal(_First1, _Last1, _First2, equal_to<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2)
		_NOEXCEPT // Enforces termination
	{	// compare [_First1, _Last1) to [_First2, ...)
	return (_STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize]) _NOEXCEPT // Enforces termination
	{	// compare [_First1, _Last1) to [_First2, ...)
	return (_STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#endif /* _HAS_CXX17 */
# 3207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, const _InIt1 _Last1,
		_InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
		input_iterator_tag, input_iterator_tag)
	{	// compare [_First1, _Last1) to [_First2, _Last2)
		// using _Pred, arbitrary iterators
	for (;;)
		{
		if (_First1 == _Last1)
			{
			return (_First2 == _Last2);
			}

		if (_First2 == _Last2)
			{
			return (false);
			}

		if (!_Pred(*_First1, *_First2))
			{
			return (false);
			}

		++_First1;
		++_First2;
		}
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// compare [_First1, _Last1) to [_First2, _Last2)
		// using _Pred, random-access iterators
	if (_Last1 - _First1 != _Last2 - _First2)
		{
		return (false);
		}

	return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	_NODISCARD inline bool equal(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, _Last2) using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pass_fn(_Pred),
			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 3276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _InIt1,
	class _InIt2>
	_NODISCARD inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)
	{	// compare [_First1, _Last1) to [_First2, _Last2)
	return (_STD equal(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2) _NOEXCEPT // Enforces termination
	{	// compare [_First1, _Last1) to [_First2, _Last2)
	return (_STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 3295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE lexicographical_compare WITH PRED
template<class _Elem1,
	class _Elem2,
	class _FTy>
	struct _Lex_compare_check_element_types_helper
		: _Conjunction_t<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			_Is_character<_FTy>,
			is_unsigned<_FTy>
		>
	{	// checks the lex_compare unwrapped element types for memcmp safety for builtin functors (e.g. less<unsigned char>)
	};

template<class _Elem1,
	class _Elem2>
	struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
		: _Conjunction_t<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			is_unsigned<_Elem1>,
			is_unsigned<_Elem2>
		>
	{	// checks the lex_compare unwrapped element types for memcmp safety for transparent functors (e.g. less<>)
	};

#if _HAS_STD_BYTE
template<>
	struct _Lex_compare_check_element_types_helper<byte, byte, byte>
		: true_type
	{	// std::byte with builtin functors (e.g. less<byte>) is memcmp safe
	};

template<>
	struct _Lex_compare_check_element_types_helper<byte, byte, void>
		: true_type
	{	// std::byte with transparent functors (e.g. less<>) is memcmp safe
	};
#endif // _HAS_STD_BYTE
# 3335 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _Memcmp_pr>
	struct _Lex_compare_optimize
	{	// optimization tag for lexicographical_compare
	};

template<class _Memcmp_pr,
	class _Obj1,
	class _Obj2,
	class _FTy>
	using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
		_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
		_Memcmp_pr, void>>;	// checks the lex_compare element types for memcmp safety

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	_Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
	{	// return lex_compare optimization category for arbitrary iterators
		// note that overload selecting greater<_FTy> is in <xfunctional>
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _FTy> inline
	_Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
		_Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const less<_FTy>&)
	{	// return lex_compare optimization category for pointer iterators and less<_FTy>
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>)
	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred, no special optimization
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{	// something to compare, do it
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
		}

	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr,
	class _Memcmp_pr> inline
	bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize<_Memcmp_pr>)
	{	// order [_First1, _Last1) vs. [_First2, _Last2) memcmp optimization
	const size_t _Num1 = _Last1 - _First1;
	const size_t _Num2 = _Last2 - _First2;
	const int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	_NODISCARD inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	const auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	return (_Lex_compare_unchecked(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred),
		_Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred)));
	}

		// FUNCTION TEMPLATE lexicographical_compare
template<class _InIt1,
	class _InIt2>
	_NODISCARD inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// order [_First1, _Last1) vs. [_First2, _Last2)
	return (_STD lexicographical_compare(_First1, _Last1,
		_First2, _Last2, less<>()));
	}

		// FUNCTION TEMPLATE find
template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
	{	// signed _Elem, signed _Ty
	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
	return (_Val <= SCHAR_MAX);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
	{	// unsigned _Elem, signed _Ty
	return (0 <= _Val && _Val <= UCHAR_MAX);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
	{	// unsigned _Elem, unsigned _Ty
	return (_Val <= UCHAR_MAX);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	// check whether _Val is within the limits of _Elem
	using _Elem = remove_pointer_t<_InIt>;
	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
		bool_constant<-1 == static_cast<_Ty>(-1)>()));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	// bools are always within the limits of _Elem
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, true_type)
	{	// find first byte matching integral _Val
	if (!_Within_limits(_First, _Val))
		return (_Last);
	_First = static_cast<_InIt>(_CSTD memchr(
		_First, static_cast<unsigned char>(_Val), _Last - _First));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type)
	{	// find first matching _Val
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val; choose optimization
	// activate optimization for pointers to (const) bytes and integral values
	using _Memchr_opt = bool_constant<is_integral_v<_Ty> && _Is_any_of_v<_InIt,
		char *, signed char *, unsigned char *, const char *, const signed char *, const unsigned char *>>;

	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));
	}

template<class _InIt,
	class _Ty>
	_NODISCARD inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt find(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 3517 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE _Find_pr WITH PRED
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// find first matching _Val, using _Pred
	for (; _First != _Last; ++_First)
		{
		if (_Pred(*_First, _Val))
			{
			break;
			}
		}

	return (_First);
	}

		// FUNCTION TEMPLATE count
template<class _InIt,
	class _Ty>
	_NODISCARD inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val)
	{	// count elements that match _Val
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (*_UFirst == _Val)
			{
			++_Count;
			}
		}

	return (_Count);
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _Iter_diff_t<_FwdIt> count(_ExPo&& _Exec,
		const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 3564 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE _Count_pr WITH PRED
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_Iter_diff_t<_InIt> _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// count elements that match _Val, using _Pred
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _First != _Last; ++_First)
		{
		if (_Pred(*_First, _Val))
			{
			++_Count;
			}
		}

	return (_Count);
	}

		// FUNCTION TEMPLATE _Trim_matching_suffixes WITH PRED
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
		forward_iterator_tag, forward_iterator_tag)
	{	// trim matching suffixes, forward iterators (do nothing)
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	// trim matching suffixes, bidirectional iterators
	// assumptions: same lengths, non-empty, !_Pred(*_First1, *_First2)
	while (_Pred(*--_Last1, *--_Last2))
		;	// find last inequality
	++_Last1;
	++_Last2;
	}

		// FUNCTION TEMPLATE _Check_match_counts WITH PRED
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2), using _Pred, same lengths
	_Trim_matching_suffixes(_Last1, _Last2, _Pred,
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
	for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
		{
		if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
			{	// new value, compare match counts
			_Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
			if (_Count2 == 0)
				{
				return (false);	// second range lacks value, fail
				}

			_FwdIt1 _Skip1 = _Next_iter(_Next1);
			_Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
			if (_Count2 != _Count1)
				{
				return (false);	// match counts differ, fail
				}
			}
		}

	return (true);
	}

		// FUNCTION TEMPLATE is_permutation WITH PRED
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{	// found first inequality, check match counts in suffix
				// narrowing _Iter_diff_t<_FwdIt1> to _Iter_diff_t<_FwdIt2> is OK because if
				// the 2nd range is shorter than the 1st, the user already triggered UB
			auto _Last2 = _STD next(_First2, static_cast<_Iter_diff_t<_FwdIt2>>(_STD distance(_First1, _Last1)));
			return (_Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred));
			}
		}

	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_NODISCARD inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
	_DEPRECATE_UNCHECKED(is_permutation, _First2);
	_DEBUG_RANGE(_First1, _Last1);
	const auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _UFirst2 = _Unchecked_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
	return (_Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	class = enable_if_t<!is_same_v<_RightTy *, _Pr>>>
	_NODISCARD inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
	return (_STD is_permutation(_First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3684 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE is_permutation
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	// test if [_First1, _Last1) == permuted [_First2, ...)
	return (_STD is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}


 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _FwdIt1,
	class _RightTy,
	size_t _RightSize>
	_NODISCARD inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize])
	{	// test if [_First1, _Last1) == permuted [_First2, ...)
	return (_STD is_permutation(_First1, _Last1, _First2, equal_to<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE is_permutation WITH TWO RANGES, PRED
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2),
		// using _Pred, arbitrary iterators
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{	// found first inequality, check match counts in suffix
			if (_STD distance(_First1, _Last1) == _STD distance(_First2, _Last2))
				{
				return (_Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred));
				}
			else
				{
				return (false);	// lengths differ, fail
				}
			}
		}

	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2),
		// using _Pred, random-access iterators
	if (_Last1 - _First1 != _Last2 - _First2)
		{
		return (false);
		}

	return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_NODISCARD inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2),
		// using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Is_permutation_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pass_fn(_Pred),
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

		// FUNCTION TEMPLATE is_permutation WITH TWO RANGES
template<class _FwdIt1,
	class _FwdIt2>
	_NODISCARD inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2)
	return (_STD is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

		// FUNCTION TEMPLATE reverse
template<class _BidIt> inline
	void _Reverse_unchecked1(_BidIt _First, _BidIt _Last, integral_constant<size_t, 0>)
	{	// reverse elements in [_First, _Last), general bidirectional iterators
	for (; _First != _Last && _First != --_Last; ++_First)
		{
		_STD iter_swap(_First, _Last);
		}
	}

#if (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID)
template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 1>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 1
	__std_reverse_trivially_swappable_1(_First, _Last);
	}

template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 2>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 2
	__std_reverse_trivially_swappable_2(_First, _Last);
	}

template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 4>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 4
	__std_reverse_trivially_swappable_4(_First, _Last);
	}

template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 8>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 8
	__std_reverse_trivially_swappable_8(_First, _Last);
	}
#endif /* (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID) */
# 3807 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

template<class _BidIt> inline
	void _Reverse_unchecked(const _BidIt _First, const _BidIt _Last)
	{	// reverse elements in [_First, _Last), choose optimization
#if (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID)
	using _Val = _Iter_value_t<_BidIt>;
	constexpr size_t _Opt = is_pointer_v<_BidIt>
		&& _Is_trivially_swappable_v<_Val>
		&& !is_volatile_v<_Val>
		&& (sizeof(_Val) == 1
			|| sizeof(_Val) == 2
			|| sizeof(_Val) == 4
			|| sizeof(_Val) == 8) ? sizeof(_Val) : 0;
#else /* ^^^ vectorize ^^^ // vvv no vectorize vvv */
# 3821 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	constexpr size_t _Opt = 0;
#endif /* (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID) */
# 3823 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
	_Reverse_unchecked1(_First, _Last, integral_constant<size_t, _Opt>{});
	}

template<class _BidIt> inline
	void reverse(const _BidIt _First, const _BidIt _Last)
	{	// reverse elements in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));
	}

 #if _HAS_CXX17
template<class _ExPo,
	class _BidIt,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void reverse(_ExPo&&, _BidIt _First, _BidIt _Last) _NOEXCEPT // Enforces termination
	{	// reverse elements in [_First, _Last)
		// not parallelized as benchmarks show it isn't worth it
	return (_STD reverse(_First, _Last));
	}
 #endif /* _HAS_CXX17 */
# 3843 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE rotate
template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions, forward iterators
	for (_FwdIt _Next = _Mid, _Res = _Last; ; )
		{	// swap [_First, ...) into place
		_STD iter_swap(_First, _Next);
		if (++_First == _Mid)
			{	// quit if done, else define next interval
			if (++_Next == _Last)
				return (_Res == _Last ? _Mid : _Res);
			else
				_Mid = _Next;	// mark end of next interval
			}
		else if (++_Next == _Last)
			{	// wrap to last end
			if (_Res == _Last)
				_Res = _First;
			_Next = _Mid;
			}
		}
	}

template<class _BidIt> inline
	pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
		_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
	{	// reverse until either _First or _Last hits _Sentinel
	while (_First != _Sentinel && _Last != _Sentinel)
		{
		_STD iter_swap(_First, --_Last);
		++_First;
		}

	return (_STD make_pair(_First, _Last));
	}

template<class _BidIt> inline
	_BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions, bidirectional iterators
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
	_Reverse_unchecked(_Tmp.first, _Tmp.second);
	return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
	}

template<class _RanIt> inline
	_RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions, random-access iterators
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	_Reverse_unchecked(_First, _Last);
	return (_First + (_Last - _Mid));
	}

template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions
	if (_First == _Mid)
		return (_Last);
	if (_Mid == _Last)
		return (_First);
	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	// exchange the ranges [_First, _Mid) and [_Mid, _Last)
		// that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
		// returns the iterator pointing at *_First's new home
	_DEBUG_RANGE(_First, _Mid);
	_DEBUG_RANGE(_Mid, _Last);
	return (_Rechecked(_First,
		_Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Last))));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt rotate(_ExPo&&, _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) _NOEXCEPT // Enforces termination
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions
		// not parallelized as benchmarks show it isn't worth it
	return (_STD rotate(_First, _Mid, _Last));
	}
#endif /* _HAS_CXX17 */
# 3934 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		// FUNCTION TEMPLATE lower_bound WITH PRED
template<class _FwdIt,
	class _Ty,
	class _Pr>
	_NODISCARD inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// find first element not before _Val, using _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	_Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Unchecked(_Last));

	while (0 < _Count)
		{	// divide and conquer, find half that contains answer
		_Iter_diff_t<_FwdIt> _Count2 = _Count >> 1; // TRANSITION, VSO#433486
		const auto _UMid = _STD next(_UFirst, _Count2);
		if (_Pred(*_UMid, _Val))
			{	// try top half
			_UFirst = _Next_iter(_UMid);
			_Count -= _Count2 + 1;
			}
		else
			{
			_Count = _Count2;
			}
		}

	return (_Rechecked(_First, _UFirst));
	}

	// CLASS TEMPLATE _Rng_from_urng
template<class _Diff,
	class _Urng>
	class _Rng_from_urng
	{	// wrap a URNG as an RNG
public:
	using _Ty0 = make_unsigned_t<_Diff>;
	using _Ty1 = typename _Urng::result_type;

	using _Udiff = conditional_t<sizeof (_Ty1) < sizeof (_Ty0), _Ty0, _Ty1>;

	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(CHAR_BIT * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	// construct from URNG
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	// adapt _Urng closed range to [0, _Index)
		for (;;)
			{	// try a sample random value
			_Udiff _Ret = 0;	// random bits
			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

			while (_Mask < _Udiff(_Index - 1))
				{	// need more random bits
				_Ret <<= _Bits - 1;	// avoid full shift
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	// avoid full shift
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	// return a random value
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);
			_Num += _Bits)
			{	// don't mask away any bits
			_Ret <<= _Bits - 1;	// avoid full shift
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
	_Udiff _Get_bits()
		{	// return a random value within [0, _Bmask]
		for (;;)
			{	// repeat until random value is in range
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	// reference to URNG
	size_t _Bits;	// number of random bits generated by _Get_bits()
	_Udiff _Bmask;	// 2^_Bits - 1
	};

		// CLASS TEMPLATE _Yarn
template<class _Elem>
	class _CRTIMP2_PURE_IMPORT _Yarn
	{	// wrap a NTBS
public:
	__CLR_OR_THIS_CALL _Yarn()
		: _Myptr(0), _Nul(0)
		{	// default construct
		}

	__CLR_OR_THIS_CALL _Yarn(const _Yarn& _Right)
		: _Myptr(0), _Nul(0)
		{	// construct from _Yarn
		*this = _Right;
		}

	__CLR_OR_THIS_CALL _Yarn(const _Elem * _Right)
		: _Myptr(0), _Nul(0)
		{	// construct from NTBS
		*this = _Right;
		}

	_Yarn& __CLR_OR_THIS_CALL operator=(const _Yarn& _Right)
		{	// assign from _Yarn
		return (*this = _Right._Myptr);
		}

	_Yarn& __CLR_OR_THIS_CALL operator=(const _Elem * _Right)
		{	// assign from NTBS
		if (_Myptr != _Right)
			{	// new value, discard old and copy new
			_Tidy();

			if (_Right != 0)
				{	// new is not empty, copy it
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 #ifdef _DEBUG
				_Myptr = (_Elem *)_malloc_dbg(_Count, _CRT_BLOCK,
					__FILE__, __LINE__);

 #else /* _DEBUG */
# 4086 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
				_Myptr = (_Elem *)_CSTD malloc(_Count);
 #endif /* _DEBUG */
# 4088 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

				if (_Myptr != 0)
					_CSTD memcpy(_Myptr, _Right, _Count);
				}
			}

		return (*this);
		}

	__CLR_OR_THIS_CALL ~_Yarn() _NOEXCEPT
		{	// destroy the object
		_Tidy();
		}

	bool __CLR_OR_THIS_CALL empty() const
		{	// test if empty string
		return (_Myptr == 0);
		}

	_Ret_z_ const _Elem *__CLR_OR_THIS_CALL c_str() const
		{	// return NTBS
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool __CLR_OR_THIS_CALL _Empty() const
		{	// test if empty string
		return (_Myptr == 0);
		}

	_Ret_z_ const _Elem *__CLR_OR_THIS_CALL _C_str() const
		{	// return NTBS
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void __CLR_OR_THIS_CALL _Tidy()
		{	// discard any string
		if (_Myptr != 0)

 #ifdef _DEBUG
			_free_dbg(_Myptr, _CRT_BLOCK);

 #else /* _DEBUG */
# 4131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
			_CSTD free(_Myptr);
 #endif /* _DEBUG */
# 4133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

		_Myptr = 0;
		}

	_Elem * _Myptr;	// pointer to allocated string
	_Elem _Nul;		// nul terminator for unallocated string
	};


		// CLASS TEMPLATE back_insert_iterator
template<class _Container>
	class back_insert_iterator
	{	// wrap pushes to back of container as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using container_type = _Container;

	explicit back_insert_iterator(_Container& _Cont)
		: container(_STD addressof(_Cont))
		{	// construct with container
		}

	back_insert_iterator& operator=(const typename _Container::value_type& _Val)
		{	// push value into container
		container->push_back(_Val);
		return (*this);
		}

	back_insert_iterator& operator=(typename _Container::value_type&& _Val)
		{	// push value into container
		container->push_back(_STD move(_Val));
		return (*this);
		}

	_NODISCARD back_insert_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	back_insert_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	back_insert_iterator operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

protected:
	_Container *container;	// pointer to container
	};

template<class _Container>
	struct _Is_checked_helper<back_insert_iterator<_Container>>
		: public true_type
	{	// mark back_insert_iterator as checked
	};


		// FUNCTION TEMPLATE back_inserter
template<class _Container>
	_NODISCARD inline back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{	// return a back_insert_iterator
	return (back_insert_iterator<_Container>(_Cont));
	}


	// STRUCT TEMPLATE _Has_allocator_type
template<class _Ty,
	class _Alloc,
	class = void>
	struct _Has_allocator_type
		: false_type
	{	// tests for suitable _Ty::allocator_type
	};

template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
		: is_convertible<_Alloc, typename _Ty::allocator_type>::type
	{	// tests for suitable _Ty::allocator_type
	};

		// STRUCT allocator_arg_t
struct allocator_arg_t
	{	// tag type for added allocator argument
	};

_INLINE_VAR constexpr allocator_arg_t allocator_arg{};

[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xbad_alloc();
[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char *);
[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char *);
[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char *);
[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char *);
[[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char *);

		// STRUCT TEMPLATE uses_allocator
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	// determine whether _Ty has an allocator_type member type
	};

template<class _Ty,
	class _Alloc>
	_INLINE_VAR constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

		// STRUCT TEMPLATE iterator
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct _CXX17_DEPRECATE_ITERATOR_BASE_CLASS iterator
	{	// base type for iterator classes
	using iterator_category = _Category;
	using value_type = _Ty;
	using difference_type = _Diff;
	using pointer = _Pointer;
	using reference = _Reference;
	};
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 4267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3
#endif /* _XUTILITY_ */
# 4268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xutility" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// FUNCTION TEMPLATE _Get_size_of_n
template<size_t _Ty_size> inline
	size_t _Get_size_of_n(const size_t _Count)
	{	// gets the size of _Count copies of a type sized _Ty_size
	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
	size_t _Result = _Count * _Ty_size;
	if (_Max_possible < _Count)
		{	// multiply overflow, try allocating all of memory and assume the
			// allocation function will throw bad_alloc
		_Result = static_cast<size_t>(-1);
		}

	return (_Result);
	}

template<> inline
	size_t _Get_size_of_n<1>(const size_t _Count)
	{	// gets the size of _Count copies of a type with size 1
	return (_Count);
	}

		// VARIABLE TEMPLATE _New_alignof
template<class _Ty>
	_INLINE_VAR constexpr size_t _New_alignof = _Max_value(alignof(_Ty),
		static_cast<size_t>(__STDCPP_DEFAULT_NEW_ALIGNMENT__) // TRANSITION, VSO#522105
		);

		// STRUCT _Default_allocate_traits
struct _Default_allocate_traits
	{
	_DECLSPEC_ALLOCATOR static void * _Allocate(const size_t _Bytes)
		{
		return (::operator new(_Bytes));
		}

 #if _HAS_ALIGNED_NEW
	_DECLSPEC_ALLOCATOR static void * _Allocate_aligned(const size_t _Bytes, const size_t _Align)
		{
		return (::operator new(_Bytes, align_val_t{_Align}));
		}
 #endif /* _HAS_ALIGNED_NEW */
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
	};

constexpr bool _Is_pow_2(const size_t _Value) _NOEXCEPT
	{
	return (_Value != 0 && (_Value & (_Value - 1)) == 0);
	}

 #if defined(_M_IX86) || defined(_M_X64)
constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;

static_assert(2 * sizeof(void *) <= _Big_allocation_alignment,
	"Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment),
	"Big allocation alignment must be a power of two");

  #ifdef _DEBUG
constexpr size_t _Non_user_size = 2 * sizeof(void *) + _Big_allocation_alignment - 1;
  #else /* _DEBUG */
# 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
constexpr size_t _Non_user_size = sizeof(void *) + _Big_allocation_alignment - 1;
  #endif /* _DEBUG */
# 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

  #ifdef _DEBUG
   #ifdef _WIN64
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;
   #else /* ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv */
# 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAUL;
   #endif /* _WIN64 */
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
  #endif /* _DEBUG */
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

		// FUNCTION _Allocate_manually_vector_aligned
template<class _Traits> inline
	_DECLSPEC_ALLOCATOR void * _Allocate_manually_vector_aligned(const size_t _Bytes)
	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment
	size_t _Block_size = _Non_user_size + _Bytes;
	if (_Block_size <= _Bytes)
		{	// add overflow, try allocating all of memory and assume the
			// allocation function will throw bad_alloc
		_Block_size = static_cast<size_t>(-1);
		}

	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]
	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
		& ~(_Big_allocation_alignment - 1));
	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  #ifdef _DEBUG
	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
  #endif /* _DEBUG */
# 110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
	return (_Ptr);
	}

		// FUNCTION TEMPLATE _Adjust_manually_vector_aligned
inline void _Adjust_manually_vector_aligned(void *& _Ptr, size_t& _Bytes)
	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
	_Bytes += _Non_user_size;

	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
	const uintptr_t _Ptr_container = _Ptr_user[-1];

  #ifdef _DEBUG
	// If the following asserts, it likely means that we are performing
	// an aligned delete on memory coming from an unaligned allocation.
	if (_Ptr_user[-2] != _Big_allocation_sentinel)
		{
		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
		}
  #endif /* _DEBUG */
# 129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
	// in range [_Min_back_shift, _Non_user_size]
  #ifdef _DEBUG
	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
  #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
	constexpr uintptr_t _Min_back_shift = sizeof(void *);
  #endif /* _DEBUG */
# 137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)
		{
		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
		}

	_Ptr = reinterpret_cast<void *>(_Ptr_container);
	}
 #endif /* defined(_M_IX86) || defined(_M_X64) */
# 146 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

		// FUNCTION TEMPLATES _Allocate and _Deallocate
 #if _HAS_ALIGNED_NEW
template<size_t _Align,
	class _Traits = _Default_allocate_traits,
	enable_if_t<(_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__), int> = 0> inline
	_DECLSPEC_ALLOCATOR void *_Allocate(const size_t _Bytes)
	{	// allocate _Bytes when _HAS_ALIGNED_NEW && _Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__
	if (_Bytes == 0)
		{
		return (nullptr);
		}

	size_t _Passed_align = _Align;
  #if defined(_M_IX86) || defined(_M_X64)
	if (_Bytes >= _Big_allocation_threshold)
		{	// boost the alignment of big allocations to help autovectorization
		_Passed_align = _Max_value(_Align, _Big_allocation_alignment);
		}
  #endif /* defined(_M_IX86) || defined(_M_X64) */
# 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

	return (_Traits::_Allocate_aligned(_Bytes, _Passed_align));
	}

template<size_t _Align,
	enable_if_t<(_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__), int> = 0> inline
	void _Deallocate(void * _Ptr, const size_t _Bytes)
	{	// deallocate storage allocated by _Allocate when _HAS_ALIGNED_NEW && _Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__
	size_t _Passed_align = _Align;
  #if defined(_M_IX86) || defined(_M_X64)
	if (_Bytes >= _Big_allocation_threshold)
		{	// boost the alignment of big allocations to help autovectorization
		_Passed_align = _Max_value(_Align, _Big_allocation_alignment);
		}
  #endif /* defined(_M_IX86) || defined(_M_X64) */
# 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

	::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
	}
 #endif /* _HAS_ALIGNED_NEW */
# 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

template<size_t _Align,
	class _Traits = _Default_allocate_traits,
	enable_if_t<(!_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__), int> = 0> inline
	_DECLSPEC_ALLOCATOR void *_Allocate(const size_t _Bytes)
	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
 #if defined(_M_IX86) || defined(_M_X64)
	if (_Bytes >= _Big_allocation_threshold)
		{	// boost the alignment of big allocations to help autovectorization
		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
		}
 #endif /* defined(_M_IX86) || defined(_M_X64) */
# 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

	if (_Bytes != 0)
		{
		return (_Traits::_Allocate(_Bytes));
		}

	return (nullptr);
	}

template<size_t _Align,
	enable_if_t<(!_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__), int> = 0> inline
	void _Deallocate(void * _Ptr, size_t _Bytes)
	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
 #if defined(_M_IX86) || defined(_M_X64)
	if (_Bytes >= _Big_allocation_threshold)
		{	// boost the alignment of big allocations to help autovectorization
		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
		}
 #endif /* defined(_M_IX86) || defined(_M_X64) */
# 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

	::operator delete(_Ptr, _Bytes);
	}

		// FUNCTION TEMPLATE _Construct_in_place
template<class _Ty,
	class... _Types> inline
	void _Construct_in_place(_Ty& _Obj, _Types&&... _Args)
		_NOEXCEPT_COND(is_nothrow_constructible_v<_Ty, _Types...>)
	{	// invoke True Placement New to initialize the referenced object with _Args...
	::new (const_cast<void *>(static_cast<const volatile void *>(_STD addressof(_Obj))))
		_Ty(_STD forward<_Types>(_Args)...);
	}

		// FUNCTION TEMPLATE _Global_new
template<class _Ty,
	class... _Types> inline
	_Ty * _Global_new(_Types&&... _Args)
	{	// acts as "new" while disallowing user overload selection
	void * const _Result = _Allocate<_New_alignof<_Ty>>(sizeof(_Ty));
	_TRY_BEGIN
	::new (_Result) _Ty(_STD forward<_Types>(_Args)...);
	_CATCH_ALL
	_Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
	_RERAISE;
	_CATCH_END
	return (static_cast<_Ty *>(_Result));
	}

		// STRUCT TEMPLATE _Get_first_parameter
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...>>
	{	// given _Ty<_First, _Rest...>, extract _First
	using type = _First;
	};

		// STRUCT TEMPLATE _Replace_first_parameter
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>>
	{	// given _Ty<_First, _Rest...>, replace _First
	using type = _Ty<_Newfirst, _Rest...>;
	};

		// STRUCT TEMPLATE _Get_element_type
template<class _Ty,
	class = void>
	struct _Get_element_type
	{	// provide fallback
	using type = typename _Get_first_parameter<_Ty>::type;
	};

template<class _Ty>
	struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>>
	{	// get _Ty::element_type
	using type = typename _Ty::element_type;
	};

		// STRUCT TEMPLATE _Get_ptr_difference_type
template<class _Ty,
	class = void>
	struct _Get_ptr_difference_type
	{	// provide fallback
	using type = ptrdiff_t;
	};

template<class _Ty>
	struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>>
	{	// get _Ty::difference_type
	using type = typename _Ty::difference_type;
	};

		// STRUCT TEMPLATE _Get_rebind_alias
template<class _Ty,
	class _Other,
	class = void>
	struct _Get_rebind_alias
	{	// provide fallback
	using type = typename _Replace_first_parameter<_Other, _Ty>::type;
	};

template<class _Ty,
	class _Other>
	struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>>
	{	// get _Ty::rebind<_Other>
	using type = typename _Ty::template rebind<_Other>;
	};

		// STRUCT TEMPLATE pointer_traits
template<class _Ty>
	struct pointer_traits
	{	// defines traits for arbitrary pointers
	using element_type = typename _Get_element_type<_Ty>::type;
	using pointer = _Ty;
	using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

	template<class _Other>
		using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

	using _Reftype = conditional_t<is_void_v<element_type>,
		char&,
		add_lvalue_reference_t<element_type>>;

	_NODISCARD static pointer pointer_to(_Reftype _Val)
		{	// convert raw reference to pointer
		return (_Ty::pointer_to(_Val));
		}
	};

template<class _Ty>
	struct pointer_traits<_Ty *>
	{	// defines traits for raw pointers
	using element_type = _Ty;
	using pointer = _Ty *;
	using difference_type = ptrdiff_t;

	template<class _Other>
		using rebind = _Other *;

	using _Reftype = conditional_t<is_void_v<_Ty>,
		char&,
		add_lvalue_reference_t<_Ty>>;

	_NODISCARD static pointer pointer_to(_Reftype _Val)
		{	// convert raw reference to pointer
		return (_STD addressof(_Val));
		}
	};

		// ALIAS TEMPLATE _Rebind_pointer_t
template<class _Ptr,
	class _Ty>
	using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

		// FUNCTION TEMPLATE _Refancy
template<class _Pointer,
	enable_if_t<!is_pointer_v<_Pointer>, int> = 0> inline
	_Pointer _Refancy(typename pointer_traits<_Pointer>::element_type * _Ptr)
	{	// transform a plain pointer into a fancy pointer
	return (pointer_traits<_Pointer>::pointer_to(*_Ptr));
	}

template<class _Pointer,
	enable_if_t<is_pointer_v<_Pointer>, int> = 0> inline
	_Pointer _Refancy(_Pointer _Ptr)
	{	// do nothing for plain pointers
	return (_Ptr);
	}

		// FUNCTION TEMPLATE _Destroy_in_place
template<class _Ty> inline
	void _Destroy_in_place(_Ty& _Obj) _NOEXCEPT
	{	// destroy the referenced object
	_Obj.~_Ty();
	}

		// FUNCTION TEMPLATE _Const_cast
template<class _Ptrty> inline
	auto _Const_cast(_Ptrty _Ptr)
	{	// remove constness from a fancy pointer
	using _Elem = typename pointer_traits<_Ptrty>::element_type;
	using _Modifiable = remove_const_t<_Elem>;
	using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

	return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr)));
	}

template<class _Ty> inline
	auto _Const_cast(_Ty * _Ptr)
	{	// remove constness from a plain pointer
	return (const_cast<remove_const_t<_Ty> *>(_Ptr));
	}

		// STRUCT TEMPLATE _Get_pointer_type
template<class _Ty,
	class = void>
	struct _Get_pointer_type
	{	// provide fallback
	using type = typename _Ty::value_type *;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>>
	{	// get _Ty::pointer
	using type = typename _Ty::pointer;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_const_pointer_type
template<class _Ty,
	class = void>
	struct _Get_const_pointer_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using _Valty = typename _Ty::value_type;
	using type = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>>
	{	// get _Ty::const_pointer
	using type = typename _Ty::const_pointer;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_void_pointer_type
template<class _Ty,
	class = void>
	struct _Get_void_pointer_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using type = typename pointer_traits<_Ptrty>::template rebind<void>;
	};

template<class _Ty>
	struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>>
	{	// get _Ty::void_pointer
	using type = typename _Ty::void_pointer;
	};

		// STRUCT TEMPLATE _Get_const_void_pointer_type
template<class _Ty,
	class = void>
	struct _Get_const_void_pointer_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using type = typename pointer_traits<_Ptrty>::template rebind<const void>;
	};

template<class _Ty>
	struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>>
	{	// get _Ty::const_void_pointer
	using type = typename _Ty::const_void_pointer;
	};

		// STRUCT TEMPLATE _Get_difference_type
template<class _Ty,
	class = void>
	struct _Get_difference_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using type = typename pointer_traits<_Ptrty>::difference_type;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>>
	{	// get _Ty::difference_type
	using type = typename _Ty::difference_type;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_size_type
template<class _Ty,
	class = void>
	struct _Get_size_type
	{	// provide fallback
	using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty>
	struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>>
	{	// get _Ty::size_type
	using type = typename _Ty::size_type;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_propagate_on_container_copy
template<class _Ty,
	class = void>
	struct _Get_propagate_on_container_copy
	{	// provide fallback
	using type = false_type;
	};

template<class _Ty>
	struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>>
	{	// get _Ty::propagate_on_container_copy_assignment
	using type = typename _Ty::propagate_on_container_copy_assignment;
	};

		// STRUCT TEMPLATE _Get_propagate_on_container_move
template<class _Ty,
	class = void>
	struct _Get_propagate_on_container_move
	{	// provide fallback
	using type = false_type;
	};

template<class _Ty>
	struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>>
	{	// get _Ty::propagate_on_container_move_assignment
	using type = typename _Ty::propagate_on_container_move_assignment;
	};

		// STRUCT TEMPLATE _Get_propagate_on_container_swap
template<class _Ty,
	class = void>
	struct _Get_propagate_on_container_swap
	{	// provide fallback
	using type = false_type;
	};

template<class _Ty>
	struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>>
	{	// get _Ty::propagate_on_container_swap
	using type = typename _Ty::propagate_on_container_swap;
	};

		// STRUCT TEMPLATE _Get_is_always_equal
template<class _Ty,
	class = void>
	struct _Get_is_always_equal
	{	// provide fallback
	using type = typename is_empty<_Ty>::type;
	};

template<class _Ty>
	struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>>
	{	// get _Ty::is_always_equal
	using type = typename _Ty::is_always_equal;
	};

		// STRUCT TEMPLATE _Get_rebind_type
template<class _Ty,
	class _Other,
	class = void>
	struct _Get_rebind_type
	{	// provide fallback
	using type = typename _Replace_first_parameter<_Other, _Ty>::type;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Ty,
	class _Other>
	struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>>
	{	// get _Ty::rebind<_Other>::other
	using type = typename _Ty::template rebind<_Other>::other;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Is_default_allocator
template<class _Ty>
	class allocator;

template<class _Alloc,
	class = void>
	struct _Is_default_allocator
		: false_type
	{	// tests whether _Alloc is non-specialized default allocator (N4659 23.10.9 [default.allocator])
	};

template<class _Ty>
	struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
		: true_type
	{	// tests whether _Alloc is non-specialized default allocator (N4659 23.10.9 [default.allocator])
	};

		// ALIAS TEMPLATES _Uses_default_construct AND _Uses_default_construct_t
struct _Has_no_alloc_construct_tag
	{	// TRANSITION, C1XX
	};

template<class _Void,
	class... _Types>
	struct _Has_no_alloc_construct
		: true_type
	{	// determines whether _Alloc has no construct
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Alloc,
	class _Ptr,
	class... _Args>
	struct _Has_no_alloc_construct<
		void_t<
			_Has_no_alloc_construct_tag,
			decltype(_STD declval<_Alloc&>().construct(_STD declval<_Ptr>(), _STD declval<_Args>()...))>,
		_Alloc, _Ptr, _Args...>
		: false_type
	{	// determines whether _Alloc has no construct
	};
#pragma warning(pop)

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;


		// ALIAS TEMPLATE _Uses_default_destroy AND _Uses_default_destroy_t
struct _Has_no_alloc_destroy_tag
	{	// TRANSITION, C1XX
	};

template<class _Alloc,
	class _Ptr,
	class = void>
	struct _Has_no_alloc_destroy
		: true_type
	{	// determines whether _Alloc has no destroy
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Alloc,
	class _Ptr>
	struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<
			_Has_no_alloc_destroy_tag,
			decltype(_STD declval<_Alloc&>().destroy(_STD declval<_Ptr>()))>>
		: false_type
	{	// determines whether _Alloc has no destroy
	};
#pragma warning(pop)

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_destroy<_Alloc, _Ptr>>;

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;


		// STRUCT TEMPLATE _Has_allocate_hint
struct _Has_allocate_hint_tag
	{	// TRANSITION, C1XX
	};

template<class _Alloc,
	class _Size_type,
	class _Const_void_pointer,
	class = void>
	struct _Has_allocate_hint
		: false_type
	{	// determines whether _Alloc has allocate(n, hint)
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Alloc,
	class _Size_type,
	class _Const_void_pointer>
	struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer, void_t<
			_Has_allocate_hint_tag,
			decltype(_STD declval<_Alloc&>().allocate(
				_STD declval<const _Size_type&>(), _STD declval<const _Const_void_pointer&>()))>>
		: true_type
	{	// determines whether _Alloc has allocate(n, hint)
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Has_max_size
struct _Has_max_size_tag
	{	// TRANSITION, C1XX
	};

template<class _Alloc,
	class = void>
	struct _Has_max_size
		: false_type
	{	// determines whether _Alloc has max_size()
	};

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Alloc>
	struct _Has_max_size<_Alloc, void_t<
			_Has_max_size_tag,
			decltype(_STD declval<const _Alloc&>().max_size())>>
		: true_type
	{	// determines whether _Alloc has max_size()
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Has_select_on_container_copy_construction
struct _Has_select_on_container_copy_construction_tag
	{	// TRANSITION, C1XX
	};

template<class _Alloc,
	class = void>
	struct _Has_select_on_container_copy_construction
		: false_type
	{	// determines whether _Alloc has select_on_container_copy_construction()
	};

template<class _Alloc>
	struct _Has_select_on_container_copy_construction<_Alloc, void_t<
			_Has_select_on_container_copy_construction_tag,
			decltype(_STD declval<const _Alloc&>().select_on_container_copy_construction())>>
		: true_type
	{	// determines whether _Alloc has select_on_container_copy_construction()
	};


		// STRUCT TEMPLATE allocator_traits
template<class _Alloc>
	struct allocator_traits;

#pragma warning(push)
#pragma warning(disable: 4996)	// was declared deprecated
template<class _Alloc>
	struct _Normal_allocator_traits
	{	// defines traits for allocators
	using allocator_type = _Alloc;
	using value_type = typename _Alloc::value_type;

	using pointer = typename _Get_pointer_type<_Alloc>::type;
	using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
	using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
	using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

	using size_type = typename _Get_size_type<_Alloc>::type;
	using difference_type = typename _Get_difference_type<_Alloc>::type;

	using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
	using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
	using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
	using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

	_NODISCARD static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count)
		{	// allocate array of _Count elements
		return (_Al.allocate(_Count));
		}

	static _DECLSPEC_ALLOCATOR pointer _Allocate1(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count,
		const const_void_pointer _Hint, true_type)
		{	// allocate array of _Count elements, with hint, allocator-supplied version
		return (_Al.allocate(_Count, _Hint));
		}

	static _DECLSPEC_ALLOCATOR pointer _Allocate1(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count,
		const_void_pointer, false_type)
		{	// allocate array of _Count elements, with hint, default version
		return (_Al.allocate(_Count));
		}

	_NODISCARD static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count,
		const const_void_pointer _Hint)
		{	// allocate array of _Count elements, with hint
		return (_Allocate1(_Al, _Count, _Hint, _Has_allocate_hint<_Alloc, size_type, const_void_pointer>{}));
		}

	static void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count)
		{	// deallocate _Count elements at _Ptr
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(true_type, _Alloc&, _Ty *_Ptr, _Types&&... _Args)
		{	// construct _Ty(_Types...) at _Ptr, default version
		::new (static_cast<void *>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(false_type, _Alloc& _Al, _Ty *_Ptr, _Types&&... _Args)
		{	// construct _Ty(_Types...) at _Ptr, allocator-supplied version
		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr, _Types&&... _Args)
		{	// construct _Ty(_Types...) at _Ptr
		_Construct1(_Uses_default_construct_t<_Alloc, _Ty *, _Types...>(),
			_Al, _Ptr, _STD forward<_Types>(_Args)...);
		}

	template<class _Ty>
		static void _Destroy1(_Alloc&, _Ty *_Ptr, true_type)
		{	// destroy object at _Ptr, default version
		_Ptr->~_Ty();
		}

	template<class _Ty>
		static void _Destroy1(_Alloc& _Al, _Ty *_Ptr, false_type)
		{	// destroy object at _Ptr, allocator-supplied version
		_Al.destroy(_Ptr);
		}

	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	// destroy object at _Ptr
		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Alloc, _Ty *>());
		}

	static size_type _Max_size1(const _Alloc& _Al, true_type) _NOEXCEPT
		{	// get maximum size, allocator-supplied version
		return (_Al.max_size());
		}

	static size_type _Max_size1(const _Alloc&, false_type) _NOEXCEPT
		{	// get maximum size, default version
		return ((numeric_limits<size_type>::max)() / sizeof(value_type));
		}

	_NODISCARD static size_type max_size(const _Alloc& _Al) _NOEXCEPT
		{	// get maximum size
		return (_Max_size1(_Al, _Has_max_size<_Alloc>{}));
		}

	static _Alloc _Select_on_container_copy_construction1(const _Alloc& _Al, true_type)
		{	// get allocator to use, allocator-supplied version
		return (_Al.select_on_container_copy_construction());
		}

	static _Alloc _Select_on_container_copy_construction1(const _Alloc& _Al, false_type)
		{	// get allocator to use, default version
		return (_Al);
		}

	_NODISCARD static _Alloc select_on_container_copy_construction(const _Alloc& _Al)
		{	// get allocator to use
		return (_Select_on_container_copy_construction1(_Al, _Has_select_on_container_copy_construction<_Alloc>{}));
		}
	};
#pragma warning(pop)

template<class _Alloc>
	struct _Default_allocator_traits
	{	// traits for std::allocator
	using allocator_type = _Alloc;
	using value_type = typename _Alloc::value_type;

	using pointer = value_type *;
	using const_pointer = const value_type *;
	using void_pointer = void *;
	using const_void_pointer = const void *;

	using size_type = size_t;
	using difference_type = ptrdiff_t;

	using propagate_on_container_copy_assignment = false_type;
	using propagate_on_container_move_assignment = true_type;
	using propagate_on_container_swap = false_type;
	using is_always_equal = true_type;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other>>;

	_NODISCARD static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc&, _CRT_GUARDOVERFLOW const size_type _Count)
		{	// allocate array of _Count elements
		return (static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count))));
		}

	_NODISCARD static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc&, _CRT_GUARDOVERFLOW const size_type _Count,
		const_void_pointer)
		{	// allocate array of _Count elements, with hint
		return (static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count))));
		}

	static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count)
		{	// deallocate _Count elements at _Ptr
		// no overflow check on the following multiply; we assume _Allocate did that check
		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc&, _Objty * const _Ptr, _Types&&... _Args)
		{	// construct _Objty(_Types...) at _Ptr
		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
			_Objty(_STD forward<_Types>(_Args)...);
		}

	template<class _Uty>
		static void destroy(_Alloc&, _Uty * const _Ptr)
		{	// destroy object at _Ptr
		_Ptr->~_Uty();
		}

	_NODISCARD static size_type max_size(const _Alloc&) _NOEXCEPT
		{	// get maximum size
		return (static_cast<size_t>(-1) / sizeof(value_type));
		}

	_NODISCARD static _Alloc select_on_container_copy_construction(const _Alloc& _Al)
		{	// get allocator to use
		return (_Al);
		}
	};

template<class _Alloc>
	struct allocator_traits
		: conditional_t<_Is_default_allocator<_Alloc>::value,
			_Default_allocator_traits<_Alloc>, _Normal_allocator_traits<_Alloc>>
	{	// defines traits for allocators
	};

		// TYPE TRAIT _Always_equal_after_move
template<class _Alloc>
	_INLINE_VAR constexpr bool _Always_equal_after_move = allocator_traits<_Alloc>::is_always_equal::value
		|| allocator_traits<_Alloc>::propagate_on_container_move_assignment::value;

		// ALIAS TEMPLATE _Rebind_alloc_t
template<class _Alloc,
	class _Value_type>
	using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;

		// VARIABLE TEMPLATE _Is_simple_alloc_v
template<class _Alloc>	// tests if allocator has simple addressing
	_INLINE_VAR constexpr bool _Is_simple_alloc_v =
		is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>
		&& is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>
		&& is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *>
		&& is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type *>;

		// STRUCT TEMPLATE _Simple_types
template<class _Value_type>
	struct _Simple_types
	{	// wraps types from allocators with simple addressing for use in iterators
		// and other SCARY machinery
	using value_type = _Value_type;
	using size_type = size_t;
	using difference_type = ptrdiff_t;
	using pointer = value_type *;
	using const_pointer = const value_type *;
	};

		// CLASS TEMPLATE allocator
template<class _Ty>
	class allocator
	{	// generic allocator for objects of class _Ty
public:
	static_assert(!is_const_v<_Ty>,
		"The C++ Standard forbids containers of const elements "
		"because allocator<const T> is ill-formed.");

	using _Not_user_specialized = void;

	using value_type = _Ty;

	_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef _Ty * pointer;
	_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef const _Ty * const_pointer;

	_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef _Ty& reference;
	_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef const _Ty& const_reference;

	_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef size_t size_type;
	_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef ptrdiff_t difference_type;

	using propagate_on_container_move_assignment = true_type;
	using is_always_equal = true_type;

	template<class _Other>
		struct _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS rebind
		{	// convert this type to allocator<_Other>
		using other = allocator<_Other>;
		};

	_NODISCARD _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _Ty * address(_Ty& _Val) const _NOEXCEPT
		{	// return address of mutable _Val
		return (_STD addressof(_Val));
		}

	_NODISCARD _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS const _Ty * address(const _Ty& _Val) const _NOEXCEPT
		{	// return address of nonmutable _Val
		return (_STD addressof(_Val));
		}

	allocator() _NOEXCEPT
		{	// construct default allocator (do nothing)
		}

	allocator(const allocator&) _NOEXCEPT = default;
	template<class _Other>
		allocator(const allocator<_Other>&) _NOEXCEPT
		{	// construct from a related allocator (do nothing)
		}

	void deallocate(_Ty * const _Ptr, const size_t _Count)
		{	// deallocate object at _Ptr
		// no overflow check on the following multiply; we assume _Allocate did that check
		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
		}

	_NODISCARD _DECLSPEC_ALLOCATOR _Ty * allocate(_CRT_GUARDOVERFLOW const size_t _Count)
		{	// allocate array of _Count elements
		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
		}

	_NODISCARD _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _DECLSPEC_ALLOCATOR _Ty * allocate(
		_CRT_GUARDOVERFLOW const size_t _Count, const void *)
		{	// allocate array of _Count elements, ignore hint
		return (allocate(_Count));
		}

	template<class _Objty,
		class... _Types>
		_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void construct(_Objty * const _Ptr, _Types&&... _Args)
		{	// construct _Objty(_Types...) at _Ptr
		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
			_Objty(_STD forward<_Types>(_Args)...);
		}

	template<class _Uty>
		_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void destroy(_Uty * const _Ptr)
		{	// destroy object at _Ptr
		_Ptr->~_Uty();
		}

	_NODISCARD _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS size_t max_size() const _NOEXCEPT
		{	// estimate maximum array size
		return (static_cast<size_t>(-1) / sizeof(_Ty));
		}
	};

		// CLASS allocator<void>
template<>
	class _CXX17_DEPRECATE_ALLOCATOR_VOID allocator<void>
	{	// generic allocator for type void
public:
	using value_type = void;
	using pointer = void *;
	using const_pointer = const void *;

	template<class _Other>
		struct rebind
		{	// convert this type to an allocator<_Other>
		using other = allocator<_Other>;
		};
	};

template<class _Ty,
	class _Other>
	_NODISCARD inline bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) _NOEXCEPT
	{	// test for allocator equality
	return (true);
	}

template<class _Ty,
	class _Other>
	_NODISCARD inline bool operator!=(const allocator<_Ty>&,
		const allocator<_Other>&) _NOEXCEPT
	{	// test for allocator inequality
	return (false);
	}

		// FUNCTION TEMPLATE _Pocca
template<class _Alloc> inline
	void _Pocca(_Alloc& _Left, const _Alloc& _Right, true_type) _NOEXCEPT
	{	// propagate on container copy assignment
	_Left = _Right;
	}

template<class _Alloc> inline
	void _Pocca(_Alloc&, const _Alloc&, false_type) _NOEXCEPT
	{	// (don't) propagate on container copy assignment
	}

template<class _Alloc> inline
	void _Pocca(_Alloc& _Left, const _Alloc& _Right) _NOEXCEPT
	{	// (maybe) propagate on container copy assignment
	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
	_Pocca(_Left, _Right, _Tag);
	}

		// FUNCTION TEMPLATE _Pocma
template<class _Alloc> inline
	void _Pocma(_Alloc& _Left, _Alloc& _Right, true_type) _NOEXCEPT
	{	// propagate on container move assignment
	_Left = _STD move(_Right);
	}

template<class _Alloc> inline
	void _Pocma(_Alloc&, _Alloc&, false_type) _NOEXCEPT
	{	// (don't) propagate on container move assignment
	}

template<class _Alloc> inline
	void _Pocma(_Alloc& _Left, _Alloc& _Right) _NOEXCEPT
	{	// (maybe) propagate on container move assignment
	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
	_Pocma(_Left, _Right, _Tag);
	}

		// FUNCTION TEMPLATE _Pocs
template<class _Alloc> inline
	void _Pocs(_Alloc& _Left, _Alloc& _Right, true_type) _NOEXCEPT
	{	// propagate on container swap
	_Swap_adl(_Left, _Right);
	}

template<class _Alloc> inline
	void _Pocs(_Alloc& _Left, _Alloc& _Right, false_type) _NOEXCEPT
	{	// (don't) propagate on container swap
	if (_Left != _Right)
		{	// containers are incompatible
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("containers incompatible for swap");
 #else /* ITERATOR_DEBUG_LEVEL == 2 */
# 1149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
		_STD terminate();
 #endif /* ITERATOR_DEBUG_LEVEL == 2 */
# 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
		}
	}

template<class _Alloc> inline
	void _Pocs(_Alloc& _Left, _Alloc& _Right) _NOEXCEPT
	{	// (maybe) propagate on container swap
	typename allocator_traits<_Alloc>::propagate_on_container_swap _Tag;
	_Pocs(_Left, _Right, _Tag);
	}


		// FUNCTION TEMPLATE _Destroy_range WITH ALLOC
template<class _Alloc> inline
	void _Destroy_range1(
		typename allocator_traits<_Alloc>::pointer _First,
		typename allocator_traits<_Alloc>::pointer _Last,
		_Alloc& _Al, false_type)
	{	// destroy [_First, _Last), no special optimization
	for (; _First != _Last; ++_First)
		{
		allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
		}
	}

template<class _Alloc> inline
	void _Destroy_range1(
		typename allocator_traits<_Alloc>::pointer,
		typename allocator_traits<_Alloc>::pointer,
		_Alloc&, true_type)
	{	// destroy [_First, _Last), trivially destructible and default destroy
		// nothing to do
	}

template<class _Alloc> inline
	void _Destroy_range(
		typename allocator_traits<_Alloc>::pointer _First,
		typename allocator_traits<_Alloc>::pointer _Last,
		_Alloc& _Al)
	{	// destroy [_First, _Last), choose optimization
		// note that this is an optimization for debug mode codegen;
		// in release mode the BE removes all of this
	using _Val = typename _Alloc::value_type;
	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
		is_trivially_destructible<_Val>,
		_Uses_default_destroy<_Alloc, _Val *>>());
	}


		// FUNCTION TEMPLATE _Destroy_range
template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt _First, _FwdIt _Last, false_type)
	{	// destroy [_First, _Last), no special optimization
	for (; _First != _Last; ++_First)
		{
		_Destroy_in_place(*_First);
		}
	}

template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt, _FwdIt, true_type)
	{	// destroy [_First, _Last), trivially destructible
		// nothing to do
	}

template<class _FwdIt> inline
	void _Destroy_range(_FwdIt _First, _FwdIt _Last)
	{	// destroy [_First, _Last), choose optimization
		// note that this is an optimization for debug mode codegen;
		// in release mode the BE removes all of this
	_Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt>>());
	}


		// FUNCTION TEMPLATE _Convert_size
template<class _Size_type> inline
	_Size_type _Convert_size(const size_t _Len)
	{	// convert size_t to _Size_type, avoiding truncation
	if (_Len > (numeric_limits<_Size_type>::max)())
		{
		_Xlength_error("size_t too long for _Size_type");
		}

	return (static_cast<_Size_type>(_Len));
	}

template<> inline
	size_t _Convert_size<size_t>(const size_t _Len)
	{	// convert size_t to size_t, unchanged
	return (_Len);
	}

		// FUNCTION TEMPLATES FOR CHECKING/UNCHECKING PAIRS
template<class _Iter1,
	class _Iter2,
	class _UIter1,
	class _UIter2>
	constexpr pair<_Iter1, _Iter2>
		_Rechecked_both(_Iter1 _Dest1, _Iter2 _Dest2, pair<_UIter1, _UIter2> _Src)
	{	// reset checked from unchecked, generic
	return {_Rechecked(_Dest1, _Src.first), _Rechecked(_Dest2, _Src.second)};
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _Iter1,
	class _Iter2,
	class _UIter1>
	constexpr pair<_Iter1, _Iter2> _Rechecked_first(_Iter1 _Dest1, pair<_UIter1, _Iter2> _Src)
	{	// reset only the first checked from unchecked
	return {_Rechecked(_Dest1, _Src.first), _Src.second};
	}

template<class _Iter1,
	class _Iter2,
	class _UIter2>
	constexpr pair<_Iter1, _Iter2> _Rechecked_second(_Iter2 _Dest2, pair<_Iter1, _UIter2> _Src)
	{	// reset only the second checked from unchecked
	return {_Src.first, _Rechecked(_Dest2, _Src.second)};
	}

template<class _Iter1,
	class _Iter2> inline
	pair<_Unchecked_t<_Iter1>, _Unchecked_t<_Iter2>> _Unchecked_both(pair<_Iter1, _Iter2> _Src)
	{	// unchecks iterators in a pair (for _ITERATOR_DEBUG_ARRAY_OVERLOADS)
	return {_Unchecked(_Src.first), _Unchecked(_Src.second)};
	}

template<class _Iter1,
	class _Iter2> inline
	pair<_Unchecked_t<_Iter1>, _Iter2> _Unchecked_first(pair<_Iter1, _Iter2> _Src)
	{	// unchecks first in a pair (for _ITERATOR_DEBUG_ARRAY_OVERLOADS)
	return {_Unchecked(_Src.first), _Src.second};
	}

template<class _Iter1,
	class _Iter2> inline
	pair<_Iter1, _Unchecked_t<_Iter2>> _Unchecked_second(pair<_Iter1, _Iter2> _Src)
	{	// unchecks second in a pair (for _ITERATOR_DEBUG_ARRAY_OVERLOADS)
	return {_Src.first, _Unchecked(_Src.second)};
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

		// FUNCTION TEMPLATE _Deallocate_plain
template<class _Alloc,
	enable_if_t<is_same_v<typename allocator_traits<_Alloc>::pointer,
		typename _Alloc::value_type *>, int> = 0> inline
	void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type * const _Ptr)
	{	// deallocate a plain pointer using an allocator, non-fancy pointers special case
	allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
	}

template<class _Alloc,
	enable_if_t<!is_same_v<typename allocator_traits<_Alloc>::pointer,
		typename _Alloc::value_type *>, int> = 0> inline
	void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type * const _Ptr)
	{	// deallocate a plain pointer using an allocator
	using _Alloc_traits = allocator_traits<_Alloc>;
	using _Ptr_traits = pointer_traits<typename _Alloc_traits::pointer>;
	_Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
	}
_STD_END

		// ATOMIC REFERENCE COUNTING PRIMITIVES
  #if 0 /* expanded by -frewrite-includes */
#include <xatomic0.h>
#endif /* expanded by -frewrite-includes */
# 1313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 1 3
/* xatomic0.h internal header */
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3
#ifndef _XATOMIC0_H
#define _XATOMIC0_H
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		/* ENUM memory_order */
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	/* SET SIZES AND FLAGS FOR COMPILER AND TARGET ARCHITECTURE */
	/* Note: the xxx_SIZE macros are used to generate function names,
		so they must expand to the digits representing
		the number of bytes in the type; they cannot be expressions
		that give the number of bytes. */

  #define _WCHAR_T_SIZE		2
  #define _SHORT_SIZE		2
  #define _INT_SIZE			4
  #define _LONG_SIZE		4
  #define _LONGLONG_SIZE	8

  #if defined(_WIN64)
   #define _ADDR_SIZE	8
  #else /* defined(_WIN64) */
# 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3
   #define _ADDR_SIZE	4
  #endif /* defined(_WIN64) */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3

		/* ATOMIC REFERENCE COUNTING */
typedef _Atomic_integral_t _Atomic_counter_t;

inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	// get counter
	return (_Counter);
	}

 #ifndef _USE_INTERLOCKED_REFCOUNTING
  #if defined(_M_IX86) || defined(_M_X64) || defined(_M_CEE_PURE)
   #define _USE_INTERLOCKED_REFCOUNTING	1
  #else /* defined(_M_IX86) || defined(_M_X64) || defined(_M_CEE_PURE) */
# 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3
   #define _USE_INTERLOCKED_REFCOUNTING	0
  #endif /* defined(_M_IX86) || defined(_M_X64) || defined(_M_CEE_PURE) */
# 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3
 #endif /* _USE_INTERLOCKED_REFCOUNTING */
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3

_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3
#endif /* _XATOMIC0_H */
# 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xatomic0.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 1314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3

  #if _USE_INTERLOCKED_REFCOUNTING
   #if 0 /* expanded by -frewrite-includes */
#include <intrin0.h>
#endif /* expanded by -frewrite-includes */
# 1316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 1 3
/***
*   intrin0.h - declarations of compiler intrinsics used by the C++ Standard Library.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This header file declares compiler intrinsics that are used by the
*   C++ Standard Library, especially <atomic>. Compiler throughput is
*   the only reason that intrin0.h is separate from intrin.h.
*
****/

#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3
#define __INTRIN0_H_
#ifndef RC_INVOKED
#ifndef __midl

#if defined(__cplusplus)
extern "C" {
#endif
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

/*
** __MACHINE              : everything
** __MACHINEX86           : x86 only
** __MACHINEX64           : x64 only
** __MACHINEX86_X64       : x86 and x64 only
** __MACHINEARM           : ARM only
** __MACHINEARM64         : ARM64 only
** __MACHINEARM_ARM64     : ARM and ARM64 only
** __MACHINEARM_ARM64_X64 : ARM and 64-bit Arch only
** __MACHINEARM64_X64     : ARM64 and x64 only
** __MACHINECHPEX86ARM64  : CHPE x86 on arm64 only
** __MACHINEWVMPURE       : /clr:pure only
** __MACHINEZ             : nothing
*/

#define __MACHINEX86           __MACHINE
#define __MACHINEX64           __MACHINE
#define __MACHINEX86_X64       __MACHINE
#define __MACHINEARM           __MACHINE
#define __MACHINEARM64         __MACHINE
#define __MACHINEARM_ARM64     __MACHINE
#define __MACHINEARM_ARM64_X64 __MACHINE
#define __MACHINEARM64_X64     __MACHINE
#define __MACHINECHPEX86ARM64  __MACHINE

/* Most intrinsics not available to pure managed code */
#if defined(_M_CEE_PURE)
#define __MACHINE(X)        __MACHINEZ(X)
#define __MACHINEWVMPURE(X) X;
#else
# 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3
#define __MACHINE(X)        X;
#define __MACHINEWVMPURE(X) __MACHINEZ(X)
#endif
# 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#define __MACHINEZ(X)       /* NOTHING */

#if !defined(_M_IX86) || defined(_CHPE_ONLY_)
#undef __MACHINEX86
#define __MACHINEX86        __MACHINEZ
#endif
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !defined(_M_X64)
#undef __MACHINEX64
#define __MACHINEX64        __MACHINEZ
#endif
# 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !(defined(_M_IX86) || defined(_M_X64)) || defined(_CHPE_ONLY_)
#undef __MACHINEX86_X64
#define __MACHINEX86_X64    __MACHINEZ
#endif
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !defined(_M_ARM)
#undef  __MACHINEARM
#define __MACHINEARM        __MACHINEZ
#endif
# 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

/* For compatibility with <winnt.h>, some intrinsics are __cdecl except on x64 */
#if defined(_M_X64)
#define __MACHINECALL_CDECL_OR_DEFAULT
#else
# 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3
#define __MACHINECALL_CDECL_OR_DEFAULT __cdecl
#endif
# 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !defined(_M_ARM64) && !defined(_M_HYBRID_X86_ARM64)
#undef  __MACHINEARM64
#define __MACHINEARM64      __MACHINEZ
#endif
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !(defined(_M_ARM) || defined(_M_ARM64) || defined(_M_HYBRID_X86_ARM64))
#undef __MACHINEARM_ARM64
#define __MACHINEARM_ARM64  __MACHINEZ
#endif
# 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !(defined(_M_ARM) || defined(_M_X64) || defined(_M_ARM64) || defined(_M_HYBRID_X86_ARM64))
#undef __MACHINEARM_ARM64_X64
#define __MACHINEARM_ARM64_X64     __MACHINEZ
#endif
# 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !(defined(_M_X64) || defined(_M_ARM64) || defined(_M_HYBRID_X86_ARM64))
#undef __MACHINEARM64_X64
#define __MACHINEARM64_X64     __MACHINEZ
#endif
# 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

#if !defined(_M_HYBRID_X86_ARM64)
#undef __MACHINECHPEX86ARM64
#define __MACHINECHPEX86ARM64 __MACHINEZ
#endif
# 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3

/*******************************************************************
* Note: New intrinsics should be added here IF AND ONLY IF they're *
* being used by the C++ Standard Library.                          *
* OTHERWISE, new intrinsics should be added to intrin.h.           *
*******************************************************************/

__MACHINEARM_ARM64(void __dmb(unsigned int _Type))

__MACHINE(unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask))
__MACHINEX64(unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask))
__MACHINEARM64(unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask))
__MACHINE(unsigned char _bittest(long const *, long))
__MACHINE(long _InterlockedAnd(long volatile * _Value, long _Mask))
__MACHINE(short _InterlockedAnd16(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedAnd16_acq(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedAnd16_nf(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedAnd16_rel(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64_X64(__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedAnd64_acq(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedAnd64_nf(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedAnd64_rel(__int64 volatile * _Value, __int64 _Mask))
__MACHINE(char _InterlockedAnd8(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedAnd8_acq(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedAnd8_nf(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedAnd8_rel(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(long _InterlockedAnd_acq(long volatile * _Value, long _Mask))
__MACHINEARM_ARM64(long _InterlockedAnd_nf(long volatile * _Value, long _Mask))
__MACHINEARM_ARM64(long _InterlockedAnd_rel(long volatile * _Value, long _Mask))
__MACHINE(long __MACHINECALL_CDECL_OR_DEFAULT _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand))
__MACHINEWVMPURE(long _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand))
__MACHINE(short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand))
__MACHINEARM_ARM64(short _InterlockedCompareExchange16_acq(short volatile * _Destination, short _Exchange, short _Comparand))
__MACHINEARM_ARM64(short _InterlockedCompareExchange16_nf(short volatile * _Destination, short _Exchange, short _Comparand))
__MACHINEARM_ARM64(short _InterlockedCompareExchange16_rel(short volatile * _Destination, short _Exchange, short _Comparand))
__MACHINE(__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand))
__MACHINEARM_ARM64(__int64 _InterlockedCompareExchange64_acq(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand))
__MACHINEARM_ARM64(__int64 _InterlockedCompareExchange64_nf(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand))
__MACHINEARM_ARM64(__int64 _InterlockedCompareExchange64_rel(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand))
__MACHINE(char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand))
__MACHINEARM_ARM64(char _InterlockedCompareExchange8_acq(char volatile * _Destination, char _Exchange, char _Comparand))
__MACHINEARM_ARM64(char _InterlockedCompareExchange8_nf(char volatile * _Destination, char _Exchange, char _Comparand))
__MACHINEARM_ARM64(char _InterlockedCompareExchange8_rel(char volatile * _Destination, char _Exchange, char _Comparand))
__MACHINEARM_ARM64(long _InterlockedCompareExchange_acq(long volatile * _Destination, long _Exchange, long _Comparand))
__MACHINEARM_ARM64(long _InterlockedCompareExchange_nf(long volatile * _Destination, long _Exchange, long _Comparand))
__MACHINEARM_ARM64(long _InterlockedCompareExchange_rel(long volatile * _Destination, long _Exchange, long _Comparand))
__MACHINE(long __MACHINECALL_CDECL_OR_DEFAULT _InterlockedDecrement(long volatile * _Addend))
__MACHINEWVMPURE(long _InterlockedDecrement(long volatile * _Addend))
__MACHINE(long __MACHINECALL_CDECL_OR_DEFAULT _InterlockedExchange(long volatile * _Target, long _Value))
__MACHINEWVMPURE(long __MACHINECALL_CDECL_OR_DEFAULT _InterlockedExchange(long volatile * _Target, long _Value))
__MACHINE(short _InterlockedExchange16(short volatile * _Target, short _Value))
__MACHINEARM_ARM64(short _InterlockedExchange16_acq(short volatile * _Target, short _Value))
__MACHINEARM_ARM64(short _InterlockedExchange16_nf(short volatile * _Target, short _Value))
__MACHINEARM_ARM64(short _InterlockedExchange16_rel(short volatile * _Target, short _Value))
__MACHINEARM_ARM64_X64(__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value))
__MACHINEARM_ARM64(__int64 _InterlockedExchange64_acq(__int64 volatile * _Target, __int64 _Value))
__MACHINEARM_ARM64(__int64 _InterlockedExchange64_nf(__int64 volatile * _Target, __int64 _Value))
__MACHINEARM_ARM64(__int64 _InterlockedExchange64_rel(__int64 volatile * _Target, __int64 _Value))
__MACHINE(char _InterlockedExchange8(char volatile * _Target, char _Value))
__MACHINEARM_ARM64(char _InterlockedExchange8_acq(char volatile * _Target, char _Value))
__MACHINEARM_ARM64(char _InterlockedExchange8_nf(char volatile * _Target, char _Value))
__MACHINEARM_ARM64(char _InterlockedExchange8_rel(char volatile * _Target, char _Value))
__MACHINE(long __MACHINECALL_CDECL_OR_DEFAULT _InterlockedExchangeAdd(long volatile * _Addend, long _Value))
__MACHINE(short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value))
__MACHINEARM_ARM64(short _InterlockedExchangeAdd16_acq(short volatile * _Addend, short _Value))
__MACHINEARM_ARM64(short _InterlockedExchangeAdd16_nf(short volatile * _Addend, short _Value))
__MACHINEARM_ARM64(short _InterlockedExchangeAdd16_rel(short volatile * _Addend, short _Value))
__MACHINEARM_ARM64_X64(__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value))
__MACHINEARM_ARM64(__int64 _InterlockedExchangeAdd64_acq(__int64 volatile * _Addend, __int64 _Value))
__MACHINEARM_ARM64(__int64 _InterlockedExchangeAdd64_nf(__int64 volatile * _Addend, __int64 _Value))
__MACHINEARM_ARM64(__int64 _InterlockedExchangeAdd64_rel(__int64 volatile * _Addend, __int64 _Value))
__MACHINE(char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value))
__MACHINEARM_ARM64(char _InterlockedExchangeAdd8_acq(char volatile * _Addend, char _Value))
__MACHINEARM_ARM64(char _InterlockedExchangeAdd8_nf(char volatile * _Addend, char _Value))
__MACHINEARM_ARM64(char _InterlockedExchangeAdd8_rel(char volatile * _Addend, char _Value))
__MACHINEARM_ARM64(long _InterlockedExchangeAdd_acq(long volatile * _Addend, long _Value))
__MACHINEARM_ARM64(long _InterlockedExchangeAdd_nf(long volatile * _Addend, long _Value))
__MACHINEARM_ARM64(long _InterlockedExchangeAdd_rel(long volatile * _Addend, long _Value))
__MACHINEARM_ARM64(long _InterlockedExchange_acq(long volatile * _Target, long _Value))
__MACHINEARM_ARM64(long _InterlockedExchange_nf(long volatile * _Target, long _Value))
__MACHINEARM_ARM64(long _InterlockedExchange_rel(long volatile * _Target, long _Value))
__MACHINE(long __MACHINECALL_CDECL_OR_DEFAULT _InterlockedIncrement(long volatile * _Addend))
__MACHINEWVMPURE(long _InterlockedIncrement(long volatile * _Addend))
__MACHINE(long _InterlockedOr(long volatile * _Value, long _Mask))
__MACHINE(short _InterlockedOr16(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedOr16_acq(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedOr16_nf(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedOr16_rel(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64_X64(__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedOr64_acq(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedOr64_nf(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedOr64_rel(__int64 volatile * _Value, __int64 _Mask))
__MACHINE(char _InterlockedOr8(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedOr8_acq(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedOr8_nf(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedOr8_rel(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(long _InterlockedOr_acq(long volatile * _Value, long _Mask))
__MACHINEARM_ARM64(long _InterlockedOr_nf(long volatile * _Value, long _Mask))
__MACHINEARM_ARM64(long _InterlockedOr_rel(long volatile * _Value, long _Mask))
__MACHINE(long _InterlockedXor(long volatile * _Value, long _Mask))
__MACHINE(short _InterlockedXor16(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedXor16_acq(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedXor16_nf(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64(short _InterlockedXor16_rel(short volatile * _Value, short _Mask))
__MACHINEARM_ARM64_X64(__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedXor64_acq(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedXor64_nf(__int64 volatile * _Value, __int64 _Mask))
__MACHINEARM_ARM64(__int64 _InterlockedXor64_rel(__int64 volatile * _Value, __int64 _Mask))
__MACHINE(char _InterlockedXor8(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedXor8_acq(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedXor8_nf(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(char _InterlockedXor8_rel(char volatile * _Value, char _Mask))
__MACHINEARM_ARM64(long _InterlockedXor_acq(long volatile * _Value, long _Mask))
__MACHINEARM_ARM64(long _InterlockedXor_nf(long volatile * _Value, long _Mask))
__MACHINEARM_ARM64(long _InterlockedXor_rel(long volatile * _Value, long _Mask))
__MACHINE(void _ReadWriteBarrier(void))
__MACHINEARM_ARM64(__int16 __iso_volatile_load16(const volatile __int16 *))
__MACHINEARM_ARM64(__int32 __iso_volatile_load32(const volatile __int32 *))
__MACHINEARM_ARM64(__int64 __iso_volatile_load64(const volatile __int64 *))
__MACHINEARM_ARM64(__int8 __iso_volatile_load8(const volatile __int8 *))
__MACHINEARM_ARM64(void __iso_volatile_store16(volatile __int16 *, __int16))
__MACHINEARM_ARM64(void __iso_volatile_store32(volatile __int32 *, __int32))
__MACHINEARM_ARM64(void __iso_volatile_store64(volatile __int64 *, __int64))
__MACHINEARM_ARM64(void __iso_volatile_store8(volatile __int8 *, __int8))
__MACHINEARM(__int64 __ldrexd(const volatile __int64 *))
__MACHINEARM_ARM64(void __yield(void))
__MACHINE(unsigned char _interlockedbittestandset(long volatile *, long))
__MACHINEARM_ARM64(unsigned char _interlockedbittestandset_acq(long volatile *, long))
__MACHINEARM_ARM64(unsigned char _interlockedbittestandset_nf(long volatile *, long))
__MACHINEARM_ARM64(unsigned char _interlockedbittestandset_rel(long volatile *, long))

/*******************************************************************
* Note: New intrinsics should be added here IF AND ONLY IF they're *
* being used by the C++ Standard Library.                          *
* OTHERWISE, new intrinsics should be added to intrin.h.           *
*******************************************************************/

#if defined(__cplusplus)
}
#endif
# 249 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3
#endif  /* __midl */
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3
#endif  /* RC_INVOKED */
# 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\intrin0.h" 3
# 1317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 2 3

   #define _MT_INCR(x) \
	_InterlockedIncrement(reinterpret_cast<volatile long *>(&x))
   #define _MT_DECR(x) \
	_InterlockedDecrement(reinterpret_cast<volatile long *>(&x))

  #else /* _USE_INTERLOCKED_REFCOUNTING */
# 1324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
   #if 0 /* expanded by -frewrite-includes */
#include <xatomic.h>
#endif /* expanded by -frewrite-includes */
# 1324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
# 1325 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

   #define _MT_INCR(x) \
	_Inc_atomic_counter_explicit(x, memory_order_relaxed)
   #define _MT_DECR(x) \
	_Dec_atomic_counter_explicit(x, memory_order_acq_rel)
  #endif /* _USE_INTERLOCKED_REFCOUNTING */
# 1331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3
#endif /* _XMEMORY0_ */
# 1337 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory0" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// FUNCTION TEMPLATE _Get_temporary_buffer
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) _NOEXCEPT
	{	// get raw temporary buffer of up to _Count elements
	if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty))
		{
		for (; 0 < _Count; _Count /= 2)
			{
			const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
			void * _Pbuf;
 #if _HAS_ALIGNED_NEW
  #pragma warning(push)
  #pragma warning(disable: 4127) // conditional expression is constant
  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
			if /* constexpr */ (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
				{
				_Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
				}
			else
  #pragma warning(pop)
 #endif /* _HAS_ALIGNED_NEW */
# 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 3
				{
				_Pbuf = ::operator new(_Size, nothrow);
				}
			if (_Pbuf)
				{
				return {static_cast<_Ty *>(_Pbuf), _Count};
				}
			}
		}

	return {nullptr, 0};
	}

		// FUNCTION TEMPLATE _Return_temporary_buffer
template<class _Ty> inline
	void _Return_temporary_buffer(_Ty * const _Pbuf)
	{	// delete raw temporary buffer
 #if _HAS_ALIGNED_NEW
  #pragma warning(push)
  #pragma warning(disable: 4127) // conditional expression is constant
  #pragma warning(disable: 6326) // Potential comparison of a constant with another constant
	if /* constexpr */ (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
		{
		::operator delete(_Pbuf, align_val_t{alignof(_Ty)});
		}
	else
  #pragma warning(pop)
 #endif /* _HAS_ALIGNED_NEW */
# 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 3
		{
		::operator delete(_Pbuf);
		}
	}

		// FUNCTION TEMPLATE _Uninitialized_move_unchecked
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) to raw [_Dest, ...), no special optimization
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, (void)++_First)
		{
		_Construct_in_place(*_Dest, _STD move(*_First));
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest);
	_RERAISE;
	_CATCH_END

	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// move [_First, _Last) to raw [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	// move [_First, _Last) to raw [_Dest, ...), choose optimization
	return (_Uninitialized_move_unchecked1(_First, _Last, _Dest, _Ptr_move_cat(_First, _Dest)));
	}


		// FUNCTION TEMPLATE _Uninitialized_copy WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc& _Al,
		_General_ptr_iterator_tag, _Any_tag)
	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, (void)++_First)
		{
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Dest), *_First);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest, _Al);
	_RERAISE;
	_CATCH_END

	return (_Dest);
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_copy_al_unchecked(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest, _Alloc&,
		_Really_trivial_ptr_iterator_tag, true_type)
	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc& _Al)
	{	// copy [_First, _Last) to raw _Dest, using _Al
		// note: only called internally from elsewhere in the STL, debug checks
		// and deprecation warnings omitted
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked(_Dest);
	return (_Rechecked(_Dest,
		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
			_Ptr_copy_cat(_UFirst, _UDest),
			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>())));
	}

		// FUNCTION TEMPLATE _Uninitialized_move WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc& _Al,
		_General_ptr_iterator_tag, _Any_tag)
	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, (void)++_First)
		{
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Dest), _STD move(*_First));
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest, _Al);
	_RERAISE;
	_CATCH_END

	return (_Dest);
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_move_al_unchecked(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest, _Alloc&,
		_Really_trivial_ptr_iterator_tag, true_type)
	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc& _Al)
	{	// move [_First, _Last) to raw _Dest, using _Al
		// note: only called internally from elsewhere in the STL, debug checks
		// and deprecation warnings omitted
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked(_Dest);
	return (_Rechecked(_Dest,
		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
			_Ptr_move_cat(_UFirst, _UDest),
			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(_STD move(*_UFirst))>())));
	}

		// FUNCTION TEMPLATE _Uninitialized_fill_n WITH ALLOCATOR
template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
		_Alloc& _Al, false_type)
	{	// copy _Count copies of _Val to raw _First, using _Al, no special optimization
	_FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, (void)++_First)
		{
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_First), _Val);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First, _Al);
	_RERAISE;
	_CATCH_END

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
		_Alloc&, true_type)
	{	// copy _Count copies of _Val to raw _First, using default _Alloc construct, memset optimization
	_CSTD memset(_First, static_cast<unsigned char>(_Val), _Count);
	return (_First + _Count);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
		_Alloc& _Al)
	{	// copy _Count copies of _Val to raw _First, using _Al
	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,
		_Conjunction_t<decltype(_Fill_memset_is_safe(_First, _Val)),
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>()));
	}

		// FUNCTION TEMPLATE _Uninitialized_value_construct_n WITH ALLOCATOR
template<class _FwdIt>
	using _Use_memset_value_construct_t = _Conjunction_t<
		is_pointer<_FwdIt>,
		is_scalar<_Iter_value_t<_FwdIt>>,
		negation<is_volatile<_Iter_value_t<_FwdIt>>>,
		negation<is_member_pointer<_Iter_value_t<_FwdIt>>>>;

template<class _FwdIt> inline
	_FwdIt _Zero_range(_FwdIt _First, _FwdIt _Last)
	{	// fill [_First, _Last) with zeroes
	char * const _First_ch = reinterpret_cast<char *>(_First);
	char * const _Last_ch = reinterpret_cast<char *>(_Last);
	_CSTD memset(_First_ch, 0, _Last_ch - _First_ch);
	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_value_construct_n1(_FwdIt _First, _Diff _Count, _Alloc& _Al, false_type)
	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization
	_FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, (void)++_First)
		{
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_First));
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First, _Al);
	_RERAISE;
	_CATCH_END

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_value_construct_n1(_FwdIt _First, _Diff _Count, _Alloc&, true_type)
	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type
	return (_Zero_range(_First, _First + _Count));
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_value_construct_n(_FwdIt _First, _Diff _Count, _Alloc& _Al)
	{	// value-initialize _Count objects to raw _First, using _Al
	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,
		_Conjunction_t<_Use_memset_value_construct_t<_FwdIt>,
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
	}


	// STRUCT _Not_a_node_tag
struct _Not_a_node_tag
	{	// Used as the type of a "pointer" to a non-node.
	};


		// FUNCTION TEMPLATE get_temporary_buffer
template<class _Ty>
	_NODISCARD _CXX17_DEPRECATE_TEMPORARY_BUFFER pair<_Ty *, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) _NOEXCEPT
	{	// get raw temporary buffer of up to _Count elements
	return (_Get_temporary_buffer<_Ty>(_Count));
	}

		// FUNCTION TEMPLATE return_temporary_buffer
template<class _Ty>
	_CXX17_DEPRECATE_TEMPORARY_BUFFER void return_temporary_buffer(_Ty * _Pbuf)
	{	// delete raw temporary buffer
	_Return_temporary_buffer(_Pbuf);
	}
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 330 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 3
#endif /* _XMEMORY_ */
# 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xmemory" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 2 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

_STD_BEGIN
		// COMMON SORT PARAMETERS
const int _ISORT_MAX = 32;	// maximum size for insertion sort


		// STRUCT TEMPLATE _Temporary_buffer
template<class _Diff>
	constexpr ptrdiff_t _Temporary_buffer_size(const _Diff _Value)
	{	// convert an iterator difference_type to a ptrdiff_t for use in _Temporary_buffer
	using _CT = common_type_t<ptrdiff_t, _Diff>;
	_CT _Max_possible = PTRDIFF_MAX;
	if (static_cast<_CT>(_Value) > _Max_possible)
		{
		return (PTRDIFF_MAX);
		}

	return (static_cast<ptrdiff_t>(_Value));
	}

template<class _Ty>
	struct _Temporary_buffer
	{	// temporary storage
	template<class _Diff>
		explicit _Temporary_buffer(const _Diff _Requested_size)
		{	// get temporary storage
		const pair<_Ty *, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Temporary_buffer_size(_Requested_size));
		_Data = _Raw.first;
		_Capacity = _Raw.second;
		}

	_Temporary_buffer(const _Temporary_buffer&) = delete;
	_Temporary_buffer& operator=(const _Temporary_buffer&) = delete;

	~_Temporary_buffer() _NOEXCEPT
		{	// return temporary storage
		_Return_temporary_buffer(_Data);
		}

	_Ty * _Data;
	ptrdiff_t _Capacity;
	};


		// STRUCT TEMPLATE _Temporary_range
template<class _Ty>
	struct _Temporary_range
	{	// a range of objects constructed in a temporary buffer
	using value_type = _Ty;

	explicit _Temporary_range(_Temporary_buffer<_Ty>& _Buffer)
		: _Data(_Buffer._Data),
		_Capacity(_Buffer._Capacity),
		_Size(0)
		{	// construct a range around a temporary buffer
		}

	template<class _FwdIt>
		_Temporary_range(_Temporary_buffer<_Ty>& _Buffer,
			const _FwdIt _First, const _FwdIt _Last, const ptrdiff_t _Count)
		: _Data(_Buffer._Data),
		_Capacity(_Buffer._Capacity),
		_Size(_Count)
		{	// construct a range around a temporary buffer, and move another range into it
		_Uninitialized_move_unchecked(_First, _Last, _Data);
		}

	_Temporary_range(const _Temporary_range&) = delete;
	_Temporary_range& operator=(const _Temporary_range&) = delete;

	~_Temporary_range() _NOEXCEPT
		{	// destroy constructed elements
		_Destroy_range(_Data, _Data + _Size);
		}

	_Ty * _Begin()
		{	// get the beginning of this range
		return (_Data);
		}

	_Ty * _End()
		{	// get the end of this range
		return (_Data + _Size);
		}

	void push_back(_Ty&& _Val)
		{	// add an element to the end
		_Construct_in_place(_Data[_Size], _STD move(_Val));
		++_Size;
		}

	_Ty * _Data;
	ptrdiff_t _Capacity;
	ptrdiff_t _Size;
	};

		// FUNCTION TEMPLATE for_each
template<class _InIt,
	class _Fn> inline
	_Fn for_each(_InIt _First, _InIt _Last, _Fn _Func)
	{	// perform function for each element [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		_Func(*_UFirst);
		}

	return (_Func);
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void for_each(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Fn _Func) _NOEXCEPT;

		// FUNCTION TEMPLATE for_each_n
template<class _InIt,
	class _Diff,
	class _Fn> inline
	_InIt for_each_n(_InIt _First, const _Diff _Count_raw, _Fn _Func)
	{	// perform function for each element [_First, _First + _Count)
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	auto _UFirst = _Unchecked_n(_First, _Count);
	for (; 0 < _Count; --_Count, (void)++_UFirst)
		{
		_Func(*_UFirst);
		}

	return (_Rechecked(_First, _UFirst));
	}

template<class _ExPo,
	class _FwdIt,
	class _Diff,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt for_each_n(_ExPo&& _Exec, _FwdIt _First, _Diff _Count_raw, _Fn _Func) _NOEXCEPT;

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _Fn> inline
	_InTy * for_each_n(_InTy (&_First)[_InSize], const _Diff _Count_raw, _Fn _Func)
	{	// perform function for each element [_First, _First + _Count)
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEBUG_ARRAY_SIZE(_First, _Count);
	_InTy * _UFirst = _First;
	for (; 0 < _Count; --_Count, (void)++_UFirst)
		{
		_Func(*_UFirst);
		}

	return (_UFirst);
	}

template<class _ExPo,
	class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_SourceTy * for_each_n(_ExPo&& _Exec, _SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _Fn _Func) _NOEXCEPT;
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE find_if
template<class _InIt,
	class _Pr>
	_NODISCARD inline _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			break;
			}
		}

	return (_Rechecked(_First, _UFirst));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD _FwdIt find_if(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE find_if_not
template<class _InIt,
	class _Pr>
	_NODISCARD inline _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred)
	{	// find first element that satisfies !_Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (!_Pred(*_UFirst))
			{
			break;
			}
		}

	return (_Rechecked(_First, _UFirst));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt find_if_not(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE adjacent_find
template<class _FwdIt,
	class _Pr>
	_NODISCARD inline _FwdIt adjacent_find(const _FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred with successor
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	auto _ULast = _Unchecked(_Last);
	if (_UFirst != _ULast)
		{
		for (auto _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext)
			{
			if (_Pred(*_UFirst, *_UNext))
				{
				_ULast = _UFirst;
				break;
				}
			}
		}

	return (_Rechecked(_Last, _ULast));
	}

template<class _FwdIt>
	_NODISCARD inline _FwdIt adjacent_find(const _FwdIt _First, const _FwdIt _Last)
	{	// find first matching successor
	return (_STD adjacent_find(_First, _Last, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt adjacent_find(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) _NOEXCEPT;

template<class _ExPo,
	class _FwdIt,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt adjacent_find(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last) _NOEXCEPT
	{	// find first matching successor
	return (_STD adjacent_find(_STD forward<_ExPo>(_Exec), _First, _Last, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE count_if
template<class _InIt,
	class _Pr>
	_NODISCARD inline _Iter_diff_t<_InIt> count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// count elements satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	_Iter_diff_t<_InIt> _Count = 0;
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			++_Count;
			}
		}

	return (_Count);
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _Iter_diff_t<_FwdIt> count_if(_ExPo&& _Exec,
		const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE mismatch
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2> _Mismatch_unchecked(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	while (_First1 != _Last1 && _Pred(*_First1, *_First2))
		{
		++_First1;
		++_First2;
		}

	return {_First1, _First2};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	_NODISCARD inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	_DEPRECATE_UNCHECKED(mismatch, _First2);
	_DEBUG_RANGE(_First1, _Last1);
	const auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _UFirst2 = _Unchecked_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
	return (_Rechecked_both(_First1, _First2,
		_Mismatch_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred))));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	enable_if_t<!is_same_v<_RightTy *, _Pr>, int> = 0>
	_NODISCARD inline pair<_InIt1, _RightTy *> mismatch(const _InIt1 _First1, const _InIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	return (_Unchecked_second(_STD mismatch(_First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 353 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline pair<_FwdIt1, _FwdIt2> mismatch(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred) _NOEXCEPT;

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	enable_if_t<is_execution_policy_v<decay_t<_ExPo>> && !is_same_v<_RightTy *, _Pr>, int> = 0>
	_NODISCARD inline pair<_FwdIt1, _RightTy *> mismatch(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	return (_Unchecked_second(_STD mismatch(_STD forward<_ExPo>(_Exec), _First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 378 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 379 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _InIt1,
	class _InIt2>
	_NODISCARD inline pair<_InIt1, _InIt2> mismatch(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	return (_STD mismatch(_First1, _Last1, _First2, equal_to<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _RightTy,
	size_t _RightSize>
	_NODISCARD inline pair<_InIt1, _RightTy *> mismatch(const _InIt1 _First1, const _InIt1 _Last1,
		_RightTy (&_First2)[_RightSize])
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, array source
	return (_STD mismatch(_First1, _Last1, _First2, equal_to<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline pair<_FwdIt1, _FwdIt2> mismatch(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2) _NOEXCEPT
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD mismatch(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline pair<_FwdIt1, _RightTy *> mismatch(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize]) _NOEXCEPT
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, array source
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	return (_STD mismatch(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 425 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2> _Mismatch_unchecked(_InIt1 _First1, const _InIt1 _Last1,
		_InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
		input_iterator_tag, input_iterator_tag)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch using _Pred, no special optimization
	while (_First1 != _Last1 && _First2 != _Last2 && _Pred(*_First1, *_First2))
		{
		++_First1;
		++_First2;
		}

	return {_First1, _First2};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2> _Mismatch_unchecked(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch using _Pred, random-access iterators
	using _CT = _Common_diff_t<_InIt1, _InIt2>;
	const _CT _Count1 = _Last1 - _First1;
	const _CT _Count2 = _Last2 - _First2;
	const auto _Count = static_cast<_Iter_diff_t<_InIt1>>(_Min_value(_Count1, _Count2));
	return (_Mismatch_unchecked(_First1, _First1 + _Count, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	_NODISCARD inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked_both(_First1, _First2,
		_Mismatch_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pass_fn(_Pred),
			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()
			)));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline pair<_FwdIt1, _FwdIt2> mismatch(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 480 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _InIt1,
	class _InIt2>
	_NODISCARD inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch
	return (_STD mismatch(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline pair<_FwdIt1, _FwdIt2> mismatch(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2) _NOEXCEPT
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD mismatch(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 501 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE all_of
template<class _InIt,
	class _Pr>
	_NODISCARD inline bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (!_Pred(*_UFirst))
			{
			return (false);
			}
		}

	return (true);
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool all_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 528 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE any_of
template<class _InIt,
	class _Pr>
	_NODISCARD inline bool any_of(const _InIt _First, const _InIt _Last, _Pr _Pred)
	{	// test if any element satisfies _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			return (true);
			}
		}

	return (false);
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool any_of(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE none_of
template<class _InIt,
	class _Pr>
	_NODISCARD inline bool none_of(const _InIt _First, const _InIt _Last, _Pr _Pred)
	{	// test if no elements satisfy _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			return (false);
			}
		}

	return (true);
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline bool none_of(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 582 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE copy_if
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	// copy each satisfying _Pred
	_DEPRECATE_UNCHECKED(copy_if, _Dest);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_idl0(_Dest);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			*_UDest = *_UFirst;
			++_UDest;
			}
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *copy_if(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize],
		_Pr _Pred)
	{	// copy each satisfying _Pred, array dest
	return (_Unchecked(
		_STD copy_if(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 619 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE partition_copy
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition to _Dest1, false to _Dest2
	_DEFINE_DEPRECATE_UNCHECKED(partition_copy);
	_USE_DEPRECATE_UNCHECKED(_Dest1);
	_USE_DEPRECATE_UNCHECKED(_Dest2);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest1 = _Unchecked_idl0(_Dest1);
	auto _UDest2 = _Unchecked_idl0(_Dest2);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			*_UDest1 = *_UFirst;
			++_UDest1;
			}
		else
			{
			*_UDest2 = *_UFirst;
			++_UDest2;
			}
		}

	return {_Rechecked(_Dest1, _UDest1), _Rechecked(_Dest2, _UDest2)};
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy1,
	size_t _DestSize1,
	class _OutIt2,
	class _Pr> inline
	pair<_DestTy1 *, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_DestTy1 (&_Dest1)[_DestSize1], _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition to _Dest1, false to _Dest2, array dest
	return (_Unchecked_first(
		_STD partition_copy(_First, _Last,
			_Array_iterator<_DestTy1, _DestSize1>(_Dest1), _Dest2, _Pass_fn(_Pred))));
	}

template<class _InIt,
	class _OutIt1,
	class _DestTy2,
	size_t _DestSize2,
	class _Pr> inline
	pair<_OutIt1, _DestTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _DestTy2 (&_Dest2)[_DestSize2], _Pr _Pred)
	{	// copy true partition to _Dest1, false to _Dest2, array dest
	return (_Unchecked_second(
		_STD partition_copy(_First, _Last,
			_Dest1, _Array_iterator<_DestTy2, _DestSize2>(_Dest2), _Pass_fn(_Pred))));
	}

template<class _InIt,
	class _DestTy1,
	size_t _DestSize1,
	class _DestTy2,
	size_t _DestSize2,
	class _Pr> inline
	pair<_DestTy1 *, _DestTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_DestTy1 (&_Dest1)[_DestSize1], _DestTy2 (&_Dest2)[_DestSize2],
			_Pr _Pred)
	{	// copy true partition to _Dest1, false to _Dest2, array dest
	return (_Unchecked_both(
		_STD partition_copy(_First, _Last,
				_Array_iterator<_DestTy1, _DestSize1>(_Dest1),
				_Array_iterator<_DestTy2, _DestSize2>(_Dest2), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 700 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE is_partitioned
template<class _InIt,
	class _Pr>
	_NODISCARD inline bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if [_First, _Last) partitioned by _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);

	for (;; ++_UFirst)
		{	// skip true partition
		if (_UFirst == _ULast)
			{
			return (true);
			}

		if (!_Pred(*_UFirst))
			{
			break;
			}
		}

	while (++_UFirst != _ULast)
		{	// verify false partition
		if (_Pred(*_UFirst))
			{
			return (false);	// found out of place element
			}
		}

	return (true);
	}

		// FUNCTION TEMPLATE partition_point
template<class _FwdIt,
	class _Pr>
	_NODISCARD inline _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find beginning of false partition in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _Count = _STD distance(_UFirst, _ULast);
	while (0 < _Count)
		{	// divide and conquer, find half that contains answer
		const auto _Count2 = static_cast<_Iter_diff_t<_FwdIt>>(_Count >> 1);
		const auto _UMid = _STD next(_UFirst, _Count2);

		if (_Pred(*_UMid))
			{	// try top half
			_UFirst = _Next_iter(_UMid);
			_Count -= _Count2;
			--_Count;
			}
		else
			{
			_Count = _Count2;
			}
		}

	return (_Rechecked(_First, _UFirst));
	}

		// FUNCTION TEMPLATE _Equal_rev_pred_unchecked
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_rev_pred_unchecked1(_InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred, false_type)
	{	// compare [_First1, ...) to [_First2, _Last2) using _Pred, no special optimization
	for (; _First2 != _Last2; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{
			return (false);
			}
		}

	return (true);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_rev_pred_unchecked1(const _InIt1 _First1, const _InIt2 _First2, const _InIt2 _Last2, _Pr, true_type)
	{	// compare [_First1, ...) to [_First2, _Last2), memcmp optimization
	const auto _First1_ch = reinterpret_cast<const char *>(_First1);
	const auto _First2_ch = reinterpret_cast<const char *>(_First2);
	const size_t _Count = reinterpret_cast<const char *>(_Last2) - _First2_ch;
	return (_CSTD memcmp(_First1_ch, _First2_ch, _Count) == 0);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_rev_pred_unchecked(const _InIt1 _First1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)
	{	// compare [_First1, ...) to [_First2, _Last2) using _Pred, choose optimization
	return (_Equal_rev_pred_unchecked1(_First1, _First2, _Last2, _Pred,
		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
	}

		// FUNCTION TEMPLATE search
template<class _FwdItHaystack,
	class _FwdItPat,
	class _Pr> inline
	_FwdItHaystack _Search_unchecked(_FwdItHaystack _First1, _FwdItHaystack _Last1,
		_FwdItPat _First2, _FwdItPat _Last2, _Pr _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	// find first [_First2, _Last2) satisfying _Pred, arbitrary iterators
	for (;; ++_First1)
		{	// loop until match or end of a sequence
		_FwdItHaystack _Mid1 = _First1;
		for (_FwdItPat _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
			{
			if (_Mid2 == _Last2)
				{
				return (_First1);
				}
			else if (_Mid1 == _Last1)
				{
				return (_Last1);
				}
			else if (!_Pred(*_Mid1, *_Mid2))
				{
				break;
				}
			}
		}
	}

template<class _FwdItHaystack,
	class _FwdItPat,
	class _Pr> inline
	_FwdItHaystack _Search_unchecked(_FwdItHaystack _First1, const _FwdItHaystack _Last1,
		const _FwdItPat _First2, const _FwdItPat _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// find first [_First2, _Last2) satisfying _Pred, random-access iterators
	_Iter_diff_t<_FwdItPat> _Count2 = _Last2 - _First2;
	if (_Last1 - _First1 >= _Count2)
		{
		const auto _Last_possible = _Last1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);
		for (;; ++_First1)
			{
			if (_Equal_rev_pred_unchecked(_First1, _First2, _Last2, _Pred))
				{
				return (_First1);
				}

			if (_First1 == _Last_possible)
				{
				break;
				}
			}
		}

	return (_Last1);
	}

template<class _FwdItHaystack,
	class _FwdItPat,
	class _Pr>
	_NODISCARD inline _FwdItHaystack search(_FwdItHaystack _First1, const _FwdItHaystack _Last1,
		const _FwdItPat _First2, const _FwdItPat _Last2, _Pr _Pred)
	{	// find first [_First2, _Last2) satisfying _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked(_First1,
		_Search_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pass_fn(_Pred),
			_Iter_cat_t<_FwdItHaystack>(), _Iter_cat_t<_FwdItPat>())));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdItHaystack,
	class _FwdItPat,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdItHaystack search(_ExPo&& _Exec, _FwdItHaystack _First1, const _FwdItHaystack _Last1,
		const _FwdItPat _First2, const _FwdItPat _Last2, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 880 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _FwdItHaystack,
	class _FwdItPat>
	_NODISCARD inline _FwdItHaystack search(const _FwdItHaystack _First1, const _FwdItHaystack _Last1,
		const _FwdItPat _First2, const _FwdItPat _Last2)
	{	// find first [_First2, _Last2) match
	return (_STD search(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdItHaystack,
	class _FwdItPat,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdItHaystack search(_ExPo&& _Exec, const _FwdItHaystack _First1, const _FwdItHaystack _Last1,
		const _FwdItPat _First2, const _FwdItPat _Last2) _NOEXCEPT
	{	// find first [_First2, _Last2) match
	return (_STD search(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 900 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _FwdItHaystack,
	class _Searcher>
	_NODISCARD inline _FwdItHaystack search(const _FwdItHaystack _First, const _FwdItHaystack _Last,
		const _Searcher& _Search)
	{	// find _Search's pattern in [_First, _Last)
	return (_Search(_First, _Last).first);
	}

		// FUNCTION TEMPLATE search_n
template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n_unchecked(_FwdIt _First, const _FwdIt _Last,
		const _Diff _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
	{	// find first _Count * _Val satisfying _Pred, forward iterators
	if (_Count <= 0)
		return (_First);

	for (; _First != _Last; ++_First)
		{
		if (_Pred(*_First, _Val))
			{	// found start of possible match, check it out
			_FwdIt _Mid = _First;

			for (_Diff _Count1 = _Count;;)
				{
				if (--_Count1 == 0)
					{
					return (_First);	// found rest of match, report it
					}
				else if (++_Mid == _Last)
					{
					return (_Last);	// short match at end
					}
				else if (!_Pred(*_Mid, _Val))
					{	// short match not at end
					break;
					}
				}

			_First = _Mid;	// pick up just beyond failed match
			}
		}

	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n_unchecked(_FwdIt _First, const _FwdIt _Last,
		const _Diff _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
	{	// find first _Count * _Val satisfying _Pred, random-access iterators
	if (_Count <= 0)
		{
		return (_First);
		}

	if (static_cast<uintmax_t>(_Count)
		> static_cast<uintmax_t>((numeric_limits<_Iter_diff_t<_FwdIt>>::max)()))
		{	// if the number of _Vals searched for is larger than the longest possible
			// sequence, we can't find it
		return (_Last);
		}

	const auto _Count_diff = static_cast<_Iter_diff_t<_FwdIt>>(_Count);
	_FwdIt _Old_first = _First;
	for (_Iter_diff_t<_FwdIt> _Inc = 0; _Count_diff <= _Last - _Old_first; )
		{	// enough room, look for a match
		_First = _Old_first + _Inc;
		if (_Pred(*_First, _Val))
			{	// found part of possible match, check it out
			_Iter_diff_t<_FwdIt> _Count1 = _Count_diff;
			_FwdIt _Mid = _First;

			for (; _Old_first != _First && _Pred(_First[-1], _Val);
				--_First)
				--_Count1;	// back up over any skipped prefix

			if (_Count1 <= _Last - _Mid)
				{
				for (;;)
					{	// enough left, test suffix
					if (--_Count1 == 0)
						{
						return (_First);	// found rest of match, report it
						}
					else if (!_Pred(*++_Mid, _Val))
						{	// short match not at end
						break;
						}
					}
				}
			_Old_first = ++_Mid;	// failed match, take small jump
			_Inc = 0;
			}
		else
			{	// no match, take big jump and back up as needed
			_Old_first = _First + 1;
			_Inc = _Count_diff - 1;
			}
		}

	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr>
	_NODISCARD inline _FwdIt search_n(_FwdIt _First, const _FwdIt _Last,
		const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred)
	{	// find first _Count * _Val satisfying _Pred
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Search_n_unchecked(_Unchecked(_First), _Unchecked(_Last), _Count, _Val,
			_Pass_fn(_Pred), _Iter_cat_t<_FwdIt>())));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt search_n(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last,
		const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 1033 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _FwdIt,
	class _Diff,
	class _Ty>
	_NODISCARD inline _FwdIt search_n(const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty& _Val)
	{	// find first _Count * _Val match
	return (_STD search_n(_First, _Last, _Count, _Val, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Diff,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt search_n(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last,
		const _Diff _Count, const _Ty& _Val) _NOEXCEPT
	{	// find first _Count * _Val match
	return (_STD search_n(_STD forward<_ExPo>(_Exec), _First, _Last, _Count, _Val, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 1054 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE find_end
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_end_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	// find last [_First2, _Last2) satisfying _Pred in forward ranges
	_FwdIt1 _Result = _Last1;
	for (;;)
		{	// try a match at _First1
		_FwdIt1 _Next1 = _First1;
		_FwdIt2 _Next2 = _First2;
		for (;;)
			{	// test if [_First2, _Last2) is a prefix of [_First1, _Last1)
			const bool _End_of_needle = static_cast<bool>(_Next2 == _Last2);
			if (_End_of_needle)
				{	// match candidate found
				_Result = _First1;
				}

			if (_Next1 == _Last1)
				{	// trying the next candidate would make [_First1, _Last1) shorter than [_First2, _Last2), done
				return (_Result);
				}

			if (_End_of_needle || !_Pred(*_Next1, *_Next2))
				{	// end of match or counterexample found, go to the next candidate
				break;
				}

			++_Next1;
			++_Next2;
			}

		++_First1;
		}
	}

template<class _BidIt1,
	class _BidIt2,
	class _Pr> inline
	_BidIt1 _Find_end_unchecked(const _BidIt1 _First1, const _BidIt1 _Last1,
		const _BidIt2 _First2, const _BidIt2 _Last2, _Pr _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	// find last [_First2, _Last2) satisfying _Pred in bidirectional ranges
	for (_BidIt1 _Candidate = _Last1; ; --_Candidate)
		{	// try a match at _Candidate
		_BidIt1 _Next1 = _Candidate;
		_BidIt2 _Next2 = _Last2;
		for (;;)
			{	// test if [_First2, _Last2) is a suffix of [_First1, _Candidate)
			if (_First2 == _Next2)
				{	// match found
				return (_Next1);
				}

			if (_First1 == _Next1)
				{	// [_First1, _Candidate) is shorter than [_First2, _Last2), remaining candidates nonviable
				return (_Last1);
				}

			--_Next1;
			--_Next2;
			if (!_Pred(*_Next1, *_Next2))
				{	// counterexample found
				break;
				}
			}
		}
	}

template<class _RanIt1,
	class _RanIt2,
	class _Pr> inline
	_RanIt1 _Find_end_unchecked(const _RanIt1 _First1, const _RanIt1 _Last1,
		const _RanIt2 _First2, const _RanIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// find last [_First2, _Last2) satisfying _Pred in random-access ranges
	const _Iter_diff_t<_RanIt2> _Count2 = _Last2 - _First2;
	if (0 < _Count2 && _Count2 <= _Last1 - _First1)
		{
		for (_RanIt1 _Candidate = _Last1 - static_cast<_Iter_diff_t<_RanIt1>>(_Count2); ; --_Candidate)
			{
			if (_Equal_rev_pred_unchecked(_Candidate, _First2, _Last2, _Pred))
				{
				return (_Candidate);
				}

			if (_First1 == _Candidate)
				{
				break;
				}
			}
		}

	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_NODISCARD inline _FwdIt1 find_end(_FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred)
	{	// find last [_First2, _Last2) satisfying _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked(_First1,
		_Find_end_unchecked(_Unchecked(_First1), _Unchecked(_Last1), _Unchecked(_First2), _Unchecked(_Last2),
		_Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>())));
	}

template<class _FwdIt1,
	class _FwdIt2>
	_NODISCARD inline _FwdIt1 find_end(_FwdIt1 const _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2)
	{	// find last [_First2, _Last2) match
	return (_STD find_end(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt1 find_end(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) _NOEXCEPT;

template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt1 find_end(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2) _NOEXCEPT
	{	// find last [_First2, _Last2) match
	return (_STD find_end(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 1194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE find_first_of
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_NODISCARD inline _FwdIt1 find_first_of(_FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred)
	{	// look for one of [_First2, _Last2) satisfying _Pred with element
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	for (; _UFirst1 != _ULast1; ++_UFirst1)
		{
		for (auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++_UMid2)
			{
			if (_Pred(*_UFirst1, *_UMid2))
				{
				return (_Rechecked(_First1, _UFirst1));
				}
			}
		}

	return (_Rechecked(_First1, _UFirst1));
	}

template<class _FwdIt1,
	class _FwdIt2>
	_NODISCARD inline _FwdIt1 find_first_of(const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2)
	{	// look for one of [_First2, _Last2) that matches element
	return (_STD find_first_of(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt1 find_first_of(_ExPo&& _Exec, const _FwdIt1 _First1, _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) _NOEXCEPT;

template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt1 find_first_of(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, const _FwdIt2 _Last2) _NOEXCEPT
	{	// look for one of [_First2, _Last2) that matches element
	return (_STD find_first_of(_STD forward<_ExPo>(_Exec), _First1, _Last1,
		_First2, _Last2, equal_to<>()));
	}
#endif /* _HAS_CXX17 */
# 1250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3


		// FUNCTION TEMPLATE swap_ranges
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	// swap [_First1, _Last1) with [_Dest, ...)
	for (; _First1 != _Last1; ++_First1, (void)++_Dest)
		_STD iter_swap(_First1, _Dest);
	return (_Dest);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	// swap [_First1, _Last1) with [_Dest, ...)
	_DEPRECATE_UNCHECKED(swap_ranges, _Dest);
	_DEBUG_RANGE(_First1, _Last1);
	const auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
	return (_Rechecked(_Dest,
		_Swap_ranges_unchecked(_UFirst1, _ULast1, _UDest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _FwdIt1,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _DestTy (&_Dest)[_DestSize])
	{	// swap [_First1, _Last1) with [_Dest, ...), array dest
	return (_Unchecked(
		_STD swap_ranges(_First1, _Last1,
		_Array_iterator<_DestTy, _DestSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 swap_ranges(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _Dest) _NOEXCEPT // Enforces termination
	{	// swap [_First1, _Last1) with [_Dest, ...)
		// not parallelized as benchmarks show it isn't worth it
	return (_STD swap_ranges(_First1, _Last1, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _DestTy,
	size_t _DestSize,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy *swap_ranges(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1,
		_DestTy (&_Dest)[_DestSize]) _NOEXCEPT // Enforces termination
	{	// swap [_First1, _Last1) with [_Dest, ...), array dest
		// not parallelized as benchmarks show it isn't worth it
	return (_STD swap_ranges(_First1, _Last1, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 1314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE transform
template<class _InIt,
	class _OutIt,
	class _Fn> inline
	_OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func)
	{	// transform [_First, _Last) with _Func
	_DEPRECATE_UNCHECKED(transform, _Dest);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	for (; _UFirst != _ULast; ++_UFirst, (void)++_UDest)
		{
		*_UDest = _Func(*_UFirst);
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Fn> inline
	_DestTy * transform(const _InIt _First, const _InIt _Last, _DestTy (&_Dest)[_DestSize], _Fn _Func)
	{	// transform [_First, _Last) with _Func, array dest
	return (_Unchecked(
		_STD transform(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1346 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 transform(_ExPo&& _Exec, const _FwdIt1 _First, const _FwdIt1 _Last, _FwdIt2 _Dest, _Fn _Func) _NOEXCEPT;

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _DestTy,
	size_t _DestSize,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy * transform(_ExPo&& _Exec, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize], _Fn _Func) _NOEXCEPT
	{	// transform [_First, _Last) with _Func, array dest
	return (_Unchecked(
		_STD transform(_STD forward<_ExPo>(_Exec), _First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 1370 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn> inline
	_OutIt transform(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _OutIt _Dest, _Fn _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	_DEFINE_DEPRECATE_UNCHECKED(transform);
	_USE_DEPRECATE_UNCHECKED(_First2);
	_USE_DEPRECATE_UNCHECKED(_Dest);
	_DEBUG_RANGE(_First1, _Last1);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	const auto _Count = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
	auto _UFirst2 = _Unchecked_n(_First2, _Count);
	auto _UDest = _Unchecked_n(_Dest, _Count);
	for (; _UFirst1 != _ULast1; ++_UFirst1, (void)++_UFirst2, ++_UDest)
		{
		*_UDest = _Func(*_UFirst1, *_UFirst2);
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _RightTy,
	size_t _RightSize,
	class _OutIt,
	class _Fn> inline
	_OutIt transform(const _InIt1 _First1, const _InIt1 _Last1,
		_RightTy (&_First2)[_RightSize], const _OutIt _Dest, _Fn _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array source
	return (_STD transform(_First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Dest, _Pass_fn(_Func)));
	}

template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize,
	class _Fn> inline
	_DestTy *transform(const _InIt1 _First1, const _InIt1 _Last1,
		_InIt2 _First2, _DestTy (&_Dest)[_DestSize], _Fn _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array dest
	return (_Unchecked(
		_STD transform(_First1, _Last1,
			_First2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))));
	}

template<class _InIt1,
	class _RightTy,
	size_t _RightSize,
	class _DestTy,
	size_t _DestSize,
	class _Fn> inline
	_DestTy * transform(const _InIt1 _First1, const _InIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _DestTy (&_Dest)[_DestSize], _Fn _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array source/dest
	return (_Unchecked(
		_STD transform(_First1, _Last1,
			_Array_iterator<_RightTy, _RightSize>(_First2),
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1436 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt3 transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		const _FwdIt2 _First2, _FwdIt3 _Dest, _Fn _Func) _NOEXCEPT;

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	class _FwdIt3,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt3 transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize], const _FwdIt3 _Dest, _Fn _Func) _NOEXCEPT
	{	// transform [_First1, _Last1) and [_First2, ...), array source
	return (_STD transform(_STD forward<_ExPo>(_Exec), _First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Dest, _Pass_fn(_Func)));
	}

template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	class _DestTy,
	size_t _DestSize,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy * transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_FwdIt2 _First2, _DestTy (&_Dest)[_DestSize], _Fn _Func) _NOEXCEPT
	{	// transform [_First1, _Last1) and [_First2, ...), array dest
	return (_Unchecked(
		_STD transform(_STD forward<_ExPo>(_Exec), _First1, _Last1,
			_First2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))));
	}

template<class _ExPo,
	class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	class _DestTy,
	size_t _DestSize,
	class _Fn,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy * transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _DestTy (&_Dest)[_DestSize], _Fn _Func) _NOEXCEPT
	{	// transform [_First1, _Last1) and [_First2, ...), array source/dest
	return (_Unchecked(
		_STD transform(_STD forward<_ExPo>(_Exec), _First1, _Last1,
			_Array_iterator<_RightTy, _RightSize>(_First2),
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1494 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 1495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE replace
template<class _FwdIt,
	class _Ty> inline
	void replace(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval)
	{	// replace each matching _Oldval with _Newval
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (*_UFirst == _Oldval)
			{
			*_UFirst = _Newval;
			}
		}
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void replace(_ExPo&& _Exec,
		const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 1521 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE replace_if
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	// replace each satisfying _Pred with _Val
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (_Pred(*_UFirst))
			{
			*_UFirst = _Val;
			}
		}
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void replace_if(_ExPo&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 1549 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE replace_copy
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	_DEPRECATE_UNCHECKED(replace_copy, _Dest);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	for (; _UFirst != _ULast; ++_UFirst, (void)++_UDest)
		{
		if (*_UFirst == _Oldval)
			{
			*_UDest = _Newval;
			}
		else
			{
			*_UDest = *_UFirst;
			}
		}
	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Ty> inline
	_DestTy *replace_copy(_InIt _First, _InIt _Last,
		_DestTy (&_Dest)[_DestSize], const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval, array dest
	return (_Unchecked(
		_STD replace_copy(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Oldval, _Newval)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1589 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE replace_copy_if
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	_DEPRECATE_UNCHECKED(replace_copy_if, _Dest);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	for (; _UFirst != _ULast; ++_UFirst, (void)++_UDest)
		{
		if (_Pred(*_UFirst))
			{
			*_UDest = _Val;
			}
		else
			{
			*_UDest = *_UFirst;
			}
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Pr,
	class _Ty> inline
	_DestTy *replace_copy_if(_InIt _First, _InIt _Last,
		_DestTy (&_Dest)[_DestSize], _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val, array dest
	return (_Unchecked(
		_STD replace_copy_if(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred), _Val)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1632 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE generate
template<class _FwdIt,
	class _Fn> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn _Func)
	{	// replace [_First, _Last) with _Func()
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		*_UFirst = _Func();
		}
	}

		// FUNCTION TEMPLATE generate_n
template<class _OutIt,
	class _Diff,
	class _Fn> inline
	_OutIt generate_n(_OutIt _Dest, const _Diff _Count_raw, _Fn _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	auto _UDest = _Unchecked_n(_Dest, _Count);
	for (; 0 < _Count; --_Count, (void)++_UDest)
		{
		*_UDest = _Func();
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _DestTy,
	size_t _DestSize,
	class _Diff,
	class _Fn> inline
	_DestTy *generate_n(_DestTy (&_Dest)[_DestSize], const _Diff _Count_raw, _Fn _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func(), array dest
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	_DestTy * _UDest = _Dest;
	for (; 0 < _Count; --_Count, (void)++_UDest)
		{
		*_UDest = _Func();
		}

	return (_UDest);
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1681 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE remove_copy
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	_DEPRECATE_UNCHECKED(remove_copy, _Dest);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_idl0(_Dest);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (!(*_UFirst == _Val))
			{
			*_UDest = *_UFirst;
			++_UDest;
			}
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Ty> inline
	_DestTy *remove_copy(_InIt _First, _InIt _Last,
		_DestTy (&_Dest)[_DestSize], const _Ty& _Val)
	{	// copy omitting each matching _Val, array dest
	return (_Unchecked(
		_STD remove_copy(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Val)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE remove_copy_if
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	// copy omitting each element satisfying _Pred
	_DEPRECATE_UNCHECKED(remove_copy_if, _Dest);
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_idl0(_Dest);
	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (!_Pred(*_UFirst))
			{
			*_UDest = *_UFirst;
			++_UDest;
			}
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *remove_copy_if(_InIt _First, _InIt _Last,
		_DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// copy omitting each element satisfying _Pred, array dest
	return (_Unchecked(
		_STD remove_copy_if(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1755 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE remove
template<class _FwdIt,
	class _Ty>
	_NODISCARD inline _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val)
	{	// remove each matching _Val
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	_UFirst = _Find_unchecked(_UFirst, _ULast, _Val);
	auto _UNext = _UFirst;
	if (_UFirst != _ULast)
		{
		while (++_UFirst != _ULast)
			{
			if (!(*_UFirst == _Val))
				{
				*_UNext = _STD move(*_UFirst);
				++_UNext;
				}
			}
		}

	return (_Rechecked(_First, _UNext));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Ty,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt remove(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 1788 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE remove_if
template<class _FwdIt,
	class _Pr>
	_NODISCARD inline _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	_UFirst = _STD find_if(_UFirst, _ULast, _Pass_fn(_Pred));
	auto _UNext = _UFirst;
	if (_UFirst != _ULast)
		{
		while (++_UFirst != _ULast)
			{
			if (!_Pred(*_UFirst))
				{
				*_UNext = _STD move(*_UFirst);
				++_UNext;
				}
			}
		}

	return (_Rechecked(_First, _UNext));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0>
	_NODISCARD inline _FwdIt remove_if(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, _Pr _Pred) _NOEXCEPT;
#endif /* _HAS_CXX17 */
# 1821 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE unique WITH PRED
template<class _FwdIt,
	class _Pr>
	_NODISCARD inline _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred with previous
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	if (_UFirst != _ULast)
		{
		for (auto _UFirstb = _UFirst; ++_UFirst != _ULast; _UFirstb = _UFirst)
			{
			if (_Pred(*_UFirstb, *_UFirst))
				{	// copy down
				while (++_UFirst != _ULast)
					{
					if (!_Pred(*_UFirstb, *_UFirst))
						{
						*++_UFirstb = _STD move(*_UFirst);
						}
					}

				return (_Rechecked(_Last, ++_UFirstb));
				}
			}
		}

	return (_Rechecked(_Last, _ULast));
	}

		// FUNCTION TEMPLATE unique
template<class _FwdIt>
	_NODISCARD inline _FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	// remove each matching previous
	return (_STD unique(_First, _Last, equal_to<>()));
	}

		// FUNCTION TEMPLATE unique_copy WITH PRED
template<class _FwdIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy_unchecked(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Pr _Pred, true_type, _Any_tag)
	{	// copy compressing pairs satisfying _Pred, forward source iterator
		// (can reread the source for comparison)
	if (_First != _Last)
		{
		_FwdIt _Firstb = _First;

		*_Dest = *_Firstb;
		++_Dest;

		while (++_First != _Last)
			{
			if (!_Pred(*_Firstb, *_First))
				{	// copy unmatched
				_Firstb = _First;
				*_Dest = *_Firstb;
				++_Dest;
				}
			}
		}

	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Pr> inline
	_FwdIt _Unique_copy_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Pr _Pred, false_type, true_type)
	{	// copy compressing pairs satisfying _Pred, forward dest iterator with matching T
		// (assignment copies T; can reread dest for comparison)
	if (_First != _Last)
		{
		*_Dest = *_First;

		while (++_First != _Last)
			{
			if (!_Pred(*_Dest, *_First))
				{
				*++_Dest = *_First;
				}
			}

		++_Dest;
		}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, false_type, false_type)
	{	// copy compressing pairs satisfying _Pred, otherwise
		// (can't reread source or dest, construct a temporary)
	if (_First != _Last)
		{
		_Iter_value_t<_InIt> _Val = *_First;

		*_Dest = _Val;
		++_Dest;

		while (++_First != _Last)
			{
			if (!_Pred(_Val, *_First))
				{	// copy unmatched
				_Val = *_First;
				*_Dest = _Val;
				++_Dest;
				}
			}
		}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy compressing pairs that match
	_DEPRECATE_UNCHECKED(unique_copy, _Dest);
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_Dest,
		_Unique_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked_idl0(_Dest), _Pass_fn(_Pred),
			is_base_of<forward_iterator_tag, _Iter_cat_t<_InIt>>(), // to avoid ambiguity
			_Conjunction_t<is_base_of<forward_iterator_tag, _Iter_cat_t<_OutIt>>,
				is_same<_Iter_value_t<_InIt>, _Iter_value_t<_OutIt>>>()
			)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *unique_copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// copy compressing pairs that match, array dest
	return (_Unchecked(
		_STD unique_copy(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1970 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE unique_copy
template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// copy compressing pairs that match
	return (_STD unique_copy(_First, _Last, _Dest, equal_to<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *unique_copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize])
	{	// copy compressing pairs that match, array dest
	return (_STD unique_copy(_First, _Last, _Dest, equal_to<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 1988 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE reverse_copy
template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	_DEPRECATE_UNCHECKED(reverse_copy, _Dest);
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_BidIt>(_UFirst, _ULast));
	for (; _UFirst != _ULast; ++_UDest)
		{
		*_UDest = *--_ULast;
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _BidIt,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *reverse_copy(_BidIt _First, _BidIt _Last, _DestTy (&_Dest)[_DestSize])
	{	// copy reversing elements in [_First, _Last), array dest
	return (_Unchecked(
		_STD reverse_copy(_First, _Last,
			_Array_iterator<_DestTy, _DestSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2019 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

#if _HAS_CXX17
template<class _ExPo,
	class _BidIt,
	class _FwdIt,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt reverse_copy(_ExPo&&, _BidIt _First, _BidIt _Last, _FwdIt _Dest) _NOEXCEPT // Enforces termination
	{	// copy reversing elements in [_First, _Last)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt);
	return (_STD reverse_copy(_First, _Last, _Dest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _ExPo,
	class _BidIt,
	class _DestTy,
	size_t _DestSize,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_DestTy *reverse_copy(_ExPo&&, _BidIt _First, _BidIt _Last,
		_DestTy (&_Dest)[_DestSize]) _NOEXCEPT // Enforces termination
	{	// copy reversing elements in [_First, _Last), array dest
		// not parallelized as benchmarks show it isn't worth it
	return (_STD reverse_copy(_First, _Last, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2045 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 2046 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE rotate_copy
template<class _FwdIt,
	class _OutIt> inline
	_OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{	// copy rotating [_First, _Last)
	_DEBUG_RANGE(_First, _Mid);
	_DEBUG_RANGE(_Mid, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _UMid = _Unchecked(_Mid);
	const auto _ULast = _Unchecked(_Last);
	auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_FwdIt>(_UFirst, _ULast));
	_UDest = _Copy_unchecked(_UMid, _ULast, _UDest);
	return (_Rechecked(_Dest, _Copy_unchecked(_UFirst, _UMid, _UDest)));
	}

#if _HAS_CXX17
template<class _ExPo,
	class _FwdIt1,
	class _FwdIt2,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	_FwdIt2 rotate_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Mid, _FwdIt1 _Last,
		_FwdIt2 _Dest) _NOEXCEPT // Enforces termination
	{	// copy rotating [_First, _Last)
		// not parallelized as benchmarks show it isn't worth it
	_REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
	return (_STD rotate_copy(_First, _Mid, _Last, _Dest));
	}

		// FUNCTION TEMPLATE sample
template<class _PopIt,
	class _SampleIt,
	class _Diff,
	class _RngFn> inline
	_SampleIt _Sample_reservoir_unchecked(_PopIt _First, const _PopIt _Last, const _SampleIt _Dest,
		const _Diff _Count, _RngFn& _RngFunc)
	{	// source is input: use reservoir sampling (unstable)
		// pre: _SampleIt is random-access && 0 < _Count && the range [_Dest, _Dest + _Count) is valid
	using _Diff_sample = _Iter_diff_t<_SampleIt>;
	const auto _SCount = static_cast<_Diff_sample>(_Count);
	_Iter_diff_t<_PopIt> _PopSize{};
	for (; _PopSize < _SCount; ++_PopSize, (void)++_First)
		{
		// _PopSize is less than _SCount, and [_Dest, _Dest + _SCount) is valid,
		// so [_Dest, _Dest + _PopSize) must be valid, so narrowing to _Diff_sample
		// can't overflow
		const auto _Sample_pop = static_cast<_Diff_sample>(_PopSize);
		if (_First == _Last)
			{
			return (_Dest + _Sample_pop);
			}

		_Dest[_Sample_pop] = *_First;
		}
	for (; _First != _Last; ++_First)
		{
		const auto _Idx = _RngFunc(++_PopSize);
		if (_Idx < _SCount)
			{
			_Dest[static_cast<_Diff_sample>(_Idx)] = *_First; // again, valid narrowing because _Idx < _SCount
			}
		}
	return (_Dest + _SCount);
	}

template<class _PopIt,
	class _SampleIt,
	class _Diff,
	class _RngFn> inline
	_SampleIt _Sample_selection_unchecked(_PopIt _First, const _PopIt _Last,
		make_unsigned_t<_Iter_diff_t<_PopIt>> _PopSize, _SampleIt _Dest,
		_Diff _Count, _RngFn& _RngFunc)
	{	// source is forward *and* we know the source range size: use selection sampling (stable)
		// pre: _PopIt is forward && _Count <= _PopSize
	using _CT = common_type_t<_Iter_diff_t<_PopIt>, _Diff>;
	for (; _Count > 0 && _First != _Last; ++_First, (void)--_PopSize)
		{
		if (static_cast<_CT>(_RngFunc(_PopSize)) < static_cast<_CT>(_Count))
			{
			--_Count;
			*_Dest = *_First;
			++_Dest;
			}
		}
	return (_Dest);
	}

template<class _PopIt,
	class _SampleIt,
	class _Diff,
	class _RngFn> inline
	_SampleIt _Sample1(_PopIt _First, _PopIt _Last, _SampleIt _Dest,
		_Diff _Count, _RngFn& _RngFunc, input_iterator_tag)
	{	// source is input: use reservoir sampling (unstable)
		// pre: _Count > 0
	return (_Rechecked(_Dest,
		_Sample_reservoir_unchecked(_First, _Last, _Unchecked_idl0(_Dest), _Count,
		_RngFunc)));
	}

template<class _PopIt,
	class _SampleIt,
	class _Diff,
	class _RngFn> inline
	_SampleIt _Sample1(_PopIt _First, _PopIt _Last, _SampleIt _Dest,
		_Diff _Count, _RngFn& _RngFunc, forward_iterator_tag)
	{	// source is forward: use selection sampling (stable)
		// pre: _Count > 0
	using _PopDiff = _Iter_diff_t<_PopIt>;
	using _CT = common_type_t<_Diff, _PopDiff>;
	const auto _PopSize = _STD distance(_First, _Last);
	if (static_cast<_CT>(_Count) > static_cast<_CT>(_PopSize))
		{
		_Count = static_cast<_Diff>(_PopSize); // narrowing OK because _Count is getting smaller
		}

	return (_Rechecked(_Dest,
		_Sample_selection_unchecked(_First, _Last, _PopSize, _Unchecked_n(_Dest, _Count),
		_Count, _RngFunc)));
	}

template<class _PopIt,
	class _SampleIt,
	class _Diff,
	class _Urng> inline
	_SampleIt sample(_PopIt _First, _PopIt _Last, _SampleIt _Dest,
		_Diff _Count, _Urng&& _Func)
	{	// randomly select _Count elements from [_First, _Last) into _Dest
	static_assert(is_base_of_v<forward_iterator_tag, _Iter_cat_t<_PopIt>>
		|| is_base_of_v<random_access_iterator_tag, _Iter_cat_t<_SampleIt>>,
		"If the source range is not forward, the destination range must be random-access.");
	static_assert(is_integral_v<_Diff>,
		"The sample size must have an integer type.");
	_DEBUG_RANGE(_First, _Last);
	if (_Count <= 0)
		{
		return (_Dest);
		}

	_Rng_from_urng<_Iter_diff_t<_PopIt>, remove_reference_t<_Urng>> _RngFunc(_Func);
	return (_Sample1(_Unchecked(_First), _Unchecked(_Last), _Dest, _Count,
		_RngFunc, _Iter_cat_t<_PopIt>()));
	}

#if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _PopIt,
	class _DestTy,
	size_t _DestSize,
	class _Diff,
	class _Urng> inline
	_DestTy *sample(_PopIt _First, _PopIt _Last, _DestTy (&_Dest)[_DestSize],
		_Diff _Count, _Urng&& _Func)
	{	// randomly select _Count elements from [_First, _Last) into _Dest
	return (_Unchecked(
		_STD sample(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest),
			_Count, _Func)));
	}
#endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _HAS_CXX17 */
# 2205 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE shuffle WITH URNG
template<class _RanIt,
	class _RngFn> inline
	void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc)
	{	// shuffle [_First, _Last) using random function _RngFunc
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	if (_UFirst == _ULast)
		{
		return;
		}

	using _Diff = _Iter_diff_t<_Unchecked_t<_RanIt>>;
	auto _UTarget = _UFirst;
	_Diff _Target_index = 1;
	for (; ++_UTarget != _ULast; ++_Target_index)
		{	// randomly place an element from [_First, _Target] at _Target
		_Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));
		_IDL_VERIFY(0 <= _Off && _Off <= _Target_index, "random value out of range");
		if (_Off != _Target_index)	// avoid self-move-assignment
			{
			_STD iter_swap(_UTarget, _UFirst + _Off);
			}
		}
	}

template<class _RanIt,
	class _Urng> inline
	void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
	{	// shuffle [_First, _Last) using URNG _Func
	typedef remove_reference_t<_Urng> _Urng0;
	_Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);
	_Random_shuffle1(_First, _Last, _RngFunc);
	}

 #if _HAS_AUTO_PTR_ETC
		// FUNCTION TEMPLATE random_shuffle WITH RANDOM FN
template<class _RanIt,
	class _RngFn> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _RngFn&& _RngFunc)
	{	// shuffle [_First, _Last) using random function _RngFunc
	_Random_shuffle1(_First, _Last, _RngFunc);
	}

	// STRUCT _Rand_urng_from_func
struct _Rand_urng_from_func
	{	// wrap rand() as a URNG
	typedef unsigned int result_type;

	static result_type (min)()
		{	// return minimum possible generated value
		return (0);
		}

	static result_type (max)()
		{	// return maximum possible generated value
		return (RAND_MAX);
		}

	result_type operator()()
		{	// invoke rand()
		return (_CSTD rand());
		}
	};

		// FUNCTION TEMPLATE random_shuffle
template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	// shuffle [_First, _Last) using rand()
	_Rand_urng_from_func _Func;
	_STD shuffle(_First, _Last, _Func);
	}
 #endif /* _HAS_AUTO_PTR_ETC */
# 2280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE partition
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		forward_iterator_tag)
	{	// move elements satisfying _Pred to front, forward iterators
	for (;;)
		{	// skip in-place elements at beginning
		if (_First == _Last)
			{
			return (_First);
			}

		if (!_Pred(*_First))
			{
			break;
			}

		++_First;
		}

	for (_FwdIt _Next = _First; ++_Next != _Last; )
		{
		if (_Pred(*_Next))
			{
			_STD iter_swap(_First, _Next);	// out of place, swap and loop
			++_First;
			}
		}

	return (_First);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred,
		bidirectional_iterator_tag)
	{	// move elements satisfying _Pred to front, bidirectional iterators
	for (;;)
		{	// find any out-of-order pair
		for (;;)
			{	// skip in-place elements at beginning
			if (_First == _Last)
				{
				return (_First);
				}

			if (!_Pred(*_First))
				{
				break;
				}

			++_First;
			}

		do
			{	// skip in-place elements at end
			--_Last;
			if (_First == _Last)
				{
				return (_First);
				}
			}
		while (!_Pred(*_Last));

		_STD iter_swap(_First, _Last);	// out of place, swap and loop
		++_First;
		}
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// move elements satisfying _Pred to beginning of sequence
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Partition_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred),
			_Iter_cat_t<_FwdIt>())));
	}

		// FUNCTION TEMPLATE stable_partition
template<class _BidIt,
	class _Ty> inline
	_BidIt _Buffered_rotate_unchecked(const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
		const _Iter_diff_t<_BidIt> _Count1, const _Iter_diff_t<_BidIt> _Count2, _Temporary_buffer<_Ty>& _Temp_buf)
	{	// rotate [_First, _Last) using temp buffer
		// precondition: _Count1 == distance(_First, _Mid)
		// precondition: _Count2 == distance(_Mid, _Last)
	if (_Count1 == 0)
		{
		return (_Last);
		}

	if (_Count2 == 0)
		{
		return (_First);
		}

	using _CT = common_type_t<ptrdiff_t, _Iter_diff_t<_BidIt>>;
	const auto _Capacity = static_cast<_CT>(_Temp_buf._Capacity);
	if (_Count1 <= _Count2 && static_cast<_CT>(_Count1) <= _Capacity)
		{	// buffer left range, then copy parts
		_Temporary_range<_Ty> _Temp(_Temp_buf, _First, _Mid, static_cast<ptrdiff_t>(_Count1));
		const _BidIt _New_mid = _Move_unchecked(_Mid, _Last, _First);
		_Move_unchecked(_Temp._Begin(), _Temp._End(), _New_mid);
		return (_New_mid);
		}

	if (static_cast<_CT>(_Count2) <= _Capacity)
		{	// buffer right range, then copy parts
		_Temporary_range<_Ty> _Temp(_Temp_buf, _Mid, _Last, static_cast<ptrdiff_t>(_Count2));
		_Move_backward_unchecked(_First, _Mid, _Last);
		return (_Move_unchecked(_Temp._Begin(), _Temp._End(), _First));
		}

	// buffer too small, rotate in place
	return (_Rotate_unchecked(_First, _Mid, _Last));
	}

template<class _BidIt,
	class _Pr,
	class _Ty> inline
	pair<_BidIt, _Iter_diff_t<_BidIt>> _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr _Pred,
		const _Iter_diff_t<_BidIt> _Count, _Temporary_buffer<_Ty>& _Temp_buf)
	{	// implement stable_partition of [_First, _Last] (note: closed range)
		// precondition: !_Pred(*_First)
		// precondition: _Pred(*_Last)
		// precondition: distance(_First, _Last) + 1 == _Count
		// note: _Count >= 2 and _First != _Last
		// returns: a pair such that first is the partition point, and second is distance(_First, partition point)
	using _Diff = _Iter_diff_t<_BidIt>;
	if (_Count - static_cast<_Diff>(1) <= _Temp_buf._Capacity) // - 1 since we never need to store *_Last
		{
		_Temporary_range<_Ty> _Temp{_Temp_buf};
		_BidIt _Next = _First;
		_Temp.push_back(_STD move(*_First));
		while (++_First != _Last)
			{	// test each element, copying to _Temp_buf if it's in the false range, or assigning backwards
				// if it's in the true range
			if (_Pred(*_First))
				{
				*_Next = _STD move(*_First);
				++_Next;
				}
			else
				{
				_Temp.push_back(_STD move(*_First));
				}
			}

		// move the last true element, *_Last, to the end of the true range
		*_Next = _STD move(*_Last);
		++_Next;
		_Move_unchecked(_Temp._Begin(), _Temp._End(), _Next);	// copy back the false range
		return (pair<_BidIt, _Diff>(_Next, static_cast<_Diff>(_Count - static_cast<_Diff>(_Temp._Size))));
		}

	const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); // note: >= 1 because _Count >= 2
	const _BidIt _Mid = _STD next(_First, _Mid_offset);

	// form [_First, _Left) true range, [_Left, _Mid) false range
	_BidIt _Left = _Mid;
	_Diff _Left_true_count = _Mid_offset;
	for (;;)
		{	// skip over the trailing false range before _Mid
		--_Left;
		if (_First == _Left)
			{	// the entire left range is false
			--_Left_true_count;	// to exclude *_First
			break;
			}

		if (_Pred(*_Left))
			{	// excluded the false range before _Mid, invariants reestablished, recurse
			const pair<_BidIt, _Diff> _Low =
				_Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_buf);
			_Left = _Low.first;
			_Left_true_count = _Low.second;
			break;
			}

		--_Left_true_count;
		}

	// form [_Mid, _Right) true range, [_Right, next(_Last)) false range
	_BidIt _Right = _Mid;
	_Diff _Right_true_count = 0;
	for (;;)
		{	// skip over the leading true range after and including _Mid
		if (_Right == _Last)
			{	// the entire right range is true
			++_Right;	// to include _Last
			++_Right_true_count;
			break;
			}

		if (!_Pred(*_Right))
			{	// excluded the true range after and including _Mid, invariants reestablished, recurse
			const _Diff _Right_count = _Count - _Mid_offset;
			const _Diff _Remaining = _Right_count - _Right_true_count;
			const pair<_BidIt, _Diff> _High =
				_Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_buf);
			_Right = _High.first;
			_Right_true_count += _High.second;
			break;
			}

		++_Right;
		++_Right_true_count;
		}

	// swap the [_Left, _Mid) false range with the [_Mid, _Right) true range
	const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,
		static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_buf);
	return (pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count)));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// partition preserving order of equivalents, using _Pred
	for (;;)
		{
		if (_First == _Last)
			{	// the input range range is true (already partitioned)
			return (_First);
			}

		if (!_Pred(*_First))
			{	// excluded the leading true range
			break;
			}

		++_First;
		}

	for (;;)
		{
		--_Last;
		if (_First == _Last)
			{	// the input range is already partitioned
			return (_First);
			}

		if (_Pred(*_Last))
			{	// excluded the trailing false range
			break;
			}
		}

	using _Diff = _Iter_diff_t<_BidIt>;
	const _Diff _Temp_count = _STD distance(_First, _Last); // _Total_count - 1 since we never need to store *_Last
	const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);
	_Temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};
	return (_Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf).first);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// partition preserving order of equivalents, using _Pred
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Stable_partition_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred))));
	}

		// FUNCTION TEMPLATE push_heap WITH PRED
template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Push_heap_by_index(_RanIt _First, _Iter_diff_t<_RanIt> _Hole,
		_Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred)
	{	// percolate _Hole to _Top or where _Val belongs, using _Pred
	for (_Iter_diff_t<_RanIt> _Idx = (_Hole - 1) >> 1;	// TRANSITION, VSO#433486
		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
		_Idx = (_Hole - 1) >> 1)	// TRANSITION, VSO#433486
		{	// move _Hole up to parent
		*(_First + _Hole) = _STD move(*(_First + _Idx));
		_Hole = _Idx;
		}

	*(_First + _Hole) = _STD move(_Val);	// drop _Val into final hole
	}

template<class _RanIt,
	class _Pr> inline
	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using _Pred
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	auto _ULast = _Unchecked(_Last);
	using _URanIt = _Unchecked_t<_RanIt>;
	using _Diff = _Iter_diff_t<_URanIt>;
	_Diff _Count = _ULast - _UFirst;
	if (2 <= _Count)
		{
		_Iter_value_t<_URanIt> _Val = _STD move(*--_ULast);
		_Push_heap_by_index(_UFirst, --_Count, _Diff(0), _STD move(_Val), _Pass_fn(_Pred));
		}
	}

		// FUNCTION TEMPLATE push_heap
template<class _RanIt> inline
	void push_heap(_RanIt _First, _RanIt _Last)
	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using operator<
	_STD push_heap(_First, _Last, less<>());
	}

		// FUNCTION TEMPLATE pop_heap WITH PRED
template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_hole_by_index(_RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom,
		_Ty&& _Val, _Pr _Pred)
	{	// percolate _Hole to _Bottom, then push _Val, using _Pred
		// precondition: _Bottom != 0
	using _Diff = _Iter_diff_t<_RanIt>;
	const _Diff _Top = _Hole;
	_Diff _Idx = _Hole;

	// Check whether _Idx can have a child before calculating that child's index, since
	// calculating the child's index can trigger integer overflows
	const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1;	// TRANSITION, VSO#433486
	while (_Idx < _Max_sequence_non_leaf)
		{	// move _Hole down to larger child
		_Idx = 2 * _Idx + 2;
		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))
			--_Idx;
		*(_First + _Hole) = _STD move(*(_First + _Idx));
		_Hole = _Idx;
		}

	if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0)
		{	// only child at bottom, move _Hole down to it
		*(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));
		_Hole = _Bottom - 1;
		}

	_Push_heap_by_index(_First, _Hole, _Top, _STD move(_Val), _Pred);
	}

template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty&& _Val, _Pr _Pred)
	{	// pop *_First to *_Dest and reheap, using _Pred
		// precondition: _First != _Last
		// precondition: _First != _Dest
	*_Dest = _STD move(*_First);
	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),
		_STD move(_Val), _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
	if (2 <= _Last - _First)
		{
		--_Last;
		_Iter_value_t<_RanIt> _Val = _STD move(*_Last);
		_Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_Pop_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred));
	}

		// FUNCTION TEMPLATE pop_heap
template<class _RanIt> inline
	void pop_heap(_RanIt _First, _RanIt _Last)
	{	// pop *_First to *(_Last - 1) and reheap, using operator<
	_STD pop_heap(_First, _Last, less<>());
	}

		// FUNCTION TEMPLATE make_heap WITH PRED
template<class _RanIt,
	class _Pr> inline
	void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// make nontrivial [_First, _Last) into a heap, using _Pred
	_Iter_diff_t<_RanIt> _Bottom = _Last - _First;
	for (_Iter_diff_t<_RanIt> _Hole = _Bottom >> 1; 0 < _Hole; )	// TRANSITION, VSO#433486
		{	// reheap top half, bottom to top
		--_Hole;
		_Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));
		_Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// make [_First, _Last) into a heap, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_Make_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred));
	}

		// FUNCTION TEMPLATE make_heap
template<class _RanIt> inline
	void make_heap(_RanIt _First, _RanIt _Last)
	{	// make [_First, _Last) into a heap, using operator<
	_STD make_heap(_First, _Last, less<>());
	}

		// FUNCTION TEMPLATES is_heap AND is_heap_until WITH PRED
template<class _RanIt,
	class _Pr> inline
	_RanIt _Is_heap_until_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// find extent of range that is a heap ordered by _Pred
	const _Iter_diff_t<_RanIt> _Size = _Last - _First;
	for (_Iter_diff_t<_RanIt> _Off = 1; _Off < _Size; ++_Off)
		{
		if (_DEBUG_LT_PRED(_Pred, _First[(_Off - 1) >> 1], _First[_Off]))	// TRANSITION, VSO#433486
			{
			return (_First + _Off);
			}
		}

	return (_Last);
	}

template<class _RanIt,
	class _Pr>
	_NODISCARD inline _RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// find extent of range that is a heap ordered by _Pred
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Is_heap_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred))));
	}

template<class _RanIt,
	class _Pr>
	_NODISCARD inline bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// test if range is a heap ordered by _Pred
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	return (_Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast);
	}

		// FUNCTION TEMPLATES is_heap AND is_heap_until
template<class _RanIt>
	_NODISCARD inline _RanIt is_heap_until(_RanIt _First, _RanIt _Last)
	{	// find extent of range that is a heap ordered by operator<
	return (_STD is_heap_until(_First, _Last, less<>()));
	}

template<class _RanIt>
	_NODISCARD inline bool is_heap(_RanIt _First, _RanIt _Last)
	{	// test if range is a heap ordered by operator<
	return (_STD is_heap(_First, _Last, less<>()));
	}

		// FUNCTION TEMPLATE sort_heap WITH PRED
template<class _RanIt,
	class _Pr> inline
	void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// order heap by repeatedly popping, using _Pred
	for (; 2 <= _Last - _First; --_Last)
		{
		_Pop_heap_unchecked(_First, _Last, _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// order heap by repeatedly popping, using _Pred
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
#if _ITERATOR_DEBUG_LEVEL == 2
	const auto _Counterexample = _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
	if (_Counterexample != _ULast)
		{
		_DEBUG_ERROR("invalid heap in sort_heap()");
		}
#endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 2765 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
	_Sort_heap_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
	}

		// FUNCTION TEMPLATE sort_heap
template<class _RanIt> inline
	void sort_heap(_RanIt _First, _RanIt _Last)
	{	// order heap by repeatedly popping, using operator<
	_STD sort_heap(_First, _Last, less<>());
	}

		// FUNCTION TEMPLATE lower_bound
template<class _FwdIt,
	class _Ty>
	_NODISCARD inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// find first element not before _Val, using operator<
	return (_STD lower_bound(_First, _Last, _Val, less<>()));
	}

		// FUNCTION TEMPLATE upper_bound WITH PRED
template<class _FwdIt,
	class _Ty,
	class _Pr>
	_NODISCARD inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// find first element that _Val is before, using _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	_Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Unchecked(_Last));

	while (0 < _Count)
		{	// divide and conquer, find half that contains answer
		_Iter_diff_t<_FwdIt> _Count2 = _Count >> 1; // TRANSITION, VSO#433486
		const auto _UMid = _STD next(_UFirst, _Count2);
		if (_Pred(_Val, *_UMid))
			{
			_Count = _Count2;
			}
		else
			{	// try top half
			_UFirst = _Next_iter(_UMid);
			_Count -= _Count2 + 1;
			}
		}
	return (_Rechecked(_First, _UFirst));
	}

		// FUNCTION TEMPLATE upper_bound
template<class _FwdIt,
	class _Ty>
	_NODISCARD inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// find first element that _Val is before, using operator<
	return (_STD upper_bound(_First, _Last, _Val, less<>()));
	}

		// FUNCTION TEMPLATE equal_range WITH PRED
template<class _FwdIt,
	class _Ty,
	class _Pr>
	_NODISCARD inline pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// find range equivalent to _Val, using _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);

	using _UFwdIt = _Unchecked_t<_FwdIt>;
	using _Diff = _Iter_diff_t<_UFwdIt>;
	_Diff _Count = _STD distance(_UFirst, _ULast);

	while (0 < _Count)
		{	// divide and conquer, check midpoint
		_Diff _Count2 = _Count >> 1; // TRANSITION, VSO#433486
		const auto _UMid = _STD next(_UFirst, _Count2);
		if (_DEBUG_LT_PRED(_Pred, *_UMid, _Val))
			{	// range begins above _UMid, loop
			_UFirst = _Next_iter(_UMid);
			_Count -= _Count2 + 1;
			}
		else if (_Pred(_Val, *_UMid))
			{
			_Count = _Count2;	// range in first half, loop
			}
		else
			{	// range straddles _UMid, find each end and return
			auto _UFirst2 = _STD lower_bound(_UFirst, _UMid, _Val, _Pass_fn(_Pred));
			_STD advance(_UFirst, _Count);
			auto _ULast2 = _STD upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));
			return {_Rechecked(_First, _UFirst2), _Rechecked(_Last, _ULast2)};
			}
		}

	return {_Rechecked(_First, _UFirst), _Rechecked(_Last, _UFirst)};	// empty range
	}

		// FUNCTION TEMPLATE equal_range
template<class _FwdIt,
	class _Ty>
	_NODISCARD inline pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// find range equivalent to _Val, using operator<
	return (_STD equal_range(_First, _Last, _Val, less<>()));
	}

		// FUNCTION TEMPLATE binary_search WITH PRED
template<class _FwdIt,
	class _Ty,
	class _Pr>
	_NODISCARD inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// test if _Val equivalent to some element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	_UFirst = _STD lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
	return (_UFirst != _ULast && !_Pred(_Val, *_UFirst));
	}

		// FUNCTION TEMPLATE binary_search
template<class _FwdIt,
	class _Ty>
	_NODISCARD inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// test if _Val equivalent to some element, using operator<
	return (_STD binary_search(_First, _Last, _Val, less<>()));
	}

		// FUNCTION TEMPLATE merge WITH PRED
inline _Distance_unknown _Idl_dist_add(_Distance_unknown, _Distance_unknown)
	{	// combine _Idl_distance results (both unknown)
	return {};
	}

template<class _Diff1> inline
	_Distance_unknown _Idl_dist_add(_Diff1, _Distance_unknown)
	{	// combine _Idl_distance results (right unknown)
	return {};
	}

template<class _Diff2> inline
	_Distance_unknown _Idl_dist_add(_Distance_unknown, _Diff2)
	{	// combine _Idl_distance results (left unknown)
	return {};
	}

template<class _Diff1,
	class _Diff2> inline
	auto _Idl_dist_add(_Diff1 _Lhs, _Diff2 _Rhs)
	{	// combine _Idl_distance results (both known)
	return (_Lhs + _Rhs);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	_DEPRECATE_UNCHECKED(merge, _Dest);
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	_DEBUG_ORDER_UNCHECKED(_UFirst1, _ULast1, _Pred);
	_DEBUG_ORDER_UNCHECKED(_UFirst2, _ULast2, _Pred);
	const auto _Count1 = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
	const auto _Count2 = _Idl_distance<_InIt2>(_UFirst2, _ULast2);
	auto _UDest = _Unchecked_n(_Dest, _Idl_dist_add(_Count1, _Count2));
	if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2)
		{
		for (;;)
			{	// merge either first or second
			if (_DEBUG_LT_PRED(_Pred, *_UFirst2, *_UFirst1))
				{
				*_UDest = *_UFirst2;
				++_UDest;
				++_UFirst2;

				if (_UFirst2 == _ULast2)
					{
					break;
					}
				}
			else
				{
				*_UDest = *_UFirst1;
				++_UDest;
				++_UFirst1;

				if (_UFirst1 == _ULast1)
					{
					break;
					}
				}
			}
		}

	_UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);	// copy any tail
	return (_Rechecked(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// copy merging ranges, both using _Pred, array dest
	return (_Unchecked(
		_STD merge(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 2981 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE merge
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// copy merging ranges, both using operator<
	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_DestTy (&_Dest)[_DestSize])
	{	// copy merging ranges, both using operator<, array dest
	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3005 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE inplace_merge WITH PRED
		// The "usual invariants" for the inplace_merge helpers below are:
		// [_First, _Mid) and [_Mid, _Last) are sorted
		// _Pred(*_Mid, *_First)             note: this means *_Mid is the "lowest" element
		// _Pred(*prev(_Last), *prev(_Mid))  note: this means *prev(_Mid) is the "highest" element
		// _Count1 == distance(_First, _Mid)
		// _Count2 == distance(_Mid, _Last)
		// _Count1 > 1
		// _Count2 > 1
template<class _BidIt> inline
	void _Rotate_one_right(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	// exchanges the range [_First, _Mid) with [_Mid, _Last)
		// pre: distance(_Mid, _Last) is 1
	_Iter_value_t<_BidIt> _Temp(_STD move(*_Mid));
	_Move_backward_unchecked(_First, _Mid, _Last);
	*_First = _STD move(_Temp);
	}

template<class _BidIt> inline
	void _Rotate_one_left(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	// exchanges the range [_First, _Mid) with [_Mid, _Last)
		// pre: distance(_First, _Mid) is 1
	_Iter_value_t<_BidIt> _Temp(_STD move(*_First));
	*_Move_unchecked(_Mid, _Last, _First) = _STD move(_Temp);
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Inplace_merge_buffer_left(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		ptrdiff_t _Count1, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// move the range [_First, _Mid) to _Temp_buf, and merge it with [_Mid, _Last) to _First, using _Pred
		// usual invariants apply
	_Temporary_range<_Ty> _Temp(_Temp_buf, _First, _Mid, _Count1);
	_Ty * _Left_first = _Temp._Begin();
	_Ty * const _Left_last = _Temp._End() - 1; // avoid a compare with the highest element
	*_First = _STD move(*_Mid); // the lowest element is now in position
	++_First;
	++_Mid;
	for (;;)
		{
		if (_Pred(*_Mid, *_Left_first))
			{	// take element from the right partition
			*_First = _STD move(*_Mid);
			++_First;
			++_Mid;
			if (_Mid == _Last)
				{
				_Move_unchecked(_Left_first, _Temp._End(), _First);	// move any tail (and the highest element)
				return;
				}
			}
		else
			{	// take element from the left partition
			*_First = _STD move(*_Left_first);
			++_First;
			++_Left_first;
			if (_Left_first == _Left_last)
				{	// move the remaining right partition and highest element, since *_Left_first is highest
				*_Move_unchecked(_Mid, _Last, _First) = _STD move(*_Left_last);
				return;
				}
			}
		}
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Inplace_merge_buffer_right(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		ptrdiff_t _Count2, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// move the range [_Mid, _Last) to _Temp_buf, and merge it with [_First, _Mid) to _Last, using _Pred
		// usual invariants apply
	_Temporary_range<_Ty> _Temp(_Temp_buf, _Mid, _Last, _Count2);
	*--_Last = _STD move(*--_Mid); // move the highest element into position
	_Ty * const _Right_first = _Temp._Begin();
	_Ty * _Right_last = _Temp._End() - 1;
	--_Mid;
	for (;;)
		{
		if (_Pred(*_Right_last, *_Mid))
			{	// merge from the left partition
			*--_Last = _STD move(*_Mid);
			if (_First == _Mid)
				{
				*--_Last = _STD move(*_Right_last);	// to make [_Right_first, _Right_last) a half-open range
				_Move_backward_unchecked(_Right_first, _Right_last, _Last);	// move any head (and lowest element)
				return;
				}

			--_Mid;
			}
		else
			{	// merge from the right partition
			*--_Last = _STD move(*_Right_last);
			--_Right_last;
			if (_Right_first == _Right_last)
				{	// we can't compare with *_Right_first, but we know it is lowest
				*--_Last = _STD move(*_Mid);	// restore half-open range [_First, _Mid)
				_Move_backward_unchecked(_First, _Mid, _Last);
				*_First = _STD move(*_Right_first);
				return;
				}
			}
		}
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred);

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Buffered_inplace_merge_divide_and_conquer2(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred,
		_BidIt _Firstn, _BidIt _Lastn, _Iter_diff_t<_BidIt> _Count1n, _Iter_diff_t<_BidIt> _Count2n)
	{	// common block of _Buffered_inplace_merge_divide_and_conquer, below
	using _Diff = _Iter_diff_t<_BidIt>;
	_BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn,
		static_cast<_Diff>(_Count1 - _Count1n), _Count2n, _Temp_buf);	// rearrange middle
	_Buffered_inplace_merge_unchecked(_First, _Firstn, _Midn,
		_Count1n, _Count2n, _Temp_buf, _Pred);	// merge each new part
	_Buffered_inplace_merge_unchecked(_Midn, _Lastn, _Last,
		static_cast<_Diff>(_Count1 - _Count1n), static_cast<_Diff>(_Count2 - _Count2n), _Temp_buf, _Pred);
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Buffered_inplace_merge_divide_and_conquer(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// merge sorted [_First, _Mid) with sorted [_Mid, _Last), using _Pred
		// usual invariants apply
	if (_Count1 <= _Count2)
		{
		const _Iter_diff_t<_BidIt> _Count1n = _Count1 >> 1;	// TRANSITION, VSO#433486
		const _BidIt _Firstn = _STD next(_First, _Count1n);
		const _BidIt _Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
		_Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2,
			_Temp_buf, _Pred,
			_Firstn, _Lastn, _Count1n, _STD distance(_Mid, _Lastn));
		}
	else
		{
		const _Iter_diff_t<_BidIt> _Count2n = _Count2 >> 1;	// TRANSITION, VSO#433486
		const _BidIt _Lastn = _STD next(_Mid, _Count2n);
		const _BidIt _Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
		_Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2,
			_Temp_buf, _Pred,
			_Firstn, _Lastn, _STD distance(_First, _Firstn), _Count2n);
		}
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Buffered_inplace_merge_unchecked_impl(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// merge sorted [_First, _Mid) with sorted [_Mid, _Last), using _Pred
		// usual invariants apply
	using _CT = common_type_t<ptrdiff_t, _Iter_diff_t<_BidIt>>;
	const auto _Capacity = static_cast<_CT>(_Temp_buf._Capacity);
	if (_Count1 <= _Count2 && static_cast<_CT>(_Count1) <= _Capacity)
		{
		_Inplace_merge_buffer_left(_First, _Mid, _Last, static_cast<ptrdiff_t>(_Count1), _Temp_buf, _Pred);
		}
	else if (static_cast<_CT>(_Count2) <= _Capacity)
		{
		_Inplace_merge_buffer_right(_First, _Mid, _Last, static_cast<ptrdiff_t>(_Count2), _Temp_buf, _Pred);
		}
	else
		{
		_Buffered_inplace_merge_divide_and_conquer(_First, _Mid, _Last, _Count1, _Count2, _Temp_buf, _Pred);
		}
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// merge sorted [_First, _Mid) with sorted [_Mid, _Last), using _Pred
		// usual invariants *do not* apply; only sortedness applies
		// establish the usual invariants (explained in inplace_merge)
	if (_Mid == _Last)
		{
		return;
		}

	for (;;)
		{
		if (_First == _Mid)
			{
			return;
			}

		if (_Pred(*_Mid, *_First))
			{
			break;
			}

		++_First;
		--_Count1;
		}

	const auto _Highest = _Prev_iter(_Mid);
	do
		{
		--_Last;
		--_Count2;
		if (_Mid == _Last)
			{
			_Rotate_one_right(_First, _Mid, ++_Last);
			return;
			}
		}
	while (!_Pred(*_Last, *_Highest));

	++_Last;
	++_Count2;

	if (_Count1 == 1)
		{
		_Rotate_one_left(_First, _Mid, _Last);
		return;
		}

	_Buffered_inplace_merge_unchecked_impl(_First, _Mid, _Last, _Count1, _Count2, _Temp_buf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
	_DEBUG_RANGE(_First, _Mid);
	_DEBUG_RANGE(_Mid, _Last);
	using _UBidIt = _Unchecked_t<_BidIt>;
	auto _UFirst = _Unchecked(_First);
	auto _UMid = _Unchecked(_Mid);
	auto _ULast = _Unchecked(_Last);
	_DEBUG_ORDER_UNCHECKED(_UFirst, _UMid, _Pred);

	// establish the usual invariants:
	if (_UMid == _ULast)
		{
		return;
		}

	for (;;)
		{
		if (_UFirst == _UMid)
			{
			return;
			}

		if (_Pred(*_UMid, *_UFirst))
			{	// found that *_UMid goes in *_UFirst's position
			break;
			}

		++_UFirst;
		}

	const auto _Highest = _Prev_iter(_UMid);
	do
		{
		--_ULast;
		if (_UMid == _ULast)
			{	// rotate only element remaining in right partition to the beginning, without allocating
			_Rotate_one_right(_UFirst, _UMid, ++_ULast);
			return;
			}
		}
	while (!_Pred(*_ULast, *_Highest));	// found that *_Highest goes in *_ULast's position

	++_ULast;

	const _Iter_diff_t<_UBidIt> _Count1 = _STD distance(_UFirst, _UMid);
	if (_Count1 == 1)
		{	// rotate only element remaining in left partition to the end, without allocating
		_Rotate_one_left(_UFirst, _UMid, _ULast);
		return;
		}

	const _Iter_diff_t<_UBidIt> _Count2 = _STD distance(_UMid, _ULast);
	_Temporary_buffer<_Iter_value_t<_UBidIt>> _Temp_buf{_Min_value(_Count1, _Count2)};
	_Buffered_inplace_merge_unchecked_impl(_UFirst, _UMid, _ULast,
		_Count1, _Count2, _Temp_buf, _Pass_fn(_Pred));
	}

		// FUNCTION TEMPLATE inplace_merge
template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
	_STD inplace_merge(_First, _Mid, _Last, less<>());
	}

		// FUNCTION TEMPLATE sort
template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// insertion sort [_First, _Last), using _Pred
	if (_First != _Last)
		{
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	// order next element
			_BidIt _Next1 = _Next;
			_Iter_value_t<_BidIt> _Val = _STD move(*_Next);

			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
				{	// found new earliest element, move to front
				_Move_backward_unchecked(_First, _Next, ++_Next1);
				*_First = _STD move(_Val);
				}
			else
				{	// look for insertion point after first
				for (_BidIt _First1 = _Next1;
					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
					_Next1 = _First1)
					{
					*_Next1 = _STD move(*_First1);	// move hole down
					}

				*_Next1 = _STD move(_Val);	// insert element in hole
				}
			}
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// sort median of three elements to middle
	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
		{
		_STD iter_swap(_Mid, _First);
		}

	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))
		{	// swap middle and last, then test first again
		_STD iter_swap(_Last, _Mid);

		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
			{
			_STD iter_swap(_Mid, _First);
			}
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// sort median element to middle
	using _Diff = _Iter_diff_t<_RanIt>;
	const _Diff _Count = _Last - _First;
	if (40 < _Count)
		{	// median of nine
		const _Diff _Step = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller
		const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
		_Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);
		_Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);
		_Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		{
		_Med3_unchecked(_First, _Mid, _Last, _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	pair<_RanIt, _RanIt>
		_Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// partition [_First, _Last), using _Pred
	_RanIt _Mid = _First + ((_Last - _First) >> 1);	// TRANSITION, VSO#433486
	_Guess_median_unchecked(_First, _Mid, _Last - 1, _Pred);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
		{
		--_Pfirst;
		}

	while (_Plast < _Last
		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
		&& !_Pred(*_Pfirst, *_Plast))
		{
		++_Plast;
		}

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (;;)
		{	// partition
		for (; _Gfirst < _Last; ++_Gfirst)
			{
			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))
				{
				}
			else if (_Pred(*_Gfirst, *_Pfirst))
				{
				break;
				}
			else if (_Plast != _Gfirst)
				{
				_STD iter_swap(_Plast, _Gfirst);
				++_Plast;
				}
			else
				{
				++_Plast;
				}
			}

		for (; _First < _Glast; --_Glast)
			{
			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))
				{
				}
			else if (_Pred(*_Pfirst, *(_Glast - 1)))
				{
				break;
				}
			else if (--_Pfirst != _Glast - 1)
				{
				_STD iter_swap(_Pfirst, _Glast - 1);
				}
			}

		if (_Glast == _First && _Gfirst == _Last)
			{
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
			}

		if (_Glast == _First)
			{	// no room at bottom, rotate pivot upward
			if (_Plast != _Gfirst)
				{
				_STD iter_swap(_Pfirst, _Plast);
				}

			++_Plast;
			_STD iter_swap(_Pfirst, _Gfirst);
			++_Pfirst;
			++_Gfirst;
			}
		else if (_Gfirst == _Last)
			{	// no room at top, rotate pivot downward
			if (--_Glast != --_Pfirst)
				{
				_STD iter_swap(_Glast, _Pfirst);
				}

			_STD iter_swap(_Pfirst, --_Plast);
			}
		else
			{
			_STD iter_swap(_Gfirst, --_Glast);
			++_Gfirst;
			}
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred)
	{	// order [_First, _Last), using _Pred
	_Iter_diff_t<_RanIt> _Count;
	while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal)
		{	// divide and conquer by quicksort
		auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);
		// TRANSITION, VSO#433486
		_Ideal = (_Ideal >> 1) + (_Ideal >> 2);	// allow 1.5 log2(N) divisions

		if (_Mid.first - _First < _Last - _Mid.second)
			{	// loop on second half
			_Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);
			_First = _Mid.second;
			}
		else
			{	// loop on first half
			_Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);
			_Last = _Mid.first;
			}
		}

	if (_ISORT_MAX < _Count)
		{	// heap sort if too many divisions
		_Make_heap_unchecked(_First, _Last, _Pred);
		_Sort_heap_unchecked(_First, _Last, _Pred);
		}
	else if (2 <= _Count)
		{
		_Insertion_sort_unchecked(_First, _Last, _Pred);	// small
		}
	}

template<class _RanIt,
	class _Pr> inline
	void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last), using _Pred
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	_Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));
	}

template<class _RanIt> inline
	void sort(const _RanIt _First, const _RanIt _Last)
	{	// order [_First, _Last), using operator<
	_STD sort(_First, _Last, less<>());
	}

#if _HAS_CXX17
template<class _ExPo,
	class _RanIt,
	class _Pr,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void sort(_ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) _NOEXCEPT;

template<class _ExPo,
	class _RanIt,
	_Enable_if_execution_policy_t<_ExPo> = 0> inline
	void sort(_ExPo&& _Exec, const _RanIt _First, const _RanIt _Last) _NOEXCEPT // enforces termination
	{	// order [_First, _Last), using operator<
	_STD sort(_STD forward<_ExPo>(_Exec), _First, _Last, less<>{});
	}
#endif /* _HAS_CXX17 */
# 3542 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE stable_sort WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Buffered_merge_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// move merging ranges, both using _Pred
	if (_First1 != _Last1 && _First2 != _Last2)
		{
		for (;;)
			{	// merge either first or second
			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
				{	// merge first
				*_Dest = _STD move(*_First2);
				++_Dest;
				++_First2;

				if (_First2 == _Last2)
					{
					break;
					}
				}
			else
				{	// merge second
				*_Dest = _STD move(*_First1);
				++_Dest;
				++_First1;

				if (_First1 == _Last1)
					{
					break;
					}
				}
			}
		}

	_Dest = _Move_unchecked(_First1, _Last1, _Dest);	// move any tail
	return (_Move_unchecked(_First2, _Last2, _Dest));
	}

template<class _BidIt,
	class _OutIt,
	class _Pr> inline
	void _Chunked_merge_unchecked(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Iter_diff_t<_BidIt> _Chunk, _Iter_diff_t<_BidIt> _Count, _Pr _Pred)
	{	// copy merging chunks, using _Pred
	for (_Iter_diff_t<_BidIt> _Chunk2 = _Chunk << 1; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	// copy merging pairs of adjacent chunks
		const _BidIt _Mid1 = _STD next(_First, _Chunk);
		const _BidIt _Mid2 = _STD next(_Mid1, _Chunk);
		_Dest = _Buffered_merge_unchecked(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		{
		_Move_unchecked(_First, _Last, _Dest);	// copy partial last chunk
		}
	else
		{	// copy merging whole and partial last chunk
		const _BidIt _Mid1 = _STD next(_First, _Chunk);
		_Buffered_merge_unchecked(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_sort_unchecked(_BidIt _First, _BidIt _Last, _Iter_diff_t<_BidIt> _Count,
		_Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// sort using temp buffer for merges, using _Pred
		// pre: _Last - _First == _Count
		// pre: _Count <= _Temp_buf._Capacity
	using _Diff = _Iter_diff_t<_BidIt>;
	const auto _Diffsort_max = static_cast<_Diff>(_ISORT_MAX);
	_BidIt _Mid = _First;
	for (auto _Nleft = _Count; _Diffsort_max <= _Nleft; _Nleft -= _Diffsort_max)
		{	// sort chunks
		const _BidIt _Midn = _STD next(_Mid, _Diffsort_max);
		_Insertion_sort_unchecked(_Mid, _Midn, _Pred);
		_Mid = _Midn;
		}
	_Insertion_sort_unchecked(_Mid, _Last, _Pred);	// sort partial last chunk

	for (auto _Chunk = _Diffsort_max; _Chunk < _Count; _Chunk <<= 1)
		{	// merge adjacent pairs of chunks to and from temp buffer
		_Temporary_range<_Ty> _Temp{_Temp_buf};
		_Chunked_merge_unchecked(_First, _Last, _STD back_inserter(_Temp),
			_Chunk, _Count, _Pred);
		_Chunk <<= 1;
		// potential narrowing to ptrdiff_t below works because _Count <= _Capacity,
		// and _Capacity can't exceed PTRDIFF_MAX
		_Chunked_merge_unchecked(_Temp._Begin(), _Temp._End(), _First,
			static_cast<ptrdiff_t>(_Chunk), static_cast<ptrdiff_t>(_Count), _Pred);
		}
	}

template<class _BidIt,
	class _Ty,
	class _Pr> inline
	void _Stable_sort_unchecked(_BidIt _First, _BidIt _Last, _Iter_diff_t<_BidIt> _Count,
		_Temporary_buffer<_Ty>& _Temp_buf, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	using _Diff = _Iter_diff_t<_BidIt>;
	if (_Count <= _ISORT_MAX)
		{
		_Insertion_sort_unchecked(_First, _Last, _Pred);	// small
		}
	else
		{	// sort halves and merge
		auto _Count2 = static_cast<_Diff>((_Count >> 1) + (_Count & static_cast<_Diff>(1)));
		const _BidIt _Mid = _STD next(_First, _Count2);
		if (_Count2 <= _Temp_buf._Capacity)
			{	// temp buffer big enough, sort each half using buffer
			_Buffered_merge_sort_unchecked(_First, _Mid, _Count2, _Temp_buf, _Pred);
			_Buffered_merge_sort_unchecked(_Mid, _Last, static_cast<_Diff>(_Count - _Count2),
				_Temp_buf, _Pred);
			}
		else
			{	// temp buffer not big enough, divide and conquer
			_Stable_sort_unchecked(_First, _Mid, _Count2, _Temp_buf, _Pred);
			_Stable_sort_unchecked(_Mid, _Last, static_cast<_Diff>(_Count - _Count2), _Temp_buf, _Pred);
			}

		_Buffered_inplace_merge_unchecked(_First, _Mid, _Last,
			_Count2, static_cast<_Diff>(_Count - _Count2), _Temp_buf, _Pred);	// merge halves
		}
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	_DEBUG_RANGE(_First, _Last);
	using _UBidIt = _Unchecked_t<_BidIt>;
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _Count = _STD distance(_UFirst, _ULast);
	if (_Count == 0)
		{
		return;
		}

	if (_Count <= _ISORT_MAX)
		{
		_Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));	// small
		}
	else
		{
		_Temporary_buffer<_Iter_value_t<_UBidIt>> _Temp_buf{
			(_Count >> 1) + (_Count & static_cast<_Iter_diff_t<_UBidIt>>(1))};
		_Stable_sort_unchecked(_UFirst, _ULast, _Count, _Temp_buf, _Pass_fn(_Pred));
		}
	}

		// FUNCTION TEMPLATE stable_sort
template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	// sort preserving order of equivalents, using operator<
	_STD stable_sort(_First, _Last, less<>());
	}

		// FUNCTION TEMPLATE partial_sort WITH PRED
template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last) up to _Mid, using _Pred
	_DEBUG_RANGE(_First, _Mid);
	_DEBUG_RANGE(_Mid, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _UMid = _Unchecked(_Mid);
	const auto _ULast = _Unchecked(_Last);

	if (_UFirst == _UMid)
		{
		return;	// nothing to do, avoid violating _Pop_heap_hole_unchecked preconditions
		}

	_Make_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
	for (auto _UNext = _UMid; _UNext < _ULast; ++_UNext)
		{
		if (_DEBUG_LT_PRED(_Pred, *_UNext, *_UFirst))
			{	// replace top with new largest
			_Iter_value_t<_Unchecked_t<_RanIt>> _Val = _STD move(*_UNext);
			_Pop_heap_hole_unchecked(_UFirst, _UMid, _UNext, _STD move(_Val), _Pass_fn(_Pred));
			}
		}

	_Sort_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
	}

		// FUNCTION TEMPLATE partial_sort
template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	// order [_First, _Last) up to _Mid, using operator<
	_STD partial_sort(_First, _Mid, _Last, less<>());
	}

		// FUNCTION TEMPLATE partial_sort_copy WITH PRED
template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	// copy [_First1, _Last1) into [_First2, _Last2) using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	using _URanIt = _Unchecked_t<_RanIt>;
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	auto _UMid2 = _UFirst2;
	if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2)
		{
		for (; _UFirst1 != _ULast1 && _UMid2 != _ULast2; ++_UFirst1, (void)++_UMid2)
			{
			*_UMid2 = *_UFirst1;	// copy min(_ULast1 - _UFirst1, _ULast2 - _UFirst2)
			}

		_Make_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
		for (; _UFirst1 != _ULast1; ++_UFirst1)
			{
			if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2))
				{
				// replace top with new largest:
				_Pop_heap_hole_by_index(_UFirst2, static_cast<_Iter_diff_t<_URanIt>>(0),
					static_cast<_Iter_diff_t<_URanIt>>(_UMid2 - _UFirst2),
					static_cast<_Iter_value_t<_Unchecked_t<_InIt>>>(*_UFirst1), _Pass_fn(_Pred));
				}
			}

		_Sort_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
		}

	return (_Rechecked(_First2, _UMid2));
	}

		// FUNCTION TEMPLATE partial_sort_copy
template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	// copy [_First1, _Last1) into [_First2, _Last2), using operator<
	return (_STD partial_sort_copy(_First1, _Last1, _First2, _Last2, less<>()));
	}

		// FUNCTION TEMPLATE nth_element WITH PRED
template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	// order Nth element, using _Pred
	_DEBUG_RANGE(_First, _Nth);
	_DEBUG_RANGE(_Nth, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _UNth = _Unchecked(_Nth);
	auto _ULast = _Unchecked(_Last);
	if (_UNth == _ULast)
		{
		return;	// nothing to do
		}

	while (_ISORT_MAX < _ULast - _UFirst)
		{	// divide and conquer, ordering partition containing Nth
		auto _UMid = _Partition_by_median_guess_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));

		if (_UMid.second <= _UNth)
			{
			_UFirst = _UMid.second;
			}
		else if (_UMid.first <= _UNth)
			{
			return;	// Nth inside fat pivot, done
			}
		else
			{
			_ULast = _UMid.first;
			}
		}

	_Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));	// sort any remainder
	}

		// FUNCTION TEMPLATE nth_element
template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	// order Nth element, using operator<
	_STD nth_element(_First, _Nth, _Last, less<>());
	}

		// FUNCTION TEMPLATE includes WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr>
	_NODISCARD inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// test if every element in sorted [_First2, _Last2) is in sorted [_First1, _Last1), using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	_DEBUG_ORDER_UNCHECKED(_UFirst1, _ULast1, _Pred);
	_DEBUG_ORDER_UNCHECKED(_UFirst2, _ULast2, _Pred);
	for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1)
		{
		if (_DEBUG_LT_PRED(_Pred, *_UFirst2, *_UFirst1))
			{
			return (false);
			}

		if (!_Pred(*_UFirst1, *_UFirst2))
			{
			++_UFirst2;
			}
		}

	return (_UFirst2 == _ULast2);
	}

		// FUNCTION TEMPLATE includes
template<class _InIt1,
	class _InIt2>
	_NODISCARD inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{	// test if every element in sorted [_First2, _Last2) is in sorted [_First1, _Last1), using operator<
	return (_STD includes(_First1, _Last1, _First2, _Last2, less<>()));
	}

		// FUNCTION TEMPLATE set_union WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEPRECATE_UNCHECKED(set_union, _Dest);
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	_DEBUG_ORDER_UNCHECKED(_UFirst1, _ULast1, _Pred);
	_DEBUG_ORDER_UNCHECKED(_UFirst2, _ULast2, _Pred);
	auto _UDest = _Unchecked_idl0(_Dest);
	for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UDest)
		{
		if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2))
			{	// copy first
			*_UDest = *_UFirst1;
			++_UFirst1;
			}
		else if (_Pred(*_UFirst2, *_UFirst1))
			{	// copy second
			*_UDest = *_UFirst2;
			++_UFirst2;
			}
		else
			{	// advance both
			*_UDest = *_UFirst1;
			++_UFirst1;
			++_UFirst2;
			}
		}

	_UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
	return (_Rechecked(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		_STD set_union(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_union
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _DestTy (&_Dest)[_DestSize])
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_STD set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 3952 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_intersection WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEPRECATE_UNCHECKED(set_intersection, _Dest);
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	_DEBUG_ORDER_UNCHECKED(_UFirst1, _ULast1, _Pred);
	_DEBUG_ORDER_UNCHECKED(_UFirst2, _ULast2, _Pred);
	auto _UDest = _Unchecked_idl0(_Dest);
	while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2)
		{
		if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2))
			{
			++_UFirst1;
			}
		else if (_Pred(*_UFirst2, *_UFirst1))
			{
			++_UFirst2;
			}
		else
			{
			*_UDest = *_UFirst1;
			++_UDest;
			++_UFirst1;
			++_UFirst2;
			}
		}

	return (_Rechecked(_Dest, _UDest));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		_STD set_intersection(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 4008 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_intersection
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _DestTy (&_Dest)[_DestSize])
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_STD set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 4030 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_difference WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	_DEPRECATE_UNCHECKED(set_difference, _Dest);
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	_DEBUG_ORDER_UNCHECKED(_UFirst1, _ULast1, _Pred);
	_DEBUG_ORDER_UNCHECKED(_UFirst2, _ULast2, _Pred);
	auto _UDest = _Unchecked_idl0(_Dest);
	while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2)
		{
		if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2))
			{	// copy first
			*_UDest = *_UFirst1;
			++_UDest;
			++_UFirst1;
			}
		else
			{
			if (!_Pred(*_UFirst2, *_UFirst1))
				{
				++_UFirst1;
				}

			++_UFirst2;
			}
		}

	return (_Rechecked(_Dest, _Copy_unchecked(_UFirst1, _ULast1, _UDest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), array dest
	return (_Unchecked(
		_STD set_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 4088 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_difference
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using operator<
	return (_STD set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_DestTy (&_Dest)[_DestSize])
	{	// take set [_First2, _Last2) from [_First1, _Last1), array dest
	return (_STD set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 4112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_symmetric_difference WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEPRECATE_UNCHECKED(set_symmetric_difference, _Dest);
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	auto _UFirst1 = _Unchecked(_First1);
	const auto _ULast1 = _Unchecked(_Last1);
	auto _UFirst2 = _Unchecked(_First2);
	const auto _ULast2 = _Unchecked(_Last2);
	_DEBUG_ORDER_UNCHECKED(_UFirst1, _ULast1, _Pred);
	_DEBUG_ORDER_UNCHECKED(_UFirst2, _ULast2, _Pred);
	auto _UDest = _Unchecked_idl0(_Dest);
	while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2)
		{
		if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2))
			{	// copy first
			*_UDest = *_UFirst1;
			++_UDest;
			++_UFirst1;
			}
		else if (_Pred(*_UFirst2, *_UFirst1))
			{	// copy second
			*_UDest = *_UFirst2;
			++_UDest;
			++_UFirst2;
			}
		else
			{	// advance both
			++_UFirst1;
			++_UFirst2;
			}
		}

	_UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
	return (_Rechecked(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize,
	class _Pr> inline
	_DestTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_DestTy (&_Dest)[_DestSize], _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		_STD set_symmetric_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 4173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE set_symmetric_difference
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InIt2,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_DestTy (&_Dest)[_DestSize])
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_STD set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>()));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 4197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

		// FUNCTION TEMPLATE max_element WITH PRED
template<class _FwdIt,
	class _Pr>
	constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find largest element, using _Pred
	_FwdIt _Found = _First;
	if (_First != _Last)
		{
		while (++_First != _Last)
			{
			if (_DEBUG_LT_PRED(_Pred, *_Found, *_First))
				{
				_Found = _First;
				}
			}
		}

	return (_Found);
	}

template<class _FwdIt,
	class _Pr>
	_NODISCARD constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find largest element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Max_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred))));
	}

		// FUNCTION TEMPLATE max_element
template<class _FwdIt>
	_NODISCARD constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	// find largest element, using operator<
	return (_STD max_element(_First, _Last, less<>()));
	}

		// FUNCTION TEMPLATE min_element WITH PRED
template<class _FwdIt,
	class _Pr>
	constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest element, using _Pred
	_FwdIt _Found = _First;
	if (_First != _Last)
		{
		while (++_First != _Last)
			{
			if (_DEBUG_LT_PRED(_Pred, *_First, *_Found))
				{
				_Found = _First;
				}
			}
		}

	return (_Found);
	}

template<class _FwdIt,
	class _Pr>
	_NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Min_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred))));
	}

		// FUNCTION TEMPLATE min_element
template<class _FwdIt>
	_NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	// find smallest element, using operator<
	return (_STD min_element(_First, _Last, less<>()));
	}

		// FUNCTION TEMPLATE minmax_element WITH PRED
template<class _FwdIt,
	class _Pr>
	constexpr pair<_FwdIt, _FwdIt> _Minmax_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest and largest elements, using _Pred
	pair<_FwdIt, _FwdIt> _Found(_First, _First);

	if (_First != _Last)
		{
		while (++_First != _Last)
			{	// process one or two elements
			_FwdIt _Next = _First;
			if (++_Next == _Last)
				{	// process last element
				if (_DEBUG_LT_PRED(_Pred, *_First, *_Found.first))
					{
					_Found.first = _First;
					}
				else if (!_DEBUG_LT_PRED(_Pred, *_First, *_Found.second))
					{
					_Found.second = _First;
					}
				}
			else
				{	// process next two elements
				if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
					{	// test _Next for new smallest
					if (_DEBUG_LT_PRED(_Pred, *_Next, *_Found.first))
						{
						_Found.first = _Next;
						}
					if (!_DEBUG_LT_PRED(_Pred, *_First, *_Found.second))
						{
						_Found.second = _First;
						}
					}
				else
					{	// test _First for new smallest
					if (_DEBUG_LT_PRED(_Pred, *_First, *_Found.first))
						{
						_Found.first = _First;
						}
					if (!_DEBUG_LT_PRED(_Pred, *_Next, *_Found.second))
						{
						_Found.second = _Next;
						}
					}
				_First = _Next;
				}
			}
		}

	return (_Found);
	}

template<class _FwdIt,
	class _Pr>
	_NODISCARD constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest and largest elements, using _Pred
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked_both(_First, _Last,
		_Minmax_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pass_fn(_Pred))));
	}

		// FUNCTION TEMPLATE minmax_element
template<class _FwdIt>
	_NODISCARD constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last)
	{	// find smallest and largest elements, using operator<
	return (_STD minmax_element(_First, _Last, less<>()));
	}

		// FUNCTION TEMPLATE max WITH PRED
template<class _Ty,
	class _Pr>
	_NODISCARD constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_DEBUG_LT_PRED(_Pred, _Left, _Right)))
	{	// return larger of _Left and _Right using _Pred
	return (_DEBUG_LT_PRED(_Pred, _Left, _Right) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr>
	_NODISCARD constexpr _Ty (max)(initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	// return leftmost/largest
	const _Ty *_Res = _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
	return (*_Res);
	}

		// FUNCTION TEMPLATE max
#pragma warning(push)
#pragma warning(disable: 28285)	// (syntax error in SAL annotation, occurs when _Ty is not an integral type)
template<class _Ty>
	_Post_equal_to_(_Left < _Right ? _Right : _Left)
	_NODISCARD constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_DEBUG_LT(_Left, _Right)))
	{	// return larger of _Left and _Right
	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);
	}
#pragma warning(pop)

template<class _Ty>
	_NODISCARD constexpr _Ty (max)(initializer_list<_Ty> _Ilist)
	{	// return leftmost/largest
	return ((_STD max)(_Ilist, less<>()));
	}

		// FUNCTION TEMPLATE min WITH PRED
template<class _Ty,
	class _Pr>
	_NODISCARD constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_DEBUG_LT_PRED(_Pred, _Right, _Left)))
	{	// return smaller of _Left and _Right using _Pred
	return (_DEBUG_LT_PRED(_Pred, _Right, _Left) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr>
	_NODISCARD constexpr _Ty (min)(initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	// return leftmost/smallest
	const _Ty *_Res = _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
	return (*_Res);
	}

		// FUNCTION TEMPLATE min
#pragma warning(push)
#pragma warning(disable: 28285)	// (syntax error in SAL annotation, occurs when _Ty is not an integral type)
template<class _Ty>
	_Post_equal_to_(_Right < _Left ? _Right : _Left)
	_NODISCARD constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_DEBUG_LT(_Right, _Left)))
	{	// return smaller of _Left and _Right
	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);
	}
#pragma warning(pop)

template<class _Ty>
	_NODISCARD constexpr _Ty (min)(initializer_list<_Ty> _Ilist)
	{	// return leftmost/smallest
	return ((_STD min)(_Ilist, less<>()));
	}


		// FUNCTION TEMPLATE minmax WITH PRED
template<class _Ty,
	class _Pr>
	_NODISCARD constexpr pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right
	return (_Pred(_Right, _Left)
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

template<class _Ty,
	class _Pr>
	_NODISCARD constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	// return {leftmost/smallest, rightmost/largest}
	pair<const _Ty *, const _Ty *> _Res = _Minmax_element_unchecked(
		_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
	return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
	}

		// FUNCTION TEMPLATE minmax
template<class _Ty>
	_NODISCARD constexpr pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right)
	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right
	return (_Right < _Left
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

template<class _Ty>
	_NODISCARD constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist)
	{	// return {leftmost/smallest, rightmost/largest}
	return (_STD minmax(_Ilist, less<>()));
	}

		// FUNCTION TEMPLATE next_permutation WITH PRED
template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// permute and test for pure ascending, using _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UNext = _ULast;
	if (_UFirst == _ULast || _UFirst == --_UNext)
		{
		return (false);
		}

	for (;;)
		{	// find rightmost element smaller than successor
		auto _UNext1 = _UNext;
		if (_DEBUG_LT_PRED(_Pred, *--_UNext, *_UNext1))
			{	// swap with rightmost element that's smaller, flip suffix
			auto _UMid = _ULast;
			do
				{
				--_UMid;
				}
			while (!_DEBUG_LT_PRED(_Pred, *_UNext, *_UMid));

			_STD iter_swap(_UNext, _UMid);
			_Reverse_unchecked(_UNext1, _ULast);
			return (true);
			}

		if (_UNext == _UFirst)
			{	// pure descending, flip all
			_Reverse_unchecked(_UFirst, _ULast);
			return (false);
			}
		}
	}

		// FUNCTION TEMPLATE next_permutation
template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	// permute and test for pure ascending, using operator<
	return (_STD next_permutation(_First, _Last, less<>()));
	}

		// FUNCTION TEMPLATE prev_permutation WITH PRED
template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// reverse permute and test for pure descending, using _Pred
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	auto _UNext = _ULast;
	if (_UFirst == _ULast || _UFirst == --_UNext)
		{
		return (false);
		}

	for (;;)
		{	// find rightmost element not smaller than successor
		auto _UNext1 = _UNext;
		if (_DEBUG_LT_PRED(_Pred, *_UNext1, *--_UNext))
			{	// swap with rightmost element that's not smaller, flip suffix
			auto _UMid = _ULast;
			do
				{
				--_UMid;
				}
			while (!_DEBUG_LT_PRED(_Pred, *_UMid, *_UNext));

			_STD iter_swap(_UNext, _UMid);
			_Reverse_unchecked(_UNext1, _ULast);
			return (true);
			}

		if (_UNext == _UFirst)
			{	// pure ascending, flip all
			_Reverse_unchecked(_UFirst, _ULast);
			return (false);
			}
		}
	}

		// FUNCTION TEMPLATE prev_permutation
template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	// reverse permute and test for pure descending, using operator<
	return (_STD prev_permutation(_First, _Last, less<>()));
	}

		// FUNCTION TEMPLATES is_sorted AND is_sorted_until WITH PRED
template<class _FwdIt,
	class _Pr>
	_NODISCARD inline _FwdIt is_sorted_until(const _FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	_DEBUG_RANGE(_First, _Last);
	auto _UFirst = _Unchecked(_First);
	auto _ULast = _Unchecked(_Last);
	if (_UFirst != _ULast)
		{
		for (auto _UNext = _UFirst; ++_UNext != _ULast; ++_UFirst)
			{
			if (_DEBUG_LT_PRED(_Pred, *_UNext, *_UFirst))
				{
				_ULast = _UNext;
				break;
				}
			}
		}

	return (_Rechecked(_Last, _ULast));
	}

template<class _FwdIt,
	class _Pr>
	_NODISCARD inline bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// test if range is ordered by predicate
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	return (_STD is_sorted_until(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast);
	}

		// FUNCTION TEMPLATES is_sorted AND is_sorted_until
template<class _FwdIt>
	_NODISCARD inline _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	// find extent of range that is ordered by operator<
	return (_STD is_sorted_until(_First, _Last, less<>()));
	}

template<class _FwdIt>
	_NODISCARD inline bool is_sorted(_FwdIt _First, _FwdIt _Last)
	{	// test if range is ordered by operator<
	return (_STD is_sorted(_First, _Last, less<>()));
	}

#if _HAS_CXX17
		// FUNCTION TEMPLATE clamp
template<class _Ty,
	class _Pr>
	_NODISCARD constexpr const _Ty& clamp(const _Ty& _Val, const _Ty& _Min_val, const _Ty& _Max_val, _Pr _Pred)
	{	// returns _Val constrained to [_Min_val, _Max_val] ordered by _Pred
#if _ITERATOR_DEBUG_LEVEL == 2
	return (_DEBUG_LT_PRED(_Pred, _Max_val, _Min_val)
		? (_DEBUG_ERROR("invalid bounds arguments passed to std::clamp"), _Val)
		: _DEBUG_LT_PRED(_Pred, _Max_val, _Val)
			? _Max_val
			: _DEBUG_LT_PRED(_Pred, _Val, _Min_val)
				? _Min_val
				: _Val);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv */
# 4601 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
	return (_Pred(_Max_val, _Val)
		? _Max_val
		: _Pred(_Val, _Min_val)
			? _Min_val
			: _Val);
#endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 4607 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
	}

template<class _Ty>
	_NODISCARD constexpr const _Ty& clamp(const _Ty& _Val, const _Ty& _Min_val, const _Ty& _Max_val)
	{	// returns _Val constrained to [_Min_val, _Max_val]
	return (_STD clamp(_Val, _Min_val, _Max_val, less<>()));
	}
#endif /* _HAS_CXX17 */
# 4615 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

_STD_END
#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)
#endif /* RC_INVOKED */
# 4621 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3
#endif /* _ALGORITHM_ */
# 4622 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\algorithm" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 2 "ice.cpp" 2
#if 0 /* expanded by -frewrite-includes */
#include <array>
#endif /* expanded by -frewrite-includes */
# 2 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 1 3
// array standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
#ifndef _ARRAY_
#define _ARRAY_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <algorithm>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
#if 0 /* expanded by -frewrite-includes */
#include <iterator>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 1 3
// iterator standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 3
#ifndef _ITERATOR_
#define _ITERATOR_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <istream>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 1 3
// istream standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3
#ifndef _ISTREAM_
#define _ISTREAM_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <ostream>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 1 3
// ostream standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
#ifndef _OSTREAM_
#define _OSTREAM_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <ios>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 1 3
// ios standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3
#ifndef _IOS_
#define _IOS_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xlocnum>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 1 3
// xlocnum internal header (from <locale>)
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
#ifndef _XLOCNUM_
#define _XLOCNUM_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <climits>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
#if 0 /* expanded by -frewrite-includes */
#include <cmath>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdio>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
#if 0 /* expanded by -frewrite-includes */
#include <streambuf>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 1 3
// streambuf standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3
#ifndef _STREAMBUF_
#define _STREAMBUF_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xiosbase>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 1 3
// xiosbase internal header (from <ios>)
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
#ifndef _XIOSBASE_
#define _XIOSBASE_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xlocale>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 1 3
// xlocale internal header (from <locale>)
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
#ifndef _XLOCALE_
#define _XLOCALE_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <climits>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
#if 0 /* expanded by -frewrite-includes */
#include <cstring>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdexcept>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 1 3
// stdexcept standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
#ifndef _STDEXCEPT_
#define _STDEXCEPT_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
#if 0 /* expanded by -frewrite-includes */
#include <xstring>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 1 3
// xstring internal header (from <string>)
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
#ifndef _XSTRING_
#define _XSTRING_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xmemory0>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

_STD_BEGIN
template<class _Traits>
	using _Traits_ch_t = typename _Traits::char_type;

template<class _Traits>
	using _Traits_ptr_t = const typename _Traits::char_type *;

template<class _Traits>
	constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
		_In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) _NOEXCEPT
	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);
	}

template<class _Traits>
	constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
		_In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) _NOEXCEPT
	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
	const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));

	if (_Ans != 0)
		{
		return (_Ans);
		}

	if (_Left_size < _Right_size)
		{
		return (-1);
		}

	if (_Left_size > _Right_size)
		{
		return (1);
		}

	return (0);
	}

template<class _Traits>
	constexpr size_t _Traits_find(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) _NOEXCEPT
	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)
		{	// xpos cannot exist, report failure
			// N4659 24.3.2.7.2 [string.find]/1 says:
			// 1. _Start_at <= xpos
			// 2. xpos + _Needle_size <= _Hay_size;
			// therefore:
			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
		return (static_cast<size_t>(-1));
		}

	if (_Needle_size == 0)
		{	// empty string always matches if xpos is possible
		return (_Start_at);
		}

	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)
		{
		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);
		if (!_Match_try)
			{	// didn't find first character; report failure
			return (static_cast<size_t>(-1));
			}

		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
			{	// found match
			return (_Match_try - _Haystack);
			}
		}
	}

template<class _Traits>
	constexpr size_t _Traits_find_ch(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) _NOEXCEPT
	{	// search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
	if (_Start_at < _Hay_size)
		{
		const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
		if (_Found_at)
			{
			return (_Found_at - _Haystack);
			}
		}

	return (static_cast<size_t>(-1));	// (npos) no match
	}

template<class _Traits>
	constexpr size_t _Traits_rfind(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) _NOEXCEPT
	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
	if (_Needle_size == 0)
		{
		return (_Min_value(_Start_at, _Hay_size));	// empty string always matches
		}

	if (_Needle_size <= _Hay_size)
		{	// room for match, look for it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size); ; --_Match_try)
			{
			if (_Traits::eq(*_Match_try, *_Needle)
				&& _Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_rfind_ch(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) _NOEXCEPT
	{	// search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
	if (_Hay_size != 0)
		{	// room for match, look for it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (_Traits::eq(*_Match_try, _Ch))
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Elem,
	bool = _Is_character<_Elem>::value>
	class _String_bitmap
	{	// _String_bitmap for character types
public:
	constexpr bool _Mark(const _Elem * _First, const _Elem * const _Last)
		{	// mark this bitmap such that the characters in [_First, _Last) are intended to match
			// returns whether all inputs can be placed in the bitmap
		for (; _First != _Last; ++_First)
			{
			_Matches[static_cast<unsigned char>(*_First)] = true;
			}

		return (true);
		}

	constexpr bool _Match(const _Elem _Ch) const
		{	// test if _Ch is in the bitmap
		return (_Matches[static_cast<unsigned char>(_Ch)]);
		}

private:
	bool _Matches[256] = {};
	};

template<class _Elem>
	class _String_bitmap<_Elem, false>
	{	// _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
public:
	static_assert(is_unsigned_v<_Elem>,
		"Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
		"Visual C++ accepts other unsigned integral types as an extension.");

	constexpr bool _Mark(const _Elem * _First, const _Elem * const _Last)
		{	// mark this bitmap such that the characters in [_First, _Last) are intended to match
			// returns whether all inputs can be placed in the bitmap
		for (; _First != _Last; ++_First)
			{
			const auto _Ch = *_First;
			if (_Ch >= 256U)
				{
				return (false);
				}

			_Matches[static_cast<unsigned char>(_Ch)] = true;
			}

		return (true);
		}

	constexpr bool _Match(const _Elem _Ch) const
		{	// test if _Ch is in the bitmap
		return (_Ch < 256U && _Matches[_Ch]);
		}

private:
	bool _Matches[256] = {};
	};

template<class _Traits>
	constexpr size_t _Traits_find_first_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// general algorithm
	if (_Needle_size != 0 && _Start_at < _Hay_size)
		{	// room for match, look for it
		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_first_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// special case for std::char_traits
	if (_Needle_size != 0 && _Start_at < _Hay_size)
		{	// room for match, look for it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (_Matches._Match(*_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
		// general algorithm
	if (_Needle_size != 0 && _Hay_size != 0)
		{	// worth searching, do it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
		// special case for std::char_traits
	if (_Needle_size != 0 && _Hay_size != 0)
		{	// worth searching, do it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (_Matches._Match(*_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_first_not_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// general algorithm
	if (_Start_at < _Hay_size)
		{	// room for match, look for it
		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (!_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_first_not_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// special case for std::char_traits
	if (_Start_at < _Hay_size)
		{	// room for match, look for it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (!_Matches._Match(*_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_not_ch(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) _NOEXCEPT
	{	// search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
	if (_Start_at < _Hay_size)
		{	// room for match, look for it
		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (!_Traits::eq(*_Match_try, _Ch))
				{
				return (_Match_try - _Haystack);	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_not_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
		// general algorithm
	if (_Hay_size != 0)
		{	// worth searching, do it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (!_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_not_of(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		_In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) _NOEXCEPT
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
		// special case for std::char_traits
	if (_Hay_size != 0)
		{	// worth searching, do it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_last_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (!_Matches._Match(*_Match_try))
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_rfind_not_ch(
		_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) _NOEXCEPT
	{	// search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
	if (_Hay_size != 0)
		{	// room for match, look for it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (!_Traits::eq(*_Match_try, _Ch))
				{
				return (_Match_try - _Haystack);	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}


#if _HAS_CXX17
		// CLASS TEMPLATE _String_view_iterator
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_string_view;

template<class _Traits>
	class _String_view_iterator;

template<class _Traits>
	constexpr _String_view_iterator<_Traits>& _Rechecked(_String_view_iterator<_Traits>& _Iter,
		typename _String_view_iterator<_Traits>::_Unchecked_type _Right) _NOEXCEPT;
template<class _Traits>
	constexpr typename _String_view_iterator<_Traits>::_Unchecked_type _Unchecked(
		_String_view_iterator<_Traits>) _NOEXCEPT;

template<class _Traits>
	class _String_view_iterator
	{	// iterator for character buffer wrapper
public:
	using iterator_category = random_access_iterator_tag;
	using value_type        = typename _Traits::char_type;
	using difference_type   = ptrdiff_t;
	using pointer           = const value_type *;
	using reference         = const value_type&;

	using _Unchecked_type = pointer;

	constexpr _String_view_iterator() _NOEXCEPT
#if _ITERATOR_DEBUG_LEVEL >= 1
		: _Mydata(),
		_Mysize(0),
		_Myoff(0)
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 511 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		: _Myptr()
#endif /* _ITERATOR_DEBUG_LEVEL */
# 513 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	{	// default-initialize a basic_string_view::const_iterator
	}

private:
	friend basic_string_view<value_type, _Traits>;
	friend constexpr _String_view_iterator& _Rechecked<>(_String_view_iterator& _Iter,
		_Unchecked_type _Right) _NOEXCEPT;
	friend constexpr _Unchecked_type _Unchecked<>(_String_view_iterator) _NOEXCEPT;

#if _ITERATOR_DEBUG_LEVEL >= 1
	constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) _NOEXCEPT
		: _Mydata(_Data),
		_Mysize(_Size),
		_Myoff(_Off)
	{	// initialize a basic_string_view::const_iterator
	}
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 530 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	constexpr explicit _String_view_iterator(const pointer _Ptr) _NOEXCEPT
		: _Myptr(_Ptr)
	{	// initialize a basic_string_view::const_iterator
	}
#endif /* _ITERATOR_DEBUG_LEVEL */
# 535 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

public:
	_NODISCARD constexpr reference operator*() const _NOEXCEPT
		{	// return designated object
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
		_IDL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
		return (_Mydata[_Myoff]);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 544 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (*_Myptr);
#endif /* _ITERATOR_DEBUG_LEVEL */
# 546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	_NODISCARD constexpr pointer operator->() const _NOEXCEPT
		{	// return pointer to class object
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
		_IDL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
		return (_Mydata + _Myoff);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (_Myptr);
#endif /* _ITERATOR_DEBUG_LEVEL */
# 557 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	constexpr _String_view_iterator& operator++() _NOEXCEPT
		{	// preincrement
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
		_IDL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
		++_Myoff;
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 566 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		++_Myptr;
#endif /* _ITERATOR_DEBUG_LEVEL */
# 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (*this);
		}

	constexpr _String_view_iterator operator++(int) _NOEXCEPT
		{	// postincrement
		_String_view_iterator _Tmp{*this};
		++*this;
		return (_Tmp);
		}

	constexpr _String_view_iterator& operator--() _NOEXCEPT
		{	// predecrement
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
		_IDL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
		--_Myoff;
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 585 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		--_Myptr;
#endif /* _ITERATOR_DEBUG_LEVEL */
# 587 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (*this);
		}

	constexpr _String_view_iterator operator--(int) _NOEXCEPT
		{	// postdecrement
		_String_view_iterator _Tmp{*this};
		--*this;
		return (_Tmp);
		}

	constexpr _String_view_iterator& operator+=(const difference_type _Off) _NOEXCEPT
		{	// increment by integer
#if _ITERATOR_DEBUG_LEVEL >= 1
		if (_Off != 0)
			{
			_IDL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
			}

		if (_Off < 0)
			{
#pragma warning(suppress: 4146)	// unary minus operator applied to unsigned type, result still unsigned
			_IDL_VERIFY(_Myoff >= -static_cast<size_t>(_Off),
				"cannot seek string_view iterator before begin");
			}

		if (_Off > 0)
			{
			_IDL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off),
				"cannot seek string_view iterator after end");
			}

		_Myoff += _Off;
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 620 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		_Myptr += _Off;
#endif /* _ITERATOR_DEBUG_LEVEL */
# 622 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		return (*this);
		}

	_NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const _NOEXCEPT
		{	// return this + integer
		_String_view_iterator _Tmp{*this};
		_Tmp += _Off;
		return (_Tmp);
		}

	constexpr _String_view_iterator& operator-=(const difference_type _Off) _NOEXCEPT
		{	// decrement by integer
#if _ITERATOR_DEBUG_LEVEL >= 1
		if (_Off != 0)
			{
			_IDL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
			}

		if (_Off > 0)
			{
			_IDL_VERIFY(_Myoff >= static_cast<size_t>(_Off),
				"cannot seek string_view iterator before begin");
			}

		if (_Off < 0)
			{
#pragma warning(suppress: 4146)	// unary minus operator applied to unsigned type, result still unsigned
			_IDL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off),
				"cannot seek string_view iterator after end");
			}

		_Myoff -= _Off;
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 656 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		_Myptr -= _Off;
#endif /* _ITERATOR_DEBUG_LEVEL */
# 658 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		return (*this);
		}

	_NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const _NOEXCEPT
		{	// return this - integer
		_String_view_iterator _Tmp{*this};
		_Tmp -= _Off;
		return (_Tmp);
		}

	_NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// return difference of iterators
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
			"cannot subtract incompatible string_view iterators");
		return (_Myoff - _Right._Myoff);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 676 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (_Myptr - _Right._Myptr);
#endif /* _ITERATOR_DEBUG_LEVEL */
# 678 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	_NODISCARD constexpr reference operator[](const difference_type _Off) const _NOEXCEPT
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// test for iterator equality
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
			"cannot compare incompatible string_view iterators for equality");
		return (_Myoff == _Right._Myoff);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 692 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (_Myptr == _Right._Myptr);
#endif /* _ITERATOR_DEBUG_LEVEL */
# 694 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	_NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// test if this < _Right
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
			"cannot compare incompatible string_view iterators");
		return (_Myoff < _Right._Myoff);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 708 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (_Myptr < _Right._Myptr);
#endif /* _ITERATOR_DEBUG_LEVEL */
# 710 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	_NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const _NOEXCEPT
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

private:
#if _ITERATOR_DEBUG_LEVEL >= 1
	pointer _Mydata;
	size_t _Mysize;
	size_t _Myoff;
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 733 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	pointer _Myptr;
#endif /* _ITERATOR_DEBUG_LEVEL */
# 735 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	};

template<class _Traits>
	_NODISCARD constexpr _String_view_iterator<_Traits> operator+(
		const typename _String_view_iterator<_Traits>::difference_type _Off,
		_String_view_iterator<_Traits> _Right) _NOEXCEPT
	{	// return integer + _Right
	_Right += _Off;
	return (_Right);
	}

template<class _Traits>
	constexpr _String_view_iterator<_Traits>& _Rechecked(_String_view_iterator<_Traits>& _Iter,
		const typename _String_view_iterator<_Traits>::_Unchecked_type _Right) _NOEXCEPT
	{	// reset from unchecked iterator
#if _ITERATOR_DEBUG_LEVEL >= 1
	_Iter._Myoff = _Right - _Iter._Mydata;
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 753 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	_Iter._Myptr = _Right;
#endif /* _ITERATOR_DEBUG_LEVEL */
# 755 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	return (_Iter);
	}

template<class _Traits>
	constexpr typename _String_view_iterator<_Traits>::_Unchecked_type _Unchecked(
		const _String_view_iterator<_Traits> _Iter) _NOEXCEPT
	{	// convert to unchecked
#if _ITERATOR_DEBUG_LEVEL >= 1
	return (_Iter._Mydata + _Iter._Myoff);
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 765 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	return (_Iter._Myptr);
#endif /* _ITERATOR_DEBUG_LEVEL */
# 767 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	}


		// CLASS TEMPLATE basic_string_view
template<class _Elem,
	class _Traits>
	class basic_string_view
	{	// wrapper for any kind of contiguous character buffer
public:
	static_assert(is_same_v<_Elem, typename _Traits::char_type>, "Bad char_traits for basic_string_view; "
	"N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");

	using traits_type            = _Traits;
	using value_type             = _Elem;
	using pointer                = _Elem *;
	using const_pointer          = const _Elem *;
	using reference              = _Elem&;
	using const_reference        = const _Elem&;
	using const_iterator         = _String_view_iterator<_Traits>;
	using iterator               = const_iterator;
	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
	using reverse_iterator       = const_reverse_iterator;
	using size_type              = size_t;
	using difference_type        = ptrdiff_t;

	static constexpr auto npos{static_cast<size_type>(-1)};

	constexpr basic_string_view() _NOEXCEPT
		: _Mydata(),
		_Mysize(0)
		{	// construct empty basic_string_view
		}

	constexpr basic_string_view(const basic_string_view&) _NOEXCEPT = default;
	constexpr basic_string_view& operator=(const basic_string_view&) _NOEXCEPT = default;

	/* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) _NOEXCEPT // strengthened
		: _Mydata(_Ntcts),
		_Mysize(_Traits::length(_Ntcts))
		{	// construct basic_string_view around a null-terminated character-type sequence
		}

	constexpr basic_string_view(_In_reads_(_Count) const const_pointer _Cts, const size_type _Count)
			_NOEXCEPT // strengthened
		: _Mydata(_Cts),
		_Mysize(_Count)
		{	// construct basic_string_view around a character-type sequence with explicit size
		_IDL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
		}

	_NODISCARD constexpr const_iterator begin() const _NOEXCEPT
		{	// get the beginning of the range
#if _ITERATOR_DEBUG_LEVEL >= 1
		return (const_iterator(_Mydata, _Mysize, 0));
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 822 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (const_iterator(_Mydata));
#endif /* _ITERATOR_DEBUG_LEVEL */
# 824 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	_NODISCARD constexpr const_iterator end() const _NOEXCEPT
		{	// get the end of the range
#if _ITERATOR_DEBUG_LEVEL >= 1
		return (const_iterator(_Mydata, _Mysize, _Mysize));
#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 831 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		return (const_iterator(_Mydata + _Mysize));
#endif /* _ITERATOR_DEBUG_LEVEL */
# 833 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
		}

	_NODISCARD constexpr const_iterator cbegin() const _NOEXCEPT
		{	// get the beginning of the range
		return (begin());
		}

	_NODISCARD constexpr const_iterator cend() const _NOEXCEPT
		{	// get the end of the range
		return (end());
		}

	_NODISCARD constexpr const_reverse_iterator rbegin() const _NOEXCEPT
		{	// get the beginning of the reversed range
		return (const_reverse_iterator{end()});
		}

	_NODISCARD constexpr const_reverse_iterator rend() const _NOEXCEPT
		{	// get the end of the reversed range
		return (const_reverse_iterator{begin()});
		}

	_NODISCARD constexpr const_reverse_iterator crbegin() const _NOEXCEPT
		{	// get the beginning of the reversed range
		return (rbegin());
		}

	_NODISCARD constexpr const_reverse_iterator crend() const _NOEXCEPT
		{	// get the end of the reversed range
		return (rend());
		}

	constexpr const_pointer _Unchecked_begin() const _NOEXCEPT
		{	// get pointer to beginning of the range
		return (_Mydata);
		}

	constexpr const_pointer _Unchecked_end() const _NOEXCEPT
		{	// get pointer to end of the range
		return (_Mydata + _Mysize);
		}

	_NODISCARD constexpr size_type size() const _NOEXCEPT
		{	// get the size of this basic_string_view
		return (_Mysize);
		}

	_NODISCARD constexpr size_type length() const _NOEXCEPT
		{	// get the size of this basic_string_view
		return (_Mysize);
		}

	_NODISCARD constexpr bool empty() const _NOEXCEPT
		{	// check whether this basic_string_view is empty
		return (_Mysize == 0);
		}

	_NODISCARD constexpr const_pointer data() const _NOEXCEPT
		{	// get the base pointer of this basic_string_view
		return (_Mydata);
		}

	_NODISCARD constexpr size_type max_size() const _NOEXCEPT
		{	// get the maximum possible size
			// bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
			// bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
		return (_Min_value(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem)));
		}

	_NODISCARD constexpr const_reference operator[](const size_type _Off) const _NOEXCEPT // strengthened
		{	// get character at offset; assume offset is in range
		_IDL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
		return (_Mydata[_Off]);
		}

	_NODISCARD constexpr const_reference at(const size_type _Off) const
		{	// get the character at _Off or throw if that is out of range
		_Check_offset_exclusive(_Off);
		return (_Mydata[_Off]);
		}

	_NODISCARD constexpr const_reference front() const _NOEXCEPT // strengthened
		{	// returns a reference to the first character in *this
		_IDL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
		return (_Mydata[0]);
		}

	_NODISCARD constexpr const_reference back() const _NOEXCEPT // strengthened
		{	// returns a reference to the last character in *this
		_IDL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
		return (_Mydata[_Mysize - 1]);
		}

	constexpr void remove_prefix(const size_type _Count) _NOEXCEPT // strengthened
		{	// chop off the beginning
		_IDL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
		_Mydata += _Count;
		_Mysize -= _Count;
		}

	constexpr void remove_suffix(const size_type _Count) _NOEXCEPT // strengthened
		{	// chop off the end
		_IDL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
		_Mysize -= _Count;
		}

	constexpr void swap(basic_string_view& _Other) _NOEXCEPT
		{	// swap contents
		const basic_string_view _Tmp{_Other};	// note: std::swap is not constexpr
		_Other = *this;
		*this = _Tmp;
		}

	_SCL_INSECURE_DEPRECATE_FN(basic_string_view::copy)
	constexpr size_type copy(_Out_writes_(_Count) _Elem * const _Ptr, size_type _Count,
		const size_type _Off = 0) const
		{	// copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		_Traits::copy(_Ptr, _Mydata + _Off, _Count);
		return (_Count);
		}

	_Pre_satisfies_(_Dest_size >= _Count) constexpr size_type _Copy_s(
		_Out_writes_all_(_Dest_size) _Elem * const _Dest, const size_type _Dest_size,
		size_type _Count, const size_type _Off = 0) const
		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		_Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
		return (_Count);
		}

	_NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const
		{	// return a new basic_string_view moved forward by _Off and trimmed to _Count elements
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		return (basic_string_view(_Mydata + _Off, _Count));
		}

	constexpr bool _Equal(const basic_string_view _Right) const _NOEXCEPT
		{	// test if *this and _Right are equal
		return (_Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize));
		}

	_NODISCARD constexpr int compare(const basic_string_view _Right) const _NOEXCEPT
		{	// compare [0, _Mysize) with _Right
		return (_Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize));
		}

	_NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const
		{	// compare [_Off, _Off + _N0) with _Right
		return (substr(_Off, _N0).compare(_Right));
		}

	_NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
		const basic_string_view _Right, const size_type _Roff, const size_type _Count) const
		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		return (substr(_Off, _N0).compare(_Right.substr(_Roff, _Count)));
		}

	_NODISCARD constexpr int compare(_In_z_ const _Elem * const _Ptr) const
		{	// compare [0, _Mysize) with [_Ptr, <null>)
		return (compare(basic_string_view(_Ptr)));
		}

	_NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
		_In_z_ const _Elem * const _Ptr) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
		return (substr(_Off, _N0).compare(basic_string_view(_Ptr)));
		}

	_NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
		_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Count) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		return (substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count)));
		}

	_NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const _NOEXCEPT
		{	// look for _Right beginning at or after _Off
		return (_Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
		}

	_NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const _NOEXCEPT
		{	// look for _Ch at or after _Off
		return (_Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
		}

	_NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
		return (_Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
		}

	_NODISCARD constexpr size_type find(_In_z_ const _Elem * const _Ptr, const size_type _Off = 0) const
		_NOEXCEPT // strengthened
		{	// look for [_Ptr, <null>) beginning at or after _Off
		return (_Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
		}

	_NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const _NOEXCEPT
		{	// look for _Right beginning before _Off
		return (_Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
		}

	_NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const _NOEXCEPT
		{	// look for _Ch before _Off
		return (_Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
		}

	_NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
		return (_Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
		}

	_NODISCARD constexpr size_type rfind(_In_z_ const _Elem * const _Ptr, const size_type _Off = npos) const
		_NOEXCEPT // strengthened
		{	// look for [_Ptr, <null>) beginning before _Off
		return (_Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
		}

	_NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
		const size_type _Off = 0) const _NOEXCEPT
		{	// look for one of _Right at or after _Off
		return (_Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const _NOEXCEPT
		{	// look for _Ch at or after _Off
		return (_Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
		}

	_NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
		return (_Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_first_of(_In_z_ const _Elem * const _Ptr,
		const size_type _Off = 0) const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, <null>) at or after _Off
		return (_Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr),
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos)
			const _NOEXCEPT
		{	// look for one of _Right before _Off
		return (_Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const _NOEXCEPT
		{	// look for _Ch before _Off
		return (_Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
		}

	_NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
		return (_Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_last_of(_In_z_ const _Elem * const _Ptr, const size_type _Off = npos) const
		_NOEXCEPT // strengthened
		{	// look for one of [_Ptr, <null>) before _Off
		return (_Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr),
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
		const size_type _Off = 0) const _NOEXCEPT
		{	// look for none of _Right at or after _Off
		return (_Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const _NOEXCEPT
		{	// look for any value other than _Ch at or after _Off
		return (_Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
		}

	_NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
		return (_Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_first_not_of(_In_z_ const _Elem * const _Ptr, const size_type _Off = 0) const
		_NOEXCEPT // strengthened
		{	// look for none of [_Ptr, <null>) at or after _Off
		return (_Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr),
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
		const size_type _Off = npos) const _NOEXCEPT
		{	// look for none of _Right before _Off
		return (_Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const _NOEXCEPT
		{	// look for any value other than _Ch before _Off
		return (_Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
		}

	_NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
		return (_Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count,
			_Is_specialization<_Traits, char_traits>{}));
		}

	_NODISCARD constexpr size_type find_last_not_of(_In_z_ const _Elem * const _Ptr, const size_type _Off = npos) const
		_NOEXCEPT // strengthened
		{	// look for none of [_Ptr, <null>) before _Off
		return (_Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr),
			_Is_specialization<_Traits, char_traits>{}));
		}

private:
	constexpr void _Check_offset(const size_type _Off) const
		{	// checks whether _Off is in the bounds of [0, size()]
		if (_Mysize < _Off)
			{
			_Xran();
			}
		}

	constexpr void _Check_offset_exclusive(const size_type _Off) const
		{	// checks whether _Off is in the bounds of [0, size())
		if (_Mysize <= _Off)
			{
			_Xran();
			}
		}

	constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const _NOEXCEPT
		{	// trims _Size to the longest it can be assuming a string at/after _Off
		return (_Min_value(_Size, _Mysize - _Off));
		}

	[[noreturn]] static void _Xran()
		{	// report an out_of_range error
		_Xout_of_range("invalid string_view position");
		}

	const_pointer _Mydata;
	size_type _Mysize;
	};


		// FUNCTION TEMPLATES operator== FOR basic_string_view
template<class _Elem,
	class _Traits>
	_NODISCARD constexpr bool operator==(const basic_string_view<_Elem, _Traits> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// compare basic_string_view instances for equality
	return (_Lhs._Equal(_Rhs));
	}

template<class _Elem,
	class _Traits,
	int = 1> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator==(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// compare objects convertible to basic_string_view instances for equality
	return (_Lhs._Equal(_Rhs));
	}

template<class _Elem,
	class _Traits,
	int = 2> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator==(const basic_string_view<_Elem, _Traits> _Lhs,
		const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) _NOEXCEPT
	{	// compare objects convertible to basic_string_view instances for equality
	return (_Lhs._Equal(_Rhs));
	}


		// FUNCTION TEMPLATES operator!= FOR basic_string_view
template<class _Elem,
	class _Traits>
	_NODISCARD constexpr bool operator!=(const basic_string_view<_Elem, _Traits> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// compare basic_string_view instances for inequality
	return (!_Lhs._Equal(_Rhs));
	}

template<class _Elem,
	class _Traits,
	int = 1> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator!=(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// compare objects convertible to basic_string_view instances for inequality
	return (!_Lhs._Equal(_Rhs));
	}

template<class _Elem,
	class _Traits,
	int = 2> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator!=(const basic_string_view<_Elem, _Traits> _Lhs,
		const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) _NOEXCEPT
	{	// compare objects convertible to basic_string_view instances for inequality
	return (!_Lhs._Equal(_Rhs));
	}


		// FUNCTION TEMPLATES operator< FOR basic_string_view
template<class _Elem,
	class _Traits>
	_NODISCARD constexpr bool operator<(const basic_string_view<_Elem, _Traits> _Lhs,
	const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// less-than compare basic_string_view instances
	return (_Lhs.compare(_Rhs) < 0);
	}

template<class _Elem,
	class _Traits,
	int = 1> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator<(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// less-than compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) < 0);
	}

template<class _Elem,
	class _Traits,
	int = 2> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator<(const basic_string_view<_Elem, _Traits> _Lhs,
		const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) _NOEXCEPT
	{	// less-than compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) < 0);
	}


		// FUNCTION TEMPLATES operator> FOR basic_string_view
template<class _Elem,
	class _Traits>
	_NODISCARD constexpr bool operator>(const basic_string_view<_Elem, _Traits> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// greater-than compare basic_string_view instances
	return (_Lhs.compare(_Rhs) > 0);
	}

template<class _Elem,
	class _Traits,
	int = 1> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator>(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// greater-than compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) > 0);
	}

template<class _Elem,
	class _Traits,
	int = 2> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator>(const basic_string_view<_Elem, _Traits> _Lhs,
		const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) _NOEXCEPT
	{	// greater-than compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) > 0);
	}


		// FUNCTION TEMPLATES operator<= FOR basic_string_view
template<class _Elem,
	class _Traits>
	_NODISCARD constexpr bool operator<=(const basic_string_view<_Elem, _Traits> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// less-than-or-equal compare basic_string_view instances
	return (_Lhs.compare(_Rhs) <= 0);
	}

template<class _Elem,
	class _Traits,
	int = 1> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator<=(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// less-than-or-equal compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) <= 0);
	}

template<class _Elem,
	class _Traits,
	int = 2> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator<=(const basic_string_view<_Elem, _Traits> _Lhs,
		const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) _NOEXCEPT
	{	// less-than-or-equal compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) <= 0);
	}


		// FUNCTION TEMPLATES operator>= FOR basic_string_view
template<class _Elem,
	class _Traits>
	_NODISCARD constexpr bool operator>=(const basic_string_view<_Elem, _Traits> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// greater-than-or-equal compare basic_string_view instances
	return (_Lhs.compare(_Rhs) >= 0);
	}

template<class _Elem,
	class _Traits,
	int = 1> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator>=(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
		const basic_string_view<_Elem, _Traits> _Rhs) _NOEXCEPT
	{	// greater-than-or-equal compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) >= 0);
	}

template<class _Elem,
	class _Traits,
	int = 2> // TRANSITION, VSO#409326
	_NODISCARD constexpr bool operator>=(const basic_string_view<_Elem, _Traits> _Lhs,
		const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) _NOEXCEPT
	{	// greater-than-or-equal compare objects convertible to basic_string_view instances
	return (_Lhs.compare(_Rhs) >= 0);
	}


		// TYPEDEFS FOR basic_string_view
using string_view    = basic_string_view<char>;
using u16string_view = basic_string_view<char16_t>;
using u32string_view = basic_string_view<char32_t>;
using wstring_view   = basic_string_view<wchar_t>;


		// STRUCT TEMPLATE SPECIALIZATION hash FOR basic_string_view
template<class _Elem,
	class _Traits>
	struct hash<basic_string_view<_Elem, _Traits>>
	{	// hash functor for basic_string_view
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string_view<_Elem, _Traits> argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_array_representation(_Keyval.data(), _Keyval.size()));
		}
	};
#endif /* _HAS_CXX17 */
# 1380 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		// CLASS TEMPLATE _String_const_iterator
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator_base
	{	// iterator for immutable string
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mystr::value_type;
	using difference_type = typename _Mystr::difference_type;
	using pointer = typename _Mystr::const_pointer;
	using reference = const value_type&;

	_String_const_iterator()
		: _Ptr()
		{	// construct with null pointer
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Ptr(_Parg)
		{	// construct with pointer _Parg
		this->_Adopt(_Pstring);
		}

	using _Unchecked_type = pointer;

	_NODISCARD reference operator*() const
		{	// return designated object
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
		const auto _Contptr = _Mycont->_Myptr();
		const auto _Rawptr = _Unfancy(_Ptr);
		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
#endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
# 1419 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		_Analysis_assume_(_Ptr);
		return (*_Ptr);
		}

	_NODISCARD pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_String_const_iterator& operator++()
		{	// preincrement
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		_IDL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
		_IDL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize,
			"cannot increment string iterator past end");
#endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
# 1439 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		++_Ptr;
		return (*this);
		}

	_String_const_iterator operator++(int)
		{	// postincrement
		_String_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_String_const_iterator& operator--()
		{	// predecrement
#if _ITERATOR_DEBUG_LEVEL >= 1
		_IDL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		_IDL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was"
			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
		_IDL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
#endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
# 1460 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		--_Ptr;
		return (*this);
		}

	_String_const_iterator operator--(int)
		{	// postdecrement
		_String_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_String_const_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
#if _ITERATOR_DEBUG_LEVEL >= 1
		if (_Off != 0)
			{
			_IDL_VERIFY(_Ptr, "cannot seek value-initialized string iterator");
			const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
			_IDL_VERIFY(_Mycont != 0, "cannot seek string iterator because the iterator was"
				" invalidated (e.g. reallocation occurred, or the string was destroyed)");
			const auto _Contptr = _Mycont->_Myptr();
			const auto _Rawptr = _Unfancy(_Ptr);
			_IDL_VERIFY(_Contptr <= _Rawptr + _Off, "cannot seek string iterator before begin");
			_IDL_VERIFY(_Rawptr + _Off <= _Contptr + _Mycont->_Mysize,
				"cannot seek string iterator past end");
			}
#endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
# 1488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		_Ptr += _Off;
		return (*this);
		}

	_NODISCARD _String_const_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_String_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_String_const_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _String_const_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_String_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const _String_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	_NODISCARD reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD bool operator==(const _String_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	_NODISCARD bool operator!=(const _String_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD bool operator<(const _String_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	_NODISCARD bool operator>(const _String_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD bool operator<=(const _String_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD bool operator>=(const _String_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

#if _ITERATOR_DEBUG_LEVEL >= 1
	void _Compat(const _String_const_iterator& _Right) const
		{	// test for compatible iterator pair
		_IDL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."
			" point to different string instances)");
		}

#else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
# 1561 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	void _Compat(const _String_const_iterator&) const
		{	// test for compatible iterator pair
		}
#endif /* _ITERATOR_DEBUG_LEVEL */
# 1565 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	pointer _Ptr;	// pointer to element in string
	};

template<class _Mystr>
	_NODISCARD inline _String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>& _Rechecked(_String_const_iterator<_Mystr>& _Iter,
		const typename _String_const_iterator<_Mystr>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
	_Iter._Ptr = _Right;
	return (_Iter);
	}

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type _Unchecked(
		const _String_const_iterator<_Mystr>& _Iter)
	{	// make an unchecked iterator
	return (_Iter._Ptr);
	}

		// CLASS TEMPLATE _String_iterator
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	// iterator for mutable string
public:
	using _Mybase = _String_const_iterator<_Mystr>;
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mystr::value_type;
	using difference_type = typename _Mystr::difference_type;
	using pointer = typename _Mystr::pointer;
	using reference = value_type&;

	_String_iterator()
		{	// construct with null string pointer
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	// construct with pointer _Parg
		}

	using _Unchecked_type = pointer;

	_NODISCARD reference operator*() const
		{	// return designated object
		return ((reference)**(_Mybase *)this);
		}

	_NODISCARD pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_String_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_String_iterator operator++(int)
		{	// postincrement
		_String_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_String_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_String_iterator operator--(int)
		{	// postdecrement
		_String_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_String_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_NODISCARD _String_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_String_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_String_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _String_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_String_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	_NODISCARD reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Mystr>
	_NODISCARD inline _String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>& _Rechecked(_String_iterator<_Mystr>& _Iter,
		const typename _String_iterator<_Mystr>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
	_Iter._Ptr = _Right;
	return (_Iter);
	}

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type _Unchecked(
		const _String_iterator<_Mystr>& _Iter)
	{	// make an unchecked iterator
	return (_Const_cast(_Iter._Ptr));
	}

		// basic_string TYPE WRAPPERS
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	// wraps types needed by iterators
	using value_type = _Value_type;
	using size_type = _Size_type;
	using difference_type = _Difference_type;
	using pointer = _Pointer;
	using const_pointer = _Const_pointer;
	};

template<class _Ty,
	class _Alloc>
	struct _String_base_types
	{	// types needed for a container base
	using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
	using _Alty_traits = allocator_traits<_Alty>;

	using _Val_types = conditional_t<_Is_simple_alloc_v<_Alty>,
		_Simple_types<_Ty>,
		_String_iter_types<_Ty,
			typename _Alty_traits::size_type,
			typename _Alty_traits::difference_type,
			typename _Alty_traits::pointer,
			typename _Alty_traits::const_pointer,
			_Ty&,
			const _Ty&>>;
	};

		// CLASS TEMPLATE _String_val
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	// base class for basic_string to hold data
public:
	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	_String_val()
		: _Bx(),
		_Mysize(0),
		_Myres(0)
		{	// initialize values
		}

	enum
		{	// length of internal buffer, [1, 16]
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	// roundup mask for allocated buffers, [0, 15]
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0
		};

	value_type *_Myptr()
		{	// determine current pointer to buffer for mutable string
		value_type * _Result = _Bx._Buf;
		if (_Large_string_engaged())
			{
			_Result = _Unfancy(_Bx._Ptr);
			}

		return (_Result);
		}

	const value_type *_Myptr() const
		{	// determine current pointer to buffer for immutable string
		const value_type * _Result = _Bx._Buf;
		if (_Large_string_engaged())
			{
			_Result = _Unfancy(_Bx._Ptr);
			}

		return (_Result);
		}

	bool _Large_string_engaged() const
		{	// returns whether the large string mode (allocated memory) is engaged
		return (_BUF_SIZE <= _Myres);
		}

	void _Check_offset(const size_type _Off) const
		{	// checks whether _Off is in the bounds of [0, this->size()]
		if (_Mysize < _Off)
			{
			_Xran();
			}
		}

	void _Check_offset_exclusive(const size_type _Off) const
		{	// checks whether _Off is in the bounds of [0, this->size())
		if (_Mysize <= _Off)
			{
			_Xran();
			}
		}

	[[noreturn]] static void _Xran()
		{	// report an out_of_range error
		_Xout_of_range("invalid string position");
		}

	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const _NOEXCEPT
		{	// trims _Size to the longest it can be assuming a string at/after _Off
		return (_Min_value(_Size, _Mysize - _Off));
		}

	union _Bxty
		{	// storage for small buffer or pointer to larger one
		_Bxty()
			{	// user-provided, for fancy pointers
			}

		~_Bxty() _NOEXCEPT
			{	// user-provided, for fancy pointers
			}

		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	// retained for /clr bincompat; unused
		} _Bx;

	size_type _Mysize;	// current length of string
	size_type _Myres;	// current storage reserved for string
	};

		// CLASS TEMPLATE _String_alloc
template<class _Alloc_types>
	class _String_alloc
	{	// base class for basic_string to hold allocator
public:
	using _Alty = typename _Alloc_types::_Alty;
	using _Alty_traits = typename _Alloc_types::_Alty_traits;
	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Val_types = typename _Alloc_types::_Val_types;
	using _Mydata_t = _String_val<_Val_types>;
	using _Bxty = typename _Mydata_t::_Bxty;

	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using iterator = _String_iterator<_Mydata_t>;
	using const_iterator = _String_const_iterator<_Mydata_t>;

	enum
		{	// length of internal buffer, [1, 16]
		_BUF_SIZE = _Mydata_t::_BUF_SIZE
		};

	enum
		{	// roundup mask for allocated buffers, [0, 15]
		_ALLOC_MASK = _Mydata_t::_ALLOC_MASK
		};

#if _ITERATOR_DEBUG_LEVEL == 0
	_String_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<decay_t<_Any_alloc>, _String_alloc>>>
		_String_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			_STD forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		_Pocca(_Getal(), _Al);
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		_Pocma(_Getal(), _Al);
		}

#else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 1909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
	_String_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<decay_t<_Any_alloc>, _String_alloc>>>
		_String_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			_STD forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		_Alloc_proxy();
		}

	~_String_alloc() _NOEXCEPT
		{	// destroy the object
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocca(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_move_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocma(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Alloc_proxy()
		{	// construct proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = _STD addressof(_Get_data());
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
		_Deallocate_plain(_Proxy_allocator, _Myproxy());
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() _NOEXCEPT
		{	// return reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const _NOEXCEPT
		{	// return const reference to _Myproxy
		return (_Get_data()._Myproxy);
		}
#endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 1997 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	void _Orphan_all()
		{	// orphan all iterators
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_String_alloc& _Right)
		{	// swap all iterators
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() _NOEXCEPT
		{	// return reference to allocator
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const _NOEXCEPT
		{	// return const reference to allocator
		return (_Mypair._Get_first());
		}

	_Mydata_t& _Get_data() _NOEXCEPT
		{	// return reference to _String_val
		return (_Mypair._Get_second());
		}

	const _Mydata_t& _Get_data() const _NOEXCEPT
		{	// return const reference to _String_val
		return (_Mypair._Get_second());
		}

private:
	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
	};


		// CLASS TEMPLATE basic_string
template<class _Ty>
	constexpr size_t _Size_after_ebco_v
		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_string
		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
	{	// null-terminated transparent array of elements
public:
	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
		_MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));

	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
		"char_traits character type match the string's character type.");

	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
	using traits_type = _Traits;
	using allocator_type = _Alloc;

	using _Alty = typename _Mybase::_Alty;
	using _Alty_traits = typename _Mybase::_Alty_traits;
	using _Mydata_t = typename _Mybase::_Mydata_t;

	using value_type = typename _Mybase::value_type;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;

	using reverse_iterator = _STD reverse_iterator<iterator>;
	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

	// When doing swap / move by memcpy, we are touching:
	//   _String_val::_Bx::_Buf (type is array of _Elem)
	//   _String_val::_Bx::_Ptr (type is pointer)
	//   _String_val::_Mysize   (type is size_type)
	//   _String_val::_Myres    (type is size_type)
	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
	// We need to ask if pointer is safe to memcpy.
	// size_type must be an unsigned integral type so memcpy is safe.
	// We also need to disable memcpy if the user has supplied _Traits, since
	//   they can observe traits::assign and similar.
	using _Use_memcpy_move = bool_constant<
		_Is_specialization<_Traits, char_traits>::value && is_trivial_v<pointer>>;
	// This offset skips over the _Container_base members, if any
	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;

	template<class _Iter>
		using _Is_elem_cptr = _Disjunction_t<
			is_same<_Iter, const _Elem * const>,
			is_same<_Iter, _Elem * const>,
			is_same<_Iter, const _Elem *>,
			is_same<_Iter, _Elem *>>;

#if _HAS_CXX17
	template<class _StringViewIsh>
		using _Is_string_view_ish = enable_if_t<conjunction_v<
			is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
			negation<is_convertible<const _StringViewIsh&, const _Elem *>>>>;
#endif /* _HAS_CXX17 */
# 2103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3


	basic_string(const basic_string& _Right)
		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct by copying _Right
		_Construct_lv_contents(_Right);
		}

	basic_string(const basic_string& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct by copying with allocator
		_Construct_lv_contents(_Right);
		}

	basic_string() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
		: _Mybase()
		{	// construct empty string
		_Tidy_init();
		}

	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
		: _Mybase(_Al)
		{	// construct empty string with allocator
		_Tidy_init();
		}

	basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Right [_Roff, <end>)
		_Tidy_init();
		assign(_Right, _Roff, npos);
		}

	basic_string(const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Right [_Roff, _Roff + _Count)
		_Tidy_init();
		assign(_Right, _Roff, _Count);
		}

	basic_string(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
		: _Mybase()
		{	// construct from [_Ptr, _Ptr + _Count)
		_Tidy_init();
		assign(_Ptr, _Count);
		}

	basic_string(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_Ptr, _Ptr + _Count) with allocator
		_Tidy_init();
		assign(_Ptr, _Count);
		}

	basic_string(_In_z_ const _Elem * const _Ptr)
		: _Mybase()
		{	// construct from [_Ptr, <null>)
		_Tidy_init();
		assign(_Ptr);
		}

	basic_string(_In_z_ const _Elem * const _Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_Ptr, <null>) with allocator
		_Tidy_init();
		assign(_Ptr);
		}

	basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
		: _Mybase()
		{	// construct from _Count * _Ch
		_Tidy_init();
		assign(_Count, _Ch);
		}

	basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from _Count * _Ch with allocator
		_Tidy_init();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from [_First, _Last) with optional allocator
		_DEBUG_RANGE(_First, _Last);
		_Tidy_init();
		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag)
		{	// initialize from [_First, _Last), input iterators
		_TRY_BEGIN
		for (; _First != _Last; ++_First)
			{
			push_back(static_cast<_Elem>(*_First));
			}

		_CATCH_ALL
		_Tidy_deallocate();
		_RERAISE;
		_CATCH_END
		}

	template<class _Iter>
		void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag)
		{	// initialize from [_First, _Last), forward iterators
		const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
		reserve(_Count);
		_Construct(_First, _Last, input_iterator_tag());
		}

	void _Construct(_Elem * const _First, _Elem * const _Last, random_access_iterator_tag)
		{	// initialize from [_First, _Last), pointers
		if (_First != _Last)
			{
			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
			}
		}

	void _Construct(const _Elem * const _First, const _Elem * const _Last, random_access_iterator_tag)
		{	// initialize from [_First, _Last), const pointers
		if (_First != _Last)
			{
			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
			}
		}

	basic_string(basic_string&& _Right) _NOEXCEPT
		: _Mybase(_STD move(_Right._Getal()))
		{	// construct by moving _Right
		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});
		}

	basic_string(basic_string&& _Right, const _Alloc& _Al)
		_NOEXCEPT_COND(_Alty_traits::is_always_equal::value) // strengthened
		: _Mybase(_Al)
		{	// construct by moving _Right, allocator
		_Assign_rv_contents(_STD move(_Right), typename _Alty_traits::is_always_equal{});
		}

#if _HAS_CXX17
	explicit basic_string(const basic_string_view<_Elem, _Traits> _Right,
		const _Alloc& _Al = _Alloc())
		: basic_string(_Right.data(), _Convert_size<size_type>(_Right.size()), _Al)
		{	// construct from _Right using _Al
		}

	template<class _StringViewIsh,
		class = _Is_string_view_ish<_StringViewIsh>>
		basic_string(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count,
			const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Right [_Roff, _Roff + _Count) using _Al
		_Tidy_init();
		assign(_Right, _Roff, _Count);
		}
#endif /* _HAS_CXX17 */
# 2265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& operator=(basic_string&& _Right) _NOEXCEPT_COND(_Always_equal_after_move<_Alty>)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, assign it
			_Tidy_deallocate();
			this->_Move_alloc(_Right._Getal());
			// tag dispatch to remove unnecessary exception handling codegen in the
			// equal allocators case
			_Assign_rv_contents(_STD move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});
			}

		return (*this);
		}

	basic_string& assign(basic_string&& _Right) _NOEXCEPT_COND(_Always_equal_after_move<_Alty>)
		{	// assign by moving _Right
		*this = _STD move(_Right);
		return (*this);
		}

	void _Assign_rv_contents(basic_string&& _Right, true_type) _NOEXCEPT
		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});
		}

	void _Assign_rv_contents(basic_string&& _Right, false_type)
		{	// assign either as an rvalue or as an lvalue copy, allocators potentially unequal
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		if (this->_Getal() == _Right._Getal())
			{
			_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});
			}
		else
			{
			_Construct_lv_contents(_Right);
			}
		}

	void _Assign_rv_contents_with_alloc_always_equal(basic_string&& _Right, true_type) _NOEXCEPT
		{	// assign by stealing _Right's buffer, memcpy optimization
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		auto& _Right_data = _Right._Get_data();

#if _ITERATOR_DEBUG_LEVEL != 0
		if (_Right_data._Large_string_engaged())
			{	// take ownership of _Right's iterators along with its buffer
			this->_Swap_all(_Right);
			}
		else
			{
			_Right._Orphan_all();
			}
#endif /* _ITERATOR_DEBUG_LEVEL != 0 */
# 2326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
			+ _Memcpy_move_offset;
		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
			+ _Memcpy_move_offset;
		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
		_Right._Tidy_init();
		}

	void _Assign_rv_contents_with_alloc_always_equal(basic_string&& _Right, false_type) _NOEXCEPT
		{	// assign by stealing _Right's buffer, general case
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		if (_Right_data._Large_string_engaged())
			{	// steal buffer
			_Alty_traits::construct(this->_Getal(), _STD addressof(_My_data._Bx._Ptr), _Right_data._Bx._Ptr);
			_Right_data._Bx._Ptr = pointer();
			this->_Swap_all(_Right);
			}
		else
			{	// copy small string buffer
			_Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
			_Right._Orphan_all();
			}

		_My_data._Mysize = _Right_data._Mysize;
		_My_data._Myres = _Right_data._Myres;
		_Right._Tidy_init();
		}

	void _Construct_lv_contents(const basic_string& _Right)
		{	// assign by copying data stored in _Right
			// pre: this != &_Right
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		const size_type _Right_size = _Right_data._Mysize;
		const _Elem * const _Right_ptr = _Right_data._Myptr();
		if (_Right_size < this->_BUF_SIZE)
			{	// stay small, don't allocate
			_Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);
			_My_data._Mysize = _Right_size;
			_My_data._Myres = this->_BUF_SIZE - 1;
			return;
			}

		auto& _Al = this->_Getal();
		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());
		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws
		_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
		_My_data._Mysize = _Right_size;
		_My_data._Myres = _New_capacity;
		}

	basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	// construct from initializer_list
		_Tidy_init();
		assign(_Ilist.begin(), _Ilist.size());
		}

	basic_string& operator=(initializer_list<_Elem> _Ilist)
		{	// assign initializer_list
		return (assign(_Ilist.begin(), _Ilist.size()));
		}

	basic_string& operator+=(initializer_list<_Elem> _Ilist)
		{	// append initializer_list
		return (append(_Ilist.begin(), _Ilist.size()));
		}

	basic_string& assign(initializer_list<_Elem> _Ilist)
		{	// assign initializer_list
		return (assign(_Ilist.begin(), _Ilist.size()));
		}

	basic_string& append(initializer_list<_Elem> _Ilist)
		{	// append initializer_list
		return (append(_Ilist.begin(), _Ilist.size()));
		}

	iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist)
		{	// insert initializer_list
		const size_type _Off = _Where - begin();
		insert(_Off, _Ilist.begin(), _Ilist.size());
		return (begin() + _Off);
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist)
		{	// replace with initializer_list
		return (replace(_First - begin(), _Last - _First, _Ilist.begin(), _Ilist.size()));
		}

	~basic_string() _NOEXCEPT
		{	// destroy the string
		_Tidy_deallocate();
		}

	static constexpr auto npos{static_cast<size_type>(-1)};

	basic_string& operator=(const basic_string& _Right)
		{	// assign _Right
		if (this != _STD addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	// conditional expression is constant
			if (_Alty_traits::propagate_on_container_copy_assignment::value
				&& this->_Getal() != _Right._Getal())
				{	// change allocator before copying
				_Tidy_deallocate();
				}
#pragma warning(pop)

			this->_Copy_alloc(_Right._Getal());

			auto& _Right_data = _Right._Get_data();
			assign(_Right_data._Myptr(), _Right_data._Mysize);
			}

		return (*this);
		}

#if _HAS_CXX17
	basic_string& operator=(const basic_string_view<_Elem, _Traits> _Right)
		{	// assign _Right
		return (assign(_Right));
		}
#endif /* _HAS_CXX17 */
# 2458 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& operator=(_In_z_ const _Elem * const _Ptr)
		{	// assign [_Ptr, <null>)
		return (assign(_Ptr));
		}

	basic_string& operator=(const _Elem _Ch)
		{	// assign {_Ch, _Elem()}
		auto& _My_data = this->_Get_data();
		_My_data._Mysize = 1;
		_Elem * const _Ptr = _My_data._Myptr();
		_Traits::assign(_Ptr[0], _Ch);
		_Traits::assign(_Ptr[1], _Elem());
		return (*this);
		}

	basic_string& operator+=(const basic_string& _Right)
		{	// append _Right
		return (append(_Right));
		}

#if _HAS_CXX17
	basic_string& operator+=(const basic_string_view<_Elem, _Traits> _Right)
		{	// append _Right
		return (append(_Right));
		}
#endif /* _HAS_CXX17 */
# 2485 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& operator+=(_In_z_ const _Elem * const _Ptr)
		{	// append [_Ptr, <null>)
		return (append(_Ptr));
		}

	basic_string& operator+=(_Elem _Ch)
		{	// append 1 * _Ch
		push_back(_Ch);
		return (*this);
		}

	basic_string& append(const basic_string& _Right)
		{	// append _Right
		auto& _Right_data = _Right._Get_data();
		return (append(_Right_data._Myptr(), _Right_data._Mysize));
		}

	basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// append _Right [_Roff, _Roff + _Count)
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (append(_Right_data._Myptr() + _Roff, _Count));
		}

#if _HAS_CXX17
	basic_string& append(const basic_string_view<_Elem, _Traits> _Right)
		{	// append _Right
		return (append(_Right.data(), _Convert_size<size_type>(_Right.size())));
		}

	template<class _StringViewIsh,
		class = _Is_string_view_ish<_StringViewIsh>>
		basic_string& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
		{	// append _Right [_Roff, _Roff + _Count)
		basic_string_view<_Elem, _Traits> _As_view = _Right;
		return (append(_As_view.substr(_Roff, _Count)));
		}
#endif /* _HAS_CXX17 */
# 2525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& append(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
		{	// append [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const _Elem * const _Ptr, const size_type _Count) {
			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
			}, _Ptr, _Count));
		}

	basic_string& append(_In_z_ const _Elem * const _Ptr)
		{	// append [_Ptr, <null>)
		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
		{	// append _Count * _Ch
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Count, const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
			}, _Count, _Ch));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string& append(const _Iter _First, const _Iter _Last)
		{	// append [_First, _Last), input iterators
		return (replace(end(), end(), _First, _Last));
		}

	basic_string& assign(const basic_string& _Right)
		{	// assign _Right
		*this = _Right;
		return (*this);
		}

	basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// assign _Right [_Roff, _Roff + _Count)
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (assign(_Right_data._Myptr() + _Roff, _Count));
		}

#if _HAS_CXX17
	basic_string& assign(const basic_string_view<_Elem, _Traits> _Right)
		{	// assign _Right
		return (assign(_Right.data(), _Convert_size<size_type>(_Right.size())));
		}

	template<class _StringViewIsh,
		class = _Is_string_view_ish<_StringViewIsh>>
		basic_string& assign(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
		{	// assign _Right [_Roff, _Roff + _Count)
		basic_string_view<_Elem, _Traits> _As_view = _Right;
		return (assign(_As_view.substr(_Roff, _Count)));
		}
#endif /* _HAS_CXX17 */
# 2610 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& assign(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
		{	// assign [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		if (_Count <= _My_data._Myres)
			{
			_Elem * const _Old_ptr = _My_data._Myptr();
			_My_data._Mysize = _Count;
			_Traits::move(_Old_ptr, _Ptr, _Count);
			_Traits::assign(_Old_ptr[_Count], _Elem());
			return (*this);
			}

		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {
			_Traits::copy(_New_ptr, _Ptr, _Count);
			_Traits::assign(_New_ptr[_Count], _Elem());
			}, _Ptr));
		}

	basic_string& assign(_In_z_ const _Elem * const _Ptr)
		{	// assign [_Ptr, <null>)
		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
		{	// assign _Count * _Ch
		auto& _My_data = this->_Get_data();
		if (_Count <= _My_data._Myres)
			{
			_Elem * const _Old_ptr = _My_data._Myptr();
			_My_data._Mysize = _Count;
			_Traits::assign(_Old_ptr, _Count, _Ch);
			_Traits::assign(_Old_ptr[_Count], _Elem());
			return (*this);
			}

		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {
			_Traits::assign(_New_ptr, _Count, _Ch);
			_Traits::assign(_New_ptr[_Count], _Elem());
			}, _Ch));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string& assign(const _Iter _First, const _Iter _Last)
		{	// assign [_First, _Last), input iterators
		return (replace(begin(), end(), _First, _Last));
		}

	basic_string& insert(const size_type _Off, const basic_string& _Right)
		{	// insert _Right at _Off
		auto& _Right_data = _Right._Get_data();
		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));
		}

	basic_string& insert(const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// insert _Right [_Roff, _Roff + _Count) at _Off
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (insert(_Off, _Right_data._Myptr() + _Roff, _Count));
		}

#if _HAS_CXX17
	basic_string& insert(const size_type _Off, const basic_string_view<_Elem, _Traits> _Right)
		{	// insert _Right at _Off
		return (insert(_Off, _Right.data(), _Convert_size<size_type>(_Right.size())));
		}

	template<class _StringViewIsh,
		class = _Is_string_view_ish<_StringViewIsh>>
		basic_string& insert(const size_type _Off,
			const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
		{	// insert _Right [_Roff, _Roff + _Count) at _Off
		basic_string_view<_Elem, _Traits> _As_view = _Right;
		return (insert(_Off, _As_view.substr(_Roff, _Count)));
		}
#endif /* _HAS_CXX17 */
# 2688 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& insert(const size_type _Off, _In_reads_(_Count) const _Elem * const _Ptr,
		_CRT_GUARDOVERFLOW const size_type _Count)
		{	// insert [_Ptr, _Ptr + _Count) at _Off
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			// the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
			// while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
			size_type _Ptr_shifted_after;
			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)
				{	// inserted content is before the shifted region, or does not alias
				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts
				}
			else if (_Insert_at <= _Ptr)
				{	// all of [_Ptr, _Ptr + _Count) shifts
				_Ptr_shifted_after = 0;
				}
			else
				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
				}

			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
			_Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,
				_Count - _Ptr_shifted_after);
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
			}, _Off, _Ptr, _Count));
		}

	basic_string& insert(const size_type _Off, _In_z_ const _Elem * const _Ptr)
		{	// insert [_Ptr, <null>) at _Off
		return (insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& insert(const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
		{	// insert _Count * _Ch at _Off
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
			_Traits::assign(_Insert_at, _Count, _Ch); // fill hole
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const size_type _Count, const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
			}, _Off, _Count, _Ch));
		}

	iterator insert(const const_iterator _Where, const _Elem _Ch)
		{	// insert _Ch at _Where
		size_type _Off = _Where - begin();
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
		{	// insert _Count * _Elem at _Where
		const size_type _Off = _Where - begin();
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last)
		{	// insert [_First, _Last) at _Where, input iterators
		const size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	basic_string& erase(const size_type _Off = 0)
		{	// erase elements [_Off, ...)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Eos(_Off);
		return (*this);
		}

	basic_string& erase(const size_type _Off, size_type _Count)
		{	// erase elements [_Off, _Off + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Count = _My_data._Clamp_suffix_size(_Off, _Count);
		const size_type _Old_size = _My_data._Mysize;
		_Elem * const _My_ptr = _My_data._Myptr();
		_Elem * const _Erase_at = _My_ptr + _Off;
		const size_type _New_size = _Old_size - _Count;
		_My_data._Mysize = _New_size;
		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
		return (*this);
		}

	iterator erase(const const_iterator _Where)
		{	// erase element at _Where
		const size_type _Off = _Where - begin();
		erase(_Off, 1);
		return (begin() + _Off);
		}

	iterator erase(const const_iterator _First, const const_iterator _Last)
		{	// erase substring [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		const size_type _Off = _First - begin();
		erase(_Off, _Last - _First);
		return (begin() + _Off);
		}

	void clear() _NOEXCEPT
		{	// erase all
		_Eos(0);
		}

	basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right)
		{	// replace [_Off, _Off + _N0) with _Right
		auto& _Right_data = _Right._Get_data();
		return (replace(_Off, _N0, _Right_data._Myptr(), _Right_data._Mysize));
		}

	basic_string& replace(const size_type _Off, size_type _N0,
		const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (replace(_Off, _N0, _Right_data._Myptr() + _Roff, _Count));
		}

#if _HAS_CXX17
	basic_string& replace(const size_type _Off, const size_type _N0, const basic_string_view<_Elem, _Traits> _Right)
		{	// replace [_Off, _Off + _N0) with _Right
		return (replace(_Off, _N0, _Right.data(), _Convert_size<size_type>(_Right.size())));
		}

	template<class _StringViewIsh,
		class = _Is_string_view_ish<_StringViewIsh>>
		basic_string& replace(const size_type _Off, const size_type _N0,
			const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		basic_string_view<_Elem, _Traits> _As_view = _Right;
		return (replace(_Off, _N0, _As_view.substr(_Roff, _Count)));
		}
#endif /* _HAS_CXX17 */
# 2856 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& replace(const size_type _Off, size_type _N0,
		_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Count)
		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_N0 = _My_data._Clamp_suffix_size(_Off, _N0);
		if (_N0 == _Count)
			{	// size doesn't change, so a single move does the trick
			_Traits::move(_My_data._Myptr() + _Off, _Ptr, _Count);
			return (*this);
			}

		const size_type _Old_size = _My_data._Mysize;
		const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
		if (_Count < _N0)
			{	// suffix shifts backwards; we don't have to move anything out of the way
			_My_data._Mysize = _Old_size - (_N0 - _Count);
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Traits::move(_Insert_at, _Ptr, _Count);
			_Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
			return (*this);
			}

		const size_type _Growth = static_cast<size_type>(_Count - _N0);
		if (_Growth <= _My_data._Myres - _Old_size)
			{	// growth fits
			_My_data._Mysize = _Old_size + _Growth;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Elem * const _Suffix_at = _Insert_at + _N0;

			size_type _Ptr_shifted_after; // see rationale in insert
			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)
				{
				_Ptr_shifted_after = _Count;
				}
			else if (_Suffix_at <= _Ptr)
				{
				_Ptr_shifted_after = 0;
				}
			else
				{
				_Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
				}

			_Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
			// next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
			// this case doesn't occur in insert because the new content must come from outside the removed
			// content there (because in insert there is no removed content)
			_Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
			// the next case can be copy, because it comes from the chunk moved out of the way in the
			// first move, and the hole we're filling can't alias the chunk we moved out of the way
			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after,
				_Count - _Ptr_shifted_after);
			return (*this);
			}

		return (_Reallocate_grow_by(_Growth,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const size_type _N0, const _Elem * const _Ptr, const size_type _Count) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
			}, _Off, _N0, _Ptr, _Count));
		}

	basic_string& replace(const size_type _Off, const size_type _N0, _In_z_ const _Elem * const _Ptr)
		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
		return (replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch)
		{	// replace [_Off, _Off + _N0) with _Count * _Ch
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_N0 = _My_data._Clamp_suffix_size(_Off, _N0);
		if (_Count == _N0)
			{
			_Traits::assign(_My_data._Myptr() + _Off, _Count, _Ch);
			return (*this);
			}

		const size_type _Old_size = _My_data._Mysize;
		if (_Count < _N0 || _Count - _N0 <= _My_data._Myres - _Old_size)
			{	// either we are shrinking, or the growth fits
			_My_data._Mysize = _Old_size + _Count - _N0; // may temporarily overflow;
				// OK because size_type must be unsigned
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
			_Traits::assign(_Insert_at, _Count, _Ch);
			return (*this);
			}

		return (_Reallocate_grow_by(_Count - _N0,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const size_type _N0, const size_type _Count, const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
			}, _Off, _N0, _Count, _Ch));
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right)
		{	// replace [_First, _Last) with _Right
		return (replace(_First - begin(), _Last - _First, _Right));
		}

#if _HAS_CXX17
	basic_string& replace(const const_iterator _First, const const_iterator _Last,
		const basic_string_view<_Elem, _Traits> _Right)
		{	// replace [_First, _Last) with _Right
		return (replace(_First - begin(), _Last - _First, _Right));
		}
#endif /* _HAS_CXX17 */
# 2973 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	basic_string& replace(const const_iterator _First, const const_iterator _Last,
		_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Count)
		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last, _In_z_ const _Elem * const _Ptr)
		{	// replace [_First, _Last) with [_Ptr, <null>)
		return (replace(_First - begin(), _Last - _First, _Ptr));
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last,
		const size_type _Count, const _Elem _Ch)
		{	// replace [_First, _Last) with _Count * _Ch
		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
		}

	template<class _Iter>
		basic_string& _Replace_range(const const_iterator _First, const const_iterator _Last,
		const _Iter _First2, const _Iter _Last2, false_type)
		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
		const basic_string _Right(_First2, _Last2, get_allocator());
		replace(_First, _Last, _Right);
		return (*this);
		}

	template<class _Ptr>
		basic_string& _Replace_range(const const_iterator _First, const const_iterator _Last,
		const _Ptr _First2, const _Ptr _Last2, true_type)
		{	// replace [_First, _Last) with [_First2, _Last2), pointers
		return (replace(_First - cbegin(), _Last - _First, _First2, _Last2 - _First2));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string& replace(const const_iterator _First, const const_iterator _Last,
			const _Iter _First2, const _Iter _Last2)
		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
		_DEBUG_RANGE(_First2, _Last2);
		const auto _UFirst2 = _Unchecked(_First2);
		const auto _ULast2 = _Unchecked(_Last2);
		return (_Replace_range(_First, _Last, _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>()));
		}

	_NODISCARD iterator begin() _NOEXCEPT
		{	// return iterator for beginning of mutable sequence
		auto _My_data = _STD addressof(this->_Get_data());
		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));
		}

	_NODISCARD const_iterator begin() const _NOEXCEPT
		{	// return iterator for beginning of immutable sequence
		auto _My_data = _STD addressof(this->_Get_data());
		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr()), _My_data));
		}

	_NODISCARD iterator end() _NOEXCEPT
		{	// return iterator for end of mutable sequence
		auto _My_data = _STD addressof(this->_Get_data());
		return (iterator(_Refancy<pointer>(_My_data->_Myptr()) + _My_data->_Mysize, _My_data));
		}

	_NODISCARD const_iterator end() const _NOEXCEPT
		{	// return iterator for end of immutable sequence
		auto _My_data = _STD addressof(this->_Get_data());
		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr()) + _My_data->_Mysize, _My_data));
		}

	_Elem * _Unchecked_begin() _NOEXCEPT
		{	// return pointer for beginning of mutable sequence
		return (this->_Get_data()._Myptr());
		}

	const _Elem * _Unchecked_begin() const _NOEXCEPT
		{	// return pointer for beginning of immutable sequence
		return (this->_Get_data()._Myptr());
		}

	_Elem * _Unchecked_end() _NOEXCEPT
		{	// return pointer for end of mutable sequence
		auto& _My_data = this->_Get_data();
		return (_My_data._Myptr() + _My_data._Mysize);
		}

	const _Elem * _Unchecked_end() const _NOEXCEPT
		{	// return pointer for end of immutable sequence
		const auto& _My_data = this->_Get_data();
		return (_My_data._Myptr() + _My_data._Mysize);
		}

	_NODISCARD reverse_iterator rbegin() _NOEXCEPT
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	_NODISCARD const_reverse_iterator rbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed immutable sequence
		return (const_reverse_iterator(end()));
		}

	_NODISCARD reverse_iterator rend() _NOEXCEPT
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	_NODISCARD const_reverse_iterator rend() const _NOEXCEPT
		{	// return iterator for end of reversed immutable sequence
		return (const_reverse_iterator(begin()));
		}

	_NODISCARD const_iterator cbegin() const _NOEXCEPT
		{	// return iterator for beginning of immutable sequence
		return (begin());
		}

	_NODISCARD const_iterator cend() const _NOEXCEPT
		{	// return iterator for end of immutable sequence
		return (end());
		}

	_NODISCARD const_reverse_iterator crbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed immutable sequence
		return (rbegin());
		}

	_NODISCARD const_reverse_iterator crend() const _NOEXCEPT
		{	// return iterator for end of reversed immutable sequence
		return (rend());
		}

	void shrink_to_fit()
		{	// reduce capacity
		auto& _My_data = this->_Get_data();
		if (!_My_data._Large_string_engaged())
			{	// can't shrink from small mode
			return;
			}

		if (_My_data._Mysize < this->_BUF_SIZE)
			{
			_Become_small();
			return;
			}

		const size_type _Target_capacity = _Min_value(_My_data._Mysize | this->_ALLOC_MASK, max_size());
		if (_Target_capacity < _My_data._Myres)
			{	// worth shrinking, do it
			auto& _Al = this->_Getal();
			const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws
			this->_Orphan_all();
			_Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
			_Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
			_My_data._Bx._Ptr = _New_ptr;
			_My_data._Myres = _Target_capacity;
			}
		}

	_NODISCARD reference at(const size_type _Off)
		{	// subscript mutable sequence with checking
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset_exclusive(_Off);
		return (_My_data._Myptr()[_Off]);
		}

	_NODISCARD const_reference at(const size_type _Off) const
		{	// subscript immutable sequence with checking
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset_exclusive(_Off);
		return (_My_data._Myptr()[_Off]);
		}

	_NODISCARD reference operator[](const size_type _Off)
		{	// subscript mutable sequence
		auto& _My_data = this->_Get_data();
		_IDL_VERIFY(_Off <= _My_data._Mysize, "string subscript out of range");
		return (_My_data._Myptr()[_Off]);
		}

	_NODISCARD const_reference operator[](const size_type _Off) const
		{	// subscript immutable sequence
		auto& _My_data = this->_Get_data();
		_IDL_VERIFY(_Off <= _My_data._Mysize, "string subscript out of range");
		return (_My_data._Myptr()[_Off]);
		}

#if _HAS_CXX17
	/* implicit */ operator basic_string_view<_Elem, _Traits>() const _NOEXCEPT
		{	// return a string_view around *this's character-type sequence
		auto& _My_data = this->_Get_data();
		return (basic_string_view<_Elem, _Traits>(_My_data._Myptr(), _My_data._Mysize));
		}
#endif /* _HAS_CXX17 */
# 3166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	void push_back(const _Elem _Ch)
		{	// insert element at end
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (_Old_size < _My_data._Myres)
			{
			_My_data._Mysize = _Old_size + 1;
			_Elem * const _Ptr = _My_data._Myptr();
			_Traits::assign(_Ptr[_Old_size], _Ch);
			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
			return;
			}

		_Reallocate_grow_by(1,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
			_Traits::assign(_New_ptr[_Old_size], _Ch);
			_Traits::assign(_New_ptr[_Old_size + 1], _Elem());
			}, _Ch);
		}

	void pop_back()
		{	// erase element at end
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		_IDL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
		_Eos(_Old_size - 1);
		}

	_NODISCARD reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	_NODISCARD const_reference front() const
		{	// return first element of immutable sequence
		return (*begin());
		}

	_NODISCARD reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	_NODISCARD const_reference back() const
		{	// return last element of immutable sequence
		return (*(end() - 1));
		}

	_NODISCARD _Ret_z_ const _Elem * c_str() const _NOEXCEPT
		{	// return pointer to null-terminated immutable array
		return (this->_Get_data()._Myptr());
		}

	_NODISCARD _Ret_z_ const _Elem * data() const _NOEXCEPT
		{	// return pointer to immutable array
		return (this->_Get_data()._Myptr());
		}

#if _HAS_CXX17
	_NODISCARD _Ret_z_ _Elem * data() _NOEXCEPT
		{	// return pointer to mutable array
		return (this->_Get_data()._Myptr());
		}
#endif /* _HAS_CXX17 */
# 3233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type length() const _NOEXCEPT
		{	// return length of sequence
		return (this->_Get_data()._Mysize);
		}

	_NODISCARD size_type size() const _NOEXCEPT
		{	// return length of sequence
		return (this->_Get_data()._Mysize);
		}

	_NODISCARD size_type max_size() const _NOEXCEPT
		{	// return maximum possible length of sequence
		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
		const size_type _Storage_max = // can always store small string
			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
		return (_Min_value(
			static_cast<size_type>((numeric_limits<difference_type>::max)()),
			_Storage_max - 1 // -1 is for null terminator and/or npos
			));

		}

	void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem())
		{	// determine new length, padding with _Ch elements as needed
		const size_type _Old_size = size();
		if (_Newsize <= _Old_size)
			{
			_Eos(_Newsize);
			}
		else
			{
			append(_Newsize - _Old_size, _Ch);
			}
		}

	_NODISCARD size_type capacity() const _NOEXCEPT
		{	// return current length of allocated storage
		return (this->_Get_data()._Myres);
		}

	void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0)
		{	// determine new minimum length of allocated storage
		auto& _My_data = this->_Get_data();
		if (_My_data._Mysize > _Newcap)
			{	// requested capacity is not large enough for current size, ignore
			return;	// nothing to do
			}

		if (_My_data._Myres == _Newcap)
			{	// we're already at the requested capacity
			return;	// nothing to do
			}

		if (_My_data._Myres < _Newcap)
			{	// reallocate to grow
			const size_type _Old_size = _My_data._Mysize;
			_Reallocate_grow_by(_Newcap - _Old_size,
				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
				});

			_My_data._Mysize = _Old_size;
			return;
			}

		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())
			{	// deallocate everything; switch back to "small" mode
			_Become_small();
			return;
			}

		// ignore requests to reserve to [_BUF_SIZE, _Myres)
		}

	_NODISCARD bool empty() const _NOEXCEPT
		{	// test if sequence is empty
		return (size() == 0);
		}

	_SCL_INSECURE_DEPRECATE_FN(basic_string::copy)
	size_type copy(_Out_writes_(_Count) _Elem * const _Ptr,
		size_type _Count, const size_type _Off = 0) const
		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Count = _My_data._Clamp_suffix_size(_Off, _Count);
		_Traits::copy(_Ptr, _My_data._Myptr() + _Off, _Count);
		return (_Count);
		}

	_Pre_satisfies_(_Dest_size >= _Count) size_type _Copy_s(
		_Out_writes_all_(_Dest_size) _Elem * const _Dest, const size_type _Dest_size,
		size_type _Count, const size_type _Off = 0) const
		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Dest_size)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Count = _My_data._Clamp_suffix_size(_Off, _Count);
		_Traits::_Copy_s(_Dest, _Dest_size, _My_data._Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_data(basic_string& _Right, true_type)
		{	// exchange _Get_data() with _Right._Get_data(), memcpy optimization
		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
			+ _Memcpy_move_offset;
		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right._Get_data()))
			+ _Memcpy_move_offset;
		unsigned char _Temp_mem[_Memcpy_move_size];
		_CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_move_size);
		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
		_CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_move_size);
		}

	void _Swap_bx_large_with_small(_Mydata_t& _Starts_large, _Mydata_t& _Starts_small)
		{	// exchange a string in large mode with one in small mode
		const pointer _Ptr = _Starts_large._Bx._Ptr;
		auto& _Al = this->_Getal();
		_Alty_traits::destroy(_Al, _STD addressof(_Starts_large._Bx._Ptr));
		_Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, this->_BUF_SIZE);
		_Alty_traits::construct(_Al, _STD addressof(_Starts_small._Bx._Ptr), _Ptr);
		}

	void _Swap_data(basic_string& _Right, false_type)
		{	// exchange _Get_data() with _Right._Get_data(), general case
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		const bool _My_large = _My_data._Large_string_engaged();
		const bool _Right_large = _Right_data._Large_string_engaged();
		if (_My_large)
			{
			if (_Right_large)
				{	// swap buffers, iterators preserved
				_Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
				}
			else
				{	// swap large with small
				_Swap_bx_large_with_small(_My_data, _Right_data);
				}
			}
		else
			{
			if (_Right_large)
				{	// swap small with large
				_Swap_bx_large_with_small(_Right_data, _My_data);
				}
			else
				{
				_Elem _Temp_buf[this->_BUF_SIZE];
				_Traits::copy(_Temp_buf, _My_data._Bx._Buf, this->_BUF_SIZE);
				_Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, this->_BUF_SIZE);
				_Traits::copy(_Right_data._Bx._Buf, _Temp_buf, this->_BUF_SIZE);
				}
			}

		_STD swap(_My_data._Mysize, _Right_data._Mysize);
		_STD swap(_My_data._Myres, _Right_data._Myres);
		}

	void swap(basic_string& _Right) _NOEXCEPT // Strengthened
		{	// exchange contents with _Right
		if (this != _STD addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			_Pocs(this->_Getal(), _Right._Getal());

#if _ITERATOR_DEBUG_LEVEL != 0
			auto& _My_data = this->_Get_data();
			auto& _Right_data = _Right._Get_data();
			const bool _My_large = _My_data._Large_string_engaged();
			const bool _Right_large = _Right_data._Large_string_engaged();
			if (!_My_large)
				{
				_My_data._Orphan_all();
				}

			if (!_Right_large)
				{
				_Right_data._Orphan_all();
				}

			if (_My_large || _Right_large)
				{
				_My_data._Swap_all(_Right_data);
				}
#endif /* _ITERATOR_DEBUG_LEVEL != 0 */
# 3418 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
			}

		_Swap_data(_Right, _Use_memcpy_move{});
		}

#if _HAS_CXX17
	_NODISCARD size_type find(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = 0) const _NOEXCEPT
		{	// look for _Right beginning at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right.data(), _Right.size())));
		}
#endif /* _HAS_CXX17 */
# 3431 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type find(const basic_string& _Right, const size_type _Off = 0) const _NOEXCEPT
		{	// look for _Right beginning at or after _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
				_Right_data._Myptr(), _Right_data._Mysize)));
		}

	_NODISCARD size_type find(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off, const size_type _Count)
		const _NOEXCEPT // strengthened
		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count)));
		}

	_NODISCARD size_type find(_In_z_ const _Elem * const _Ptr, const size_type _Off = 0) const _NOEXCEPT // strengthened
		{	// look for [_Ptr, <null>) beginning at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
		}

	_NODISCARD size_type find(const _Elem _Ch, const size_type _Off = 0) const _NOEXCEPT // strengthened
		{	// look for _Ch at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}

#if _HAS_CXX17
	_NODISCARD size_type rfind(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = npos) const
		_NOEXCEPT
		{	// look for _Right beginning before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right.data(), _Right.size())));
		}
#endif /* _HAS_CXX17 */
# 3472 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type rfind(const basic_string& _Right, const size_type _Off = npos) const _NOEXCEPT
		{	// look for _Right beginning before _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
				_Right_data._Myptr(), _Right_data._Mysize)));
		}

	_NODISCARD size_type rfind(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count)));
		}

	_NODISCARD size_type rfind(_In_z_ const _Elem * const _Ptr, const size_type _Off = npos)
		const _NOEXCEPT // strengthened
		{	// look for [_Ptr, <null>) beginning before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
		}

	_NODISCARD size_type rfind(const _Elem _Ch, const size_type _Off = npos) const _NOEXCEPT // strengthened
		{	// look for _Ch before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}

#if _HAS_CXX17
	_NODISCARD size_type find_first_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = 0)
		const _NOEXCEPT
		{	// look for one of _Right at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right.data(), _Right.size(), _Is_specialization<_Traits, char_traits>{})));
		}
#endif /* _HAS_CXX17 */
# 3514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type find_first_of(const basic_string& _Right, const size_type _Off = 0) const _NOEXCEPT
		{	// look for one of _Right at or after _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_first_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_first_of(_In_z_ const _Elem * const _Ptr, const size_type _Off = 0)
		const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, <null>) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr),
				_Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const _NOEXCEPT // strengthened
		{	// look for _Ch at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}

#if _HAS_CXX17
	_NODISCARD size_type find_last_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = npos)
		const _NOEXCEPT
		{	// look for one of _Right before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right.data(), _Right.size(), _Is_specialization<_Traits, char_traits>{})));
		}
#endif /* _HAS_CXX17 */
# 3557 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const _NOEXCEPT
		{	// look for one of _Right before _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_last_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_last_of(_In_z_ const _Elem * const _Ptr, const size_type _Off = npos)
		const _NOEXCEPT // strengthened
		{	// look for one of [_Ptr, <null>) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr),
				_Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const _NOEXCEPT // strengthened
		{	// look for _Ch before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}

#if _HAS_CXX17
	_NODISCARD size_type find_first_not_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = 0)
		const _NOEXCEPT
		{	// look for none of _Right at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right.data(), _Right.size(), _Is_specialization<_Traits, char_traits>{})));
		}
#endif /* _HAS_CXX17 */
# 3599 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type find_first_not_of(const basic_string& _Right, const size_type _Off = 0) const _NOEXCEPT
		{	// look for none of _Right at or after _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_first_not_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_first_not_of(_In_z_ const _Elem * const _Ptr, size_type _Off = 0) const
		_NOEXCEPT // strengthened
		{	// look for one of [_Ptr, <null>) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr,
				_Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const _NOEXCEPT // strengthened
		{	// look for non _Ch at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}

#if _HAS_CXX17
	_NODISCARD size_type find_last_not_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = npos)
		const _NOEXCEPT
		{	// look for none of _Right before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right.data(), _Right.size(), _Is_specialization<_Traits, char_traits>{})));
		}
#endif /* _HAS_CXX17 */
# 3641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD size_type find_last_not_of(const basic_string& _Right, const size_type _Off = npos) const _NOEXCEPT
		{	// look for none of _Right before _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_last_not_of(_In_reads_(_Count) const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const _NOEXCEPT // strengthened
		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_last_not_of(_In_z_ const _Elem * const _Ptr, const size_type _Off = npos) const
		_NOEXCEPT // strengthened
		{	// look for none of [_Ptr, <null>) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{})));
		}

	_NODISCARD size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const _NOEXCEPT // strengthened
		{	// look for non _Ch before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}

	_NODISCARD basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const
		{	// return [_Off, _Off + _Count) as new string
		return (basic_string(*this, _Off, _Count, get_allocator()));
		}

	bool _Equal(const basic_string& _Right) const _NOEXCEPT
		{	// compare [0, size()) with _Right for equality
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Right_data._Myptr(), _Right_data._Mysize));
		}

	bool _Equal(_In_z_ const _Elem * const _Ptr) const _NOEXCEPT
		{	// compare [0, size()) with _Ptr for equality
		auto& _My_data = this->_Get_data();
		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));
		}

#if _HAS_CXX17
	_NODISCARD int compare(const basic_string_view<_Elem, _Traits> _Right) const _NOEXCEPT
		{	// compare [0, size()) with _Right
		auto& _My_data = this->_Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize,
			_Right.data(), _Right.size()));
		}

	_NODISCARD int compare(const size_type _Off, const size_type _N0,
		const basic_string_view<_Elem, _Traits> _Right) const
		{	// compare [_Off, _Off + _N0) with _Right
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Right.data(), _Right.size()));
		}

	template<class _StringViewIsh,
		class = _Is_string_view_ish<_StringViewIsh>>
		_NODISCARD int compare(const size_type _Off, const size_type _N0,
			const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) const
		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		basic_string_view<_Elem, _Traits> _As_view = _Right;
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		const auto _With_substr = _As_view.substr(_Roff, _Count);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_With_substr.data(), _With_substr.size()));
		}
#endif /* _HAS_CXX17 */
# 3722 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

	_NODISCARD int compare(const basic_string& _Right) const _NOEXCEPT
		{	// compare [0, size()) with _Right
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize,
			_Right_data._Myptr(), _Right_data._Mysize));
		}

	_NODISCARD int compare(size_type _Off, size_type _N0, const basic_string& _Right) const
		{	// compare [_Off, _Off + _N0) with _Right
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		auto& _Right_data = _Right._Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Right_data._Myptr(), _Right_data._Mysize));
		}

	_NODISCARD int compare(const size_type _Off, const size_type _N0, const basic_string& _Right,
		const size_type _Roff, const size_type _Count = npos) const
		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		_My_data._Check_offset(_Off);
		_Right_data._Check_offset(_Roff);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Right_data._Myptr() + _Roff, _Right_data._Clamp_suffix_size(_Roff, _Count)));
		}

	_NODISCARD int compare(_In_z_ const _Elem * const _Ptr) const _NOEXCEPT // strengthened
		{	// compare [0, size()) with [_Ptr, <null>)
		auto& _My_data = this->_Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize,
			_Ptr, _Traits::length(_Ptr)));
		}

	_NODISCARD int compare(const size_type _Off, const size_type _N0, _In_z_ const _Elem * const _Ptr) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Ptr, _Traits::length(_Ptr)));
		}

	_NODISCARD int compare(const size_type _Off, const size_type _N0, _In_reads_(_Count) const _Elem * const _Ptr,
		const size_type _Count) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Ptr, _Count));
		}

	_NODISCARD allocator_type get_allocator() const _NOEXCEPT
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Getal()));
		}

	size_type _Calculate_growth(const size_type _Requested) const
		{	// determines the next array size to allocate
		const size_type _Max = max_size();
		auto& _My_data = this->_Get_data();
		const size_type _Masked = _Requested | this->_ALLOC_MASK;
		if (_Masked > _Max)
			{	// the mask overflows, settle for max_size()
			return (_Max);
			}

		const size_type _Old = _My_data._Myres;
		if (_Old > _Max - _Old / 2)
			{	// similarly, geometric overflows
			return (_Max);
			}

		return (_Max_value(_Masked, _Old + _Old / 2));
		}

	template<class _Fty,
		class... _ArgTys>
		basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args)
		{	// reallocate to store exactly _New_size elements, new buffer prepared by
			// _Fn(_New_ptr, _New_size, _Args...)
		if (_New_size > max_size())
			{
			_Xlen();	// result too long
			}

		auto& _My_data = this->_Get_data();
		const size_type _Old_capacity = _My_data._Myres;
		const size_type _New_capacity = _Calculate_growth(_New_size);
		auto& _Al = this->_Getal();
		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws
		_My_data._Orphan_all();
		_My_data._Mysize = _New_size;
		_My_data._Myres = _New_capacity;
		_Fn(_Unfancy(_New_ptr), _New_size, _Args...);
		if (this->_BUF_SIZE <= _Old_capacity)
			{
			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);
			_My_data._Bx._Ptr = _New_ptr;
			}
		else
			{
			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);
			}

		return (*this);
		}

	template<class _Fty,
		class... _ArgTys>
		basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args)
		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by
			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (max_size() - _Old_size < _Size_increase)
			{
			_Xlen();	// result too long
			}

		const size_type _New_size = _Old_size + _Size_increase;
		const size_type _Old_capacity = _My_data._Myres;
		const size_type _New_capacity = _Calculate_growth(_New_size);
		auto& _Al = this->_Getal();
		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws
		_My_data._Orphan_all();
		_My_data._Mysize = _New_size;
		_My_data._Myres = _New_capacity;
		_Elem * const _Raw_new = _Unfancy(_New_ptr);
		if (this->_BUF_SIZE <= _Old_capacity)
			{
			const pointer _Old_ptr = _My_data._Bx._Ptr;
			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
			_Al.deallocate(_Old_ptr, _Old_capacity + 1);
			_My_data._Bx._Ptr = _New_ptr;
			}
		else
			{
			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);
			}

		return (*this);
		}

	void _Become_small()
		{	// release any held storage and return to small string mode
			// pre: *this is in large string mode
			// pre: this is small enough to return to small string mode
		auto& _My_data = this->_Get_data();
		_My_data._Orphan_all();
		const pointer _Ptr = _My_data._Bx._Ptr;
		auto& _Al = this->_Getal();
		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
		_Al.deallocate(_Ptr, _My_data._Myres + 1);
		_My_data._Myres = this->_BUF_SIZE - 1;
		}

	void _Eos(const size_type _Newsize)
		{	// set new length and null terminator
		auto& _My_data = this->_Get_data();
		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
		}

	void _Tidy_init()
		{	// initialize basic_string data members
		auto& _My_data = this->_Get_data();
		_My_data._Mysize = 0;
		_My_data._Myres = this->_BUF_SIZE - 1;
		// the _Traits::assign is last so the codegen doesn't think the char
		// write can alias this
		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
		}

	void _Tidy_deallocate()
		{	// initialize buffer, deallocating any storage
		this->_Orphan_all();
		auto& _My_data = this->_Get_data();
		if (_My_data._Large_string_engaged())
			{
			const pointer _Ptr = _My_data._Bx._Ptr;
			auto& _Al = this->_Getal();
			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
			_Al.deallocate(_Ptr, _My_data._Myres + 1);
			}

		_My_data._Mysize = 0;
		_My_data._Myres = this->_BUF_SIZE - 1;
		// the _Traits::assign is last so the codegen doesn't think the char
		// write can alias this
		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
		}

	[[noreturn]] static void _Xlen()
		{	// report a length_error
		_Xlength_error("string too long");
		}
	};

#if _HAS_DEDUCTION_GUIDES
template<class _Iter,
	class _Alloc = allocator<_Iter_value_t<_Iter>>,
	enable_if_t<conjunction_v<
		_Is_iterator<_Iter>,
		_Is_allocator<_Alloc>
	>, int> = 0>
	basic_string(_Iter, _Iter, _Alloc = _Alloc())
		-> basic_string<_Iter_value_t<_Iter>, char_traits<_Iter_value_t<_Iter>>, _Alloc>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 3933 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT // Strengthened
	{	// swap _Left and _Right strings
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return string + string
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return NTCTS + string
	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
	using _Size_type = typename _String_type::size_type;
	_String_type _Ans;
	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return character + string
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// return string + NTCTS
	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
	using _Size_type = typename _String_type::size_type;
	_String_type _Ans;
	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	// return string + character
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return string + string
	return (_STD move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return string + string
	return (_STD move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return string + string
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (_STD move(_Left.append(_Right)));
	else
		return (_STD move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		_In_z_ const _Elem * const _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return NTCTS + string
	return (_STD move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return character + string
	using size_type = typename allocator_traits<_Alloc>::size_type;
	return (_STD move(_Right.insert(static_cast<size_type>(0), static_cast<size_type>(1), _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		_In_z_ const _Elem * const _Right)
	{	// return string + NTCTS
	return (_STD move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	// return string + character
	_Left.push_back(_Right);
	return (_STD move(_Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT
	{	// test for string equality
	return (_Left._Equal(_Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator==(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test for NTCTS vs. string equality
	return (_Right._Equal(_Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// test for string vs. NTCTS equality
	return (_Left._Equal(_Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT
	{	// test for string inequality
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator!=(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test for NTCTS vs. string inequality
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// test for string vs. NTCTS inequality
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT
	{	// test if string < string
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator<(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS < string
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// test if string < NTCTS
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT
	{	// test if string > string
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator>(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS > string
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// test if string > NTCTS
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT
	{	// test if string <= string
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator<=(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS <= string
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// test if string <= NTCTS
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) _NOEXCEPT
	{	// test if string >= string
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator>=(
		_In_z_ const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS >= string
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	_NODISCARD inline bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		_In_z_ const _Elem * const _Right)
	{	// test if string >= NTCTS
	return (!(_Left < _Right));
	}

using string = basic_string<char, char_traits<char>, allocator<char>>;
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

	// STRUCT TEMPLATE SPECIALIZATION hash
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc>>
	{	// hash functor for basic_string
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_array_representation(_Keyval.c_str(), _Keyval.size()));
		}
	};
_STD_END

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)
#endif /* RC_INVOKED */
# 4298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3
#endif /* _XSTRING_ */
# 4299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new
_STD_BEGIN
		// CLASS logic_error
class logic_error
	: public exception
	{	// base of all logic-error exceptions
public:
	typedef exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS domain_error
class domain_error
	: public logic_error
	{	// base of all domain-error exceptions
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS invalid_argument
class invalid_argument
	: public logic_error
	{	// base of all invalid-argument exceptions
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS length_error
class length_error
	: public logic_error
	{	// base of all length-error exceptions
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 119 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS out_of_range
class out_of_range
	: public logic_error
	{	// base of all out-of-range exceptions
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS runtime_error
class runtime_error
	: public exception
	{	// base of all runtime-error exceptions
public:
	typedef exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS overflow_error
class overflow_error
	: public runtime_error
	{	// base of all overflow-error exceptions
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS underflow_error
class underflow_error
	: public runtime_error
	{	// base of all underflow-error exceptions
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};

		// CLASS range_error
class range_error
	: public runtime_error
	{	// base of all range-error exceptions
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
	};
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3
#endif /* _STDEXCEPT_ */
# 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\stdexcept" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <typeinfo>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 1 3
// typeinfo standard header

/***
*typeinfo - Defines the type_info structure and exceptions used for RTTI
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*	Modified January 1996 by P.J. Plauger
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3

#ifndef _TYPEINFO_
#define _TYPEINFO_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3
# 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

#pragma warning(disable: 4275)	// non dll-interface class 'X' used as base for dll-interface class 'Y'

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_typeinfo.h>
#endif /* expanded by -frewrite-includes */
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 1 3
//
// vcruntime_typeinfo.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <typeinfo> functionality that is implemented in the VCRuntime.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <vcruntime.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 1 3
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _UCRT
    #define _UCRT
#endif
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
    #define _VCRT_DEFINED_CRTIMP
    #if defined CRTDLL && defined _CRTBLD
        #define _CRTIMP __declspec(dllexport)
    #else
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #ifdef _DLL
            #define _CRTIMP __declspec(dllimport)
        #else
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
            #define _CRTIMP
        #endif
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #endif
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#if 0 /* expanded by -frewrite-includes */
#include <sal.h>
#endif /* expanded by -frewrite-includes */
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <vadefs.h>
#endif /* expanded by -frewrite-includes */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

    #define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl
# 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

    #define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

    #define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

    #define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif
# 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
    #ifdef _KERNEL_MODE
        #define _HAS_EXCEPTIONS 0
    #else
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _HAS_EXCEPTIONS 1
    #endif /* _KERNEL_MODE */
# 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif /* _HAS_EXCEPTIONS */
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__



#ifndef _VCRTIMP
    #if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
        #define _VCRTIMP _CRTIMP
    #elif defined _VCRT_BUILD && defined CRTDLL
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP __declspec(dllexport)
    #else
# 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _VCRTIMP
    #endif
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _MRTIMP
    #if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
        #define _MRTIMP __declspec(dllexport)
    #else
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _MRTIMP
    #endif
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
    #define __CLRCALL_OR_CDECL __clrcall
    #define __CLR_OR_THIS_CALL __clrcall
#else
# 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_OR_CDECL __cdecl
    #define __CLR_OR_THIS_CALL
#endif
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef _M_CEE_PURE
    #define __CLRCALL_PURE_OR_CDECL __clrcall
#else
# 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
# 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)

#if !defined _MSC_VER || _MSC_VER >= 1900
    #define _VCRT_ALLOCATOR __declspec(allocator)
#else
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALLOCATOR
#endif
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_CEE && defined _M_X64
    #define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_JIT_INTRINSIC
#endif
# 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __midl
    #define _VCRT_ALIGN(x)
#else
# 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _VCRT_ALIGN(x) __declspec(align(x))
#endif
# 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CONST_RETURN
    #ifdef __cplusplus
        #define _CRT_CONST_CORRECT_OVERLOADS
        #define _CONST_RETURN  const
    #else
# 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
      #define _CONST_RETURN
    #endif
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#else
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#endif
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined __cplusplus
    typedef bool  __vcrt_bool;
#elif defined __midl
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    // MIDL understands neither bool nor _Bool.  Use char as a best-fit
    // replacement (the differences won't matter in practice).
    typedef char __vcrt_bool;
#else
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
#endif
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
    #define _SIZE_T_DEFINED
#endif
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _PTRDIFF_T_DEFINED
    #define _PTRDIFF_T_DEFINED
#endif
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _INTPTR_T_DEFINED
    #define _INTPTR_T_DEFINED
#endif
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
    #define _WCHAR_T_DEFINED
    typedef unsigned short wchar_t;
#endif
# 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define NULL ((void *)0)
    #endif
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
    #define _UNALIGNED __unaligned
#else
# 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define _UNALIGNED
#endif
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifdef __cplusplus
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        #define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
    }
#else
# 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
    #define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
# 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
#endif
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE
    #ifdef _CRT_SECURE_NO_WARNINGS
        #define _CRT_INSECURE_DEPRECATE(_Replacement)
    #else
# 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
    #endif
# 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
    #define _CRT_SECURE_WARNINGS_MEMORY
#endif
# 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
    #ifndef _CRT_SECURE_WARNINGS_MEMORY
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
    #else
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        #define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
    #endif
# 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

#if !defined _M_CEE && !defined __midl
    void __cdecl __security_init_cookie(void);

    #ifdef _M_IX86
        void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    #else  /* _M_IX86 */
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
        void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
    #endif
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
#endif
# 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
    #define __vcrt_malloc_normal(_Size) malloc(_Size)
    #define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
    #define __vcrt_free_normal(_Memory) free(_Memory)
#endif
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3

_CRT_END_C_HEADER

#endif // _VCRUNTIME_H
# 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime.h" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <vcruntime_exception.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3

#pragma pack(push, _CRT_PACKING)
#ifndef RC_INVOKED

#if defined _M_CEE_MIXED && !defined _VCRT_BUILD
    // Provide a fake definition of __type_info_node to suppress linker warning
    // LNK4248: unresolved typeref token for '__type_info_node'; image may not run.
    struct __type_info_node { };
#else
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
    struct __type_info_node;
#endif
# 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3

#ifdef _M_CEE_PURE
    extern System::IntPtr __type_info_root_node;
#else
# 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
    extern __type_info_node __type_info_root_node;
#endif
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3



_CRT_BEGIN_C_HEADER

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

_VCRTIMP int __cdecl __std_type_info_compare(
    _In_ const __std_type_info_data* _Lhs,
    _In_ const __std_type_info_data* _Rhs
    );

_VCRTIMP size_t __cdecl __std_type_info_hash(
    _In_ const __std_type_info_data* _Data
    );

_VCRTIMP const char* __cdecl __std_type_info_name(
    _Inout_ __std_type_info_data* _Data,
    _Inout_ __type_info_node*     _RootNode
    );

_CRT_END_C_HEADER



class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(const type_info& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(const type_info& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(const type_info& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    const char* name() const throw()
    {
        #ifdef _M_CEE_PURE
        return __std_type_info_name(&_Data, static_cast<__type_info_node*>(__type_info_root_node.ToPointer()));
        #else
# 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
        return __std_type_info_name(&_Data, &__type_info_root_node);
        #endif
# 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
    }

    const char* raw_name() const throw()
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    mutable __std_type_info_data _Data;
};

namespace std {
	using ::type_info;
}

#if _HAS_EXCEPTIONS

namespace std {

class bad_cast
    : public exception
{
public:

    bad_cast() throw()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) throw()
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() throw()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) throw()
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) throw()
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) throw()
        : bad_typeid(_Message, 1)
    {
    }
};

} // namespace std

#endif // _HAS_EXCEPTIONS
# 189 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
#endif // !RC_INVOKED
# 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vcruntime_typeinfo.h" 3
#pragma pack(pop)
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 2 3

 _STD_BEGIN

// size in pointers of std::function and std::any (roughly 3 pointers larger than std::string when building debug)
constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof (void *);

 #if !(_HAS_EXCEPTIONS)

		// CLASS bad_cast
class _CRTIMP2_IMPORT bad_cast
	: public exception
	{	// base of all bad cast exceptions
public:
	bad_cast(const char *_Message = "bad cast") _NOEXCEPT
		: exception(_Message)
		{	// construct from message string
		}

	virtual ~bad_cast() _NOEXCEPT
		{	// destroy the object
		}

protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
	};

		// CLASS bad_typeid
class _CRTIMP2_IMPORT bad_typeid
	: public exception
	{	// base of all bad typeid exceptions
public:
	bad_typeid(const char *_Message = "bad typeid") _NOEXCEPT
		: exception(_Message)
		{	// construct from message string
		}

	virtual ~bad_typeid() _NOEXCEPT
		{	// destroy the object
		}

protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
	};

class _CRTIMP2_IMPORT __non_rtti_object
	: public bad_typeid
	{	// report a non RTTI object
public:
	__non_rtti_object(const char *_Message)
		: bad_typeid(_Message)
		{	// construct from message string
		}
	};
 #endif /* _HAS_EXCEPTIONS */
# 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3

 _STD_END

#pragma pop_macro("new")
#pragma pack(pop)
#pragma warning(pop)
#endif /* RC_INVOKED */
# 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3
#endif // _TYPEINFO_
# 101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\typeinfo" 3

/*
 * Copyright (c) Microsoft Corporation.  ALL RIGHTS RESERVED.
 * Modified January 1996 by P.J. Plauger
 * Modified November 1998 by P.J. Plauger
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <xlocinfo>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 1 3
// xlocinfo internal header for Microsoft
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
#ifndef _XLOCINFO_
#define _XLOCINFO_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xlocinfo.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 1 3
/* xlocinfo.h internal header for Microsoft */
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
#ifndef _XLOCINFO
#define _XLOCINFO
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <ctype.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 1 3
//
// ctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the narrow character (char) classification functionality.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
#define _INC_CTYPE

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <corecrt_wctype.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3

_CRT_BEGIN_C_HEADER
#if !defined __midl && !defined RC_INVOKED



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Function Declarations
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _ACRTIMP int __cdecl _isctype(_In_ int _C, _In_ int _Type);
_Check_return_ _ACRTIMP int __cdecl _isctype_l(_In_ int _C, _In_ int _Type, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isalpha(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isalpha_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isupper(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isupper_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl islower(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _islower_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isdigit(_In_ int _C);

_Check_return_ _ACRTIMP int __cdecl _isdigit_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isxdigit(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isxdigit_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isspace(_In_ int _C);

_Check_return_ _ACRTIMP int __cdecl _isspace_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl ispunct(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _ispunct_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isblank(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isblank_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isalnum(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isalnum_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isprint(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isprint_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isgraph(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isgraph_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl iscntrl(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _iscntrl_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl toupper(_In_ int _C);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl tolower(_In_ int _C);

_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl _tolower(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _tolower_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl _toupper(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _toupper_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP int __cdecl __isascii(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl __toascii(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl __iscsymf(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl __iscsym(_In_ int _C);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Macro Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _CTYPE_DISABLE_MACROS

    // Maximum number of bytes in multi-byte character in the current locale
    // (also defined in stdlib.h).
    #ifndef MB_CUR_MAX
          #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
            #define MB_CUR_MAX __mb_cur_max
        #else
# 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
            #define MB_CUR_MAX ___mb_cur_max_func()
        #endif
# 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3

        #ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
            extern int __mb_cur_max;
        #else
# 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
            #define __mb_cur_max (___mb_cur_max_func())
        #endif
# 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3

        // MB_LEN_MAX = 5 in limits.h but we do not include that header here so use 5
        // directly.
        _Post_satisfies_(return > 0 && return < 5)
        _ACRTIMP int __cdecl ___mb_cur_max_func(void);
        _Post_satisfies_(return > 0 && return < 5)
        _ACRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
    #endif
# 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3



    // In the debug CRT, we make all calls through the validation function to catch
    // invalid integer inputs that yield undefined behavior.
    #ifdef _DEBUG
        _ACRTIMP int __cdecl _chvalidator(_In_ int _Ch, _In_ int _Mask);
        #define __chvalidchk(a, b) _chvalidator(a, b)
    #else
# 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
        #define __chvalidchk(a, b) (__PCTYPE_FUNC[(a)] & (b))
    #endif
# 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3



    #define __ascii_isalpha(c)   ( __chvalidchk(c, _ALPHA))
    #define __ascii_isdigit(c)   ( __chvalidchk(c, _DIGIT))
    #define __ascii_tolower(c)   ( (((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c) )
    #define __ascii_toupper(c)   ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )
    #define __ascii_iswalpha(c)  ( ('A' <= (c) && (c) <= 'Z') || ( 'a' <= (c) && (c) <= 'z'))
    #define __ascii_iswdigit(c)  ( '0' <= (c) && (c) <= '9')
    #define __ascii_towlower(c)  ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )
    #define __ascii_towupper(c)  ( (((c) >= L'a') && ((c) <= L'z')) ? ((c) - L'a' + L'A') : (c) )



    #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL && !defined __cplusplus
        #define isalpha(c)  (MB_CUR_MAX > 1 ? _isctype(c, _ALPHA) : __chvalidchk(c, _ALPHA))
        #define isupper(c)  (MB_CUR_MAX > 1 ? _isctype(c, _UPPER) : __chvalidchk(c, _UPPER))
        #define islower(c)  (MB_CUR_MAX > 1 ? _isctype(c, _LOWER) : __chvalidchk(c, _LOWER))
        #define isdigit(c)  (MB_CUR_MAX > 1 ? _isctype(c, _DIGIT) : __chvalidchk(c, _DIGIT))
        #define isxdigit(c) (MB_CUR_MAX > 1 ? _isctype(c, _HEX)   : __chvalidchk(c, _HEX))
        #define isspace(c)  (MB_CUR_MAX > 1 ? _isctype(c, _SPACE) : __chvalidchk(c, _SPACE))
        #define ispunct(c)  (MB_CUR_MAX > 1 ? _isctype(c, _PUNCT) : __chvalidchk(c, _PUNCT))
        #define isblank(c)  (MB_CUR_MAX > 1 ? (((c) == '\t') ? _BLANK : _isctype(c, _BLANK)) : (((c) == '\t') ? _BLANK : __chvalidchk(c, _BLANK)))
        #define isalnum(c)  (MB_CUR_MAX > 1 ? _isctype(c, _ALPHA | _DIGIT) : __chvalidchk(c, (_ALPHA | _DIGIT)))
        #define isprint(c)  (MB_CUR_MAX > 1 ? _isctype(c, _BLANK | _PUNCT | _ALPHA | _DIGIT) : __chvalidchk(c, (_BLANK | _PUNCT | _ALPHA | _DIGIT)))
        #define isgraph(c)  (MB_CUR_MAX > 1 ? _isctype(c, _PUNCT | _ALPHA | _DIGIT) : __chvalidchk(c, (_PUNCT | _ALPHA | _DIGIT)))
        #define iscntrl(c)  (MB_CUR_MAX > 1 ? _isctype(c, _CONTROL) : __chvalidchk(c, _CONTROL))
    #endif
# 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3

    __inline __crt_locale_data_public* __CRTDECL __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    #ifdef _DEBUG
    _ACRTIMP int __cdecl _chvalidator_l(_In_opt_ _locale_t, _In_ int _Ch, _In_ int _Mask);
    #endif
# 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3

    __inline int __CRTDECL _chvalidchk_l(
        _In_     int       const _C,
        _In_     int       const _Mask,
        _In_opt_ _locale_t const _Locale
        )
    {
        #ifdef _DEBUG
        return _chvalidator_l(_Locale, _C, _Mask);
        #else
# 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
        if (_Locale)
        {
            return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
        }

        return __chvalidchk(_C, _Mask);
        #endif
# 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
    }

    #define __ascii_isalpha_l(c, locale) (_chvalidchk_l(c, _ALPHA, locale))
    #define __ascii_isdigit_l(c, locale) (_chvalidchk_l(c, _DIGIT, locale))

    __inline int __CRTDECL _ischartype_l(
        _In_     int       const _C,
        _In_     int       const _Mask,
        _In_opt_ _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    #define _isalpha_l(c, locale)  _ischartype_l(c, _ALPHA, locale)
    #define _isupper_l(c, locale)  _ischartype_l(c, _UPPER, locale)
    #define _islower_l(c, locale)  _ischartype_l(c, _LOWER, locale)
    #define _isdigit_l(c, locale)  _ischartype_l(c, _DIGIT, locale)
    #define _isxdigit_l(c, locale) _ischartype_l(c, _HEX, locale)
    #define _isspace_l(c, locale)  _ischartype_l(c, _SPACE, locale)
    #define _ispunct_l(c, locale)  _ischartype_l(c, _PUNCT, locale)
    #define _isblank_l(c, locale)  (((c) == '\t') ? _BLANK : _ischartype_l(c, _BLANK, locale))
    #define _isalnum_l(c, locale)  _ischartype_l(c, _ALPHA | _DIGIT, locale)
    #define _isprint_l(c, locale)  _ischartype_l(c, _BLANK | _PUNCT | _ALPHA | _DIGIT, locale)
    #define _isgraph_l(c, locale)  _ischartype_l(c, _PUNCT | _ALPHA | _DIGIT, locale)
    #define _iscntrl_l(c, locale)  _ischartype_l(c, _CONTROL, locale)

    #define _tolower(c) ((c) - 'A' + 'a')
    #define _toupper(c) ((c) - 'a' + 'A')

    #define __isascii(c)   ((unsigned)(c) < 0x80)
    #define __toascii(c)   ((c) & 0x7f)


    // Microsoft C version 2.0 extended ctype macros
    #define __iscsymf(c)  (isalpha(c) || ((c) == '_'))
    #define __iscsym(c)   (isalnum(c) || ((c) == '_'))
    #define __iswcsymf(c) (iswalpha(c) || ((c) == '_'))
    #define __iswcsym(c)  (iswalnum(c) || ((c) == '_'))

    #define _iscsymf_l(c, p)  (_isalpha_l(c, p) || ((c) == '_'))
    #define _iscsym_l(c, p)   (_isalnum_l(c, p) || ((c) == '_'))
    #define _iswcsymf_l(c, p) (iswalpha(c) || ((c) == '_'))
    #define _iswcsym_l(c, p)  (iswalnum(c) || ((c) == '_'))

#endif // _CTYPE_DISABLE_MACROS
# 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3


#if _CRT_INTERNAL_NONSTDC_NAMES
    #define isascii __isascii
    #define toascii __toascii
    #define iscsymf __iscsymf
    #define iscsym  __iscsym
#endif
# 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3



#endif // !defined __midl && !defined RC_INVOKED
# 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
_CRT_END_C_HEADER
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <locale.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\locale.h" 1 3
//
// locale.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C locale library.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\locale.h" 3
#define _INC_LOCALE

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\locale.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\locale.h" 3

_CRT_BEGIN_C_HEADER



// Locale categories
#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

// Locale convention structure
struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;

// ANSI: char lconv members default is CHAR_MAX which is compile time dependent.
// Defining and using __do_unsigned_char_lconv_initialization here causes CRT
// startup code to initialize lconv members properly
#ifdef _CHAR_UNSIGNED
    extern int __do_unsigned_char_lconv_initialization;
    extern __inline int __use_char_max(void)
    {
        return __do_unsigned_char_lconv_initialization;
    }
#endif
# 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\locale.h" 3



#define _ENABLE_PER_THREAD_LOCALE         0x0001
#define _DISABLE_PER_THREAD_LOCALE        0x0002
#define _ENABLE_PER_THREAD_LOCALE_GLOBAL  0x0010
#define _DISABLE_PER_THREAD_LOCALE_GLOBAL 0x0020
#define _ENABLE_PER_THREAD_LOCALE_NEW     0x0100
#define _DISABLE_PER_THREAD_LOCALE_NEW    0x0200

#if _CRT_FUNCTIONS_REQUIRED

    _ACRTIMP void __cdecl _lock_locales(void);
    _ACRTIMP void __cdecl _unlock_locales(void);

    _Check_return_opt_
    _ACRTIMP int __cdecl _configthreadlocale(
        _In_ int _Flag
        );

    _Check_return_opt_
    _ACRTIMP char* __cdecl setlocale(
        _In_       int         _Category,
        _In_opt_z_ char const* _Locale
        );

    _Check_return_opt_
    _ACRTIMP struct lconv* __cdecl localeconv(void);

    _Check_return_opt_
    _ACRTIMP _locale_t __cdecl _get_current_locale(void);

    _Check_return_opt_
    _ACRTIMP _locale_t __cdecl _create_locale(
        _In_   int         _Category,
        _In_z_ char const* _Locale
        );

    _ACRTIMP void __cdecl _free_locale(
        _In_opt_ _locale_t _Locale
        );

    // Also declared in <wchar.h>
    _Check_return_opt_
    _ACRTIMP wchar_t* __cdecl _wsetlocale(
        _In_       int            _Category,
        _In_opt_z_ wchar_t const* _Locale
        );

    _Check_return_opt_
    _ACRTIMP _locale_t __cdecl _wcreate_locale(
        _In_   int            _Category,
        _In_z_ wchar_t const* _Locale
        );



    _ACRTIMP wchar_t**    __cdecl ___lc_locale_name_func(void);
    _ACRTIMP unsigned int __cdecl ___lc_codepage_func   (void);
    _ACRTIMP unsigned int __cdecl ___lc_collate_cp_func (void);




    // Time-related functions
    _Success_(return != 0)
    _Ret_z_
    _ACRTIMP char*    __cdecl _Getdays(void);

    _Success_(return != 0)
    _Ret_z_
    _ACRTIMP char*    __cdecl _Getmonths(void);

    _ACRTIMP void*    __cdecl _Gettnames(void);

    _Success_(return != 0)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl _W_Getdays(void);

    _Success_(return != 0)
    _Ret_z_
    _ACRTIMP wchar_t* __cdecl _W_Getmonths(void);

    _ACRTIMP void*    __cdecl _W_Gettnames(void);

    _Success_(return > 0)
    _ACRTIMP size_t __cdecl _Strftime(
        _Out_writes_z_(_Max_size) char*           _Buffer,
        _In_                     size_t           _Max_size,
        _In_z_                   char const*      _Format,
        _In_                     struct tm const* _Timeptr,
        _In_opt_                 void*            _Lc_time_arg);

    _Success_(return > 0)
    _ACRTIMP size_t __cdecl _Wcsftime(
        _Out_writes_z_(_Max_size) wchar_t*        _Buffer,
        _In_                     size_t           _Max_size,
        _In_z_                   wchar_t const*   _Format,
        _In_                     struct tm const* _Timeptr,
        _In_opt_                 void*            _Lc_time_arg
        );

#endif // _CRT_FUNCTIONS_REQUIRED
# 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\locale.h" 3


_CRT_END_C_HEADER
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

#if !defined(MRTDLL) || !defined(_CRTBLD)
 #ifndef _M_CEE_PURE
_EXTERN_C
 #endif /* _M_CEE_PURE */
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
#endif /* !MRTDLL || !_CRTBLD */
# 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

		/* CTYPE CODE BITS */
#define _XB	0x000		/* extra blank */
#define _XA	0x100		/* extra alphabetic */
#define _XS	0x000		/* extra space */
#define _BB	_CONTROL	/* BEL, BS, etc. */
#define _CN	_SPACE		/* CR, FF, HT, NL, VT */
#define _DI	_DIGIT		/* '0'-'9' */
#define _LO	_LOWER		/* 'a'-'z' */
#define _PU	_PUNCT		/* punctuation */
#define _SP	_BLANK		/* space */
#define _UP	_UPPER		/* 'A'-'Z' */
#define _XD	_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL		LC_ALL
#define _X_COLLATE	LC_COLLATE
#define _X_CTYPE	LC_CTYPE
#define _X_MONETARY	LC_MONETARY
#define _X_NUMERIC	LC_NUMERIC
#define _X_TIME		LC_TIME
#define _X_MAX		LC_MAX
#define _X_MESSAGES	6
#define _NCAT		(_X_MESSAGES + 1)	/* maximum + 1 */

 #define _CATMASK(n)	((1 << (n)) >> 1)
 #define _M_COLLATE		_CATMASK(_X_COLLATE)
 #define _M_CTYPE		_CATMASK(_X_CTYPE)
 #define _M_MONETARY	_CATMASK(_X_MONETARY)
 #define _M_NUMERIC		_CATMASK(_X_NUMERIC)
 #define _M_TIME		_CATMASK(_X_TIME)
 #define _M_MESSAGES	_CATMASK(_X_MESSAGES)
 #define _M_ALL			(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned int _Page;		// UINT
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned int _Page;		// UINT
	unsigned int _Mbcurmax;
	int _Isclocale;	// LCID == _CLOCALEHANDLE
	unsigned char _Isleadbyte[32];	// 256 bits
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_CRTIMP2_PURE _Collvec __CLRCALL_PURE_OR_CDECL _Getcoll(void);
_CRTIMP2_PURE _Ctypevec __CLRCALL_PURE_OR_CDECL _Getctype(void);
_CRTIMP2_PURE _Cvtvec __CLRCALL_PURE_OR_CDECL _Getcvt(void);

#ifdef __cplusplus
#if !defined(MRTDLL) && !defined(_M_CEE_PURE)
extern "C"
#endif /* !MRTDLL && !_M_CEE_PURE */
# 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Getdateorder(void);
#endif /* __cplusplus */
# 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

 #ifdef _M_CEE_PURE
[System::Runtime::InteropServices::DllImport(_CRT_MSVCP_CURRENT,
	EntryPoint = "_Mbrtowc",
	CallingConvention =
		System::Runtime::InteropServices::CallingConvention::Cdecl)]
extern "C" int _Mbrtowc(_Out_opt_ wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);

 #else /* _M_CEE_PURE */
# 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
_MRTIMP2 int __cdecl _Mbrtowc(_Out_opt_ wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #endif /* _M_CEE_PURE */
# 102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _Stof(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **, long);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stod(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **, long);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _Stold(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **, long);

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm(
	_Out_writes_(_End1 - _String1) _Post_readable_size_(return) char *_String1,
	_In_z_ char *_End1, const char *, const char *, const _Collvec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Tolower(int, const _Ctypevec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Toupper(int, const _Ctypevec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcrtomb(_Out_ char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(
	_Out_writes_(_End1 - _String1) _Post_readable_size_(return) wchar_t *_String1,
	_In_z_ wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2_PURE const wchar_t *__CLRCALL_PURE_OR_CDECL _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towupper(wchar_t, const _Ctypevec *);

#if !defined(MRTDLL) || !defined(_CRTBLD)
 #ifndef _M_CEE_PURE
_END_EXTERN_C
 #endif /* _M_CEE_PURE */
# 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
#endif /* !MRTDLL || !_CRTBLD */
# 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

_EXTERN_C
_Success_(return != 0)
_Ret_z_
_ACRTIMP char *__cdecl _Getdays(void);

_Success_(return != 0)
_Ret_z_
_ACRTIMP char *__cdecl _Getmonths(void);

_ACRTIMP void *__cdecl _Gettnames(void);

_Success_(return > 0)
_ACRTIMP size_t __cdecl _Strftime(_Out_writes_z_(_Maxsize) char *,
	_In_ size_t _Maxsize, _In_z_ const char *, _In_ const struct tm *,
	_In_opt_ void *);

_Success_(return != 0)
_Ret_z_
_ACRTIMP wchar_t *__cdecl _W_Getdays(void);

_Success_(return != 0)
_Ret_z_
_ACRTIMP wchar_t *__cdecl _W_Getmonths(void);

_ACRTIMP void *__cdecl _W_Gettnames(void);

_Success_(return > 0)
_ACRTIMP size_t __cdecl _Wcsftime(_Out_writes_z_(_Maxsize) wchar_t *,
	_In_ size_t _Maxsize, _In_z_ const wchar_t *, _In_ const struct tm *,
	_In_opt_ void *);
_END_EXTERN_C

 #ifdef _M_CEE_PURE
[System::Runtime::InteropServices::DllImport(_CRT_MSVCP_CURRENT,
	EntryPoint = "_GetLocaleForCP",
	CallingConvention =
		System::Runtime::InteropServices::CallingConvention::Cdecl)]
extern "C" _locale_t _GetLocaleForCP(unsigned int);

 #else /* _M_CEE_PURE */
# 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
_MRTIMP2 _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #endif /* _M_CEE_PURE */
# 179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3
#endif /* _XLOCINFO */
# 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
#if 0 /* expanded by -frewrite-includes */
#include <xstddef>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// CLASS _Timevec
class _CRTIMP2_PURE_IMPORT _Timevec
	{	// smart pointer to information used by _Strftime
public:
	__CLR_OR_THIS_CALL _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	// construct from ptr
		}

	__CLR_OR_THIS_CALL _Timevec(const _Timevec& _Right)
		{	// construct from _Right
		*this = _Right;
		}

	__CLR_OR_THIS_CALL ~_Timevec() _NOEXCEPT
		{	// destroy the object
		free(_Timeptr);
		}

	_Timevec& __CLR_OR_THIS_CALL operator=(const _Timevec& _Right)
		{	// transfer ownership of _Timeptr from _Right
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void *__CLR_OR_THIS_CALL _Getptr() const
		{	// return pointer to time information
		return (_Timeptr);
		}

private:
	void *_Timeptr;	// pointer to time information
	};

		// CLASS _Locinfo
class _CRTIMP2_PURE_IMPORT _Locinfo
	{	// summary of all stuff peculiar to a locale used by standard facets
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef _STD _Timevec _Timevec;

	static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(
		_Locinfo *, const char *);
	static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL _Locinfo_dtor(
		_Locinfo *);
	static _MRTIMP2_PURE_NPURE _Locinfo& __CLRCALL_PURE_OR_CDECL _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	__CLR_OR_THIS_CALL _Locinfo(const char *_Pch = "C")
 #ifndef _M_CEE
		: _Lock(_LOCK_LOCALE)
 #endif /* _M_CEE */
# 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3

		{	// construct from NTBS
		if (_Pch == 0)
			_THROW(runtime_error("bad locale name"));
		_Locinfo_ctor(this, _Pch);
		}

	__CLR_OR_THIS_CALL _Locinfo(int _Cat, const char *_Pch)
 #ifndef _M_CEE
		: _Lock(_LOCK_LOCALE)
 #endif /* _M_CEE */
# 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3

		{	// construct from category mask and NTBS
		if (_Pch == 0)
			_THROW(runtime_error("bad locale name"));
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	__CLR_OR_THIS_CALL ~_Locinfo() _NOEXCEPT
		{	// destroy the object
		_Locinfo_dtor(this);
		}

	_Locinfo& __CLR_OR_THIS_CALL _Addcats(int _Cat, const char *_Pch)
		{	// add facets matching category mask and NTBS
		if (_Pch == 0)
			_THROW(runtime_error("bad locale name"));
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char *__CLR_OR_THIS_CALL _Getname() const
		{	// return the new locale name
		return (_Newlocname._C_str());
		}

	_Collvec __CLR_OR_THIS_CALL _Getcoll() const
		{	// return collation stuff
		return (::_Getcoll());
		}

	_Ctypevec __CLR_OR_THIS_CALL _Getctype() const
		{	// return ctype stuff
		return (::_Getctype());
		}

	_Cvtvec __CLR_OR_THIS_CALL _Getcvt() const
		{	// return codecvt stuff
		return (::_Getcvt());
		}

	const lconv *__CLR_OR_THIS_CALL _Getlconv() const
		{	// return localeconv stuff
		return (localeconv());
		}

	_Timevec __CLR_OR_THIS_CALL _Gettnames() const
		{	// return names used by _Strftime
		return (_Timevec(::_Gettnames()));
		}

	const char *__CLR_OR_THIS_CALL _Getdays() const
		{	// return names for weekdays
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char *__CLR_OR_THIS_CALL _Getmonths() const
		{	// return names for months
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char *__CLR_OR_THIS_CALL _Getfalse() const
		{	// return false name (no C source)
		return ("false");
		}

	const char *__CLR_OR_THIS_CALL _Gettrue() const
		{	// return true name (no C source)
		return ("true");
		}

	int __CLR_OR_THIS_CALL _Getdateorder() const
		{	// return date order
		return (::_Getdateorder());
		}

	_Timevec __CLR_OR_THIS_CALL _W_Gettnames() const
		{	// return names used by _Wcsftime
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short *__CLR_OR_THIS_CALL _W_Getdays() const
		{	// return names for weekdays
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short *__CLR_OR_THIS_CALL _W_Getmonths() const
		{	// return names for months
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 #ifdef _M_CEE
	_EmptyLockit _Empty_lock;	// to maintain same size

 #else /* _M_CEE */
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
	_Lockit _Lock;	// thread lock, because global locale is altered
 #endif /* _M_CEE */
# 226 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3

	_Yarn<char> _Days;	// weekday names
	_Yarn<char> _Months;	// month names
	_Yarn<wchar_t> _W_Days;	// wide weekday names
	_Yarn<wchar_t> _W_Months;	// wide month names
	_Yarn<char> _Oldlocname;	// old locale name to revert to on destruction
	_Yarn<char> _Newlocname;	// new locale name for this object
	};

		// FUNCTION TEMPLATE _LStrcoll
template<class _Elem> inline
	int __CRTDECL _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	// perform locale-specific comparison of _Elem sequences
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	// [_First1, _Last1) < [_First2, _Last2)
		else if (*_First2 < *_First1)
			return (+1);	// [_First1, _Last1) > [_First2, _Last2)
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __CRTDECL _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific comparison of char sequences
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __CRTDECL _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific comparison of wchar_t sequences
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		// FUNCTION TEMPLATE _LStrxfrm
template<class _Elem> inline
	size_t __CRTDECL _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	// perform locale-specific transform of _Elems [_First1, _Last1)
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		_CRT_SECURE_MEMCPY(_First1, (_Last1 - _First1) * sizeof (_Elem),
			_First2, _Count * sizeof (_Elem));
	return (_Count);
	}

template<> inline
	size_t __CRTDECL _LStrxfrm(_Out_writes_ (_Last1 - _First1)
		_Post_readable_size_(return) char *_First1, _In_z_ char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific transform of chars [_First1, _Last1)
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __CRTDECL _LStrxfrm(_Out_writes_ (_Last1 - _First1)
		_Post_readable_size_(return) wchar_t *_First1, _In_z_ wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific transform of wchar_ts [_First1, _Last1)
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3
#endif /* _XLOCINFO_ */
# 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocinfo" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 2 3

#if 0 /* expanded by -frewrite-includes */
#include <xfacet>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 1 3
// xfacet internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3
#ifndef _XFACET_
#define _XFACET_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

// This must be as small as possible, because its contents are
// injected into the msvcprt.lib and msvcprtd.lib import libraries.
// Do not include or define anything else here.
// In particular, basic_string must not be included here.

_STD_BEGIN
	// CLASS _Facet_base
class _CRTIMP2_PURE_IMPORT _Facet_base
	{	// code for reference counting a facet
public:
	virtual __CLR_OR_THIS_CALL ~_Facet_base() _NOEXCEPT
		{	// ensure that derived classes can be destroyed properly
		}

	// increment use count
	virtual void __CLR_OR_THIS_CALL _Incref() = 0;

	// decrement use count
	virtual _Facet_base * __CLR_OR_THIS_CALL _Decref() = 0;
	};

 #if defined(_M_CEE)
void __CLRCALL_OR_CDECL _Facet_Register_m(_Facet_base *);

 #else /* defined(_M_CEE) */
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3
void __CLRCALL_OR_CDECL _Facet_Register(_Facet_base *);
 #endif /* defined(_M_CEE) */
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3
#endif /* _XFACET_ */
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xfacet" 3

 /*
 * Copyright (c) by P.J. Plauger. All rights reserved.
  * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// CLASS TEMPLATE _Locbase
template<class _Dummy>
	class _Locbase
	{	// define templatized category constants, instantiate on demand
public:
	_PGLOBAL static const int collate = _M_COLLATE;
	_PGLOBAL static const int ctype = _M_CTYPE;
	_PGLOBAL static const int monetary = _M_MONETARY;
	_PGLOBAL static const int numeric = _M_NUMERIC;
	_PGLOBAL static const int time = _M_TIME;
	_PGLOBAL static const int messages = _M_MESSAGES;
	_PGLOBAL static const int all = _M_ALL;
	_PGLOBAL static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		// CLASS locale
class locale;
template<class _Facet>
	const _Facet& __CRTDECL use_facet(const locale&);
template<class _Elem>
	class collate;

struct _CRTIMP2_PURE_IMPORT _Crt_new_delete
	{	// base class for marking allocations as CRT blocks
  #ifdef _DEBUG
	void * __CLRCALL_OR_CDECL operator new(size_t _Size)
		{	// replace operator new
		void * _Ptr = operator new(_Size, nothrow);
		if (!_Ptr)
			_Xbad_alloc();
		return (_Ptr);
		}

	void * __CLRCALL_OR_CDECL operator new(size_t _Size, const nothrow_t&) _NOEXCEPT
		{	// replace nothrow operator new
		return (_malloc_dbg(_Size > 0 ? _Size : 1, _CRT_BLOCK, __FILE__, __LINE__));
		}

	void __CLRCALL_OR_CDECL operator delete(void * _Ptr) _NOEXCEPT
		{	// replace operator delete
		_CSTD free(_Ptr);
		}

	void __CLRCALL_OR_CDECL operator delete(void * _Ptr, const nothrow_t&) _NOEXCEPT
		{	// replace nothrow operator delete
		operator delete(_Ptr);
		}

	void * __CLRCALL_OR_CDECL operator new(size_t, void *_Ptr) _NOEXCEPT
		{	// imitate True Placement New
		return (_Ptr);
		}

	void __CLRCALL_OR_CDECL operator delete(void *, void *) _NOEXCEPT
		{	// imitate True Placement Delete
		}
  #endif /* _DEBUG */
# 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
	};

class locale
	: public _Locbase<int>, public _Crt_new_delete
	{	// nonmutable collection of facets that describe a locale
public:
	typedef int category;

			// CLASS id
	class _CRTIMP2_PURE_IMPORT id
		{	// identifier stamp, unique for each distinct kind of facet
	public:
		__CLR_OR_THIS_CALL id(size_t _Val = 0)
			: _Id(_Val)
			{	// construct with specified stamp value
			}

		__CLR_OR_THIS_CALL operator size_t()
			{	// get stamp, with lazy allocation
			if (_Id == 0)
				{	// still zero, allocate stamp
				_BEGIN_LOCK(_LOCK_LOCALE)
					if (_Id == 0)
						_Id = ++_Id_cnt;
				_END_LOCK()
				}
			return (_Id);
			}

	private:
		size_t _Id;	// the identifier stamp

		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;

	public:
		__CLR_OR_THIS_CALL id(const id&) = delete;
		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
		};

	class _Locimp;

			// CLASS facet
	class _CRTIMP2_PURE_IMPORT facet
		: public _Facet_base, public _Crt_new_delete
		{	// base class for all locale facets, performs reference counting
	public:
		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
			const locale * = 0)
			{	// get category value, or -1 if no corresponding C category
			return ((size_t)(-1));
			}

		virtual void __CLR_OR_THIS_CALL _Incref()
			{	// increment use count
			_MT_INCR(_Myrefs);
			}

		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
			{	// decrement use count
			if (_MT_DECR(_Myrefs) == 0)
				return (this);
			else
				return (0);
			}

	private:
		_Atomic_counter_t _Myrefs;	// the reference count

	protected:
		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization
			{	// construct with initial reference count
			}

		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
			{	// ensure that derived classes can be destroyed properly
			}

	public:
		__CLR_OR_THIS_CALL facet(const facet&) = delete;
		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
		};

			// CLASS _Locimp
	class _CRTIMP2_PURE_IMPORT _Locimp
		: public facet
		{	// reference-counted actual implementation of a locale
	protected:
		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
		{	// destroy the object
		_Locimp_dtor(this);
		}

	private:
		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
			_New_Locimp(bool _Transparent = false);
		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
			_New_Locimp(const _Locimp& _Right);

		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
			_Locimp_dtor(_Locimp *);
		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
		static void __CLRCALL_PURE_OR_CDECL
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend locale;

		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	// construct an empty _Locimp
			}

		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	// construct by copying
			_Locimp_ctor(this, _Right);
			}

		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
			{	// add a facet
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make essential facets

		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make wchar_t facets

 #ifdef _NATIVE_WCHAR_T_DEFINED
		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make ushort facets
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make remaining facets

		facet **_Facetvec;	// pointer to vector of facets
		size_t _Facetcount;	// size of vector of facets
		category _Catmask;	// mask describing implemented categories
		bool _Xparent;	// true if locale is transparent
		_Yarn<char> _Name;	// locale name, or "*" if not known

		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;

public:
		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
		};

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	// compare _Left and _Right strings using collate facet in locale
		const auto& _Coll_fac = use_facet<_STD collate<_Elem>>(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	// combine two locales
		_Facet *_Facptr;

		_TRY_BEGIN
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		_CATCH_ALL
			_Xruntime_error("locale::combine facet missing");
		_CATCH_END

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = none;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct from _Loc, replacing facet with *_Facptr
		if (_Facptr != 0)
			{	// replace facet
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			_Ptr->_Catmask = none;
			_Ptr->_Name = "*";
			}
		}

	locale(_Uninitialized)
		{	// defer construction
		}

	locale(const locale& _Right) _NOEXCEPT
		: _Ptr(_Right._Ptr)
		{	// construct by copying
		_Ptr->_Incref();
		}

	locale() _NOEXCEPT
		: _Ptr(_Init(true))
		{	// construct from current locale
		}

 #if !defined(MRTDLL) || !defined(_CRTBLD)
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct a locale by copying named facets
		if (_Cat != none)
			{	// worth adding, do it
			_TRY_BEGIN
				_BEGIN_LOCINFO(_Lobj)
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
					_Lobj._Addcats(_Loc._Ptr->_Catmask,
						_Loc.name().c_str());
					_Lobj._Addcats(_Other._Ptr->_Catmask,
						_Other.name().c_str());
					_Ptr->_Catmask = _Loc._Ptr->_Catmask
						| _Other._Ptr->_Catmask;
					_Ptr->_Name = _Lobj._Getname();
				_END_LOCINFO()
			_CATCH_ALL
			delete _Ptr->_Decref();
			_RERAISE;
			_CATCH_END
			}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)
		{	// construct a locale with named facets
		bool _Bad = false;
		_Init();
		if (_Cat != none)
			{	// worth adding, do it
			_TRY_BEGIN
				_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
					if (_Badname(_Lobj))
						_Bad = true;
					else
						{	// name okay, build the locale
						_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
						_Ptr->_Catmask = _Cat;
						_Ptr->_Name = _Str.c_str();
						}
				_END_LOCINFO()
			_CATCH_ALL
			delete _Ptr->_Decref();
			_RERAISE;
			_CATCH_END
			}

		if (_Bad)
			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
			delete _Ptr->_Decref();
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	// construct a locale with named facets
		// _Locname might have been returned from setlocale().
		// Therefore, _Construct() takes const string&.
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct a locale by copying, replacing named facets
		// _Locname might have been returned from setlocale().
		// Therefore, _Construct() takes const string&.
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	// construct a locale with named facets
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct a locale by copying, replacing named facets
		_Construct(_Str, _Cat);
		}
 #endif /* !MRTDLL || !_CRTBLD */
# 400 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

	~locale() _NOEXCEPT
		{	// destroy the object
		if (_Ptr != 0)
			delete _Ptr->_Decref();
		}

	locale& operator=(const locale& _Right) _NOEXCEPT
		{	// assign a locale
		if (_Ptr != _Right._Ptr)
			{	// different implementation, point at new one
			delete _Ptr->_Decref();
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}

	string name() const
		{	// return locale name
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	_Ret_z_ const char *c_str() const
		{	// return locale name as NTBS
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	// look up a facet in locale object
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	// found facet or not transparent
		else
			{	// look in current locale
			locale::_Locimp *_Ptr0 = _Getgloballocale();
			return (_Id < _Ptr0->_Facetcount
				? _Ptr0->_Facetvec[_Id]	// get from current locale
				: 0);	// no entry in current locale
			}
		}

	_NODISCARD bool operator==(const locale& _Loc) const
		{	// compare locales for equality
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	_NODISCARD bool operator!=(const locale& _Right) const
		{	// test for locale inequality
		return (!(*this == _Right));
		}

	static _MRTIMP2_PURE const locale& __CLRCALL_PURE_OR_CDECL
		classic();	// classic "C" locale

	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
		global(const locale&);	// current locale

	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
		empty();	// empty (transparent) locale

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	// construct from _Locimp pointer
		}

	static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
		_Init(bool _Do_incref = false);	// initialize locale
	static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
		_Getgloballocale();
	static _MRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	// test if name is "*"
		return (_CSTD strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	// pointer to locale implementation object
	};

		// SUPPORT TEMPLATES
template<class _Facet>
	struct _Facetptr
	{	// store pointer to lazy facet for use_facet
	__PURE_APPDOMAIN_GLOBAL static const locale::facet *_Psave;
	};

template<class _Facet>
	__PURE_APPDOMAIN_GLOBAL const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  #define _ADDFAC(loc, pfac)	locale(loc, pfac)	/* add facet to locale */

  #define _USE(loc, fac)	\
	use_facet< fac >(loc)	/* get facet reference from locale */

template<class _Facet> inline
	const _Facet& __CRTDECL use_facet(const locale& _Loc)

	{	// get facet reference from locale
	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	// got facet from locale
		else if (_Psave != 0)
			_Pf = _Psave;	// lazy facet already allocated
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 #if _HAS_EXCEPTIONS

			_THROW(bad_cast{});	// lazy disallowed

 #else /* _HAS_EXCEPTIONS */
# 523 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
			abort();	// lazy disallowed
 #endif /* _HAS_EXCEPTIONS */
# 525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		else
			{	// queue up lazy facet for destruction
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 #if defined(_M_CEE)
			_Facet_Register_m(_Pfmod);

 #else /* defined(_M_CEE) */
# 538 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
			_Facet_Register(_Pfmod);
 #endif /* defined(_M_CEE) */
# 540 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
			}

		return ((const _Facet&)(*_Pf));	// should be dynamic_cast
	_END_LOCK()
	}	// end of use_facet body

		// FUNCTION TEMPLATE _Getloctxt
template<class _Elem,
	class _InIt> inline
	int __CRTDECL _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	// find field at _Ptr that matches longest in [_First, _Last)
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	// add fields with leading mark to initial count
	string _Str(_Numfields, '\0');	// one column counter for each field

	int _Ans = -2;	// no candidates so far
	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
		{	// test each element against all viable fields
		bool _Prefix = false;	// seen at least one valid prefix
		size_t _Off = 0;	// offset into fields
		size_t _Field = 0;	// current field number

		for (; _Field < _Numfields; ++_Field)
			{	// test element at _Column in field _Field
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	// find beginning of field

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	// skip tested columns in field
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	// matched all of field, save as possible answer
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	// save skip count if small enough
				_Ans = (int)_Field;	// save answer
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	// no match, just save skip count
			else
				_Prefix = true;	// still a valid prefix
			}

		if (!_Prefix || _First == _Last)
			break;	// no pending prefixes or no input, give up
		}
	return (_Ans);	// return field number or negative value on failure
	}

		// FUNCTION TEMPLATE _Maklocbyte
#define _MAKLOCBYTE(Elem, chr, cvt) \
	_Maklocbyte((_Elem)chr, cvt)	/* convert Elem to char */

template<class _Elem> inline
	char __CRTDECL _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	// convert _Elem to char using _Cvtvec
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __CRTDECL _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert wchar_t to char using _Cvtvec
	char _Byte = '\0';
	_Mbstinit(_Mbst1);
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<> inline
	char __CRTDECL _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert unsigned short to char using _Cvtvec
	char _Byte = '\0';
	_Mbstinit(_Mbst1);
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 623 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// FUNCTION TEMPLATE _Maklocchr
#define _MAKLOCCHR(Elem, chr, cvt) \
	_Maklocchr(chr, (Elem *)0, cvt)	/* convert char to Elem */

template<class _Elem> inline
	_Elem __CRTDECL _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert char to _Elem using _Cvtvec
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __CRTDECL _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert char to wchar_t using _Cvtvec
	wchar_t _Wc = L'\0';
	_Mbstinit(_Mbst1);
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<> inline
	unsigned short __CRTDECL _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert char to unsigned short using _Cvtvec
	unsigned short _Wc = (unsigned short)0;
	_Mbstinit(_Mbst1);
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 656 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// FUNCTION TEMPLATE _Maklocstr
#define _MAKLOCSTR(Elem, str, cvt)	\
	_Maklocstr(str, (Elem *)0, cvt)	/* convert C string to Elem sequence */

template<class _Elem> inline
	_Elem *__CRTDECL _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert C string to _Elem sequence using _Cvtvec
	size_t _Count = _CSTD strlen(_Ptr) + 1;

	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),
		_CRT_BLOCK, __FILE__, __LINE__);

	if (!_Ptrdest)
		_Xbad_alloc();

	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__CRTDECL _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert C string to wchar_t sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	_Mbstinit(_Mbst1);

	_Count1 = _CSTD strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		_CRT_BLOCK, __FILE__, __LINE__);

	if (!_Ptrdest)
		_Xbad_alloc();
	wchar_t *_Ptrnext = _Ptrdest;
	_Mbstinit(_Mbst2);

	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';

	return (_Ptrdest);
	}

 #ifdef _NATIVE_WCHAR_T_DEFINED
template<> inline
	unsigned short *__CRTDECL _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert C string to unsigned short sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	_Mbstinit(_Mbst1);

	_Count1 = _CSTD strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		_CRT_BLOCK, __FILE__, __LINE__);

	if (!_Ptrdest)
		_Xbad_alloc();

	wchar_t *_Ptrnext = _Ptrdest;
	_Mbstinit(_Mbst2);
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 750 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// STRUCT codecvt_base
class _CRTIMP2_PURE_IMPORT codecvt_base
	: public locale::facet
	{	// base class for codecvt
public:
	enum
		{	// constants for different parse states
		ok, partial, error, noconv};
	typedef int result;

	__CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	bool __CLR_OR_THIS_CALL always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input (from codecvt)
		return (do_always_noconv());
		}

	int __CLR_OR_THIS_CALL max_length() const _NOEXCEPT
		{	// return maximum length required for a conversion (from codecvt)
		return (do_max_length());
		}

	int __CLR_OR_THIS_CALL encoding() const _NOEXCEPT
		{	// return length of code sequence (from codecvt)
		return (do_encoding());
		}

	__CLR_OR_THIS_CALL ~codecvt_base() _NOEXCEPT
		{	// destroy the object
		}

protected:
	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input (from codecvt)
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _NOEXCEPT
		{	// return maximum length required for a conversion (from codecvt)
		return (1);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _NOEXCEPT
		{	// return length of code sequence (from codecvt)
		return (1);	// -1 ==> state dependent, 0 ==> varying length
		}
	};

		// CLASS TEMPLATE codecvt
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	// facet for converting between _Elem and char (_Byte) sequences
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_Init(_Locinfo());
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input (from codecvt)
		return (is_same_v<_Byte, _Elem>);
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_Mid1 = _First1;
		_Mid2 = _First2;
		if (is_same_v<_Byte, _Elem>)
			return (noconv);	// convert nothing
		else
			{	// types differ, copy one for one
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_Mid1 = _First1;
		_Mid2 = _First2;
		if (is_same_v<_Byte, _Elem>)
			return (noconv);	// convert nothing
		else
			{	// types differ, copy one for one
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	// generate bytes to return to default shift state
		_Mid2 = _First2;
		return (ok);	// convert nothing
		}

	virtual int __CLR_OR_THIS_CALL do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion
		}
	};

		// STATIC codecvt::id OBJECT
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif /* __clang__ */
# 931 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

template<class _Elem,
	class _Byte,
	class _Statype>
	__PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 940 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// ENUM _Codecvt_mode
enum _Codecvt_mode {
	_Consume_header = 4,
	_Generate_header = 2
	};

		// CLASS codecvt<char16_t, char, _Mbstatet>
template<>
	class _CRTIMP2_PURE_IMPORT codecvt<char16_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between char16_t and UTF-8 byte sequences
public:
	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
	typedef char16_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	// construct from specified locale and parameters
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
		{	// initialize
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last2)
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert a multibyte sequence
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra, _Nskip;

			if (*_Pstate <= 1)
				;	// no leftover word
			else if (_By < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	// not continuation byte
			else
				{	// deliver second half of two-word value
				++_Mid1;
				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
				*_Pstate = 1;
				continue;
				}

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	// 0x80-0xdf not first byte
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			_Nskip = _Nextra < 3 ? 0 : 1;	// leave a byte for 2nd word
			_First1 = _Mid1;	// roll back point

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
				break;	// not enough input
			else
				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	// not continuation byte
					else
						_Ch = _Ch << 6 | (_By & 0x3f);
			if (0 < _Nskip)
				_Ch <<= 6;	// get last byte on next call

			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
				return (_Mybase::error);	// value too large
			else if (0xffff < _Ch)
				{	// deliver first half of two-word value, save second word
				unsigned short _Ch0 =
					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

				*_Mid2++ = (_Elem)_Ch0;
				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
				continue;
				}

			if (_Nskip == 0)
				;
			else if (_Mid1 == _Last1)
				{	// not enough bytes, noncanonical value
				_Mid1 = _First1;
				break;
				}
			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	// not continuation byte
			else
				_Ch |= _By & 0x3f;	// complete noncanonical value

			if (*_Pstate == 0)
				{	// first time, maybe look for and consume header
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	// drop header and retry
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	// roll back header determination
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert and put a wide char
			unsigned long _Ch;
			unsigned short _Ch1 = (unsigned short)*_Mid1;
			bool _Save = false;

			if (1 < *_Pstate)
				{	// get saved MS 11 bits from *_Pstate
				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
					return (_Mybase::error);	// bad second word
				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
				}
			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
				{	// get new first word
				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
				_Save = true;	// put only first byte, rest with second word
				}
			else
				_Ch = _Ch1;	// not first word, just put it

			_Byte _By;
			int _Nextra;

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x10000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

			if (_Last2 - _Mid2 < _Nput)
				break;	// not enough room, even without header
			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
				;	// no header to put
			else if (_Last2 - _Mid2 < 3 + _Nput)
				break;	// not enough room for header + output
			else
				{	// prepend header
				*_Mid2++ = (_Byte)(unsigned char)0xef;
				*_Mid2++ = (_Byte)(unsigned char)0xbb;
				*_Mid2++ = (_Byte)(unsigned char)0xbf;
				}

			++_Mid1;
			if (_Save || _Nextra < 3)
				{	// put first byte of sequence, if not already put
				*_Mid2++ = _By;
				--_Nput;
				}
			for (; 0 < _Nput; --_Nput)
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid2 = _First2;

		return (1 < *_Pstate
			? _Mybase::error : _Mybase::ok);	// fail if trailing first word
		}

	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		while (_Wchars < _Count && _First1 != _Last1)
			{	// convert another wide character
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	// test result of single wide-char conversion
			case _Mybase::noconv:
				return ((int)(_Wchars + (_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	// replacement do_in might not convert one
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	// error or partial
				}
			}

		return ((int)_Wchars);
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _NOEXCEPT
		{	// return maximum length required for a conversion
		return ((_Mode & _Consume_header) != 0 ? 9	// header + max input
			: (_Mode & _Generate_header) != 0 ? 7	// header + max output
			: 6);	// 6-byte max input sequence, no 3-byte header
		}

	virtual int do_encoding() const _NOEXCEPT
		{	// return length of code sequence (from codecvt)
		return (0);	// 0 => varying length
		}

private:
	unsigned long _Maxcode;	// default: 0x10ffff
	_Codecvt_mode _Mode;	// default: _Consume_header
	};

		// CLASS codecvt<char32_t, char, _Mbstatet>
template<>
	class _CRTIMP2_PURE_IMPORT codecvt<char32_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between char32_t and UTF-8 byte sequences
public:
	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
	typedef char32_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	// construct from specified locale and parameters
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
		{	// initialize
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert a multibyte sequence
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra;

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	// 0x80-0xdf not first byte
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1)
				break;	// not enough input
			else
				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	// not continuation byte
					else
						_Ch = _Ch << 6 | (_By & 0x3f);

			if (*_Pstate == 0)
				{	// first time, maybe look for and consume header
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	// drop header and retry
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	// roll back header determination
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			if (_Maxcode < _Ch)
				return (_Mybase::error);	// code too large
			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert and put a wide char
			_Byte _By;
			int _Nextra;
			unsigned long _Ch = (unsigned long)*_Mid1;

			if (_Maxcode < _Ch)
				return (_Mybase::error);

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x00010000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else if (_Ch < 0x00200000)
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
			else if (_Ch < 0x04000000)
				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
			else
				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

			if (*_Pstate == 0)
				{	// first time, maybe generate header
				*_Pstate = 1;
				if ((_Mode & _Generate_header) == 0)
					;
				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
					return (_Mybase::partial);	// not enough room for both
				else
					{	// prepend header
					*_Mid2++ = (_Byte)(unsigned char)0xef;
					*_Mid2++ = (_Byte)(unsigned char)0xbb;
					*_Mid2++ = (_Byte)(unsigned char)0xbf;
					}
				}

			if (_Last2 - _Mid2 < 1 + _Nextra)
				break;	// not enough room for output

			++_Mid1;
			for (*_Mid2++ = _By; 0 < _Nextra; )
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
			}
		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_Mid2 = _First2;
		return (_Mybase::ok);
		}

	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		int _Wchars = 0;
		_Statype _Mystate = _State;

		while ((size_t)_Wchars < _Count && _First1 != _Last1)
			{	// convert another wide character
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	// test result of single wide-char conversion
			case _Mybase::noconv:
				return ((int)(_Wchars + (int)(_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	// replacement do_in might not convert one
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	// error or partial
				}
			}

		return ((int)_Wchars);
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _NOEXCEPT
		{	// return maximum length required for a conversion
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? 9 : 6);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _NOEXCEPT
		{	// return length of code sequence (from codecvt)
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? -1 : 0);	// -1 => state dependent, 0 => varying length
		}

private:
	unsigned long _Maxcode;	// default: 0xffffffff
	_Codecvt_mode _Mode;	// default: _Consume_header
	};

		// CLASS codecvt<wchar_t, char, _Mbstatet>
template<>
	class _CRTIMP2_PURE_IMPORT codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between wchar_t and char (_Byte) sequences
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	// failed conversion
				return (error);

			case 0:	// may have converted null character
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to a wchar_t
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{
			if ((int)MB_LEN_MAX <= _Last2 - _Mid2)
				{
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else
					{
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			else
				{	// destination too small, convert into buffer
				_Byte _Buf[MB_LEN_MAX];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					break;
					}
				else
					{	// copy converted bytes from buffer
					_CSTD memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			}

		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_DEBUG_RANGE(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[MB_LEN_MAX];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	// locale-specific wcrtomb failed
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			_CSTD memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		_DEBUG_RANGE(_First1, _Last1);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	// convert another wchar_t
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				return (_Wchars);

			case -1:	// failed conversion
				return (_Wchars);

			case 0:	// may have converted null character
				if (_Ch == (_Elem)0)
					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to a wchar_t
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _NOEXCEPT
		{	// return maximum length required for a conversion (from codecvt)
		return (MB_LEN_MAX);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _NOEXCEPT
		{	// return length of code sequence (from codecvt)
		return (0);	// 0 => varying length
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};

 #ifdef _NATIVE_WCHAR_T_DEFINED
		// CLASS codecvt<unsigned short, char, _Mbstatet>
template<>
	class _CRTIMP2_PURE_IMPORT codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between unsigned short and char sequences
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	// failed conversion
				return (error);

			case 0:	// may have converted null character
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to an unsigned short
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{
			if ((int)MB_LEN_MAX <= _Last2 - _Mid2)
				{
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else
					{
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			else
				{	// destination too small, convert into buffer
				_Byte _Buf[MB_LEN_MAX];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					break;
					}
				else
					{	// copy converted bytes from buffer
					_CSTD memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			}

		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_DEBUG_RANGE(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[MB_LEN_MAX];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	// locale-specific wcrtomb failed
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			_CSTD memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		_DEBUG_RANGE(_First1, _Last1);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	// convert another unsigned char
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				return (_Wchars);

			case -1:	// failed conversion
				return (_Wchars);

			case 0:	// may have converted null character
				if (_Ch == (_Elem)0)
					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to an unsigned char
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _NOEXCEPT
		{	// return true if conversions never change input
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _NOEXCEPT
		{	// return maximum length required for a conversion (from codecvt)
		return (MB_LEN_MAX);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _NOEXCEPT
		{	// return length of code sequence (from codecvt)
		return (0);	// 0 => varying length
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 2035 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// CLASS TEMPLATE codecvt_byname
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	// codecvt for named locale
public:
	explicit __CLR_OR_THIS_CALL codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

	explicit __CLR_OR_THIS_CALL codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual __CLR_OR_THIS_CALL ~codecvt_byname() _NOEXCEPT
		{	// destroy the object
		}
	};

		// STRUCT ctype_base
struct _CRTIMP2_PURE_IMPORT ctype_base
	: public locale::facet
	{	// base for ctype
	enum
		{	// constants for character classifications
		alnum = _DI | _LO | _UP | _XA, alpha = _LO | _UP | _XA,
		cntrl = _BB, digit = _DI, graph = _DI | _LO | _PU | _UP | _XA,
		lower = _LO, print = _DI | _LO | _PU | _SP | _UP | _XA | _XD,
		punct = _PU, space = _CN | _SP | _XS, upper = _UP,
		xdigit = _XD, blank = _CN | _SP | _XS | _XB};
	typedef short mask;	// to match <ctype.h>

	__CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	__CLR_OR_THIS_CALL ~ctype_base() _NOEXCEPT
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE ctype
template<class _Elem>
	class ctype
		: public ctype_base
	{	// facet for classifying elements, converting cases
public:
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
		{	// destroy the object
		if (_Ctype._Delfl)
			_CSTD free((void *)_Ctype._Table);

		_CSTD free(_Ctype._LocaleName);
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to lower case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to upper case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_MAKLOCCHR(_Elem, _Byte, _Cvt));
		}

	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _MAKLOCCHR(_Elem, *_First, _Cvt);
		return (_First);
		}

	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _MAKLOCBYTE(_Elem, _Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// STATIC ctype::id OBJECT
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif /* __clang__ */
# 2322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

template<class _Elem>
	locale::id ctype<_Elem>::id;

#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 2329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// CLASS ctype<char>
template<>
	class _CRTIMP2_PURE_IMPORT ctype<char>
	: public ctype_base
	{	// facet for classifying char elements, converting cases
public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const _Elem *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct with specified table and delete flag for table
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()

		_Tidy();	// free existing table, as needed
		if (_Table != 0)
			{	// replace existing char to mask table
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	// use classic table
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

	const mask *__CLR_OR_THIS_CALL table() const _NOEXCEPT
		{	// return address of char to mask table
		return (_Ctype._Table);
		}

	static const mask *__CLRCALL_OR_CDECL classic_table() _NOEXCEPT
		{	// return address of char to mask table for "C" locale
		const ctype& _Ctype_fac = _USE(locale::classic(), ctype);
		return (_Ctype_fac.table());
		}

	_PGLOBAL static const size_t table_size =
		1 << CHAR_BIT;	// size of ctype mapping table, typically 256

protected:
	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
		{	// destroy the object
		_Tidy();
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		}

	void __CLR_OR_THIS_CALL _Tidy()
		{	// free any allocated storage
		if (0 < _Ctype._Delfl)
			_CSTD free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] _Ctype._Table;

		_CSTD free(_Ctype._LocaleName);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_Byte);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_CSTD memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const
		{	// narrow char
		return (_Ch);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_CSTD memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// information
	};

		// CLASS ctype<wchar_t>
template<>
	class _CRTIMP2_PURE_IMPORT ctype<wchar_t>
	: public ctype_base
	{	// facet for classifying wchar_t elements, converting cases
public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
		{	// destroy the object
		if (_Ctype._Delfl)
			_CSTD free((void *)_Ctype._Table);

		_CSTD free(_Ctype._LocaleName);
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		return (_CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const
		{	// widen char
		_Mbstinit(_Mbst);
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)WEOF : _Wc);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[MB_LEN_MAX];
		_Mbstinit(_Mbst);
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

 #ifdef _NATIVE_WCHAR_T_DEFINED
		// CLASS ctype<unsigned short>
template<>
	class _CRTIMP2_PURE_IMPORT ctype<unsigned short>
	: public ctype_base
	{	// facet for classifying unsigned short elements, converting cases
public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;

	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (_X_CTYPE);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
		{	// destroy the object
		if (_Ctype._Delfl)
			_CSTD free((void *)_Ctype._Table);

		_CSTD free(_Ctype._LocaleName);
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		return ((const _Elem *)_CSTD _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const
		{	// widen char
		_Mbstinit(_Mbst);
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)WEOF : _Wc);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[MB_LEN_MAX];
		_Mbstinit(_Mbst);
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};
 #endif /* _NATIVE_WCHAR_T_DEFINED */
# 2989 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

		// CLASS TEMPLATE ctype_byname
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	// ctype for named locale
public:
	explicit __CLR_OR_THIS_CALL ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

	explicit __CLR_OR_THIS_CALL ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual __CLR_OR_THIS_CALL ~ctype_byname() _NOEXCEPT
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE ctype_byname<char>
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	// ctype_byname<char> for named locale
public:
	explicit __CLR_OR_THIS_CALL ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

	explicit __CLR_OR_THIS_CALL ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual __CLR_OR_THIS_CALL ~ctype_byname() _NOEXCEPT
		{	// destroy the object
		}
	};

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT codecvt<char, char, _Mbstatet>;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 3039 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
 #endif /* defined(_DLL_CPPLIB) */
# 3040 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 3045 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3
#endif /* _XLOCALE_ */
# 3046 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocale" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 2 3

 #if 0 /* expanded by -frewrite-includes */
#include <system_error>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 1 3
// system_error standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
#ifndef _SYSTEM_ERROR_
#define _SYSTEM_ERROR_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <cerrno>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 1 3
// cerrno standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3
#ifndef _CERRNO_
#define _CERRNO_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3
#if 0 /* expanded by -frewrite-includes */
#include <errno.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3

#endif /* RC_INVOKED */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3
#endif /* _CERRNO_ */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cerrno" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>		// for strerror
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdexcept>	// for runtime_error
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
#if 0 /* expanded by -frewrite-includes */
#include <xcall_once.h>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xcall_once.h" 1 3
// xcall_once.h internal header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xcall_once.h" 3
#ifndef _XCALL_ONCE_H
#define _XCALL_ONCE_H
#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xcall_once.h" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xcall_once.h" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// STRUCT once_flag
struct once_flag
	{	// opaque data structure for call_once()
	constexpr once_flag() _NOEXCEPT
		: _Opaque(0)
		{	// default construct
		}

	once_flag(const once_flag&) = delete;
	once_flag& operator=(const once_flag&) = delete;

	void *_Opaque;
	};

typedef int (__stdcall *_Execute_once_fp_t)(void *, void *, void **);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Execute_once(
	once_flag& _Flag, _Execute_once_fp_t _Callback, void *_Pv) _NOEXCEPT;

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xcall_once.h" 3
#endif /* _XCALL_ONCE_H */
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xcall_once.h" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new


 #ifdef _CRT_NO_POSIX_ERROR_CODES
  #error <system_error> is incompatible with _CRT_NO_POSIX_ERROR_CODES.
 #endif /* _CRT_NO_POSIX_ERROR_CODES */
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3


_STD_BEGIN
		// ENUM errc
enum class errc {	// names for generic error codes
	address_family_not_supported = EAFNOSUPPORT,
	address_in_use = EADDRINUSE,
	address_not_available = EADDRNOTAVAIL,
	already_connected = EISCONN,
	argument_list_too_long = E2BIG,
	argument_out_of_domain = EDOM,
	bad_address = EFAULT,
	bad_file_descriptor = EBADF,
	bad_message = EBADMSG,
	broken_pipe = EPIPE,
	connection_aborted = ECONNABORTED,
	connection_already_in_progress = EALREADY,
	connection_refused = ECONNREFUSED,
	connection_reset = ECONNRESET,
	cross_device_link = EXDEV,
	destination_address_required = EDESTADDRREQ,
	device_or_resource_busy = EBUSY,
	directory_not_empty = ENOTEMPTY,
	executable_format_error = ENOEXEC,
	file_exists = EEXIST,
	file_too_large = EFBIG,
	filename_too_long = ENAMETOOLONG,
	function_not_supported = ENOSYS,
	host_unreachable = EHOSTUNREACH,
	identifier_removed = EIDRM,
	illegal_byte_sequence = EILSEQ,
	inappropriate_io_control_operation = ENOTTY,
	interrupted = EINTR,
	invalid_argument = EINVAL,
	invalid_seek = ESPIPE,
	io_error = EIO,
	is_a_directory = EISDIR,
	message_size = EMSGSIZE,
	network_down = ENETDOWN,
	network_reset = ENETRESET,
	network_unreachable = ENETUNREACH,
	no_buffer_space = ENOBUFS,
	no_child_process = ECHILD,
	no_link = ENOLINK,
	no_lock_available = ENOLCK,
	no_message_available = ENODATA,
	no_message = ENOMSG,
	no_protocol_option = ENOPROTOOPT,
	no_space_on_device = ENOSPC,
	no_stream_resources = ENOSR,
	no_such_device_or_address = ENXIO,
	no_such_device = ENODEV,
	no_such_file_or_directory = ENOENT,
	no_such_process = ESRCH,
	not_a_directory = ENOTDIR,
	not_a_socket = ENOTSOCK,
	not_a_stream = ENOSTR,
	not_connected = ENOTCONN,
	not_enough_memory = ENOMEM,
	not_supported = ENOTSUP,
	operation_canceled = ECANCELED,
	operation_in_progress = EINPROGRESS,
	operation_not_permitted = EPERM,
	operation_not_supported = EOPNOTSUPP,
	operation_would_block = EWOULDBLOCK,
	owner_dead = EOWNERDEAD,
	permission_denied = EACCES,
	protocol_error = EPROTO,
	protocol_not_supported = EPROTONOSUPPORT,
	read_only_file_system = EROFS,
	resource_deadlock_would_occur = EDEADLK,
	resource_unavailable_try_again = EAGAIN,
	result_out_of_range = ERANGE,
	state_not_recoverable = ENOTRECOVERABLE,
	stream_timeout = ETIME,
	text_file_busy = ETXTBSY,
	timed_out = ETIMEDOUT,
	too_many_files_open_in_system = ENFILE,
	too_many_files_open = EMFILE,
	too_many_links = EMLINK,
	too_many_symbolic_link_levels = ELOOP,
	value_too_large = EOVERFLOW,
	wrong_protocol_type = EPROTOTYPE
	};

		// ENUM io_errc
enum class io_errc {	// error codes for ios_base::failure
	stream = 1
	};

		// STRUCT TEMPLATE is_error_code_enum
template<class _Enum>
	struct is_error_code_enum
		: false_type
	{	// tests for error_code enumeration
	};

template<>
	struct is_error_code_enum<io_errc>
		: true_type
	{	// tests for error_condition enumeration
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

		// STRUCT TEMPLATE is_error_condition_enum
template<class _Enum>
	struct is_error_condition_enum
		: false_type
	{	// tests for error_condition enumeration
	};

template<>
	struct is_error_condition_enum<errc>
		: true_type
	{	// tests for error_condition enumeration
	};

template<class _Ty>
	_INLINE_VAR constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

class error_code;
class error_condition;
_NODISCARD error_code make_error_code(errc) _NOEXCEPT;
_NODISCARD error_code make_error_code(io_errc) _NOEXCEPT;
_NODISCARD error_condition make_error_condition(errc) _NOEXCEPT;
_NODISCARD error_condition make_error_condition(io_errc) _NOEXCEPT;

		// CLASS error_category
class error_category;

_NODISCARD const error_category& generic_category() _NOEXCEPT;
_NODISCARD const error_category& iostream_category() _NOEXCEPT;
_NODISCARD const error_category& system_category() _NOEXCEPT;

class error_category
	{	// categorize an error
public:
	/* constexpr */ error_category() _NOEXCEPT	// TRANSITION
		{	// default constructor
		_Addr = reinterpret_cast<uintptr_t>(this);
		}

	virtual ~error_category() _NOEXCEPT
		{
		}

	_NODISCARD virtual const char *name() const _NOEXCEPT = 0;

	_NODISCARD virtual string message(int _Errval) const = 0;

	_NODISCARD virtual error_condition default_error_condition(int _Errval) const _NOEXCEPT;

	_NODISCARD virtual bool equivalent(int _Errval, const error_condition& _Cond) const _NOEXCEPT;

	_NODISCARD virtual bool equivalent(const error_code& _Code, int _Errval) const _NOEXCEPT;

	_NODISCARD bool operator==(const error_category& _Right) const _NOEXCEPT
		{	// compare categories for equality
		return (_Addr == _Right._Addr);
		}

	_NODISCARD bool operator!=(const error_category& _Right) const _NOEXCEPT
		{	// compare categories for inequality
		return (!(*this == _Right));
		}

	_NODISCARD bool operator<(const error_category& _Right) const _NOEXCEPT
		{	// compare categories for order
		return (_Addr < _Right._Addr);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;

protected:
	uintptr_t _Addr;

	enum : uintptr_t
		{	// imaginary addresses for Standard error_category objects
		_Future_addr = 1,
		_Generic_addr = 3,
		_Iostream_addr = 5,
		_System_addr = 7
		};
	};

		// CLASS error_code
class error_code
	{	// store an implementation-specific error code and category
public:
	error_code() _NOEXCEPT
		: _Myval(0),
		_Mycat(&system_category())
		{	// construct non-error
		}

	error_code(int _Val, const error_category& _Cat) _NOEXCEPT
		: _Myval(_Val),
		_Mycat(&_Cat)
		{	// construct from error code and category
		}

	template<class _Enum,
		class = enable_if_t<is_error_code_enum_v<_Enum>>>
		error_code(_Enum _Errcode) _NOEXCEPT
		: _Myval(0),
		_Mycat(0)
		{	// construct from enumerated error code
		*this = make_error_code(_Errcode);	// using ADL
		}

	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
		{	// assign error code and category
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum,
		class = enable_if_t<is_error_code_enum_v<_Enum>>>
		error_code& operator=(_Enum _Errcode) _NOEXCEPT
		{	// assign enumerated error code
		*this = make_error_code(_Errcode);	// using ADL
		return (*this);
		}

	void clear() _NOEXCEPT
		{	// assign non-error
		_Myval = 0;
		_Mycat = &system_category();
		}

	_NODISCARD int value() const _NOEXCEPT
		{	// get error code
		return (_Myval);
		}

	_NODISCARD const error_category& category() const _NOEXCEPT
		{	// get category
		return (*_Mycat);
		}

	_NODISCARD error_condition default_error_condition() const _NOEXCEPT;

	_NODISCARD string message() const
		{	// get name of error code
		return (category().message(value()));
		}

	explicit operator bool() const _NOEXCEPT
		{	// test for actual error
		return (value() != 0);
		}

private:
	int _Myval;	// the stored error number
	const error_category *_Mycat;	// pointer to error category
	};

		// CLASS error_condition
class error_condition
	{	// store an abstract error code and category
public:
	error_condition() _NOEXCEPT
		: _Myval(0),
		_Mycat(&generic_category())
		{	// construct non-error
		}

	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
		: _Myval(_Val),
		_Mycat(&_Cat)
		{	// construct from error code and category
		}

	template<class _Enum,
		class = enable_if_t<is_error_condition_enum_v<_Enum>>>
		error_condition(_Enum _Errcode) _NOEXCEPT
		: _Myval(0),
		_Mycat(0)
		{	// construct from enumerated error code
		*this = make_error_condition(_Errcode);	// using ADL
		}

	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
		{	// assign error code and category
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum,
		class = enable_if_t<is_error_condition_enum_v<_Enum>>>
		error_condition& operator=(_Enum _Errcode) _NOEXCEPT
		{	// assign enumerated error code
		*this = make_error_condition(_Errcode);	// using ADL
		return (*this);
		}

	void clear() _NOEXCEPT
		{	// assign non-error
		_Myval = 0;
		_Mycat = &generic_category();
		}

	_NODISCARD int value() const _NOEXCEPT
		{	// get error code
		return (_Myval);
		}

	_NODISCARD const error_category& category() const _NOEXCEPT
		{	// get category
		return (*_Mycat);
		}

	_NODISCARD string message() const
		{	// get name of error code
		return (category().message(value()));
		}

	explicit operator bool() const _NOEXCEPT
		{	// test for actual error
		return (value() != 0);
		}

private:
	int _Myval;	// the stored error number
	const error_category * _Mycat;	// pointer to error category
	};

		// operator== FOR error_code/error_condition
_NODISCARD inline bool operator==(const error_code& _Left, const error_code& _Right) _NOEXCEPT
	{	// test errors for equality
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

_NODISCARD inline bool operator==(const error_code& _Left, const error_condition& _Right) _NOEXCEPT
	{	// test errors for equality
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

_NODISCARD inline bool operator==(const error_condition& _Left, const error_code& _Right) _NOEXCEPT
	{	// test errors for equality
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

_NODISCARD inline bool operator==(const error_condition& _Left, const error_condition& _Right) _NOEXCEPT
	{	// test errors for equality
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

		// operator!= FOR error_code/error_condition
_NODISCARD inline bool operator!=(const error_code& _Left, const error_code& _Right) _NOEXCEPT
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

_NODISCARD inline bool operator!=(const error_code& _Left, const error_condition& _Right) _NOEXCEPT
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

_NODISCARD inline bool operator!=(const error_condition& _Left, const error_code& _Right) _NOEXCEPT
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

_NODISCARD inline bool operator!=(const error_condition& _Left, const error_condition& _Right) _NOEXCEPT
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

		// operator< FOR error_code/error_condition
_NODISCARD inline bool operator<(const error_code& _Left, const error_code& _Right) _NOEXCEPT
	{	// test if _Left < _Right
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

_NODISCARD inline bool operator<(const error_condition& _Left, const error_condition& _Right) _NOEXCEPT
	{	// test if _Left < _Right
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

		// VIRTUALS FOR error_category
_NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const _NOEXCEPT
	{	// make error_condition for error code
	return (error_condition(_Errval, *this));
	}

_NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const _NOEXCEPT
	{	// test if error code same condition
	return (default_error_condition(_Errval) == _Cond);
	}

_NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const _NOEXCEPT
	{	// test if conditions same for this category
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		// MEMBER FUNCTIONS for error_code
_NODISCARD inline error_condition error_code::default_error_condition() const _NOEXCEPT
	{	// make error_condition for error code
	return (category().default_error_condition(value()));
	}

		// FUNCTION make_error_code
_NODISCARD inline error_code make_error_code(errc _Errno) _NOEXCEPT
	{	// make an error_code
	return (error_code((int)_Errno, generic_category()));
	}

_NODISCARD inline error_code make_error_code(io_errc _Errno) _NOEXCEPT
	{	// make an error_code
	return (error_code((int)_Errno, iostream_category()));
	}

		// FUNCTION make_error_condition
_NODISCARD inline error_condition make_error_condition(errc _Errno) _NOEXCEPT
	{	// make an error_condition
	return (error_condition((int)_Errno, generic_category()));
	}

_NODISCARD inline error_condition make_error_condition(io_errc _Errno) _NOEXCEPT
	{	// make an error_condition
	return (error_condition((int)_Errno, iostream_category()));
	}

		// STRUCT TEMPLATE SPECIALIZATION hash
template<>
	struct hash<error_code>
	{	// hash functor for error_code
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef error_code argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const error_code& _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<int>{}(_Keyval.value()));
		}
	};

template<>
	struct hash<error_condition>
	{	// hash functor for error_condition
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef error_condition argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const error_condition& _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<int>{}(_Keyval.value()));
		}
	};

		// CLASS system_error
class _System_error
	: public runtime_error
	{	// base of all system-error exceptions
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	// compose error message
		if (!_Message.empty())
			{
			_Message.append(": ");
			}

		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)),
		_Mycode(_Errcode)
		{	// construct from error code and message string
		}

	error_code _Mycode;	// the stored error code
	};

class system_error
	: public _System_error
	{	// base of all system-error exceptions
private:
	typedef _System_error _Mybase;

public:
	system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	// construct from error code
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	// construct from error code and message string
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	// construct from error code and message string
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	// construct from error code components
		}

	system_error(int _Errval, const error_category& _Errcat, const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	// construct from error code components and message string
		}

	system_error(int _Errval, const error_category& _Errcat, const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	// construct from error code components and message string
		}

	_NODISCARD const error_code& code() const _NOEXCEPT
		{	// return stored error code
		return (_Mycode);
		}

 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		_RAISE(*this);
		}
 #endif /* _HAS_EXCEPTIONS */
# 558 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
	};

_CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Syserror_map(int);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Winerror_map(int);
_CRTIMP2_PURE unsigned long __CLRCALL_PURE_OR_CDECL _Winerror_message(
	unsigned long _Message_id, char *_Narrow, unsigned long _Size);

		// CLASS _Generic_error_category
class _Generic_error_category
	: public error_category
	{	// categorize a generic error
public:
	_Generic_error_category() _NOEXCEPT
		{	// default constructor
		_Addr = _Generic_addr;
		}

	_NODISCARD virtual const char *name() const _NOEXCEPT
		{	// get name of category
		return ("generic");
		}

	_NODISCARD virtual string message(int _Errcode) const
		{	// convert to name of error
		return (_Syserror_map(_Errcode));
		}
	};

		// CLASS _Iostream_error_category
class _Iostream_error_category
	: public _Generic_error_category
	{	// categorize an iostream error
public:
	_Iostream_error_category() _NOEXCEPT
		{	// default constructor
		_Addr = _Iostream_addr;
		}

	_NODISCARD virtual const char *name() const _NOEXCEPT
		{	// get name of category
		return ("iostream");
		}

	_NODISCARD virtual string message(int _Errcode) const
		{	// convert to name of error
		if (_Errcode == (int)io_errc::stream)
			{
			return ("iostream stream error");
			}
		else
			{
			return (_Generic_error_category::message(_Errcode));
			}
		}
	};

		// CLASS _System_error_category
class _System_error_category
	: public error_category
	{	// categorize an operating system error
public:
	_System_error_category() _NOEXCEPT
		{	// default constructor
		_Addr = _System_addr;
		}

	_NODISCARD virtual const char *name() const _NOEXCEPT
		{	// get name of category
		return ("system");
		}

	_NODISCARD virtual string message(int _Errcode) const
		{	// convert to name of error
		const unsigned long _Size = 32767;
		string _Narrow(_Size, '\0');

		const unsigned long _Val = _Winerror_message(static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);
		if (_Val == 0)
			{
			_Narrow = "unknown error";
			}
		else
			{
			_Narrow.resize(_Val);
			}

		_Narrow.shrink_to_fit();
		return (_Narrow);
		}

	_NODISCARD virtual error_condition default_error_condition(int _Errval) const _NOEXCEPT
		{	// make error_condition for error code (generic if possible)
		int _Posv = _Winerror_map(_Errval);
		if (_Posv == 0)
			{
			return (error_condition(_Errval, system_category()));
			}
		else
			{
			return (error_condition(_Posv, generic_category()));
			}
		}
	};

#ifdef _M_CEE_PURE
template<class _Ty>
	struct _Immortalizer
	{	// constructs _Ty, never destroys
	_Immortalizer()
		{	// construct _Ty inside _Storage
		::new (static_cast<void *>(&_Storage)) _Ty();
		}

	_Immortalizer(const _Immortalizer&) = delete;
	_Immortalizer& operator=(const _Immortalizer&) = delete;

	aligned_union_t<1, _Ty> _Storage;
	};

template<class _Ty> inline
	_Ty& _Immortalize()
	{	// return a reference to an object that will live forever
	/* MAGIC */ static _Immortalizer<_Ty> _Static;
	return (reinterpret_cast<_Ty&>(_Static._Storage));
	}
#else /* ^^^ _M_CEE_PURE ^^^ // vvv !_M_CEE_PURE vvv */
# 684 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
template<class _Ty> inline
	int __stdcall _Immortalize_impl(void *, void * _Storage_ptr, void **) _NOEXCEPT
	{	// adapt True Placement New to _Execute_once
	::new (_Storage_ptr) _Ty();
	return (1);
	}

template<class _Ty> inline
	_Ty& _Immortalize()
	{	// return a reference to an object that will live forever
	static_assert(sizeof(void *) == sizeof(once_flag), "TRANSITION, VSO#406237");
	static_assert(alignof(void *) == alignof(once_flag), "TRANSITION, VSO#406237");
	static void * _Flag = nullptr;
	static aligned_union_t<1, _Ty> _Storage;
	if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)
		{	// _Execute_once should never fail if the callback never fails
		_STD terminate();
		}

	return (reinterpret_cast<_Ty&>(_Storage));
	}
#endif /* _M_CEE_PURE */
# 706 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3

_NODISCARD inline const error_category& generic_category() _NOEXCEPT
	{	// get generic_category
	return (_Immortalize<_Generic_error_category>());
	}

_NODISCARD inline const error_category& iostream_category() _NOEXCEPT
	{	// get iostream_category
	return (_Immortalize<_Iostream_error_category>());
	}

_NODISCARD inline const error_category& system_category() _NOEXCEPT
	{	// get system_category
	return (_Immortalize<_System_error_category>());
	}
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 726 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3
#endif /* _SYSTEM_ERROR_ */
# 727 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\system_error" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 2 3

 #if 0 /* expanded by -frewrite-includes */
#include <share.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\share.h" 1 3
//
// share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.
//
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\share.h" 3
#define _INC_SHARE

#if 0 /* expanded by -frewrite-includes */
#include <corecrt_share.h>
#endif /* expanded by -frewrite-includes */
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\share.h" 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\share.h" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

 #define _OPENPROT	_SH_DENYNO

_STD_BEGIN
 #define _IOSskipws		0x0001
 #define _IOSunitbuf	0x0002
 #define _IOSuppercase	0x0004
 #define _IOSshowbase	0x0008
 #define _IOSshowpoint	0x0010
 #define _IOSshowpos	0x0020
 #define _IOSleft		0x0040
 #define _IOSright		0x0080
 #define _IOSinternal	0x0100
 #define _IOSdec		0x0200
 #define _IOSoct		0x0400
 #define _IOShex		0x0800
 #define _IOSscientific	0x1000
 #define _IOSfixed		0x2000

 #define _IOShexfloat	0x3000	// added with TR1

 #define _IOSboolalpha	0x4000
 #define _IOS_Stdio		0x8000

 #define _IOS_Nocreate	0x40
 #define _IOS_Noreplace	0x80
 #define _IOSbinary		0x20

		// CLASS TEMPLATE _Iosb
template<class _Dummy>
	class _Iosb
	{	// define templatized bitmask/enumerated types, instantiate on demand
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	// don't ask
	enum _Fmtflags
		{	// constants for formatting options
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static constexpr _Fmtflags skipws = (_Fmtflags)_IOSskipws;
	static constexpr _Fmtflags unitbuf = (_Fmtflags)_IOSunitbuf;
	static constexpr _Fmtflags uppercase = (_Fmtflags)_IOSuppercase;
	static constexpr _Fmtflags showbase = (_Fmtflags)_IOSshowbase;
	static constexpr _Fmtflags showpoint = (_Fmtflags)_IOSshowpoint;
	static constexpr _Fmtflags showpos = (_Fmtflags)_IOSshowpos;
	static constexpr _Fmtflags left = (_Fmtflags)_IOSleft;
	static constexpr _Fmtflags right = (_Fmtflags)_IOSright;
	static constexpr _Fmtflags internal = (_Fmtflags)_IOSinternal;
	static constexpr _Fmtflags dec = (_Fmtflags)_IOSdec;
	static constexpr _Fmtflags oct = (_Fmtflags)_IOSoct;
	static constexpr _Fmtflags hex = (_Fmtflags)_IOShex;
	static constexpr _Fmtflags scientific = (_Fmtflags)_IOSscientific;
	static constexpr _Fmtflags fixed = (_Fmtflags)_IOSfixed;

	static constexpr _Fmtflags hexfloat =
		(_Fmtflags)_IOShexfloat;	// added with TR1 (not in C++11)

	static constexpr _Fmtflags boolalpha = (_Fmtflags)_IOSboolalpha;
	static constexpr _Fmtflags _Stdio = (_Fmtflags)_IOS_Stdio;
	static constexpr _Fmtflags adjustfield = (_Fmtflags)(_IOSleft
		| _IOSright | _IOSinternal);
	static constexpr _Fmtflags basefield = (_Fmtflags)(_IOSdec
		| _IOSoct | _IOShex);
	static constexpr _Fmtflags floatfield = (_Fmtflags)(_IOSscientific
		| _IOSfixed);

	enum _Iostate
		{	// constants for stream states
		_Statmask = 0x17};

	static constexpr _Iostate goodbit = (_Iostate)0x0;
	static constexpr _Iostate eofbit = (_Iostate)0x1;
	static constexpr _Iostate failbit = (_Iostate)0x2;
	static constexpr _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{	// constants for file opening options
		_Openmask = 0xff};

	static constexpr _Openmode in = (_Openmode)0x01;
	static constexpr _Openmode out = (_Openmode)0x02;
	static constexpr _Openmode ate = (_Openmode)0x04;
	static constexpr _Openmode app = (_Openmode)0x08;
	static constexpr _Openmode trunc = (_Openmode)0x10;
	static constexpr _Openmode _Nocreate = (_Openmode)_IOS_Nocreate;
	static constexpr _Openmode _Noreplace = (_Openmode)_IOS_Noreplace;
	static constexpr _Openmode binary = (_Openmode)_IOSbinary;

	enum _Seekdir
		{	// constants for file positioning options
		_Seekbeg,
		_Seekcur,
		_Seekend
		};

	static constexpr _Seekdir beg = _Seekbeg;
	static constexpr _Seekdir cur = _Seekcur;
	static constexpr _Seekdir end = _Seekend;

	enum
		{	// constant for default file opening protection
		_Openprot = _OPENPROT};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	// added with TR1 (not in C++11)

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		// CLASS ios_base
class _CRTIMP2_PURE_IMPORT ios_base
	: public _Iosb<int>
	{	// base class for ios
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	typedef _STD streamoff streamoff;
	typedef _STD streampos streampos;
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3

	enum event
		{	// constants for ios events
		erase_event, imbue_event, copyfmt_event};

	typedef void (__CLRCALL_OR_CDECL *event_callback)(event, ios_base&, int);

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	typedef unsigned int io_state, open_mode, seek_dir;
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3

			// CLASS failure
	class failure

		: public system_error
		{	// base of all iostreams exceptions
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	// construct with message
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	// construct with message
			}


 #if _HAS_EXCEPTIONS

 #else /* _HAS_EXCEPTIONS */
# 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
	protected:
		virtual void _Doraise() const
			{	// report the exception
			_RAISE(*this);
			}
 #endif /* _HAS_EXCEPTIONS */
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
		};

			// CLASS Init
	class _CRTIMP2_PURE_IMPORT Init
		{	// controller for standard-stream initialization
	public:
		__CLR_OR_THIS_CALL Init()
			{	// initialize standard streams on first construction
			_Init_ctor(this);
			}

		__CLR_OR_THIS_CALL ~Init() _NOEXCEPT
			{	// flush standard streams on last destruction
			_Init_dtor(this);
			}

	private:
		static _MRTIMP2_NPURE void __cdecl _Init_ctor(Init *);
		static _MRTIMP2_NPURE void __cdecl _Init_dtor(Init *);

		__PURE_APPDOMAIN_GLOBAL static int _Init_cnt;	// net ctor count

		static _MRTIMP2_NPURE int& __cdecl _Init_cnt_func();
		};

	explicit __CLR_OR_THIS_CALL operator bool() const
		{	// test if no stream operation has failed
		return (!fail());
		}

	_NODISCARD bool __CLR_OR_THIS_CALL operator!() const
		{	// test if any stream operation has failed
		return (fail());
		}

	void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise)
		{	// set state, possibly reraise exception
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			_RERAISE;
		else if (_Mystate & _Except & badbit)
			_THROW(failure("ios_base::badbit set"));
		else if (_Mystate & _Except & failbit)
			_THROW(failure("ios_base::failbit set"));
		else
			_THROW(failure("ios_base::eofbit set"));
		}

	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
		{	// set state to argument
		clear(_State, false);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void __CLR_OR_THIS_CALL clear(io_state _State)
		{	// set state to argument, old-style
		clear((iostate)_State);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3

	_NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const
		{	// return stream state
		return (_Mystate);
		}

	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
		{	// merge in state argument, possibly reraise exception
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void __CLR_OR_THIS_CALL setstate(iostate _State)
		{	// merge in state argument
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void __CLR_OR_THIS_CALL setstate(io_state _State)
		{	// merge in state argument, old style
		setstate((iostate)_State);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 335 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3

	_NODISCARD bool __CLR_OR_THIS_CALL good() const
		{	// test if no state bits are set
		return (rdstate() == goodbit);
		}

	_NODISCARD bool __CLR_OR_THIS_CALL eof() const
		{	// test if eofbit is set in stream state
		return ((int)rdstate() & (int)eofbit);
		}

	_NODISCARD bool __CLR_OR_THIS_CALL fail() const
		{	// test if badbit or failbit is set in stream state
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	_NODISCARD bool __CLR_OR_THIS_CALL bad() const
		{	// test if badbit is set in stream state
		return (((int)rdstate() & (int)badbit) != 0);
		}

	_NODISCARD iostate __CLR_OR_THIS_CALL exceptions() const
		{	// return exception mask
		return (_Except);
		}

	void __CLR_OR_THIS_CALL exceptions(iostate _Newexcept)
		{	// set exception mask to argument
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void __CLR_OR_THIS_CALL exceptions(io_state _State)
		{	// set exception mask to argument, old style
		exceptions((iostate)_State);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 374 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3

	_NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const
		{	// return format flags
		return (_Fmtfl);
		}

	fmtflags __CLR_OR_THIS_CALL flags(fmtflags _Newfmtflags)
		{	// set format flags to argument
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags __CLR_OR_THIS_CALL setf(fmtflags _Newfmtflags)
		{	// merge in format flags argument
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| ((int)_Newfmtflags & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	fmtflags __CLR_OR_THIS_CALL setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	// merge in format flags argument under mask argument
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void __CLR_OR_THIS_CALL unsetf(fmtflags _Mask)
		{	// clear format flags under mask argument
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	_NODISCARD streamsize __CLR_OR_THIS_CALL precision() const
		{	// return precision
		return (_Prec);
		}

	streamsize __CLR_OR_THIS_CALL precision(streamsize _Newprecision)
		{	// set precision to argument
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	_NODISCARD streamsize __CLR_OR_THIS_CALL width() const
		{	// return width
		return (_Wide);
		}

	streamsize __CLR_OR_THIS_CALL width(streamsize _Newwidth)
		{	// set width to argument
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	_NODISCARD locale __CLR_OR_THIS_CALL getloc() const
		{	// get locale
		return (*_Ploc);
		}

	locale __CLR_OR_THIS_CALL imbue(const locale& _Loc)
		{	// set locale to argument
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	_NODISCARD static int __CLRCALL_OR_CDECL xalloc()
		{	// allocate new iword/pword index
		_BEGIN_LOCK(_LOCK_STREAM)	// lock thread to ensure atomicity
			return (_Index++);
		_END_LOCK()
		}

	_NODISCARD long& __CLR_OR_THIS_CALL iword(int _Idx)
		{	// return reference to long element
		return (_Findarr(_Idx)._Lo);
		}

	_NODISCARD void *& __CLR_OR_THIS_CALL pword(int _Idx)
		{	// return reference to pointer element
		return (_Findarr(_Idx)._Vp);
		}

	void __CLR_OR_THIS_CALL register_callback(event_callback _Pfn,
		int _Idx)
		{	// register event handler
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base& __CLR_OR_THIS_CALL copyfmt(const ios_base& _Other)
		{	// copy format stuff
		if (this != _STD addressof(_Other))
			{	// copy all but _Mystate
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	// copy over nonzero array values
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	// call callbacks
			exceptions(_Other._Except);	// cause any throw at end
			}
		return (*this);
		}

	static bool __CLRCALL_OR_CDECL sync_with_stdio(bool _Newsync = true)
		{	// set C/C++ synchronization flag from argument
		_BEGIN_LOCK(_LOCK_STREAM)	// lock thread to ensure atomicity
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		_END_LOCK()
		}

	void __CLR_OR_THIS_CALL swap(ios_base& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			{	// different, do the move
			_STD swap(_Mystate, _Right._Mystate);
			_STD swap(_Except, _Right._Except);
			_STD swap(_Fmtfl, _Right._Fmtfl);
			_STD swap(_Prec, _Right._Prec);
			_STD swap(_Wide, _Right._Wide);

			_STD swap(_Arr, _Right._Arr);
			_STD swap(_Calls, _Right._Calls);
			_STD swap(_Ploc, _Right._Ploc);
			}
		}

	virtual __CLR_OR_THIS_CALL ~ios_base() _NOEXCEPT	// destroy the object
		{	// destroy the object
		_Ios_base_dtor(this);
		}

	static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
		_Addstd(ios_base *);	// add standard stream

	size_t _Stdstr;	// if > 0 index of standard stream to suppress destruction

protected:
	__CLR_OR_THIS_CALL ios_base()
		{	// default constructor
		}

	void __CLR_OR_THIS_CALL _Init()
		{	// initialize a new ios_base
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			// STRUCT _Iosarray
	struct _Iosarray
		: public _Crt_new_delete
		{	// list element for open-ended sparse array of longs/pointers
	public:
		__CLR_OR_THIS_CALL _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	// construct node for index _Idx and link it in
			}

		_Iosarray *_Next;	// pointer to next node
		int _Index;	// index of this node
		long _Lo;	// stored long value
		void *_Vp;	// stored pointer value
		};

			// STRUCT _Fnarray
	struct _Fnarray
		: public _Crt_new_delete
		{	// list element for open-ended sparse array of event handlers
		__CLR_OR_THIS_CALL _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	// construct node for index _Idx and link it in
			}

		_Fnarray *_Next;	// pointer to next node
		int _Index;	// index of this node
		event_callback _Pfn;	// pointer to event handler
		};

	void __CLR_OR_THIS_CALL _Callfns(event _Ev)
		{	// call all event handlers, reporting event
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray& __CLR_OR_THIS_CALL _Findarr(int _Idx)
		{	// locate or make a variable array element
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	// found element, return it
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	// found recycling candidate

		if (_Ptr2 != 0)
			{	// recycle existing element
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	// make a new element
		return (*_Arr);
		}

	void __CLR_OR_THIS_CALL _Tidy()
		{	// discard storage for an ios_base
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	// delete array element
			_Ptr2 = _Ptr1->_Next;
			delete _Ptr1;
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	// delete callback element
			_Pfa2 = _Pfa1->_Next;
			delete _Pfa1;
			}
		_Calls = 0;
		}

	iostate _Mystate;	// stream state
	iostate _Except;	// exception mask
	fmtflags _Fmtfl;	// format flags
	streamsize _Prec;	// field precision
	streamsize _Wide;	// field width
	_Iosarray *_Arr;	// pointer to first node of long/pointer array
	_Fnarray *_Calls;	// pointer to first node of call list
	locale *_Ploc;	// pointer to locale

	__PURE_APPDOMAIN_GLOBAL static int _Index;
	__PURE_APPDOMAIN_GLOBAL static bool _Sync;

	static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 652 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3
#endif /* _XIOSBASE_ */
# 653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xiosbase" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// CLASS TEMPLATE basic_streambuf
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	// control read/write buffers
protected:
	__CLR_OR_THIS_CALL basic_streambuf()
		: _Plocale(new locale)
		{	// construct with no buffers
		_Init();
		}

	__CLR_OR_THIS_CALL basic_streambuf(_Uninitialized)
		{	// construct uninitialized
		}

	__CLR_OR_THIS_CALL basic_streambuf(const basic_streambuf& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	// construct by copying _Right
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	basic_streambuf& __CLR_OR_THIS_CALL operator=(const basic_streambuf& _Right)
		{	// assign from _Right
		if (this != _STD addressof(_Right))
			{	// different, worth copying
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void __CLR_OR_THIS_CALL swap(basic_streambuf& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			{	// different, worth swapping
			_Elem *_Pfirst0 = pbase();
			_Elem *_Pnext0 = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst0 = eback();
			_Elem *_Gnext0 = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst0, _Pnext0, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst0, _Gnext0, _Gend);

			_STD swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual __CLR_OR_THIS_CALL ~basic_streambuf() _NOEXCEPT
		{	// destroy the object
		delete _Plocale;
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type __CLR_OR_THIS_CALL pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	// change position by _Off, according to _Way, _Mode
		return (seekoff(_Off, _Way, _Mode));
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	pos_type __CLR_OR_THIS_CALL pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	// change position by _Off, according to _Way, _Mode (old style)
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

	pos_type __CLR_OR_THIS_CALL pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	// change position to _Pos, according to _Mode
		return (seekpos(_Pos, _Mode));
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	pos_type __CLR_OR_THIS_CALL pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	// change position to _Pos, according to _Mode (old style)
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

	basic_streambuf *__CLR_OR_THIS_CALL pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	// offer _Buffer to external agent
		return (setbuf(_Buffer, _Count));
		}

	locale __CLR_OR_THIS_CALL pubimbue(const locale &_Newlocale)
		{	// set locale to argument
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale __CLR_OR_THIS_CALL getloc() const
		{	// get locale
		return (*_Plocale);
		}

	streamsize __CLR_OR_THIS_CALL in_avail()
		{	// return count of buffered input characters
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int __CLR_OR_THIS_CALL pubsync()
		{	// synchronize with external agent
		return (sync());
		}

	int_type __CLR_OR_THIS_CALL sbumpc()
		{	// get a character and point past it
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type __CLR_OR_THIS_CALL sgetc()
		{	// get a character and don't point past it
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	// get up to _Count characters into array beginning at _Ptr
		return (xsgetn(_Ptr, _Count));
		}

	int_type __CLR_OR_THIS_CALL snextc()
		{	// point to next character and return it
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
		{	// put back _Ch
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void __CLR_OR_THIS_CALL stossc()
		{	// point past a character
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

	int_type __CLR_OR_THIS_CALL sungetc()
		{	// back up one position
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
		{	// put a character
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	// put _Count characters from array beginning at _Ptr
		return (xsputn(_Ptr, _Count));
		}

	virtual void __CLR_OR_THIS_CALL _Lock()
		{	// set the thread lock (overridden by basic_filebuf)
		}

	virtual void __CLR_OR_THIS_CALL _Unlock()
		{	// clear the thread lock (overridden by basic_filebuf)
		}

protected:
	_Elem *__CLR_OR_THIS_CALL eback() const
		{	// return beginning of read buffer
		return (*_IGfirst);
		}

	_Elem *__CLR_OR_THIS_CALL gptr() const
		{	// return current position in read buffer
		return (*_IGnext);
		}

	_Elem *__CLR_OR_THIS_CALL pbase() const
		{	// return beginning of write buffer
		return (*_IPfirst);
		}

	_Elem *__CLR_OR_THIS_CALL pptr() const
		{	// return current position in write buffer
		return (*_IPnext);
		}

	_Elem *__CLR_OR_THIS_CALL egptr() const
		{	// return end of read buffer
		return (*_IGnext + *_IGcount);
		}

	void __CLR_OR_THIS_CALL gbump(int _Off)
		{	// alter current position in read buffer by _Off
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	// set pointers for read buffer
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem *__CLR_OR_THIS_CALL epptr() const
		{	// return end of write buffer
		return (*_IPnext + *_IPcount);
		}

	_Elem *__CLR_OR_THIS_CALL _Gndec()
		{	// decrement current position in read buffer
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem *__CLR_OR_THIS_CALL _Gninc()
		{	// increment current position in read buffer
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
		{	// preincrement current position in read buffer
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize __CLR_OR_THIS_CALL _Gnavail() const
		{	// count number of available elements in read buffer
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void __CLR_OR_THIS_CALL pbump(int _Off)
		{	// alter current position in write buffer by _Off
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
		{	// set pointers for write buffer
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	// set pointers for write buffer, extended version
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem *__CLR_OR_THIS_CALL _Pninc()
		{	// increment current position in write buffer
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize __CLR_OR_THIS_CALL _Pnavail() const
		{	// count number of available positions in write buffer
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void __CLR_OR_THIS_CALL _Init()
		{	// initialize buffer parameters for no buffers
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void __CLR_OR_THIS_CALL _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	// initialize buffer parameters as specified
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type __CLR_OR_THIS_CALL overflow(int_type = _Traits::eof())
		{	// put a character to stream (always fail)
		return (_Traits::eof());
		}

	virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type = _Traits::eof())
		{	// put a character back to stream (always fail)
		return (_Traits::eof());
		}

	virtual streamsize __CLR_OR_THIS_CALL showmanyc()
		{	// return count of input characters
		return (0);
		}

	virtual int_type __CLR_OR_THIS_CALL underflow()
		{	// get a character from stream, but don't point past it
		return (_Traits::eof());
		}

	virtual int_type __CLR_OR_THIS_CALL uflow()
		{	// get a character from stream, point past it
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	// get _Count characters from stream
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	// copy from read buffer
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	// end of file, quit
			else
				{	// get a single character
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	// put _Count characters to stream
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	// copy to write buffer
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	// single character put failed, quit
			else
				{	// count character successfully put
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type __CLR_OR_THIS_CALL seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	// change position by offset, according to way and mode
		return (streampos(_BADOFF));
		}

	virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	// change to specified position, according to mode
		return (streampos(_BADOFF));
		}

	virtual basic_streambuf *__CLR_OR_THIS_CALL setbuf(_Elem *, streamsize)
		{	// offer buffer to external agent (do nothing)
		return (this);
		}

	virtual int __CLR_OR_THIS_CALL sync()
		{	// synchronize with external agent (do nothing)
		return (0);
		}

	virtual void __CLR_OR_THIS_CALL imbue(const locale&)
		{	// set locale to argument (do nothing)
		}

private:
	_Elem *_Gfirst;	// beginning of read buffer
	_Elem *_Pfirst;	// beginning of write buffer
	_Elem **_IGfirst;	// pointer to beginning of read buffer
	_Elem **_IPfirst;	// pointer to beginning of write buffer
	_Elem *_Gnext;	// current position in read buffer
	_Elem *_Pnext;	// current position in write buffer
	_Elem **_IGnext;	// pointer to current position in read buffer
	_Elem **_IPnext;	// pointer to current position in write buffer

	int _Gcount;	// length of read buffer
	int _Pcount;	// length of write buffer
	int *_IGcount;	// pointer to length of read buffer
	int *_IPcount;	// pointer to length of write buffer

protected:
	locale *_Plocale;	// pointer to imbued locale object
	};

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_streambuf<char, char_traits<char> >;
template class _CRTIMP2_PURE_IMPORT basic_streambuf<wchar_t, char_traits<wchar_t> >;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 473 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_streambuf<unsigned short,
	char_traits<unsigned short> >;
  #endif /* __FORCE_INSTANCE */
# 478 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3
 #endif /* defined(_DLL_CPPLIB) */
# 479 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

		// CLASS TEMPLATE istreambuf_iterator
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
	{	// wrap stream buffer as input iterator
public:
	using iterator_category = input_iterator_tag;
	using value_type = _Elem;
	using difference_type = typename _Traits::off_type;
	using pointer = const _Elem *;
	using reference = _Elem;

	using char_type = _Elem;
	using traits_type = _Traits;
	using streambuf_type = basic_streambuf<_Elem, _Traits>;
	using istream_type = basic_istream<_Elem, _Traits>;

	using int_type = typename traits_type::int_type;

	constexpr istreambuf_iterator(streambuf_type *_Sb = 0) _NOEXCEPT
		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()
		{	// construct from stream buffer _Sb
		}

	istreambuf_iterator(istream_type& _Istr) _NOEXCEPT
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	// construct from stream buffer in istream _Istr
		}

	_NODISCARD _Elem operator*() const
		{	// return designated value
		if (!_Got)
			_Peek();

 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Strbuf == 0)
			{
			_DEBUG_ERROR("istreambuf_iterator is not dereferencable");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

		return (_Val);
		}

	istreambuf_iterator& operator++()
		{	// preincrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Strbuf == 0)
			{
			_DEBUG_ERROR("istreambuf_iterator is not incrementable");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

		_Inc();
		return (*this);
		}

	istreambuf_iterator operator++(int)
		{	// postincrement
		if (!_Got)
			_Peek();
		istreambuf_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_NODISCARD bool equal(const istreambuf_iterator& _Right) const
		{	// test for equality
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	// skip to next input element
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			{
			_Strbuf = 0;
			_Got = true;
			}
		else
			{
			_Got = false;
			}
		}

	_Elem _Peek() const
		{	// peek at next input element
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	// the wrapped stream buffer
	mutable bool _Got;	// true if _Val is valid
	mutable _Elem _Val;	// next element to deliver
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	// mark istreambuf_iterator as checked
	};

template<class _Elem,
	class _Traits>
	_NODISCARD inline bool operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	// test for istreambuf_iterator equality
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits>
	_NODISCARD inline bool operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	// test for istreambuf_iterator inequality
	return (!(_Left == _Right));
	}

		// CLASS TEMPLATE ostreambuf_iterator
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
	{	// wrap stream buffer as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using char_type = _Elem;
	using traits_type = _Traits;
	using streambuf_type = basic_streambuf<_Elem, _Traits>;
	using ostream_type = basic_ostream<_Elem, _Traits>;

	ostreambuf_iterator(streambuf_type *_Sb) _NOEXCEPT
		: _Failed(false), _Strbuf(_Sb)
		{	// construct from stream buffer _Sb
		}

	ostreambuf_iterator(ostream_type& _Ostr) _NOEXCEPT
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	// construct from stream buffer in _Ostr
		}

	ostreambuf_iterator& operator=(_Elem _Right)
		{	// store element and increment
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_NODISCARD ostreambuf_iterator& operator*()
		{	// pretend to get designated element
		return (*this);
		}

	ostreambuf_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	ostreambuf_iterator& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

	_NODISCARD bool failed() const _NOEXCEPT
		{	// return true if any stores failed
		return (_Failed);
		}

private:
	bool _Failed;	// true if any stores have failed
	streambuf_type *_Strbuf;	// the wrapped stream buffer
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	// mark ostreambuf_iterator as checked
	};
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 688 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3
#endif /* _STREAMBUF_ */
# 689 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\streambuf" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

		// TEXT-TO-NUMERIC CONVERSION FUNCTIONS

 #if !defined(MRTDLL) && !defined(_M_CEE_PURE)
_EXTERN_C
 #endif /* !defined(MRTDLL) etc. */
# 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

extern _CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _Stofx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	long, int *);
extern _CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stodx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	long, int *);
extern _CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _Stoldx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	long, int *);
extern _CRTIMP2_PURE long __CLRCALL_PURE_OR_CDECL _Stolx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	int, int *);
extern _CRTIMP2_PURE unsigned long __CLRCALL_PURE_OR_CDECL _Stoulx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	int, int *);
extern _CRTIMP2_PURE long long __CLRCALL_PURE_OR_CDECL _Stollx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	int, int *);
extern _CRTIMP2_PURE unsigned long long __CLRCALL_PURE_OR_CDECL _Stoullx(const char *,
	_Out_opt_ _Deref_post_opt_valid_ char **,
	int, int *);

 #if !defined(MRTDLL) && !defined(_M_CEE_PURE)
_END_EXTERN_C
 #endif /* !defined(MRTDLL) etc. */
# 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

_STD_BEGIN

		// FUNCTION _Stodx_v2
inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	// convert string to double
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	double _Val = _CSTD strtod(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= _CSTD pow(10.0, static_cast<double>(_Pten));

	return (_Val);
	}

		// FUNCTION _Stofx_v2
inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	// convert string to float
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	float _Val = _CSTD strtof(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= _CSTD powf(10.0f, static_cast<float>(_Pten));

	return (_Val);
	}

		// FUNCTION TEMPLATE _Find_elem
template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	// lookup _Ch in NUL-terminated string _Base
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	// copy NTWCS to allocated storage
	size_t _Count = _CSTD wcslen(_Ptr) + 1;

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),
		_CRT_BLOCK, __FILE__, __LINE__);

	if (!_Ptrdest)
		_Xbad_alloc();
	_CSTD wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		// CLASS TEMPLATE numpunct
template<class _Elem>
	class numpunct
		: public locale::facet
	{	// facet for defining numeric punctuation text
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	__PURE_APPDOMAIN_GLOBAL _CRTIMP2_PURE_IMPORT static locale::id id;	// unique facet id

	_Elem decimal_point() const
		{	// return decimal point
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	// return thousands separator
		return (do_thousands_sep());
		}

	string grouping() const
		{	// return grouping string
		return (do_grouping());
		}

	string_type falsename() const
		{	// return name for false
		return (do_falsename());
		}

	string_type truename() const
		{	// return name for true
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	// NB: differs from "C" locale
					_MAKLOCCHR(_Elem, ',', _Lobj._Getcvt());
		_END_LOCINFO()
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (_X_NUMERIC);
		}

protected:
	virtual __CLR_OR_THIS_CALL ~numpunct() _NOEXCEPT
		{	// destroy the object
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_BEGIN_LOCINFO(_Lobj(_Locname))
			_Init(_Lobj, _Isdef);
		_END_LOCINFO()
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	// get values
		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);
		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);
		}

	void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	// get values
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	// initialize from _Lobj
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		_TRY_BEGIN
		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,
			_Lobj._Getcvt());
		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);
		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);
		_CATCH_ALL
		_Tidy();
		_RERAISE;
		_CATCH_END

		if (_Isdef)
			{	// apply defaults for required facets
//			_Grouping = _MAKLOCSTR(char, "", _Cvt);
			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);
			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const
		{	// return decimal point
		return (_Dp);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const
		{	// return thousands separator
		return (_Kseparator);
		}

	virtual string __CLR_OR_THIS_CALL do_grouping() const
		{	// return grouping string
		return (string(_Grouping));
		}

	virtual string_type __CLR_OR_THIS_CALL do_falsename() const
		{	// return name for false
		return (string_type(_Falsename));
		}

	virtual string_type __CLR_OR_THIS_CALL do_truename() const
		{	// return name for true
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	// free all storage
		_CSTD free((void *)_Grouping);
		_CSTD free((void *)_Falsename);
		_CSTD free((void *)_Truename);
		}

	const char *_Grouping;	// grouping string, "" for "C" locale
	_Elem _Dp;	// decimal point, '.' for "C" locale
	_Elem _Kseparator;	// thousands separator, '\0' for "C" locale
	const _Elem *_Falsename;	// name for false, "false" for "C" locale
	const _Elem *_Truename;	// name for true, "true" for "C" locale
	};

		// CLASS TEMPLATE numpunct_byname
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	// numpunct for named locale
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	// construct for named locale
		}

protected:
	virtual __CLR_OR_THIS_CALL ~numpunct_byname() _NOEXCEPT
		{	// destroy the object
		}
	};

		// STATIC numpunct::id OBJECT
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif /* __clang__ */
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

template<class _Elem>
	__PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 302 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

		// CLASS TEMPLATE num_get
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	// facet for converting text to encoded numbers
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (_X_NUMERIC);
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id

protected:
	virtual __CLR_OR_THIS_CALL ~num_get() _NOEXCEPT
		{	// destroy the object
		}

	void _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

public:
	explicit __CLR_OR_THIS_CALL num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	// get bool from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	// get unsigned short from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	// get unsigned int from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	// get long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	// get unsigned long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	// get long long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	// get unsigned long long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	// get float from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	// get double from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	// get long double from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	// get void pointer from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	// get bool from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		int _Ans = -1;	// negative answer indicates failure

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	// get false name or true name
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	// construct "\0false\0true"
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	// get zero or nonzero integer
			char _Ac[_MAX_INT_DIG], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = _CSTD _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	// get unsigned short from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	// gather field into _Ac
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign
		const unsigned long _Ans =
			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || USHRT_MAX < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	// get unsigned int from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	// gather field into _Ac
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign
		const unsigned long _Ans =
			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || UINT_MAX < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	// get long from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;
		const long _Ans = _CSTD _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	// gather field, convert

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	// get unsigned long from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = _CSTD _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	// gather field, convert

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	// get long long from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;
		const long long _Ans = _CSTD _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	// gather field, convert

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	// get unsigned long long from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;
		const unsigned long long _Ans = _CSTD _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	// gather field, convert

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

// Sentinel value used by num_get::do_get() to enable correct "V2" behavior in _Getffld() and _Getffldx()
#define _ENABLE_V2_BEHAVIOR	1000000000

// Size of char buffer used by num_get::do_get() for float/double/long double
#define _FLOATING_BUFFER_SIZE	(_MAX_EXP_DIG + _MAX_SIG_DIG_V2 + 16)

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	// get float from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_FLOATING_BUFFER_SIZE], *_Ep;
		int _Errno = 0;
		int _Hexexp = _ENABLE_V2_BEHAVIOR;
		float _Ans = _Stofx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert

		if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)
			_Ans = _CSTD ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	// get double from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_FLOATING_BUFFER_SIZE], *_Ep;
		int _Errno = 0;
		int _Hexexp = _ENABLE_V2_BEHAVIOR;
		double _Ans = _Stodx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert

		if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)
			_Ans = _CSTD ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	// get long double from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_FLOATING_BUFFER_SIZE], *_Ep;
		int _Errno = 0;
		int _Hexexp = _ENABLE_V2_BEHAVIOR;
		long double _Ans = _Stodx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert, "widen" double to long double

		if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)
			_Ans = _CSTD ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	// deliver value
		return (_First);
		}

#undef _FLOATING_BUFFER_SIZE

	virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	// get void pointer from [_First, _Last) into _Val
		_DEBUG_RANGE(_First, _Last);
		char _Ac[_MAX_INT_DIG], *_Ep;
		int _Errno = 0;

		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	// gather field
		const unsigned long long _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned long long)_CSTD _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: _CSTD _Stoullx(_Ac, &_Ep, _Base, &_Errno);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	// deliver value
		return (_First);
		}

private:
	int __CLRCALL_OR_CDECL _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	// get integer field from [_First, _Last) into _Ac
		const _Mypunct& _Punct_fac = _USE(_Loc, _Mypunct);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			_USE(_Loc, ctype<_Elem>);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	// empty field
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			{	// gather plus sign
			*_Ptr++ = '+';
			++_First;
			}
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			{	// gather minus sign
			*_Ptr++ = '-';
			++_First;
			}

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	// seen a digit in input
		bool _Nonzero = false;	// seen a nonzero digit in input

		if (_First != _Last && *_First == _Atoms[0])
			{	// leading zero, look for 0x, 0X
			_Seendigit = true;
			++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				{
				_Base = 16;
				_Seendigit = false;
				++_First;
				}
			else if (_Base == 0)
				{
				_Base = 8;
				}
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[_MAX_INT_DIG - 1];
			_First != _Last; ++_First)
			{	// look for digits and separators
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	// got a digit, characterize it and add to group size
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					{
					++_Ptr;
					_Nonzero = true;
					}

				_Seendigit = true;
				if (_Groups[_Group] != CHAR_MAX)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	// not a group separator, done
			else
				{	// add a new group to _Groups string
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	// no thousands separators seen
		else if ('\0' < _Groups[_Group])
			++_Group;	// add trailing group to group count
		else
			_Seendigit = false;	// trailing separator, fail

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == CHAR_MAX)
				break;	// end of grouping constraints to check
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	// bad group size, fail
			else if ('\0' < _Pg[1])
				++_Pg;	// group size okay, advance to next test

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	// zero field, replace stripped zero(s)
		else if (!_Seendigit)
			_Ptr = _Ac;	// roll back pointer to indicate failure
		*_Ptr = '\0';
		return (_Base);
		}

	int __CLRCALL_OR_CDECL _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	// get floating-point field from [_First, _Last) into _Ac
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	// hex format

		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;
		bool _Sticky = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static constexpr char _Src[] = {"0123456789-+Ee"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			_USE(_Iosbase.getloc(), ctype<_Elem>);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		if (_First == _Last)
			;	// empty field
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			{	// gather plus sign
			*_Ptr++ = '+';
			++_First;
			}
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			{	// gather minus sign
			*_Ptr++ = '-';
			++_First;
			}

		char *_Leading = _Ptr;	// remember backstop
		*_Ptr++ = '0';	// backstop carries from sticky bit

		bool _Seendigit = false;	// seen a digit in input
		int _Significant = 0;	// number of significant digits
		int _Pten = 0;	// power of 10 multiplier
		size_t _Idx;

		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == CHAR_MAX || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, (void)++_First)
				if (_Max_sig_dig <= _Significant)
					{	// enough digits, scale by 10 and update _Sticky
					++_Pten;
					if (0 < _Idx)
						_Sticky = true;
					}
				else if (_Idx == 0 && _Significant == 0)
					;	// drop leading zeros
				else
					{	// save a significant digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	// grouping specified, gather digits and group sizes
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	// got a digit, add to group size
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						{	// enough digits, scale by 10 and update _Sticky
						++_Pten;
						if (0 < _Idx)
							_Sticky = true;
						}
					else if (_Idx == 0 && _Significant == 0)
						;	// drop leading zeros
					else
						{	// save a significant digit
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != CHAR_MAX)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	// not a group separator, done
				else
					{	// add a new group to _Groups string
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	// no thousands separators seen
			else if ('\0' < _Groups[_Group])
				++_Group;	// add trailing group to group count
			else
				_Bad = true;	// trailing separator, fail

			while (!_Bad && 0 < _Group)
				if (*_Pg == CHAR_MAX)
					break;	// end of grouping constraints to check
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	// bad group size, fail
				else if ('\0' < _Pg[1])
					++_Pg;	// group size okay, advance to next test
			}

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			{	// add .
			*_Ptr++ = localeconv()->decimal_point[0];
			++_First;
			}

		if (*_Phexexp != _ENABLE_V2_BEHAVIOR && _Significant == 0)
			{	// 0000. so far
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, (void)++_First)
				--_Pten;	// just count leading fraction zeros
			if (_Pten < 0)
				{	// put one back
				*_Ptr++ = '0';
				++_Pten;
				}
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, (void)++_First)
			if (_Significant < _Max_sig_dig)
				{	// save a significant fraction digit
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}
			else if (0 < _Idx)
				_Sticky = true;	// just update _Sticky

		if (_Sticky)
			{	// increment ls digit in memory of those lost
			char *_Px = _Ptr;
			while (--_Px != _Leading)
				{	// add in carry
				if (*_Px == localeconv()->decimal_point[0])
					;	// skip over decimal point
				else if (*_Px != '9')
					{	// carry stops here
					++*_Px;
					break;
					}
				else
					*_Px = '0';	// propagate carry
				}

			if (_Px == _Leading)
				{	// change "999..." to "1000..." and scale _Pten
				*_Px = '1';
				++_Pten;
				}
			}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	// 'e' or 'E', collect exponent
			*_Ptr++ = 'e';
			++_First;
			_Seendigit = false;
			_Significant = 0;

			if (_First == _Last)
				;	// 'e' or 'E' is last element
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				{	// gather plus sign
				*_Ptr++ = '+';
				++_First;
				}
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				{	// gather minus sign
				*_Ptr++ = '-';
				++_First;
				}

			for (; _First != _Last && *_First == _Atoms[0]; ++_First)
				{	// strip leading zeros
				_Seendigit = true;
				}

			if (_Seendigit)
				*_Ptr++ = '0';	// put one back
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, (void)++_First)
				if (_Significant < _MAX_EXP_DIG)
					{	// save a significant exponent digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	// roll back pointer to indicate failure
		*_Ptr = '\0';
		return (_Pten);
		}

	int __CLRCALL_OR_CDECL _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	// get hex floating-point field from [_First, _Last) into _Ac
		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			_USE(_Iosbase.getloc(), ctype<_Elem>);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	// empty field
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			{	// gather plus sign
			*_Ptr++ = '+';
			++_First;
			}
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			{	// gather minus sign
			*_Ptr++ = '-';
			++_First;
			}

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	// seen a digit in input
		int _Significant = 0;	// number of significant digits
		int _Phex = 0;	// power of 10 multiplier

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				|| *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	// discard any 0x or 0X
		else
			_Seendigit = true;	// '0' not followed by 'x' or 'X'

		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == CHAR_MAX || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, (void)++_First)
				if (_Max_sig_dig <= _Significant)
					++_Phex;	// just scale by 10
				else if (_Idx == 0 && _Significant == 0)
					;	// drop leading zeros
				else
					{	// save a significant digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	// grouping specified, gather digits and group sizes
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	// got a digit, add to group size
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						++_Phex;	// just scale by 10
					else if (_Idx == 0 && _Significant == 0)
						;	// drop leading zeros
					else
						{	// save a significant digit
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != CHAR_MAX)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	// not a group separator, done
				else
					{	// add a new group to _Groups string
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	// no thousands separators seen
			else if ('\0' < _Groups[_Group])
				++_Group;	// add trailing group to group count
			else
				_Bad = true;	// trailing separator, fail

			while (!_Bad && 0 < _Group)
				if (*_Pg == CHAR_MAX)
					break;	// end of grouping constraints to check
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	// bad group size, fail
				else if ('\0' < _Pg[1])
					++_Pg;	// group size okay, advance to next test
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	// save at least one leading digit

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			{	// add .
			*_Ptr++ = localeconv()->decimal_point[0];
			++_First;
			}

		if (_Significant == 0)
			{	// 0000. so far
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, (void)++_First)
				--_Phex;	// just count leading fraction zeros
			if (_Phex < 0)
				{	// put one back
				*_Ptr++ = '0';
				++_Phex;
				}
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, (void)++_First)
			if (_Significant < _Max_sig_dig)
				{	// save a significant fraction digit
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	// 'p' or 'P', collect exponent
			*_Ptr++ = 'p';
			++_First;
			_Seendigit = false;
			_Significant = 0;

			if (_First == _Last)
				;	// 'p' or 'P' is last element
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				{	// gather plus sign
				*_Ptr++ = '+';
				++_First;
				}
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				{	// gather minus sign
				*_Ptr++ = '-';
				++_First;
				}

			for (; _First != _Last && *_First == _Atoms[0]; ++_First)
				{	// strip leading zeros
				_Seendigit = true;
				}

			if (_Seendigit)
				*_Ptr++ = '0';	// put one back
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, (void)++_First)
				if (_Significant < _MAX_EXP_DIG)
					{	// save a significant exponent digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	// roll back pointer to indicate failure
		*_Ptr = '\0';
		*_Phexexp = _Phex;	// power of 16 multiplier
		return (0);	// power of 10 multiplier
		}

#undef _ENABLE_V2_BEHAVIOR

	};

		// STATIC num_get::id OBJECT
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif /* __clang__ */
# 1227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

template<class _Elem,
	class _InIt>
	__PURE_APPDOMAIN_GLOBAL locale::id num_get<_Elem, _InIt>::id;

#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 1235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

		// CLASS TEMPLATE num_put
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	// facet for converting encoded numbers to text
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (_X_NUMERIC);
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id

protected:
	virtual __CLR_OR_THIS_CALL ~num_put() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

public:
	explicit __CLR_OR_THIS_CALL num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	// put formatted bool to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	// put formatted long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	// put formatted unsigned long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	// put formatted long long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	// put formatted unsigned long long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	// put formatted double to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	// put formatted long double to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	// put formatted void pointer to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	// put formatted bool to _Dest
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	// put "false" or "true"
			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	// put leading fill
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
			}
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	// put formatted long to _Dest
		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	// put formatted unsigned long to _Dest
		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	// put formatted long long to _Dest
		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	// put formatted unsigned long long to _Dest
		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	// put formatted double to _Dest
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	// desired precision
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < _CSTD fabs(_Val))
			{	// f or F format
			int _Ptwo;
			(void)_CSTD frexp(_Val, &_Ptwo);
			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	// add fudge factor

		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	// put formatted long double to _Dest
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	// desired precision
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))
			{	// f or F format
			int _Ptwo;
			(void)_CSTD frexpl(_Val, &_Ptwo);
			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	// add fudge factor

		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	// put formatted void pointer to _Dest
		char _Buf[2 * _MAX_INT_DIG];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__CLRCALL_OR_CDECL _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	// generate sprintf format for floating-point
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	// for precision argument
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __CLRCALL_OR_CDECL _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Count) const
		{	// put formatted floating-point to _Dest
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	// correct for hexadecimal floating-point
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent
		char _Dp[2] = {"."};
		_Dp[0] = _CSTD localeconv()->decimal_point[0];
		const size_t _Poff =
			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

		const ctype<_Elem>& _Ctype_fac =
			_USE(_Iosbase.getloc(), ctype<_Elem>);
		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		if (_Poff != _Count)
			_Groupstring[_Poff] = _Punct_fac.decimal_point();

		size_t _Off = _Poff == _Count ? _Eoff : _Poff;
		const char *_Pg = &_Grouping[0];
		while (*_Pg != CHAR_MAX && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	// add thousands separator
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	// not last group, advance
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	// put leading fill
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	// put internal fill
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
		}

	char *__CLRCALL_OR_CDECL _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	// generate sprintf format for integer
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	// qualifier
		else

			{	/* change L to I64 */
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __CLRCALL_OR_CDECL _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	// put formatted integer to _Dest
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			_USE(_Iosbase.getloc(), ctype<_Elem>);
		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != CHAR_MAX && '\0' < *_Pg)
			{	// grouping specified, add thousands separators
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != CHAR_MAX && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	// insert thousands separator
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	// not last group, advance
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	// put leading fill
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	// put internal fill
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
		}

	_OutIt __CLRCALL_OR_CDECL _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	// put [_Ptr, _Ptr + _Count) to _Dest
		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	// put _Count * _Ch to _Dest
		for (; 0 < _Count; --_Count, (void)++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		// STATIC num_put::id OBJECT
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif /* __clang__ */
# 1673 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

template<class _Elem,
	class _OutIt>
	__PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template __PURE_APPDOMAIN_GLOBAL locale::id numpunct<char>::id;
template class _CRTIMP2_PURE_IMPORT num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class _CRTIMP2_PURE_IMPORT num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template __PURE_APPDOMAIN_GLOBAL locale::id numpunct<wchar_t>::id;
template class _CRTIMP2_PURE_IMPORT num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class _CRTIMP2_PURE_IMPORT num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 1693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

  #ifdef __FORCE_INSTANCE
template __PURE_APPDOMAIN_GLOBAL locale::id numpunct<unsigned short>::id;
template class _CRTIMP2_PURE_IMPORT num_get<unsigned short,
	istreambuf_iterator<unsigned short, char_traits<unsigned short> > >;
template class _CRTIMP2_PURE_IMPORT num_put<unsigned short,
	ostreambuf_iterator<unsigned short, char_traits<unsigned short> > >;
  #endif /* __FORCE_INSTANCE */
# 1701 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
 #endif /* defined(_DLL_CPPLIB) */
# 1702 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 1706 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1711 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3
#endif /* _XLOCNUM_ */
# 1712 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xlocnum" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// CLASS TEMPLATE basic_ios
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	// base class for basic_istream/basic_ostream
public:
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit __CLR_OR_THIS_CALL basic_ios(_Mysb *_Strbuf)
		{	// construct from stream buffer pointer
		init(_Strbuf);
		}

	virtual __CLR_OR_THIS_CALL ~basic_ios() _NOEXCEPT
		{	// destroy the object
		}

	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	// set state, possibly reraise exception
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void __CLR_OR_THIS_CALL clear(io_state _State)
		{	// set state to _State
		clear((iostate)_State);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3

	void __CLR_OR_THIS_CALL setstate(iostate _State,
		bool _Reraise = false)
		{	// merge _State into state, possibly reraise exception
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

 #if _HAS_OLD_IOSTREAMS_MEMBERS
	void __CLR_OR_THIS_CALL setstate(io_state _State)
		{	// merge _State into state
		setstate((iostate)_State);
		}
 #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
# 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3

	basic_ios& __CLR_OR_THIS_CALL copyfmt(const basic_ios& _Right)
		{	// copy format parameters
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos *__CLR_OR_THIS_CALL tie() const
		{	// return tie pointer
		return (_Tiestr);
		}

	_Myos *__CLR_OR_THIS_CALL tie(_Myos *_Newtie)
		{	// set tie pointer
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_NODISCARD _Mysb *__CLR_OR_THIS_CALL rdbuf() const
		{	// return stream buffer pointer
		return (_Mystrbuf);
		}

	_Mysb *__CLR_OR_THIS_CALL rdbuf(_Mysb *_Strbuf)
		{	// set stream buffer pointer
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale __CLR_OR_THIS_CALL imbue(const locale& _Loc)
		{	// set locale to argument
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem __CLR_OR_THIS_CALL fill() const
		{	// return fill character
		return (_Fillch);
		}

	_Elem __CLR_OR_THIS_CALL fill(_Elem _Newfill)
		{	// set fill character
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// convert _Ch to byte using imbued locale
		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// convert _Byte to character using imbued locale
		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);
		return (_Ctype_fac.widen(_Byte));
		}

	void __CLR_OR_THIS_CALL move(basic_ios& _Right)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, do the move
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void __CLR_OR_THIS_CALL move(basic_ios&& _Right)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, do the move
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void __CLR_OR_THIS_CALL swap(basic_ios& _Right) _NOEXCEPT
		{	// swap all but rdbuf() with right
		ios_base::swap(_Right);
		_STD swap(_Fillch, _Right._Fillch);
		_STD swap(_Tiestr, _Right._Tiestr);
		}

	void __CLR_OR_THIS_CALL set_rdbuf(_Mysb *_Strbuf)
		{	// set stream buffer pointer without changing state
		_Mystrbuf = _Strbuf;
		}

protected:
	void __CLR_OR_THIS_CALL init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	// initialize with stream buffer pointer
		_Init();	// initialize ios_base
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	// special handling for standard streams
		}

	__CLR_OR_THIS_CALL basic_ios()
		{	// default constructor, do nothing
		}

private:
	_Mysb *_Mystrbuf;	// pointer to stream buffer
	_Myos *_Tiestr;	// pointer to tied output stream
	_Elem _Fillch;	// the fill character

public:
	__CLR_OR_THIS_CALL basic_ios(const basic_ios&) = delete;
	basic_ios& __CLR_OR_THIS_CALL operator=(const basic_ios&) = delete;
	};

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_ios<char,
	char_traits<char> >;
template class _CRTIMP2_PURE_IMPORT basic_ios<wchar_t,
	char_traits<wchar_t> >;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_ios<unsigned short,
	char_traits<unsigned short> >;
  #endif /* __FORCE_INSTANCE */
# 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3
 #endif /* defined(_DLL_CPPLIB) */
# 209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3

		// MANIPULATORS
inline ios_base& __CLRCALL_OR_CDECL boolalpha(ios_base& _Iosbase)
	{	// set boolalpha
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL dec(ios_base& _Iosbase)
	{	// set basefield to dec
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL defaultfloat(ios_base& _Iosbase)
	{	// clear floatfield
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL fixed(ios_base& _Iosbase)
	{	// set floatfield to fixed
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL hex(ios_base& _Iosbase)
	{	// set basefield to hex
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL hexfloat(ios_base& _Iosbase)
	{	// set floatfield to hexfloat
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL internal(ios_base& _Iosbase)
	{	// set adjustfield to internal
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL left(ios_base& _Iosbase)
	{	// set adjustfield to left
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL noboolalpha(ios_base& _Iosbase)
	{	// clear boolalpha
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL noshowbase(ios_base& _Iosbase)
	{	// clear showbase
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL noshowpoint(ios_base& _Iosbase)
	{	// clear showpoint
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL noshowpos(ios_base& _Iosbase)
	{	// clear showpos
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL noskipws(ios_base& _Iosbase)
	{	// clear skipws
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL nounitbuf(ios_base& _Iosbase)
	{	// clear unitbuf
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL nouppercase(ios_base& _Iosbase)
	{	// clear uppercase
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL oct(ios_base& _Iosbase)
	{	// set oct in basefield
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL right(ios_base& _Iosbase)
	{	// set right in adjustfield
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL scientific(ios_base& _Iosbase)
	{	// set scientific in floatfield
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL showbase(ios_base& _Iosbase)
	{	// set showbase
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL showpoint(ios_base& _Iosbase)
	{	// set showpoint
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL showpos(ios_base& _Iosbase)
	{	// set showpos
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL skipws(ios_base& _Iosbase)
	{	// set skipws
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL unitbuf(ios_base& _Iosbase)
	{	// set unitbuf
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __CLRCALL_OR_CDECL uppercase(ios_base& _Iosbase)
	{	// set uppercase
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _STD hexfloat;
}
#endif /* _HAS_TR1_NAMESPACE */
# 360 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3
#endif /* _IOS_ */
# 368 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ios" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// I/O EXCEPTION MACROS

 #if _HAS_EXCEPTIONS
 #define _TRY_IO_BEGIN	_TRY_BEGIN	/* begin try block */

 #define _CATCH_IO_END	_CATCH_ALL	/* catch block for _Myios */ \
	_Myios::setstate(ios_base::badbit, true);	/* set badbit and rethrow */ \
	_CATCH_END

 #define _CATCH_IO_(x)	_CATCH_ALL	/* catch block for basic_ios x */ \
	(x).setstate(ios_base::badbit, true);	/* set badbit and rethrow */ \
	_CATCH_END

 #else /* _HAS_EXCEPTIONS */
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
 #define _TRY_IO_BEGIN	{	/* begin try block */
 #define _CATCH_IO_END	}	/* catch block for _Myios */
 #define _CATCH_IO_(x)	}	/* catch block for basic_ios x */
 #endif /* _HAS_EXCEPTIONS */
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3

 #pragma vtordisp(push, 2)	// compiler bug workaround

		// CLASS TEMPLATE basic_ostream
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	// control insertions into a stream buffer
public:
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit __CLR_OR_THIS_CALL basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	// construct from a stream buffer pointer
		_Myios::init(_Strbuf, _Isstd);
		}

	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)
		{	// construct uninitialized
		if (_Addit)
			this->_Addstd(this);	// suppress for basic_iostream
		}

protected:
	__CLR_OR_THIS_CALL basic_ostream(basic_ostream&& _Right)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(_STD move(_Right));
		}

	basic_ostream& __CLR_OR_THIS_CALL operator=(basic_ostream&& _Right)
		{	// move from _Right
		this->swap(_Right);
		return (*this);
		}

	void __CLR_OR_THIS_CALL swap(basic_ostream& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			_Myios::swap(_Right);
		}

public:
	__CLR_OR_THIS_CALL basic_ostream(const basic_ostream&) = delete;
	basic_ostream& __CLR_OR_THIS_CALL operator=(const basic_ostream&) = delete;

	virtual __CLR_OR_THIS_CALL ~basic_ostream() _NOEXCEPT
		{	// destroy the object
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	// stores thread lock and reference to output stream
	public:
		__CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr)
			: _Myostr(_Ostr)
			{	// lock the stream buffer, if there
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
			{	// destroy after unlocking
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		basic_ostream& _Myostr;	// the output stream, for _Unlock call at destruction

		_Sentry_base& operator=(const _Sentry_base&) = delete;
		};

	class sentry
		: public _Sentry_base
		{	// stores thread lock and state of stream
	public:
		explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)
			: _Sentry_base(_Ostr)
			{	// construct locking and testing stream
			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	// store test only after flushing tie
			}

		__CLR_OR_THIS_CALL ~sentry() _NOEXCEPT
			{	// destroy the object
 #if _HAS_EXCEPTIONS
			if (_STD uncaught_exceptions() == 0)
				{
				this->_Myostr._Osfx();
				}
 #else /* _HAS_EXCEPTIONS */
# 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
			this->_Myostr._Osfx();
 #endif /* _HAS_EXCEPTIONS */
# 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
			}

		explicit __CLR_OR_THIS_CALL operator bool() const
			{	// test if stream state okay
			return (_Ok);
			}

		__CLR_OR_THIS_CALL sentry(const sentry&) = delete;
		sentry& __CLR_OR_THIS_CALL operator=(const sentry&) = delete;

	private:
		bool _Ok;	// true if stream state okay at construction
		};

	bool __CLR_OR_THIS_CALL opfx()
		{	// test stream state and flush tie stream as needed (retained)
		if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void __CLR_OR_THIS_CALL osfx()
		{	// perform any wrapup (retained)
		_Osfx();
		}

	void __CLR_OR_THIS_CALL _Osfx()
		{	// perform any wrapup
		_TRY_BEGIN
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed
				_Myios::setstate(ios_base::badbit);
		_CATCH_ALL
		_CATCH_END
		}

  #ifdef _M_CEE_PURE
	basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream& (__clrcall *_Pfn)(basic_ostream&))
		{	// call basic_ostream manipulator
		return ((*_Pfn)(*this));
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(_Myios& (__clrcall *_Pfn)(_Myios&))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(ios_base& (__clrcall *_Pfn)(ios_base&))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}
  #endif /* _M_CEE_PURE */
# 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3

	basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream& (__cdecl *_Pfn)(basic_ostream&))
		{	// call basic_ostream manipulator
		return ((*_Pfn)(*this));
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(bool _Val)
		{	// insert a boolean
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(short _Val)
		{	// insert a short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

/* NOTE:
	If you are not using native wchar_t, the unsigned short inserter
	is masked by an explicit specialization that treats an unsigned
	short as a wide character.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */

	basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned short _Val)
		{	// insert an unsigned short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(int _Val)
		{	// insert an int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned int _Val)
		{	// insert an unsigned int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(long _Val)
		{	// insert a long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned long _Val)
		{	// insert an unsigned long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(long long _Val)
		{	// insert a long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned long long _Val)
		{	// insert an unsigned long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(float _Val)
		{	// insert a float
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(double _Val)
		{	// insert a double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(long double _Val)
		{	// insert a long double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(const void *_Val)
		{	// insert a void pointer
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL operator<<(_Mysb *_Strbuf)
		{	// insert until end-of-file from a stream buffer
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	// extract another character from stream buffer
				_TRY_BEGIN
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				_CATCH_ALL
					_Myios::setstate(ios_base::failbit);
					_RERAISE;
				_CATCH_END

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	// end of file, quit

				_TRY_IO_BEGIN
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	// insertion failed, quit
						_State |= ios_base::badbit;
						break;
						}
				_CATCH_IO_END
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL put(_Elem _Ch)
		{	// insert a character
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	// state okay, insert character
			_TRY_IO_BEGIN
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL write(const _Elem *_Str,
		streamsize _Count)
		{	// insert _Count characters from array _Str
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 < _Count)
			{	// state okay, insert characters
			_TRY_IO_BEGIN
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL flush()
		{	// flush output stream
		if (_Myios::rdbuf() != 0)
			{	// buffer exists, flush it
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	// sync failed
			}
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL seekp(pos_type _Pos)
		{	// set output stream position to _Pos
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	basic_ostream& __CLR_OR_THIS_CALL seekp(off_type _Off, ios_base::seekdir _Way)
		{	// change output stream position by _Off, according to _Way
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type __CLR_OR_THIS_CALL tellp()
		{	// return output stream position
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

 #pragma vtordisp(pop)	// compiler bug workaround

  #ifndef _NATIVE_WCHAR_T_DEFINED
/* NOTE:
	If you are not using native wchar_t, the following explicit
	specialization will mask the member function (above) that treats
	an unsigned short as an integer.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */
template<> inline
	basic_ostream<unsigned short, char_traits<unsigned short> >&
		__CLR_OR_THIS_CALL basic_ostream<unsigned short,
			char_traits<unsigned short> >::operator<<(unsigned short _Ch)
	{	// extract a character
	typedef char_traits<unsigned short> _Traits;

	ios_base::iostate _State = ios_base::goodbit;
	const sentry _Ok(*this);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = this->width() <= 1 ? 0 : this->width() - 1;

		_TRY_IO_BEGIN
		if ((this->flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					this->rdbuf()->sputc(this->fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				this->rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				this->rdbuf()->sputc(this->fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_END
		}

	this->width(0);
	_Myios::setstate(_State);
	return (*this);
	}
  #endif /* _NATIVE_WCHAR_T_DEFINED */
# 661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_ostream<char,
	char_traits<char> >;
template class _CRTIMP2_PURE_IMPORT basic_ostream<wchar_t,
	char_traits<wchar_t> >;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 670 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_ostream<unsigned short,
	char_traits<unsigned short> >;
  #endif /* __FORCE_INSTANCE */
# 675 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
 #endif /* defined(_DLL_CPPLIB) */
# 676 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3

		// INSERTERS

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	// insert NTBS
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_CSTD strlen(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert characters
		_TRY_IO_BEGIN
		const ctype<_Elem>& _Ctype_fac = _USE(_Ostr.getloc(), ctype<_Elem>);
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		_CATCH_IO_(_Ostr)
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	// insert a character
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		const ctype<_Elem>& _Ctype_fac = _USE(_Ostr.getloc(), ctype<_Elem>);
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		_TRY_IO_BEGIN
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_(_Ostr)
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	// insert NTBS into char stream
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert
		_TRY_IO_BEGIN
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		_CATCH_IO_(_Ostr)
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	// insert a char into char stream
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		_TRY_IO_BEGIN
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_(_Ostr)
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	// insert NTCS
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert
		_TRY_IO_BEGIN
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		_CATCH_IO_(_Ostr)
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	// insert a character
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		_TRY_IO_BEGIN
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_(_Ostr)
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	// insert a signed char NTBS
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	// insert a signed char
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	// insert an unsigned char NTBS
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	// insert an unsigned char
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	// insert to rvalue stream
	return (_Ostr << _Val);
	}

		// MANIPULATORS
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__CLRCALL_OR_CDECL endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	// insert newline and flush stream
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__CLRCALL_OR_CDECL ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	// insert null character
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__CLRCALL_OR_CDECL flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	// flush stream
	_Ostr.flush();
	return (_Ostr);
	}

		// INSERTER FOR error_category
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	// display error code
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1019 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3
#endif /* _OSTREAM_ */
# 1020 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\ostream" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
 #pragma vtordisp(push, 2)	// compiler bug workaround

		// CLASS TEMPLATE basic_istream
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	// control extractions from a stream buffer
public:
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  #if defined(__FORCE_INSTANCE)
	explicit __CLR_OR_THIS_CALL basic_istream(_Mysb *_Strbuf,
		bool _Isstd, bool _Noinit)
		: _Chcount(0)
		{	// construct from stream buffer pointer
		if (!_Noinit)
			_Myios::init(_Strbuf, _Isstd);
		}
  #endif /* defined(__FORCE_INSTANCE) */
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

	explicit __CLR_OR_THIS_CALL basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	// construct from stream buffer pointer
		_Myios::init(_Strbuf, _Isstd);
		}

	__CLR_OR_THIS_CALL basic_istream(_Uninitialized)
		{	// construct uninitialized
		this->_Addstd(this);
		}

protected:
	__CLR_OR_THIS_CALL basic_istream(basic_istream&& _Right)
		: _Chcount(_Right._Chcount)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(_STD move(_Right));
		_Right._Chcount = 0;
		}

	basic_istream& __CLR_OR_THIS_CALL operator=(basic_istream&& _Right)
		{	// move from _Right
		this->swap(_Right);
		return (*this);
		}

	void __CLR_OR_THIS_CALL swap(basic_istream& _Right)
		{	// swap with _Right
		_Myios::swap(_Right);
		_STD swap(_Chcount, _Right._Chcount);
		}

public:
	__CLR_OR_THIS_CALL basic_istream(const basic_istream&) = delete;
	basic_istream& __CLR_OR_THIS_CALL operator=(const basic_istream&) = delete;

	virtual __CLR_OR_THIS_CALL ~basic_istream() _NOEXCEPT
		{	// destroy the object
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		// CLASS TEMPLATE sentry
	class _Sentry_base
		{	// stores thread lock and reference to input stream
	public:
		__CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr)
			: _Myistr(_Istr)
			{	// lock the stream buffer, if there
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
			{	// destroy after unlocking
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		basic_istream& _Myistr;	// the input stream, for _Unlock call at destruction

		_Sentry_base& operator=(const _Sentry_base&) = delete;
		};

	class sentry
		: public _Sentry_base
		{	// stores thread lock and result of _Ipfx call
	public:
		explicit __CLR_OR_THIS_CALL sentry(basic_istream& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	// construct locking and calling _Ipfx
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit __CLR_OR_THIS_CALL operator bool() const
			{	// test if _Ipfx succeeded
			return (_Ok);
			}

		__CLR_OR_THIS_CALL sentry(const sentry&) = delete;
		sentry& __CLR_OR_THIS_CALL operator=(const sentry&) = delete;

	private:
		bool _Ok;	// true if _Ipfx succeeded at construction
		};

	bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false)
		{	// test stream state and skip whitespace as needed
		if (this->good())
			{	// state okay, flush tied stream and skip whitespace
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	// skip whitespace
				const _Ctype& _Ctype_fac = _USE(this->getloc(), _Ctype);

				_TRY_IO_BEGIN
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	// end of file, quit
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	// not whitespace, quit
				_CATCH_IO_END
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool __CLR_OR_THIS_CALL ipfx(bool _Noskip = false)
		{	// test stream state and skip whitespace as needed (retained)
		return (_Ipfx(_Noskip));
		}

	void __CLR_OR_THIS_CALL isfx()
		{	// perform any wrapup (retained)
		}

  #ifdef _M_CEE_PURE
	basic_istream& __CLR_OR_THIS_CALL operator>>(basic_istream& (__clrcall *_Pfn)(basic_istream&))
		{	// call basic_istream manipulator
		return ((*_Pfn)(*this));
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(_Myios& (__clrcall *_Pfn)(_Myios&))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(ios_base& (__clrcall *_Pfn)(ios_base&))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}
  #endif /* _M_CEE_PURE */
# 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

	basic_istream& __CLR_OR_THIS_CALL operator>>(basic_istream& (__cdecl *_Pfn)(basic_istream&))
		{	// call basic_istream manipulator
		return ((*_Pfn)(*this));
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(bool& _Val)
		{	// extract a boolean
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(short& _Val)
		{	// extract a short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			long _Tmp = 0;
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			_CATCH_IO_END

			if (_State & ios_base::failbit
				|| _Tmp < SHRT_MIN || SHRT_MAX < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

/* NOTE:
	If you are not using native wchar_t, the unsigned short extractor
	is masked by an explicit specialization that treats an unsigned
	short as a wide character.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */

	basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned short& _Val)
		{	// extract an unsigned short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(int& _Val)
		{	// extract an int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			long _Tmp = 0;
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			_CATCH_IO_END

			if (_State & ios_base::failbit
				|| _Tmp < INT_MIN || INT_MAX < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned int& _Val)
		{	// extract an unsigned int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(long& _Val)
		{	// extract a long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);
			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned long& _Val)
		{	// extract an unsigned long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(long long& _Val)
		{	// extract a long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned long long& _Val)
		{	// extract an unsigned long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(float& _Val)
		{	// extract a float
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(double& _Val)
		{	// extract a double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(long double& _Val)
		{	// extract a long double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);
			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(void *& _Val)
		{	// extract a void pointer
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

			_TRY_IO_BEGIN
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL operator>>(_Mysb *_Strbuf)
		{	// extract until end-of-file into a stream buffer
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	// state okay, extract characters
			_TRY_IO_BEGIN
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	// got a character, insert it into buffer
					_TRY_BEGIN
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					_CATCH_ALL
						break;
					_CATCH_END
					_Copied = true;
					}
			_CATCH_IO_END
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type __CLR_OR_THIS_CALL get()
		{	// extract a metacharacter
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	// state not okay, return EOF
		else
			{	// state okay, extract a character
			_TRY_IO_BEGIN
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	// end of file
			else
				{	// got a character, count it
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	basic_istream& __CLR_OR_THIS_CALL get(_Elem *_Str, streamsize _Count)
		{	// get up to _Count characters into NTCS
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	basic_istream& __CLR_OR_THIS_CALL get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	// get up to _Count characters into NTCS, stop before _Delim
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, extract characters
			_TRY_IO_BEGIN
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	// got a delimiter, quit
				else
					{	// got a character, add it to string
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			_CATCH_IO_END
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	// add terminating null character
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL get(_Elem& _Ch)
		{	// get a character
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL get(_Mysb& _Strbuf)
		{	// extract up to newline and insert into stream buffer
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	basic_istream& __CLR_OR_THIS_CALL get(_Mysb& _Strbuf, _Elem _Delim)
		{	// extract up to delimiter and insert into stream buffer
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	// state okay, use facet to extract
			_TRY_IO_BEGIN
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	// got a character, insert it into stream buffer
					_TRY_BEGIN
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					_CATCH_ALL
						break;
					_CATCH_END
					++_Chcount;
					}
			_CATCH_IO_END
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL getline(_Elem *_Str, streamsize _Count)
		{	// get up to _Count characters into NTCS, discard newline
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	basic_istream& __CLR_OR_THIS_CALL getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	// get up to _Count characters into NTCS, discard _Delim
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, use facet to extract
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			_TRY_IO_BEGIN
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	// got a delimiter, discard it and quit
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	// buffer full, quit
					_State |= ios_base::failbit;
					break;
					}
				else
					{	// got a character, add it to string
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			_CATCH_IO_END
			}

		*_Str = _Elem();	// add terminating null character
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	// ignore up to _Count characters, discarding delimiter
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, use facet to extract
			_TRY_IO_BEGIN
			for (;;)
				{	// get a metacharacter if more room in buffer
				int_type _Meta;
				if (_Count != (numeric_limits<streamsize>::max)()
					&& --_Count < 0)
					break;	// buffer full, quit
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	// got a character, count it
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	// got a delimiter, quit
					}
				}
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL read(_Elem *_Str, streamsize _Count)
		{	// read up to _Count characters into buffer
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, use facet to extract
			_TRY_IO_BEGIN
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	// short read
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize __CLR_OR_THIS_CALL readsome(_Elem *_Str,
		streamsize _Count)
		{	// read up to _Count characters into buffer, without blocking
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	// no buffer, fail
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	// no characters available
		else if (0 < _Count && 0 < _Num)
			{	// read available
			read(_Str, _Num < _Count ? _Num : _Count);
			}

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type __CLR_OR_THIS_CALL peek()
		{	// return next character, unconsumed
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	// state not okay, return EOF
		else
			{	// state okay, read a character
			_TRY_IO_BEGIN
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	basic_istream& __CLR_OR_THIS_CALL putback(_Elem _Ch)
		{	// put back a character
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	// state okay, put character back
			_TRY_IO_BEGIN
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL unget()
		{	// put back last read character
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	// state okay, put character back
			_TRY_IO_BEGIN
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_NODISCARD streamsize __CLR_OR_THIS_CALL gcount() const
		{	// get count from last extraction
		return (_Chcount);
		}

	int __CLR_OR_THIS_CALL sync()
		{	// synchronize with input source
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	// sync failed
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	basic_istream& __CLR_OR_THIS_CALL seekg(pos_type _Pos)
		{	// set input stream position to _Pos
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	basic_istream& __CLR_OR_THIS_CALL seekg(off_type _Off, ios_base::seekdir _Way)
		{	// change input stream position by _Off, according to _Way
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type __CLR_OR_THIS_CALL tellg()
		{	// return input stream position
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	// the character count
	};

 #pragma vtordisp(pop)	// compiler bug workaround

  #ifndef _NATIVE_WCHAR_T_DEFINED
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch);

/* NOTE:
	If you are not using native wchar_t, the following explicit
	specialization will mask the member function (above) that treats
	an unsigned short as an integer.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */
template<> inline
	basic_istream<unsigned short, char_traits<unsigned short> >&
		__CLR_OR_THIS_CALL basic_istream<unsigned short,
			char_traits<unsigned short> >::operator>>(unsigned short& _Ch)
	{	// extract a character
	return (_STD operator>>(*this, _Ch));
	}
  #endif /* _NATIVE_WCHAR_T_DEFINED */
# 904 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_istream<char, char_traits<char> >;
template class _CRTIMP2_PURE_IMPORT basic_istream<wchar_t, char_traits<wchar_t> >;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_istream<unsigned short,
	char_traits<unsigned short> >;
  #endif /* __FORCE_INSTANCE */
# 916 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3
 #endif /* defined(_DLL_CPPLIB) */
# 917 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

		// CLASS TEMPLATE basic_iostream
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	// control insertions and extractions from a stream buffer
public:
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit __CLR_OR_THIS_CALL basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	// construct from stream buffer pointer
		}

protected:
	__CLR_OR_THIS_CALL basic_iostream(basic_iostream&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(_STD move(_Right));
		}

	basic_iostream& __CLR_OR_THIS_CALL operator=(basic_iostream&& _Right)
		{	// move from _Right
		this->swap(_Right);
		return (*this);
		}

	void __CLR_OR_THIS_CALL swap(basic_iostream& _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			_Myios::swap(_Right);
		}

public:
	__CLR_OR_THIS_CALL basic_iostream(const basic_iostream&) = delete;
	basic_iostream& __CLR_OR_THIS_CALL operator=(const basic_iostream&) = delete;

	virtual __CLR_OR_THIS_CALL ~basic_iostream() _NOEXCEPT
		{	// destroy the object
		}
	};

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_iostream<char, char_traits<char> >;
template class _CRTIMP2_PURE_IMPORT basic_iostream<wchar_t, char_traits<wchar_t> >;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */
# 977 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_iostream<unsigned short,
	char_traits<unsigned short> >;
  #endif /* __FORCE_INSTANCE */
# 982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3
 #endif /* defined(_DLL_CPPLIB) */
# 983 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

		// EXTRACTORS

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	// extract NTBS
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	// state okay, extract characters
		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

		_TRY_IO_BEGIN
		streamsize _Count = 0 < _Istr.width() ? _Istr.width()
			: (numeric_limits<streamsize>::max)();
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	// whitespace or nul, quit
			else
				*_Str++ = _Traits::to_char_type(_Meta);	// add it to string
		_CATCH_IO_(_Istr)
		}

	*_Str = _Elem();	// add terminating null character
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	// extract a character
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	// state okay, extract characters
		_TRY_IO_BEGIN
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	// end of file
		else
			_Ch = _Traits::to_char_type(_Meta);	// got a character
		_CATCH_IO_(_Istr)
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	// extract a signed char NTBS
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	// extract a signed char
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	// extract an unsigned char NTBS
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	// extract an unsigned char
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty&& _Val)
	{	// extract from rvalue stream
	_Istr >> _STD forward<_Ty>(_Val);
	return (_Istr);
	}

		// MANIPULATORS
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__CLRCALL_OR_CDECL ws(basic_istream<_Elem, _Traits>& _Istr)
	{	// consume whitespace
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	// not at eof, okay to construct sentry and skip
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	// state okay, extract characters
			const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

			_TRY_IO_BEGIN
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	// not whitespace, quit
			_CATCH_IO_(_Istr)
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3
#endif /* _ISTREAM_ */
# 1134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\istream" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <xutility>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

_STD_BEGIN
		// CLASS TEMPLATE front_insert_iterator
template<class _Container>
	class front_insert_iterator
	{	// wrap pushes to front of container as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using container_type = _Container;

	explicit front_insert_iterator(_Container& _Cont)
		: container(_STD addressof(_Cont))
		{	// construct with container
		}

	front_insert_iterator& operator=(const typename _Container::value_type& _Val)
		{	// push value into container
		container->push_front(_Val);
		return (*this);
		}

	front_insert_iterator& operator=(typename _Container::value_type&& _Val)
		{	// push value into container
		container->push_front(_STD move(_Val));
		return (*this);
		}

	_NODISCARD front_insert_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	front_insert_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	front_insert_iterator operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

protected:
	_Container * container;	// pointer to container
	};

template<class _Container>
	struct _Is_checked_helper<front_insert_iterator<_Container> >
		: public true_type
	{	// mark front_insert_iterator as checked
	};


		// FUNCTION TEMPLATE front_inserter
template<class _Container>
	_NODISCARD inline front_insert_iterator<_Container> front_inserter(_Container& _Cont)
	{	// return front_insert_iterator
	return (front_insert_iterator<_Container>(_Cont));
	}


		// CLASS TEMPLATE insert_iterator
template<class _Container>
	class insert_iterator
	{	// wrap inserts into container as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using container_type = _Container;

	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
		: container(_STD addressof(_Cont)), iter(_Where)
		{	// construct with container and iterator
		}

	insert_iterator& operator=(const typename _Container::value_type& _Val)
		{	// insert into container and increment stored iterator
		iter = container->insert(iter, _Val);
		++iter;
		return (*this);
		}

	insert_iterator& operator=(typename _Container::value_type&& _Val)
		{	// push value into container
		iter = container->insert(iter, _STD move(_Val));
		++iter;
		return (*this);
		}

	_NODISCARD insert_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	insert_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	insert_iterator& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

protected:
	_Container * container;	// pointer to container
	typename _Container::iterator iter;	// iterator into container
	};

template<class _Container>
	struct _Is_checked_helper<insert_iterator<_Container> >
		: public true_type
	{	// mark insert_iterator as checked
	};


		// FUNCTION TEMPLATE inserter
template<class _Container>
	_NODISCARD inline insert_iterator<_Container> inserter(_Container& _Cont,
		typename _Container::iterator _Where)
	{	// return insert_iterator
	return (insert_iterator<_Container>(_Cont, _Where));
	}


		// CLASS TEMPLATE istream_iterator
template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem>,
	class _Diff = ptrdiff_t>
	class istream_iterator
	{	// wrap _Ty extracts from input stream as input iterator
public:
	using iterator_category = input_iterator_tag;
	using value_type = _Ty;
	using difference_type = _Diff;
	using pointer = const _Ty *;
	using reference = const _Ty&;

	using char_type = _Elem;
	using traits_type = _Traits;
	using istream_type = basic_istream<_Elem, _Traits>;

	constexpr istream_iterator()
		: _Myistr(0), _Myval()
		{	// construct singular iterator
		}

	istream_iterator(istream_type& _Istr)
		: _Myistr(_STD addressof(_Istr))
		{	// construct with input stream
		_Getval();
		}

	_NODISCARD const _Ty& operator*() const
		{	// return designated value
		return (_Myval);
		}

	_NODISCARD const _Ty * operator->() const
		{	// return pointer to class object
		return (_STD addressof(_Myval));
		}

	istream_iterator& operator++()
		{	// preincrement
		_Getval();
		return (*this);
		}

	istream_iterator operator++(int)
		{	// postincrement
		istream_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool _Equal(const istream_iterator& _Right) const
		{	// test for iterator equality
		return (_Myistr == _Right._Myistr);
		}

protected:
	void _Getval()
		{	// get a _Ty value if possible
		if (_Myistr != 0 && !(*_Myistr >> _Myval))
			{
			_Myistr = 0;
			}
		}

	istream_type * _Myistr;	// pointer to input stream
	_Ty _Myval;	// lookahead value (valid if _Myistr is not null)
	};

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff>
	struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
		: public true_type
	{	// mark istream_iterator as checked
	};

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff>
	_NODISCARD inline bool operator==(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	// test for istream_iterator equality
	return (_Left._Equal(_Right));
	}

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff>
	_NODISCARD inline bool operator!=(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	// test for istream_iterator inequality
	return (!(_Left == _Right));
	}


		// CLASS TEMPLATE ostream_iterator
template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem> >
	class ostream_iterator
	{	// wrap _Ty inserts to output stream as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using char_type = _Elem;
	using traits_type = _Traits;
	using ostream_type = basic_ostream<_Elem, _Traits>;

	ostream_iterator(ostream_type& _Ostr, const _Elem * const _Delim = 0)
		: _Mydelim(_Delim), _Myostr(_STD addressof(_Ostr))
		{	// construct from output stream and delimiter
		}

	ostream_iterator& operator=(const _Ty& _Val)
		{	// insert value into output stream, followed by delimiter
		*_Myostr << _Val;
		if (_Mydelim != 0)
			{
			*_Myostr << _Mydelim;
			}

		return (*this);
		}

	_NODISCARD ostream_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	ostream_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	ostream_iterator& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

protected:
	const _Elem * _Mydelim;	// pointer to delimiter string (NB: not freed)
	ostream_type * _Myostr;	// pointer to output stream
	};

template<class _Ty,
	class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
		: public true_type
	{	// mark ostream_iterator as checked
	};
_STD_END

_STDEXT_BEGIN
using _STD iterator_traits;
using _STD size_t;

		// CLASS TEMPLATE checked_array_iterator
template<class _Iterator>
	class checked_array_iterator;

template<class _Iterator>
	checked_array_iterator<_Iterator>& _Rechecked(checked_array_iterator<_Iterator>& _Iter,
		const typename checked_array_iterator<_Iterator>::_Unchecked_type _Right);

template<class _Iterator>
	class checked_array_iterator
	{	// wrap an iterator (actually, a pointer) with checking
public:
	using iterator_category = typename iterator_traits<_Iterator>::iterator_category;
	using value_type = typename iterator_traits<_Iterator>::value_type;
	using difference_type = typename iterator_traits<_Iterator>::difference_type;
	using pointer = typename iterator_traits<_Iterator>::pointer;
	using reference = typename iterator_traits<_Iterator>::reference;

	checked_array_iterator()
		: _Myarray(), _Mysize(0), _Myindex(0)
		{	// default construct
		}

	checked_array_iterator(const _Iterator _Array, const size_t _Size, const size_t _Index = 0)
		: _Myarray(_Array), _Mysize(_Size), _Myindex(_Index)
		{	// construct with array, size, and optional index
		_IDL_VERIFY_ALWAYS(_Index <= _Size, "checked_array_iterator construction index out of range");
		}

	_NODISCARD _Iterator base() const
		{	// return unwrapped iterator
		return (_Myarray + _Myindex);
		}

	typedef _Iterator _Unchecked_type;

	friend checked_array_iterator& _Rechecked<>(checked_array_iterator& _Iter,
		typename checked_array_iterator::_Unchecked_type _Right);

	_NODISCARD reference operator*() const
		{	// return designated object
		_IDL_VERIFY_ALWAYS(_Myarray, "cannot dereference value-initialized or null checked_array_iterator");
		_IDL_VERIFY_ALWAYS(_Myindex < _Mysize, "cannot dereference end checked_array_iterator");
		return (_Myarray[_Myindex]);
		}

	_NODISCARD pointer operator->() const
		{	// return pointer to class object
		_IDL_VERIFY_ALWAYS(_Myarray, "cannot dereference value-initialized or null checked_array_iterator");
		_IDL_VERIFY_ALWAYS(_Myindex < _Mysize, "cannot dereference end checked_array_iterator");
		return (_Myarray + _Myindex);
		}

	checked_array_iterator& operator++()
		{	// preincrement
		_IDL_VERIFY_ALWAYS(_Myarray, "cannot increment value-initialized or null checked_array_iterator");
		_IDL_VERIFY_ALWAYS(_Myindex < _Mysize, "cannot increment checked_array_iterator past end");
		++_Myindex;
		return (*this);
		}

	checked_array_iterator operator++(int)
		{	// postincrement
		checked_array_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	checked_array_iterator& operator--()
		{	// predecrement
		_IDL_VERIFY_ALWAYS(_Myarray, "cannot decrement value-initialized or null checked_array_iterator");
		_IDL_VERIFY_ALWAYS(_Myindex != 0, "cannot decrement checked_array_iterator before begin");
		--_Myindex;
		return (*this);
		}

	checked_array_iterator operator--(int)
		{	// postdecrement
		checked_array_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	checked_array_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		if (_Off != 0)
			{
			_IDL_VERIFY_ALWAYS(_Myarray, "cannot seek value-initialized or null checked_array_iterator");
			}

		if (_Off < 0)
			{
#pragma warning(suppress: 4146)	// unary minus operator applied to unsigned type, result still unsigned
			_IDL_VERIFY_ALWAYS(_Myindex >= -static_cast<size_t>(_Off),
				"cannot seek checked_array_iterator before begin");
			}

		if (_Off > 0)
			{
			_IDL_VERIFY_ALWAYS(_Mysize - _Myindex >= static_cast<size_t>(_Off),
				"cannot seek checked_array_iterator after end")
			}

		_Myindex += _Off;
		return (*this);
		}

	_NODISCARD checked_array_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		checked_array_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	checked_array_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		if (_Off != 0)
			{
			_IDL_VERIFY_ALWAYS(_Myarray, "cannot seek value-initialized or null checked_array_iterator");
			}

		if (_Off > 0)
			{
			_IDL_VERIFY_ALWAYS(_Myindex >= static_cast<size_t>(_Off),
				"cannot seek checked_array_iterator before begin");
			}

		if (_Off < 0)
			{
#pragma warning(suppress: 4146)	// unary minus operator applied to unsigned type, result still unsigned
			_IDL_VERIFY_ALWAYS(_Mysize - _Myindex >= -static_cast<size_t>(_Off),
				"cannot seek checked_array_iterator after end");
			}

		_Myindex -= _Off;
		return (*this);
		}

	_NODISCARD checked_array_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		checked_array_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const checked_array_iterator& _Right) const
		{	// return difference of iterators
		_IDL_VERIFY_ALWAYS(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
			"cannot subtract incompatible checked_array_iterators");
		return (_Myindex - _Right._Myindex);
		}

	_NODISCARD reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD bool operator==(const checked_array_iterator& _Right) const
		{	// test for iterator equality
		_IDL_VERIFY_ALWAYS(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
			"cannot compare incompatible checked_array_iterators for equality");
		return (_Myindex == _Right._Myindex);
		}

	_NODISCARD bool operator!=(const checked_array_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD bool operator<(const checked_array_iterator& _Right) const
		{	// test if this < _Right
		_IDL_VERIFY_ALWAYS(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
			"cannot compare incompatible checked_array_iterators");
		return (_Myindex < _Right._Myindex);
		}

	_NODISCARD bool operator>(const checked_array_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD bool operator<=(const checked_array_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD bool operator>=(const checked_array_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

private:
	_Iterator _Myarray;	// beginning of array
	size_t _Mysize;	// size of array
	size_t _Myindex;	// offset into array
	};

template<class _Iterator>
	_NODISCARD inline checked_array_iterator<_Iterator> operator+(
		const typename checked_array_iterator<_Iterator>::difference_type _Off,
		checked_array_iterator<_Iterator> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator>& _Rechecked(checked_array_iterator<_Iterator>& _Iter,
		const typename checked_array_iterator<_Iterator>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
	_Iter._Myindex = _Right - _Iter._Myarray;
	return (_Iter);
	}

template<class _Iterator> inline
	typename checked_array_iterator<_Iterator>::_Unchecked_type _Unchecked(
		const checked_array_iterator<_Iterator>& _Iter)
	{	// make an unchecked iterator
	return (_Iter.base());
	}

template<class _Iterator>
	_NODISCARD inline checked_array_iterator<_Iterator> make_checked_array_iterator(
		const _Iterator _Array, const size_t _Size, const size_t _Index = 0)
	{	// construct with array, size, and optional index
	return (checked_array_iterator<_Iterator>(_Array, _Size, _Index));
	}

		// CLASS TEMPLATE unchecked_array_iterator
template<class _Iterator>
	class unchecked_array_iterator;

template<class _Iterator>
	unchecked_array_iterator<_Iterator>& _Rechecked(unchecked_array_iterator<_Iterator>& _Iter,
		typename unchecked_array_iterator<_Iterator>::_Unchecked_type _Right);

template<class _Iterator>
	class unchecked_array_iterator
	{	// wrap an iterator (pointer) without checking, to silence warnings
public:
	using iterator_category = typename iterator_traits<_Iterator>::iterator_category;
	using value_type = typename iterator_traits<_Iterator>::value_type;
	using difference_type = typename iterator_traits<_Iterator>::difference_type;
	using pointer = typename iterator_traits<_Iterator>::pointer;
	using reference = typename iterator_traits<_Iterator>::reference;

	unchecked_array_iterator()
		: _Myptr()
		{	// default construct
		}

	explicit unchecked_array_iterator(const _Iterator _Ptr)
		: _Myptr(_Ptr)
		{	// construct with pointer
		}

	_NODISCARD _Iterator base() const
		{	// return unwrapped iterator
		return (_Myptr);
		}

	typedef _Iterator _Unchecked_type;

	friend unchecked_array_iterator& _Rechecked<>(unchecked_array_iterator&,
		typename unchecked_array_iterator::_Unchecked_type);

	_NODISCARD reference operator*() const
		{	// return designated object
		return (*_Myptr);
		}

	_NODISCARD pointer operator->() const
		{	// return pointer to class object
		return (_Myptr);
		}

	unchecked_array_iterator& operator++()
		{	// preincrement
		++_Myptr;
		return (*this);
		}

	unchecked_array_iterator operator++(int)
		{	// postincrement
		unchecked_array_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	unchecked_array_iterator& operator--()
		{	// predecrement
		--_Myptr;
		return (*this);
		}

	unchecked_array_iterator operator--(int)
		{	// postdecrement
		unchecked_array_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	unchecked_array_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		_Myptr += _Off;
		return (*this);
		}

	_NODISCARD unchecked_array_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		unchecked_array_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	unchecked_array_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD unchecked_array_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		unchecked_array_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const unchecked_array_iterator& _Right) const
		{	// return difference of iterators
		return (_Myptr - _Right._Myptr);
		}

	_NODISCARD reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD bool operator==(const unchecked_array_iterator& _Right) const
		{	// test for iterator equality
		return (_Myptr == _Right._Myptr);
		}

	_NODISCARD bool operator!=(const unchecked_array_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD bool operator<(const unchecked_array_iterator& _Right) const
		{	// test if this < _Right
		return (_Myptr < _Right._Myptr);
		}

	_NODISCARD bool operator>(const unchecked_array_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD bool operator<=(const unchecked_array_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD bool operator>=(const unchecked_array_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

private:
	_Iterator _Myptr;	// underlying pointer
	};

template<class _Iterator>
	_NODISCARD inline unchecked_array_iterator<_Iterator> operator+(
		const typename unchecked_array_iterator<_Iterator>::difference_type _Off,
		unchecked_array_iterator<_Iterator> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator>& _Rechecked(unchecked_array_iterator<_Iterator>& _Iter,
		const typename unchecked_array_iterator<_Iterator>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
	_Iter._Myptr = _Right;
	return (_Iter);
	}

template<class _Iterator> inline
	typename unchecked_array_iterator<_Iterator>::_Unchecked_type _Unchecked(
		const unchecked_array_iterator<_Iterator>& _Iter)
	{	// make an unchecked iterator
	return (_Iter.base());
	}

template<class _Iterator>
	_NODISCARD inline unchecked_array_iterator<_Iterator> make_unchecked_array_iterator(const _Iterator _Ptr)
	{	// construct with pointer
	return (unchecked_array_iterator<_Iterator>(_Ptr));
	}
_STDEXT_END

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)
#endif /* RC_INVOKED */
# 716 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 3
#endif /* _ITERATOR_ */
# 717 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iterator" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <tuple>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 1 3
// tuple standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
#ifndef _TUPLE_
#define _TUPLE_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <new>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
#if 0 /* expanded by -frewrite-includes */
#include <xutility>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
	// ALIAS TEMPLATE _Tuple_implicit_t
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_implicit_val0
		: false_type
	{	// Constrain tuple's implicit constructors
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_implicit_val0<true, tuple<_Dests...>, _Srcs...>
		: _Conjunction_t<
			is_constructible<_Dests, _Srcs>...,
			is_convertible<_Srcs, _Dests>...
		>
	{	// Constrain tuple's implicit constructors
	};

template<class _Dest,
	class... _Srcs>
	struct _Tuple_implicit_val
		: _Tuple_implicit_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::type
	{	// Constrain tuple's implicit constructors
	};

template<class _Dest,
	class... _Srcs>
	using _Tuple_implicit_t = enable_if_t<_Tuple_implicit_val<_Dest, _Srcs...>::value, int>;

	// ALIAS TEMPLATE _Tuple_explicit_t
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_explicit_val0
		: false_type
	{	// Constrain tuple's explicit constructors
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_explicit_val0<true, tuple<_Dests...>, _Srcs...>
		: _Conjunction_t<
			is_constructible<_Dests, _Srcs>...,
			negation<conjunction<is_convertible<_Srcs, _Dests>...>>
		>
	{	// Constrain tuple's explicit constructors
	};

template<class _Dest,
	class... _Srcs>
	struct _Tuple_explicit_val
		: _Tuple_explicit_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::type
	{	// Constrain tuple's explicit constructors
	};

template<class _Dest,
	class... _Srcs>
	using _Tuple_explicit_t = enable_if_t<_Tuple_explicit_val<_Dest, _Srcs...>::value, int>;

	// ALIAS TEMPLATE _Tuple_convert_copy_t
template<class _Myself,
	class... _Other>
	struct _Tuple_convert_copy
	{	// Constrain tuple's converting copy constructor (LWG 2549)
	typedef int type;
	};

template<class _This,
	class _Uty>
	struct _Tuple_convert_copy<tuple<_This>, _Uty>
		: enable_if<!is_same_v<_This, _Uty>
			&& !is_constructible_v<_This, const tuple<_Uty>&>
			&& !is_convertible_v<const tuple<_Uty>&, _This>, int>
	{	// Constrain tuple's converting copy constructor (LWG 2549)
	};

template<class _Myself,
	class... _Other>
	using _Tuple_convert_copy_t = typename _Tuple_convert_copy<_Myself, _Other...>::type;

	// ALIAS TEMPLATE _Tuple_convert_move_t
template<class _Myself,
	class... _Other>
	struct _Tuple_convert_move
	{	// Constrain tuple's converting move constructor (LWG 2549)
	typedef int type;
	};

template<class _This,
	class _Uty>
	struct _Tuple_convert_move<tuple<_This>, _Uty>
		: enable_if<!is_same_v<_This, _Uty>
			&& !is_constructible_v<_This, tuple<_Uty>>
			&& !is_convertible_v<tuple<_Uty>, _This>, int>
	{	// Constrain tuple's converting move constructor (LWG 2549)
	};

template<class _Myself,
	class... _Other>
	using _Tuple_convert_move_t = typename _Tuple_convert_move<_Myself, _Other...>::type;

	// STRUCT TEMPLATE _Tuple_perfect_val
template<class _Myself,
	class _This2,
	class... _Rest2>
	struct _Tuple_perfect_val
		: true_type
	{	// Constrain tuple's perfect forwarding constructor (LWG issue not yet filed)
	};

template<class _Myself,
	class _This2>
	struct _Tuple_perfect_val<_Myself, _This2>
		: negation<is_same<_Myself, remove_const_t<remove_reference_t<_This2>>>>::type
	{	// Constrain tuple's perfect forwarding constructor (LWG issue not yet filed)
	};

	// STRUCT _Ignore
struct _Ignore
	{	// struct that ignores assignments
	template<class _Ty>
		void operator=(const _Ty&) const
		{	// do nothing
		}
	};

_INLINE_VAR constexpr _Ignore ignore{};

	// STRUCT TEMPLATE _Tuple_val
template<class _Ty>
	struct _Tuple_val
	{	// stores each value in a tuple
	constexpr _Tuple_val()
		: _Val()
		{	// default construct
		}

	template<class _Other>
		constexpr _Tuple_val(_Other&& _Arg)
		: _Val(_STD forward<_Other>(_Arg))
		{	// construct with argument
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
		_Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg)
		: _Val(_STD forward<_Other>(_Arg)...)
		{	// construct with optional arguments, no allocator
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<uses_allocator_v<_Ty, _Alloc>
			&& is_constructible_v<_Ty, allocator_arg_t, const _Alloc&, _Other...>,
			int> = 0>
		_Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
		{	// construct with optional arguments, leading allocator
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<uses_allocator_v<_Ty, _Alloc>
			&& !is_constructible_v<_Ty, allocator_arg_t, const _Alloc&, _Other...>,
			int> = 0>
		_Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
		: _Val(_STD forward<_Other>(_Arg)..., _Al)
		{	// construct with optional arguments, trailing allocator
		}

	_Ty _Val;
	};

	// CLASS TEMPLATE tuple
struct _Exact_args_t
	{	// tag type to disambiguate construction (from one arg per element)
	};

struct _Unpack_tuple_t
	{	// tag type to disambiguate construction (from unpacking a tuple/pair)
	};

struct _Alloc_exact_args_t
	{	// tag type to disambiguate construction (from an allocator and one arg per element)
	};

struct _Alloc_unpack_tuple_t
	{	// tag type to disambiguate construction (from an allocator and unpacking a tuple/pair)
	};

template<class... _Types>
	class tuple;

template<>
	class tuple<>
	{	// empty tuple
public:
	constexpr tuple() _NOEXCEPT
		{	// default construct
		}

	constexpr tuple(const tuple&) _NOEXCEPT	// TRANSITION, for binary compatibility
		{	// copy construct
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
		{	// default construct, allocator
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
		{	// copy construct, allocator
		}

	template<class _Tag,
		enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
		constexpr tuple(_Tag) _NOEXCEPT
		{	// construct from one arg per element
		}

	template<class _Tag,
		class _Alloc,
		enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
		tuple(_Tag, const _Alloc&) _NOEXCEPT
		{	// construct from an allocator and one arg per element
		}

	void swap(tuple&) _NOEXCEPT
		{	// swap elements
		}

	constexpr bool _Equals(const tuple&) const _NOEXCEPT
		{	// test if *this == _Right
		return (true);
		}

	constexpr bool _Less(const tuple&) const _NOEXCEPT
		{	// test if *this < _Right
		return (false);
		}
	};

template<class _This,
	class... _Rest>
	class tuple<_This, _Rest...>
		: private tuple<_Rest...>
	{	// recursive tuple definition
public:
	typedef _This _This_type;
	typedef tuple<_Rest...> _Mybase;
	static constexpr size_t _Mysize = 1 + sizeof...(_Rest);

	template<class _Tag,
		class _This2,
		class... _Rest2,
		enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
		constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...),
			_Myfirst(_STD forward<_This2>(_This_arg))
		{	// construct from one arg per element
		}

	template<class _Tag,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
		constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

	template<class _Tag,
		class _Tpl,
		enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
		constexpr tuple(_Tag, _Tpl&& _Right)
		: tuple(_Unpack_tuple_t{}, _STD forward<_Tpl>(_Right),
			make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{})
		{	// construct from unpacking a tuple/pair
		}

	template<class _Tag,
		class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
		tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(_Alloc_exact_args_t{}, _Al, _STD forward<_Rest2>(_Rest_arg)...),
			_Myfirst(_Al, allocator_arg, _STD forward<_This2>(_This_arg))
		{	// construct from an allocator and one arg per element
		}

	template<class _Tag,
		class _Alloc,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0> inline
		tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

	template<class _Tag,
		class _Alloc,
		class _Tpl,
		enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0>
		tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _STD forward<_Tpl>(_Right),
			make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{})
		{	// construct from an allocator and unpacking a tuple/pair
		}

	template<class _This2 = _This,
		class = enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...>>>
		constexpr tuple()
		: _Mybase(), _Myfirst()
		{	// construct default
		}

	template<class... _Other,
		_Tuple_implicit_t<tuple, const _Other&...> = 0,
		_Tuple_convert_copy_t<tuple, _Other...> = 0>
		constexpr tuple(const tuple<_Other...>& _Right)
			: tuple(_Unpack_tuple_t{}, _Right)
		{	// construct by copying same size tuple
		}

	template<class... _Other,
		_Tuple_explicit_t<tuple, const _Other&...> = 0,
		_Tuple_convert_copy_t<tuple, _Other...> = 0>
		constexpr explicit tuple(const tuple<_Other...>& _Right)
			: tuple(_Unpack_tuple_t{}, _Right)
		{	// construct by copying same size tuple
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_implicit_t<tuple, const _Other&...> = 0,
		_Tuple_convert_copy_t<tuple, _Other...> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	// construct by copying same size tuple, allocator
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_explicit_t<tuple, const _Other&...> = 0,
		_Tuple_convert_copy_t<tuple, _Other...> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	// construct by copying same size tuple, allocator
		}

	template<class _This2 = _This,
		_Tuple_implicit_t<tuple, const _This2&, const _Rest&...> = 0>
		constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
			: tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
		{	// construct from one or more copied elements
		}

	template<class _This2 = _This,
		_Tuple_explicit_t<tuple, const _This2&, const _Rest&...> = 0>
		constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
			: tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
		{	// construct from one or more copied elements
		}

	template<class _Alloc,
		class _This2 = _This,
		_Tuple_implicit_t<tuple, const _This2&, const _Rest&...> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
		{	// construct from one or more copied elements, allocator
		}

	template<class _Alloc,
		class _This2 = _This,
		_Tuple_explicit_t<tuple, const _This2&, const _Rest&...> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
		{	// construct from one or more copied elements, allocator
		}

	template<class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_implicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
			: tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...)
		{	// construct from one or more moved elements
		}

	template<class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_explicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
			: tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...)
		{	// construct from one or more moved elements
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_implicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...)
		{	// construct from one or more moved elements, allocator
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_explicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...)
		{	// construct from one or more moved elements, allocator
		}

	template<class... _Other,
		_Tuple_implicit_t<tuple, _Other...> = 0,
		_Tuple_convert_move_t<tuple, _Other...> = 0>
		constexpr tuple(tuple<_Other...>&& _Right)
			: tuple(_Unpack_tuple_t{}, _STD move(_Right))
		{	// construct by moving same size tuple
		}

	template<class... _Other,
		_Tuple_explicit_t<tuple, _Other...> = 0,
		_Tuple_convert_move_t<tuple, _Other...> = 0>
		constexpr explicit tuple(tuple<_Other...>&& _Right)
			: tuple(_Unpack_tuple_t{}, _STD move(_Right))
		{	// construct by moving same size tuple
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_implicit_t<tuple, _Other...> = 0,
		_Tuple_convert_move_t<tuple, _Other...> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right))
		{	// construct by moving same size tuple, allocator
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_explicit_t<tuple, _Other...> = 0,
		_Tuple_convert_move_t<tuple, _Other...> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right))
		{	// construct by moving same size tuple, allocator
		}

	template<class... _Other>
		tuple& operator=(const tuple<_Other...>& _Right)
		{	// assign by copying same size tuple
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class... _Other>
		tuple& operator=(tuple<_Other...>&& _Right)
		{	// assign by moving same size tuple
		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
		_Get_rest() = _STD forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class... _Other>
		constexpr bool _Equals(const tuple<_Other...>& _Right) const
		{	// test if *this == _Right
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val == _Right._Myfirst._Val
			&& _Mybase::_Equals(_Right._Get_rest()));
		}

	template<class... _Other>
		constexpr bool _Less(const tuple<_Other...>& _Right) const
		{	// test if *this < _Right
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val < _Right._Myfirst._Val
			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
				&& _Mybase::_Less(_Right._Get_rest())));
		}

	template<class _Alloc,
		class _This2 = _This,
		class = enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...>>>
		tuple(allocator_arg_t, const _Alloc& _Al)
		: _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg)
		{	// construct default, allocator
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	// construct by copying, allocator
		}

	tuple(const tuple&) = default;
	tuple(tuple&&) = default;

	template<class _First,
		class _Second,
		_Tuple_implicit_t<tuple, const _First&, const _Second&> = 0>
		constexpr tuple(const pair<_First, _Second>& _Right)
			: tuple(_Unpack_tuple_t{}, _Right)
		{	// construct by copying pair
		}

	template<class _First,
		class _Second,
		_Tuple_explicit_t<tuple, const _First&, const _Second&> = 0>
		constexpr explicit tuple(const pair<_First, _Second>& _Right)
			: tuple(_Unpack_tuple_t{}, _Right)
		{	// construct by copying pair
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_implicit_t<tuple, const _First&, const _Second&> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	// construct by copying pair, allocator
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_explicit_t<tuple, const _First&, const _Second&> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	// construct by copying pair, allocator
		}

	tuple& operator=(const tuple& _Right)
		{	// assign
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class _First,
		class _Second>
		tuple& operator=(const pair<_First, _Second>& _Right)
		{	// assign by copying pair
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _Right.first;
		_Get_rest()._Myfirst._Val = _Right.second;
		return (*this);
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right))
		{	// construct by moving, allocator
		}

	template<class _First,
		class _Second,
		_Tuple_implicit_t<tuple, _First, _Second> = 0>
		constexpr tuple(pair<_First, _Second>&& _Right)
			: tuple(_Unpack_tuple_t{}, _STD move(_Right))
		{	// construct by moving pair
		}

	template<class _First,
		class _Second,
		_Tuple_explicit_t<tuple, _First, _Second> = 0>
		constexpr explicit tuple(pair<_First, _Second>&& _Right)
			: tuple(_Unpack_tuple_t{}, _STD move(_Right))
		{	// construct by moving pair
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_implicit_t<tuple, _First, _Second> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right))
		{	// construct by moving pair, allocator
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_explicit_t<tuple, _First, _Second> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right))
		{	// construct by moving pair, allocator
		}

	tuple& operator=(tuple&& _Right)
		_NOEXCEPT_COND(is_nothrow_move_assignable_v<_This>
			&& is_nothrow_move_assignable_v<_Mybase>)
		{	// assign by moving
		_Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);
		_Get_rest() = _STD forward<_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class _First,
		class _Second>
		tuple& operator=(pair<_First, _Second>&& _Right)
		{	// assign by moving pair
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _STD forward<_First>(_Right.first);
		_Get_rest()._Myfirst._Val = _STD forward<_Second>(_Right.second);
		return (*this);
		}

	_Mybase& _Get_rest() _NOEXCEPT
		{	// get reference to rest of elements
		return (*this);
		}

	constexpr const _Mybase& _Get_rest() const _NOEXCEPT
		{	// get const reference to rest of elements
		return (*this);
		}

	void swap(tuple& _Right)
		_NOEXCEPT_COND(conjunction_v<_Is_nothrow_swappable<_This>,
			_Is_nothrow_swappable<_Rest>...>)
		{	// swap *this and _Right
		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
		_Mybase::swap(_Right._Get_rest());
		}

	_Tuple_val<_This> _Myfirst;	// the stored element
	};

#if _HAS_DEDUCTION_GUIDES
template<class... _Types>
	tuple(_Types...) -> tuple<_Types...>;

template<class _Ty1,
	class _Ty2>
	tuple(pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template<class _Alloc,
	class... _Types>
	tuple(allocator_arg_t, _Alloc, _Types...) -> tuple<_Types...>;

template<class _Alloc,
	class _Ty1,
	class _Ty2>
	tuple(allocator_arg_t, _Alloc, pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template<class _Alloc,
	class... _Types>
	tuple(allocator_arg_t, _Alloc, tuple<_Types...>) -> tuple<_Types...>;

 #ifdef __clang__ // TRANSITION, LLVM#34970
template<class... _Types>
	tuple(tuple<_Types...>) -> tuple<_Types...>;
 #endif /* __clang__ */
# 700 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
#endif /* _HAS_DEDUCTION_GUIDES */
# 701 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3

	// OPERATORS FOR tuple
template<class... _Types1,
	class... _Types2>
	_NODISCARD constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left == _Right
	return (_Left._Equals(_Right));
	}

template<class... _Types1,
	class... _Types2>
	_NODISCARD constexpr bool operator!=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left != _Right
	return (!(_Left == _Right));
	}

template<class... _Types1,
	class... _Types2>
	_NODISCARD constexpr bool operator<(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left < _Right
	return (_Left._Less(_Right));
	}

template<class... _Types1,
	class... _Types2>
	_NODISCARD constexpr bool operator>=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left >= _Right
	return (!(_Left < _Right));
	}

template<class... _Types1,
	class... _Types2>
	_NODISCARD constexpr bool operator>(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left > _Right
	return (_Right < _Left);
	}

template<class... _Types1,
	class... _Types2>
	_NODISCARD constexpr bool operator<=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left <= _Right
	return (!(_Right < _Left));
	}

template<class... _Types,
	class = enable_if_t<conjunction_v<_Is_swappable<_Types>...>>> inline
	void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right)
		_NOEXCEPT_COND(_NOEXCEPT_OPER(_Left.swap(_Right)))
	{	// swap _Left and _Right
	return (_Left.swap(_Right));
	}


	// CLASS _Tuple_element (find element by type)
template<class _Ty,
	class _Tuple>
	struct _Tuple_element;

template<class _This,
	class... _Rest>
	struct _Tuple_element<_This, tuple<_This, _Rest...> >
	{	// select first element
	typedef int _Check_type;
	static_assert(is_void_v<typename _Tuple_element<_This, tuple<_Rest...>>::_Check_type>,
		"duplicate type T in get<T>(tuple)");

	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<class _Ty,
	class _This,
	class... _Rest>
	struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
		: _Tuple_element<_Ty, tuple<_Rest...> >
	{	// recursive _Tuple_element definition
	};

template<class _Ty>
	struct _Tuple_element<_Ty, tuple<> >
	{	// backstop _Tuple_element definition
	typedef void _Check_type;	// proof that no duplicate type exists
	};

	// FUNCTION TEMPLATE get (by index)
template<size_t _Index,
	class... _Types>
	_NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>&
		get(tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types>
	_NODISCARD constexpr const tuple_element_t<_Index, tuple<_Types...>>&
		get(const tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get const reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types>
	_NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>&&
		get(tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get rvalue reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	typedef tuple_element_t<_Index, tuple<_Types...>>&& _RRtype;
	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

template<size_t _Index,
	class... _Types>
	_NODISCARD constexpr const tuple_element_t<_Index, tuple<_Types...>>&&
		get(const tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get const rvalue reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	typedef const tuple_element_t<_Index, tuple<_Types...>>&& _RRtype;
	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	// FUNCTION TEMPLATE get (by type)
template<class _Ty,
	class... _Types>
	_NODISCARD constexpr _Ty& get(tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types>
	_NODISCARD constexpr const _Ty& get(const tuple<_Types...>& _Tuple) _NOEXCEPT
	{	// get const reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types>
	_NODISCARD constexpr _Ty&& get(tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get rvalue reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (_STD forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

template<class _Ty,
	class... _Types>
	_NODISCARD constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) _NOEXCEPT
	{	// get const rvalue reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (_STD forward<const _Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	// CONSTRUCTOR TEMPLATES FOR tuple
template<class _This,
	class... _Rest>
	template<class _Tag,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int>>
		constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
		: tuple(_Exact_args_t{}, _STD get<_Indices>(_STD forward<_Tpl>(_Right))...)
		{	// construct from unpacking a tuple/pair, using get<I>()
		}

template<class _This,
	class... _Rest>
	template<class _Tag,
		class _Alloc,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int>> inline
		tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
		: tuple(_Alloc_exact_args_t{}, _Al, _STD get<_Indices>(_STD forward<_Tpl>(_Right))...)
		{	// construct from an allocator and unpacking a tuple/pair, using get<I>()
		}

	// FUNCTION TEMPLATE make_tuple
template<class... _Types>
	_NODISCARD constexpr tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	// make tuple from elements
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(_STD forward<_Types>(_Args)...));
	}

	// FUNCTION TEMPLATE tie
template<class... _Types>
	_NODISCARD constexpr tuple<_Types&...>
		tie(_Types&... _Args) _NOEXCEPT
	{	// make tuple from elements
	typedef tuple<_Types&...> _Ttype;
	return (_Ttype(_Args...));
	}


	// FUNCTION TEMPLATE forward_as_tuple

template<class... _Types>
	_NODISCARD constexpr tuple<_Types&&...>
		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
	{	// forward arguments in a tuple
	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
	}


	// STRUCT TEMPLATE _Cat_sequences
template<class _Seq_type1,
	class _Seq_type2>
	struct _Cat_sequences;

template<size_t... _Indexes1,
	size_t... _Indexes2>
	struct _Cat_sequences<index_sequence<_Indexes1...>,
		index_sequence<_Indexes2...> >
	{	// concatenates two index_sequence types
	typedef index_sequence<_Indexes1..., _Indexes2...> type;
	};

	// FORWARD DECLARATIONS
template<class _Ty,
	size_t _Size>
	class array;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty& get(array<_Ty, _Size>& _Arr) _NOEXCEPT;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) _NOEXCEPT;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) _NOEXCEPT;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) _NOEXCEPT;

	// STRUCT TEMPLATE _View_as_tuple
template<class _Ty,
	class... _For_array>
	struct _View_as_tuple
	{	// tuple_cat() supports only tuples, pairs, and arrays
	static_assert(_Always_false<_Ty>::value,
		"Unsupported tuple_cat arguments.");
	};

template<class... _Types>
	struct _View_as_tuple<tuple<_Types...> >
	{	// view a tuple as a tuple
	typedef tuple<_Types...> type;
	};

template<class _Ty1,
	class _Ty2>
	struct _View_as_tuple<pair<_Ty1, _Ty2> >
	{	// view a pair as a tuple
	typedef tuple<_Ty1, _Ty2> type;
	};

template<class _Ty,
	class... _Types>
	struct _View_as_tuple<array<_Ty, 0>, _Types...>
	{	// view an array as a tuple; ends recursion at 0
	typedef tuple<_Types...> type;
	};

template<class _Ty,
	size_t _Size,
	class... _Types>
	struct _View_as_tuple<array<_Ty, _Size>, _Types...>
		: _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
	{	// view an array as a tuple; counts down to 0
	};

	// STRUCT TEMPLATE _Repeat_for
template<size_t _Nx,
	class _Ty>
	struct _Repeat_for
		: integral_constant<size_t, _Nx>
	{	// repeats _Nx for each _Ty in a parameter pack
	};

	// FUNCTION TEMPLATE tuple_cat
template<class _Ret,
	class _Kx_arg,
	class _Ix_arg,
	size_t _Ix_next,
	class... _Tuples>
	struct _Tuple_cat2
	{	// determine tuple_cat's return type and _Kx/_Ix indices
	static_assert(sizeof...(_Tuples) == 0,
		"Unsupported tuple_cat arguments.");
	typedef _Ret type;
	typedef _Kx_arg _Kx_arg_seq;
	typedef _Ix_arg _Ix_arg_seq;
	};

template<class... _Types1,
	class _Kx_arg,
	size_t... _Ix,
	size_t _Ix_next,
	class... _Types2,
	class... _Rest>
	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
		index_sequence<_Ix...>, _Ix_next,
		tuple<_Types2...>, _Rest...>
		: _Tuple_cat2<
			tuple<_Types1..., _Types2...>,
			typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
			index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
			_Ix_next + 1,
			_Rest...>
	{	// determine tuple_cat's return type and _Kx/_Ix indices
	};

template<class... _Tuples>
	struct _Tuple_cat1
		: _Tuple_cat2<tuple<>, index_sequence<>,
				index_sequence<>, 0,
			typename _View_as_tuple<decay_t<_Tuples>>::type...>
	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
	};

#pragma warning(push)
#pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
template<class _Ret,
	size_t... _Kx,
	size_t... _Ix,
	class _Ty>
	constexpr _Ret _Tuple_cat(index_sequence<_Kx...>,
		index_sequence<_Ix...>, _Ty&& _Arg)
	{	// concatenate tuples
	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
	}
#pragma warning(pop)

template<class... _Tuples>
	_NODISCARD constexpr typename _Tuple_cat1<_Tuples...>::type
		tuple_cat(_Tuples&&... _Tpls)
	{	// concatenate tuples
	typedef _Tuple_cat1<_Tuples...> _Cat1;
	return (_Tuple_cat<typename _Cat1::type>(
		typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
	}

#if _HAS_CXX17
	// FUNCTION TEMPLATE apply
#pragma warning(push)
#pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
template<class _Callable,
	class _Tuple,
	size_t... _Indices>
	constexpr decltype(auto) _Apply_impl(_Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>)
	{	// invoke _Obj with the elements of _Tpl
	return (_C_invoke(_STD forward<_Callable>(_Obj), _STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...));
	}
#pragma warning(pop)

template<class _Callable,
	class _Tuple>
	constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl)
	{	// invoke _Obj with the elements of _Tpl
	return (_Apply_impl(_STD forward<_Callable>(_Obj), _STD forward<_Tuple>(_Tpl),
		make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{}));
	}

	// FUNCTION TEMPLATE make_from_tuple
#pragma warning(push)
#pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
template<class _Ty,
	class _Tuple,
	size_t... _Indices>
	constexpr _Ty _Make_from_tuple_impl(_Tuple&& _Tpl, index_sequence<_Indices...>)
	{	// construct _Ty from the elements of _Tpl
	return (_Ty(_STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...));
	}
#pragma warning(pop)

template<class _Ty,
	class _Tuple>
	_NODISCARD constexpr _Ty make_from_tuple(_Tuple&& _Tpl)
	{	// construct _Ty from the elements of _Tpl
	return (_Make_from_tuple_impl<_Ty>(_STD forward<_Tuple>(_Tpl),
		make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{}));
	}
#endif /* _HAS_CXX17 */
# 1098 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3

	// FUNCTION TEMPLATE _For_each_tuple_element
template<class _Tpl,
	class _Fx,
	size_t... _Indices> inline
	void _For_each_tuple_element_impl(_Tpl&& _Tuple,
		_Fx _Func, index_sequence<_Indices...>)
	{	// call _Func() on the _Indices elements of _Tuple
	int _Ignored[] = { (static_cast<void>(_Func(
		_STD get<_Indices>(_STD forward<_Tpl>(_Tuple))
		)), 0)... };
	(void)_Ignored;
	}

template<class _Tpl,
	class _Fx> inline
	void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
	{	// call _Func() on each element in _Tuple
	_For_each_tuple_element_impl(
		_STD forward<_Tpl>(_Tuple),
		_Func,
		make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>()
		);
	}


#pragma warning(push)
#pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, sequence, sequence)
template<class _Ty1,
	class _Ty2>
	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			index_sequence<_Indexes1...>,
			index_sequence<_Indexes2...>)
		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
			second(_STD get<_Indexes2>(_STD move(_Val2))...)
		{	// construct from pair of tuples
		}
#pragma warning(pop)

	// TEMPLATE CONSTRUCTOR pair::pair(piecewise_construct_t, tuple, tuple)
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
		: pair(_Val1, _Val2,
			index_sequence_for<_Types1...>(),
			index_sequence_for<_Types2...>())
		{	// construct from pair of tuples
		}

	// STRUCT TEMPLATE uses_allocator
template<class... _Types,
	class _Alloc>
	struct uses_allocator<tuple<_Types...>, _Alloc>
		: true_type
	{	// true_type if container allocator enabled
	};

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _STD get;
using _STD ignore;
using _STD make_tuple;
using _STD ref;
using _STD tie;
using _STD tuple;
}
#endif /* _HAS_TR1_NAMESPACE */
# 1175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 1182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3
#endif /* _TUPLE_ */
# 1183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\tuple" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 2 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
	// CLASS TEMPLATE array
template<class _Ty,
	size_t _Size>
	class array
	{	// fixed size array of values
public:
	using value_type = _Ty;
	using size_type = size_t;
	using difference_type = ptrdiff_t;
	using pointer = _Ty *;
	using const_pointer = const _Ty *;
	using reference = _Ty&;
	using const_reference = const _Ty&;

	using iterator = _Array_iterator<_Ty, _Size>;
	using const_iterator = _Array_const_iterator<_Ty, _Size>;

	using reverse_iterator = _STD reverse_iterator<iterator>;
	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

#if _HAS_TR1_NAMESPACE
	_DEPRECATE_TR1_NAMESPACE void assign(const _Ty& _Value)
		{	// assign value to all elements
		_Fill_n_unchecked(_Elems, _Size, _Value);
		}
#endif /* _HAS_TR1_NAMESPACE */
# 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

	void fill(const _Ty& _Value)
		{	// assign value to all elements
		_Fill_n_unchecked(_Elems, _Size, _Value);
		}

	void swap(array& _Other)
		_NOEXCEPT_COND(_Is_nothrow_swappable<_Ty>::value)
		{	// swap contents with _Other
		_Swap_ranges_unchecked(_Elems, _Elems + _Size, _Other._Elems);
		}

	_NODISCARD _CONSTEXPR17 iterator begin() _NOEXCEPT
		{	// return iterator for beginning of mutable sequence
		return (iterator(_Elems, 0));
		}

	_NODISCARD _CONSTEXPR17 const_iterator begin() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(_Elems, 0));
		}

	_NODISCARD _CONSTEXPR17 iterator end() _NOEXCEPT
		{	// return iterator for end of mutable sequence
		return (iterator(_Elems, _Size));
		}

	_NODISCARD _CONSTEXPR17 const_iterator end() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(_Elems, _Size));
		}

	_NODISCARD _CONSTEXPR17 reverse_iterator rbegin() _NOEXCEPT
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator rbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	_NODISCARD _CONSTEXPR17 reverse_iterator rend() _NOEXCEPT
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator rend() const _NOEXCEPT
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	_NODISCARD _CONSTEXPR17 const_iterator cbegin() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	_NODISCARD _CONSTEXPR17 const_iterator cend() const _NOEXCEPT
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator crbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator crend() const _NOEXCEPT
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	_CONSTEXPR17 _Ty * _Unchecked_begin() _NOEXCEPT
		{	// return plain pointer to beginning of mutable sequence
		return (_Elems);
		}

	_CONSTEXPR17 const _Ty * _Unchecked_begin() const _NOEXCEPT
		{	// return plain pointer to beginning of nonmutable sequence
		return (_Elems);
		}

	_CONSTEXPR17 _Ty * _Unchecked_end() _NOEXCEPT
		{	// return plain pointer to end of mutable sequence
		return (_Elems + _Size);
		}

	_CONSTEXPR17 const _Ty * _Unchecked_end() const _NOEXCEPT
		{	// return plain pointer to end of nonmutable sequence
		return (_Elems + _Size);
		}

	_NODISCARD constexpr size_type size() const _NOEXCEPT
		{	// return length of sequence
		return (_Size);
		}

	_NODISCARD constexpr size_type max_size() const _NOEXCEPT
		{	// return maximum possible length of sequence
		return (_Size);
		}

	_NODISCARD constexpr bool empty() const _NOEXCEPT
		{	// test if sequence is empty
		return (false);
		}

	_NODISCARD _CONSTEXPR17 reference at(size_type _Pos)
		{	// subscript mutable sequence with checking
		if (_Size <= _Pos)
			{
			_Xran();
			}

		return (_Elems[_Pos]);
		}

	_NODISCARD constexpr const_reference at(size_type _Pos) const
		{	// subscript nonmutable sequence with checking
		if (_Size <= _Pos)
			{
			_Xran();
			}

		return (_Elems[_Pos]);
		}

	_NODISCARD _CONSTEXPR17 reference operator[](_In_range_(0, _Size - 1) size_type _Pos)
		{	// subscript mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Size <= _Pos)
			{
			_DEBUG_ERROR("array subscript out of range");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(_Pos < _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[_Pos]);
		}

	_NODISCARD constexpr const_reference operator[](_In_range_(0, _Size - 1) size_type _Pos) const
		{	// subscript nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Size <= _Pos)
			{
			_DEBUG_ERROR("array subscript out of range");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(_Pos < _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[_Pos]);
		}

	_NODISCARD _CONSTEXPR17 reference front()
		{	// return first element of mutable sequence
		return (_Elems[0]);
		}

	_NODISCARD constexpr const_reference front() const
		{	// return first element of nonmutable sequence
		return (_Elems[0]);
		}

	_NODISCARD _CONSTEXPR17 reference back()
		{	// return last element of mutable sequence
		return (_Elems[_Size - 1]);
		}

	_NODISCARD constexpr const_reference back() const
		{	// return last element of nonmutable sequence
		return (_Elems[_Size - 1]);
		}

	_NODISCARD _CONSTEXPR17 _Ty * data() _NOEXCEPT
		{	// return pointer to mutable data array
		return (_Elems);
		}

	_NODISCARD _CONSTEXPR17 const _Ty * data() const _NOEXCEPT
		{	// return pointer to nonmutable data array
		return (_Elems);
		}

	[[noreturn]] void _Xran() const
		{	// report an out_of_range error
		_Xout_of_range("invalid array<T, N> subscript");
		}

	_Ty _Elems[_Size];
	};

#if _HAS_DEDUCTION_GUIDES
template<class _First,
	class... _Rest>
	struct _Enforce_same
	{
	static_assert(conjunction_v<is_same<_First, _Rest>...>,
		"N4687 26.3.7.2 [array.cons]/2: "
		"Requires: (is_same_v<T, U> && ...) is true. Otherwise the program is ill-formed.");
	using type = _First;
	};

template<class _First,
	class... _Rest>
	array(_First, _Rest...)
		-> array<typename _Enforce_same<_First, _Rest...>::type, 1 + sizeof...(_Rest)>;

 #ifdef __clang__ // TRANSITION, LLVM#34970
template<class _Ty,
	size_t _Size>
	array(array<_Ty, _Size>) -> array<_Ty, _Size>;
 #endif /* __clang__ */
# 257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
#endif /* _HAS_DEDUCTION_GUIDES */
# 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

template<class _Ty>
	class array<_Ty, 0>
	{	// zero size array of values
public:
	using value_type = _Ty;
	using size_type = size_t;
	using difference_type = ptrdiff_t;
	using pointer = _Ty *;
	using const_pointer = const _Ty *;
	using reference = _Ty&;
	using const_reference = const _Ty&;

	using iterator = _Array_iterator<_Ty, 0>;
	using const_iterator = _Array_const_iterator<_Ty, 0>;
	using reverse_iterator = _STD reverse_iterator<iterator>;
	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

#if _HAS_TR1_NAMESPACE
	_DEPRECATE_TR1_NAMESPACE void assign(const _Ty&)
		{	// assign value to all elements
		}
#endif /* _HAS_TR1_NAMESPACE */
# 281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

	void fill(const _Ty&)
		{	// assign value to all elements
		}

	void swap(array&) _NOEXCEPT
		{	// swap contents with _Other
		}

	_NODISCARD _CONSTEXPR17 iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (iterator(0, 0));
		}

	_NODISCARD _CONSTEXPR17 const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (iterator(0, 0));
		}

	_NODISCARD _CONSTEXPR17 iterator end()
		{	// return iterator for end of mutable sequence
		return (iterator(0, 0));
		}

	_NODISCARD _CONSTEXPR17 const_iterator end() const
		{	// return iterator for beginning of nonmutable sequence
		return (iterator(0, 0));
		}

	_NODISCARD _CONSTEXPR17 reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	_NODISCARD _CONSTEXPR17 reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	_NODISCARD _CONSTEXPR17 const_iterator cbegin() const
		{	// return iterator for beginning of nonmutable sequence
		return (iterator(0, 0));
		}

	_NODISCARD _CONSTEXPR17 const_iterator cend() const
		{	// return iterator for end of nonmutable sequence
		return (iterator(0, 0));
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator crbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	_NODISCARD _CONSTEXPR17 const_reverse_iterator crend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	_CONSTEXPR17 _Ty * _Unchecked_begin() _NOEXCEPT
		{	// return plain pointer to beginning of mutable sequence
		return (nullptr);
		}

	_CONSTEXPR17 const _Ty * _Unchecked_begin() const _NOEXCEPT
		{	// return plain pointer to beginning of nonmutable sequence
		return (nullptr);
		}

	_CONSTEXPR17 _Ty * _Unchecked_end() _NOEXCEPT
		{	// return plain pointer to end of mutable sequence
		return (nullptr);
		}

	_CONSTEXPR17 const _Ty * _Unchecked_end() const _NOEXCEPT
		{	// return plain pointer to end of nonmutable sequence
		return (nullptr);
		}

	_NODISCARD constexpr size_type size() const
		{	// return length of sequence
		return (0);
		}

	_NODISCARD constexpr size_type max_size() const
		{	// return maximum possible length of sequence
		return (0);
		}

	_NODISCARD constexpr bool empty() const
		{	// test if sequence is empty
		return (true);
		}

	[[noreturn]] reference at(size_type)
		{	// subscript mutable sequence with checking
		_Xran();
		}

	[[noreturn]] const_reference at(size_type) const
		{	// subscript nonmutable sequence with checking
		_Xran();
		}

	_NODISCARD reference operator[](size_type)
		{	// subscript mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("array subscript out of range");
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 400 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(false);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 402 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[0]);
		}

	_NODISCARD const_reference operator[](size_type) const
		{	// subscript nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("array subscript out of range");
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 411 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(false);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 413 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[0]);
		}

	_NODISCARD reference front()
		{	// return first element of mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("array<T, 0>::front() invalid");
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 422 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(false);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[0]);
		}

	_NODISCARD const_reference front() const
		{	// return first element of nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("array<T, 0>::front() invalid");
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 433 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(false);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[0]);
		}

	_NODISCARD reference back()
		{	// return last element of mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("array<T, 0>::back() invalid");
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 444 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(false);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[0]);
		}

	_NODISCARD const_reference back() const
		{	// return last element of nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		_DEBUG_ERROR("array<T, 0>::back() invalid");
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 455 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
		_SCL_SECURE_VALIDATE_RANGE(false);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

		return (_Elems[0]);
		}

	_NODISCARD _CONSTEXPR17 _Ty * data()
		{	// return pointer to mutable data array
		return (nullptr);
		}

	_NODISCARD _CONSTEXPR17 const _Ty * data() const
		{	// return pointer to nonmutable data array
		return (nullptr);
		}

	[[noreturn]] void _Xran() const
		{	// report an out_of_range error
		_Xout_of_range("invalid array<T, 0> subscript");
		}

	_Ty _Elems[1];
	};

template<class _Ty,
	size_t _Size,
	class = enable_if_t<_Size == 0 || _Is_swappable<_Ty>::value>>
	void swap(array<_Ty,_Size>& _Left,
		array<_Ty,_Size>& _Right)
			_NOEXCEPT_COND(_NOEXCEPT_OPER(_Left.swap(_Right)))
	{	// swap arrays
	return (_Left.swap(_Right));
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD bool operator==(const array<_Ty,_Size>& _Left,
		const array<_Ty,_Size>& _Right)
	{	// test for array equality
	return (_STD equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD bool operator!=(const array<_Ty,_Size>& _Left,
		const array<_Ty,_Size>& _Right)
	{	// test for array inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD bool operator<(const array<_Ty,_Size>& _Left,
		const array<_Ty,_Size>& _Right)
	{	// test if _Left < _Right for arrays
	return (_STD lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD bool operator>(const array<_Ty,_Size>& _Left,
		const array<_Ty,_Size>& _Right)
	{	// test if _Left > _Right for arrays
	return (_Right < _Left);
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD bool operator<=(const array<_Ty,_Size>& _Left,
	const array<_Ty,_Size>& _Right)
	{	// test if _Left <= _Right for arrays
	return (!(_Right < _Left));
	}

template<class _Ty,
	size_t _Size>
	_NODISCARD bool operator>=(const array<_Ty,_Size>& _Left,
	const array<_Ty,_Size>& _Right)
	{	// test if _Left >= _Right for arrays
	return (!(_Left < _Right));
	}

	// TUPLE INTERFACE TO array
template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty& get(array<_Ty, _Size>& _Arr) _NOEXCEPT
	{	// return element at _Idx in array _Arr
	static_assert(_Idx < _Size, "array index out of bounds");
	return (_Arr._Elems[_Idx]);
	}

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) _NOEXCEPT
	{	// return element at _Idx in array _Arr
	static_assert(_Idx < _Size, "array index out of bounds");
	return (_Arr._Elems[_Idx]);
	}

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) _NOEXCEPT
	{	// return element at _Idx in array _Arr
	static_assert(_Idx < _Size, "array index out of bounds");
	return (_STD move(_Arr._Elems[_Idx]));
	}

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	_NODISCARD constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) _NOEXCEPT
	{	// return element at _Idx in array _Arr
	static_assert(_Idx < _Size, "array index out of bounds");
	return (_STD move(_Arr._Elems[_Idx]));
	}

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _STD array;
using _STD get;
}
#endif /* _HAS_TR1_NAMESPACE */
# 581 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 587 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3
#endif /* _ARRAY_ */
# 588 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\array" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 3 "ice.cpp" 2
#if 0 /* expanded by -frewrite-includes */
#include <cassert>
#endif /* expanded by -frewrite-includes */
# 3 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cassert" 1 3
// cassert standard header
// NOTE: no include guard
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cassert" 3
# 4 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cassert" 3
#if 0 /* expanded by -frewrite-includes */
#include <assert.h>
#endif /* expanded by -frewrite-includes */
# 4 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cassert" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\assert.h" 1 3
//
// assert.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the assert macro and related functionality.
//
#if defined _VCRT_BUILD && !defined _ASSERT_OK
    #error assert.h not for CRT internal use
#endif
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\assert.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <corecrt.h>
#endif /* expanded by -frewrite-includes */
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\assert.h" 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\assert.h" 3

_CRT_BEGIN_C_HEADER



#undef assert

#ifdef NDEBUG

    #define assert(expression) ((void)0)

#else
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\assert.h" 3

    _ACRTIMP void __cdecl _wassert(
        _In_z_ wchar_t const* _Message,
        _In_z_ wchar_t const* _File,
        _In_   unsigned       _Line
        );

    #define assert(expression) (void)(                                                       \
            (!!(expression)) ||                                                              \
            (_wassert(_CRT_WIDE(#expression), _CRT_WIDE(__FILE__), (unsigned)(__LINE__)), 0) \
        )

#endif
# 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\assert.h" 3



_CRT_END_C_HEADER
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cassert" 2 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 4 "ice.cpp" 2
#if 0 /* expanded by -frewrite-includes */
#include <cstddef>
#endif /* expanded by -frewrite-includes */
# 4 "ice.cpp"
# 5 "ice.cpp"
#if 0 /* expanded by -frewrite-includes */
#include <cctype>
#endif /* expanded by -frewrite-includes */
# 5 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 1 3
// cctype standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3
#ifndef _CCTYPE_
#define _CCTYPE_
#if 0 /* expanded by -frewrite-includes */
#include <yvals.h>
#endif /* expanded by -frewrite-includes */
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3
#if 0 /* expanded by -frewrite-includes */
#include <ctype.h>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3

	/* remove any (improper) macro overrides */
#undef isalnum
#undef isalpha
#undef isblank
#undef iscntrl
#undef isdigit
#undef isgraph
#undef islower
#undef isprint
#undef ispunct
#undef isspace
#undef isupper
#undef isxdigit
#undef tolower
#undef toupper

 #ifndef RC_INVOKED
_STD_BEGIN
using _CSTD isalnum; using _CSTD isalpha; using _CSTD iscntrl;
using _CSTD isdigit; using _CSTD isgraph; using _CSTD islower;
using _CSTD isprint; using _CSTD ispunct; using _CSTD isspace;
using _CSTD isupper; using _CSTD isxdigit; using _CSTD tolower;
using _CSTD toupper;

using _CSTD isblank;
_STD_END
 #endif /* RC_INVOKED */
# 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3

#endif /* _CCTYPE_ */
# 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\cctype" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 6 "ice.cpp" 2
#if 0 /* expanded by -frewrite-includes */
#include <memory>
#endif /* expanded by -frewrite-includes */
# 6 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 1 3
// memory standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
#ifndef _MEMORY_
#define _MEMORY_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xmemory>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
#if 0 /* expanded by -frewrite-includes */
#include <typeinfo>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// FUNCTION TEMPLATE uninitialized_copy
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), no special optimization
	const _FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, (void)++_First)
		{
		_Construct_in_place(*_Dest, *_First);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest);
	_RERAISE;
	_CATCH_END

	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	// copy [_First, _Last) to raw [_Dest, ...)
	_DEPRECATE_UNCHECKED(uninitialized_copy, _Dest);
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	return (_Rechecked(_Dest,
		_Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest))));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _Last) to raw [_Dest, ...)
	return (_Unchecked(
		_STD uninitialized_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		// FUNCTION TEMPLATE uninitialized_copy_n
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), no special optimization
	const _FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		{
		_Construct_in_place(*_Dest, *_First);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest);
	_RERAISE;
	_CATCH_END

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), memmove optimization
	if (0 < _Count)
		{
		return (_Copy_memmove(_First, _First + _Count, _Dest));
		}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), choose optimization
	return (_Uninitialized_copy_n_unchecked1(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
		// Note that we _DEPRECATE_UNCHECKED _Dest because _Count logically goes with _First
	_DEPRECATE_UNCHECKED(uninitialized_copy_n, _Dest);
	return (_Rechecked(_Dest,
		_Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input
		// Note that we _DEPRECATE_UNCHECKED _Dest because _Count logically goes with _First
	_DEPRECATE_UNCHECKED(uninitialized_copy_n, _Dest);
	_DEBUG_ARRAY_SIZE(_First, _Count);
	return (_Rechecked(_Dest,
		_Uninitialized_copy_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	return (_Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest
	_DEBUG_ARRAY_SIZE(_First, _Count);
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	return (_Uninitialized_copy_n_unchecked(_First, _Count, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

#if _HAS_CXX17
		// FUNCTION TEMPLATE uninitialized_move
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) to raw [_Dest, ...), no special optimization
	const _FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, (void)++_First)
		{
		_Construct_in_place(*_Dest, _STD move(*_First));
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest);
	_RERAISE;
	_CATCH_END

	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// move [_First, _Last) to raw [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_move(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	// move [_First, _Last) to raw [_Dest, ...)
	_DEPRECATE_UNCHECKED(uninitialized_move, _Dest);
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	const auto _ULast = _Unchecked(_Last);
	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	return (_Rechecked(_Dest,
		_Uninitialized_move_unchecked(_UFirst, _ULast, _UDest, _Ptr_move_cat(_UFirst, _UDest))));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_move(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// move [_First, _Last) to raw [_Dest, ...)
	return (_Unchecked(
		_STD uninitialized_move(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		// FUNCTION TEMPLATE uninitialized_move_n
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	pair<_InIt, _FwdIt> _Uninitialized_move_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _First + _Count) to [_Dest, ...), no special optimization
	const _FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		{
		_Construct_in_place(*_Dest, _STD move(*_First));
		}

	_CATCH_ALL
	_Destroy_range(_Next, _Dest);
	_RERAISE;
	_CATCH_END

	return (pair<_InIt, _FwdIt>(_First, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	pair<_InIt, _FwdIt> _Uninitialized_move_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// move [_First, _First + _Count) to [_Dest, ...), memmove optimization
	if (0 < _Count)
		{
		_Dest = _Copy_memmove(_First, _First + _Count, _Dest);
		_First += _Count;
		}

	return (pair<_InIt, _FwdIt>(_First, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	pair<_InIt, _FwdIt> _Uninitialized_move_n_unchecked(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// move [_First, _First + _Count) to [_Dest, ...), choose optimization
	return (_Uninitialized_move_n_unchecked1(_First, _Count,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	pair<_InIt, _FwdIt> uninitialized_move_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// move [_First, _First + _Count) to [_Dest, ...)
		// Note that we _DEPRECATE_UNCHECKED _Dest because _Count logically goes with _First
	_DEPRECATE_UNCHECKED(uninitialized_move_n, _Dest);
	return (_Rechecked_both(_First, _Dest,
		_Uninitialized_move_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	pair<_InTy *, _FwdIt> uninitialized_move_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	// move [_First, _First + _Count) to [_Dest, ...), array input
		// Note that we _DEPRECATE_UNCHECKED _Dest because _Count logically goes with _First
	_DEPRECATE_UNCHECKED(uninitialized_move_n, _Dest);
	_DEBUG_ARRAY_SIZE(_First, _Count);
	return (_Rechecked_second(_Dest,
		_Uninitialized_move_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	pair<_InIt, _OutTy *> uninitialized_move_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// move [_First, _First + _Count) to [_Dest, ...), array dest
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	return (_Rechecked_first(_First,
		_Uninitialized_move_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest)));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	pair<_InTy *, _OutTy *> uninitialized_move_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// move [_First, _First + _Count) to [_Dest, ...), array input/dest
	_DEBUG_ARRAY_SIZE(_First, _Count);
	_DEBUG_ARRAY_SIZE(_Dest, _Count);
	return (_Uninitialized_move_n_unchecked(_First, _Count, _Dest));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
# 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

#endif /* _HAS_CXX17 */
# 334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		// FUNCTION TEMPLATE uninitialized_fill
template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, false_type)
	{	// copy _Val throughout raw [_First, _Last), no special optimization
	const _FwdIt _Next = _First;

	_TRY_BEGIN
	for (; _First != _Last; ++_First)
		{
		_Construct_in_place(*_First, _Val);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First);
	_RERAISE;
	_CATCH_END
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, true_type)
	{	// copy _Val throughout raw [_First, _Last), memset optimization
	_CSTD memset(_First, static_cast<unsigned char>(_Val), _Last - _First);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	// copy _Val throughout raw [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	_Uninitialized_fill_unchecked(_UFirst, _Unchecked(_Last), _Val, _Fill_memset_is_safe(_UFirst, _Val));
	}


		// FUNCTION TEMPLATE uninitialized_fill_n
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val, false_type)
	{	// copy _Count copies of _Val to raw _First, no special optimization
	const _FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, (void)++_First)
		{
		_Construct_in_place(*_First, _Val);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First);
	_RERAISE;
	_CATCH_END

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val, true_type)
	{	// copy _Count copies of _Val to raw _First, memset optimization
	if (0 < _Count)
		{
		_CSTD memset(_First, static_cast<unsigned char>(_Val), _Count);
		return (_First + _Count);
		}

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val)
	{	// copy _Count copies of _Val to raw _First
	const auto _UFirst = _Unchecked_n(_First, _Count);
	return (_Rechecked(_First,
		_Uninitialized_fill_n_unchecked(_UFirst, _Count, _Val, _Fill_memset_is_safe(_UFirst, _Val))));
	}

#if _HAS_CXX17
		// FUNCTION TEMPLATE destroy_at
template<class _Ty> inline
	void destroy_at(_Ty * const _Location)
	{	// destroy _Ty at memory address _Location
	_Location->~_Ty();
	}

		// FUNCTION TEMPLATE destroy
template<class _FwdIt> inline
	void destroy(const _FwdIt _First, const _FwdIt _Last)
	{	// destroy all elements in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_Destroy_range(_Unchecked(_First), _Unchecked(_Last));
	}

		// FUNCTION TEMPLATE destroy_n
template<class _FwdIt,
	class _Diff> inline
	_FwdIt _Destroy_n1(_FwdIt _First, _Diff _Count, false_type)
	{	// destroy [_First, _First + _Count), no special optimization
	for (; 0 < _Count; ++_First, (void)--_Count)
		{
		_Destroy_in_place(*_First);
		}

	return (_First);
	}

template<class _FwdIt,
	class _Diff> inline
	_FwdIt _Destroy_n1(const _FwdIt _First, const _Diff _Count, true_type)
	{	// destroy [_First, _First + _Count), trivially destructible
	return (_STD next(_First, _Count)); // nothing to do
	}

template<class _FwdIt,
	class _Diff> inline
	_FwdIt destroy_n(_FwdIt _First, const _Diff _Count_raw)
	{	// destroy all elements in [_First, _First + _Count)
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	const auto _UFirst = _Unchecked_n(_First, _Count);
	return (_Rechecked(_First, _Destroy_n1(_UFirst, _Count,
		is_trivially_destructible<_Iter_value_t<_FwdIt>>())));
	}

		// FUNCTION TEMPLATE uninitialized_default_construct
template<class _FwdIt> inline
	void _Uninitialized_default_construct_unchecked(_FwdIt _First, const _FwdIt _Last, false_type)
	{	// default-initialize all elements in [_First, _Last), no special optimization
	const _FwdIt _Next = _First;

	_TRY_BEGIN
	for (; _First != _Last; ++_First)
		{
		::new (static_cast<void *>(_Unfancy(_First))) _Iter_value_t<_FwdIt>;
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First);
	_RERAISE;
	_CATCH_END
	}

template<class _FwdIt> inline
	void _Uninitialized_default_construct_unchecked(_FwdIt, _FwdIt, true_type)
	{	// default-initialize all elements in [_First, _Last), trivially default constructible types
		// nothing to do
	}

template<class _FwdIt> inline
	void uninitialized_default_construct(const _FwdIt _First, const _FwdIt _Last)
	{	// default-initialize all elements in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_Uninitialized_default_construct_unchecked(_Unchecked(_First), _Unchecked(_Last),
		is_trivially_default_constructible<_Iter_value_t<_FwdIt>>());
	}

		// FUNCTION TEMPLATE uninitialized_default_construct_n
template<class _FwdIt,
	class _Diff> inline
	_FwdIt _Uninitialized_default_construct_n_unchecked(_FwdIt _First, _Diff _Count, false_type)
	{	// default-initialize all elements in [_First, _First + _Count), no special optimization
	const _FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; ++_First, (void)--_Count)
		{
		::new (static_cast<void *>(_Unfancy(_First))) _Iter_value_t<_FwdIt>;
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First);
	_RERAISE;
	_CATCH_END

	return (_First);
	}

template<class _FwdIt,
	class _Diff> inline
	_FwdIt _Uninitialized_default_construct_n_unchecked(const _FwdIt _First, const _Diff _Count, true_type)
	{	// default-initialize all elements in [_First, _First + _Count), trivially default constructible types
		// nothing to do
	return (_STD next(_First, _Count));
	}

template<class _FwdIt,
	class _Diff> inline
	_FwdIt uninitialized_default_construct_n(_FwdIt _First, const _Diff _Count_raw)
	{	// default-initialize all elements in [_First, _First + _Count_raw)
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	const auto _UFirst = _Unchecked_n(_First, _Count);
	return (_Rechecked(_First,
		_Uninitialized_default_construct_n_unchecked(_UFirst, _Count,
		is_trivially_default_constructible<_Iter_value_t<_FwdIt>>())));
	}

		// FUNCTION TEMPLATE uninitialized_value_construct
template<class _FwdIt> inline
	void _Uninitialized_value_construct_unchecked(_FwdIt _First, const _FwdIt _Last, false_type)
	{	// value-initialize all elements in [_First, _Last), no special optimization
	const _FwdIt _Next = _First;

	_TRY_BEGIN
	for (; _First != _Last; ++_First)
		{
		_Construct_in_place(*_First);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First);
	_RERAISE;
	_CATCH_END
	}

template<class _FwdIt> inline
	void _Uninitialized_value_construct_unchecked(const _FwdIt _First, const _FwdIt _Last, true_type)
	{	// value-initialize all elements in [_First, _Last), all-bits-zero type
	_Zero_range(_First, _Last);
	}

template<class _FwdIt> inline
	void uninitialized_value_construct(const _FwdIt _First, const _FwdIt _Last)
	{	// value-initialize all elements in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	const auto _UFirst = _Unchecked(_First);
	_Uninitialized_value_construct_unchecked(_UFirst, _Unchecked(_Last),
		_Use_memset_value_construct_t<_Unchecked_t<_FwdIt>>());
	}

		// FUNCTION TEMPLATE uninitialized_value_construct_n
template<class _FwdIt,
	class _Diff> inline
	_FwdIt _Uninitialized_value_construct_n_unchecked(_FwdIt _First, _Diff _Count, false_type)
	{	// value-initialize all elements in [_First, _First + _Count), no special optimization
	const _FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; ++_First, (void)--_Count)
		{
		_Construct_in_place(*_First);
		}

	_CATCH_ALL
	_Destroy_range(_Next, _First);
	_RERAISE;
	_CATCH_END

	return (_First);
	}

template<class _FwdIt,
	class _Diff> inline
	_FwdIt _Uninitialized_value_construct_n_unchecked(_FwdIt _First, const _Diff _Count, true_type)
	{	// value-initialize all elements in [_First, _First + _Count), all-bits-zero type
	if (0 < _Count)
		{
		return (_Zero_range(_First, _First + _Count));
		}

	return (_First);
	}

template<class _FwdIt,
	class _Diff> inline
	_FwdIt uninitialized_value_construct_n(_FwdIt _First, const _Diff _Count_raw)
	{	// value-initialize all elements in [_First, _First + _Count_raw)
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	const auto _UFirst = _Unchecked_n(_First, _Count);
	return (_Rechecked(_First,
		_Uninitialized_value_construct_n_unchecked(_UFirst, _Count,
			_Use_memset_value_construct_t<_Unchecked_t<_FwdIt>>())));
	}

#endif /* _HAS_CXX17 */
# 614 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3


		// CLASS TEMPLATE raw_storage_iterator
template<class _OutIt,
	class _Ty>
	class _CXX17_DEPRECATE_RAW_STORAGE_ITERATOR raw_storage_iterator
	{	// wrap stores to raw buffer as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	// construct with iterator
		}

	_NODISCARD raw_storage_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	raw_storage_iterator& operator=(const _Ty& _Val)
		{	// construct value designated by stored iterator
		_Construct_in_place(*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator& operator=(_Ty&& _Val)
		{	// construct value designated by stored iterator
		_Construct_in_place(*_Next, _STD move(_Val));
		return (*this);
		}

	raw_storage_iterator& operator++()
		{	// preincrement
		++_Next;
		return (*this);
		}

	raw_storage_iterator operator++(int)
		{	// postincrement
		raw_storage_iterator _Ans = *this;
		++_Next;
		return (_Ans);
		}

	_NODISCARD _OutIt base() const
		{	// return the stored iterator
		return (_Next);
		}

private:
	_OutIt _Next;	// the stored iterator
	};


 #if _HAS_AUTO_PTR_ETC
		// CLASS TEMPLATE auto_ptr
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	// proxy reference for auto_ptr copying
	explicit auto_ptr_ref(_Ty * _Right)
		: _Ref(_Right)
		{	// construct from generic pointer to auto_ptr ptr
		}

	_Ty * _Ref;	// generic pointer to auto_ptr ptr
	};

template<class _Ty>
	class auto_ptr
	{	// wrap an object pointer to ensure destruction
public:
	typedef _Ty element_type;

	explicit auto_ptr(_Ty * _Ptr = 0) _NOEXCEPT
		: _Myptr(_Ptr)
		{	// construct from object pointer
		}

	auto_ptr(auto_ptr& _Right) _NOEXCEPT
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right auto_ptr
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) _NOEXCEPT
		{	// construct by assuming pointer from _Right auto_ptr_ref
		_Ty * _Ptr = _Right._Ref;
		_Right._Ref = 0;	// release old
		_Myptr = _Ptr;	// reset this
		}

	template<class _Other>
		operator auto_ptr<_Other>() _NOEXCEPT
		{	// convert to compatible auto_ptr
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() _NOEXCEPT
		{	// convert to compatible auto_ptr_ref
		_Other * _Cvtptr = _Myptr;	// test implicit conversion
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	// pass ownership to auto_ptr_ref
		return (_Ans);
		}

	template<class _Other>
		auto_ptr& operator=(auto_ptr<_Other>& _Right) _NOEXCEPT
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) _NOEXCEPT
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right
		}

	auto_ptr& operator=(auto_ptr& _Right) _NOEXCEPT
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) _NOEXCEPT
		{	// assign compatible _Right._Ref (assume pointer)
		_Ty * _Ptr = _Right._Ref;
		_Right._Ref = 0;	// release old
		reset(_Ptr);	// set new
		return (*this);
		}

	~auto_ptr() _NOEXCEPT
		{	// destroy the object
		delete _Myptr;
		}

	_NODISCARD _Ty& operator*() const _NOEXCEPT
		{	// return designated value
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Myptr == 0)
			{
			_DEBUG_ERROR("auto_ptr not dereferencable");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 767 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		return (*get());
		}

	_NODISCARD _Ty * operator->() const _NOEXCEPT
		{	// return pointer to class object
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Myptr == 0)
			{
			_DEBUG_ERROR("auto_ptr not dereferencable");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 779 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		return (get());
		}

	_NODISCARD _Ty * get() const _NOEXCEPT
		{	// return wrapped pointer
		return (_Myptr);
		}

	_Ty * release() _NOEXCEPT
		{	// return wrapped pointer and give up ownership
		_Ty * _Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty * _Ptr = 0)
		{	// destroy designated object and store new pointer
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty * _Myptr;	// the wrapped object pointer
	};

template<>
	class auto_ptr<void>
	{
public:
	typedef void element_type;
	};
 #endif /* _HAS_AUTO_PTR_ETC */
# 813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3


	// CLASS bad_weak_ptr
class bad_weak_ptr
	: public exception
	{	// exception type for invalid use of expired weak_ptr object
public:
	bad_weak_ptr() _NOEXCEPT
		{	// default construct
		}

	virtual const char * __CLR_OR_THIS_CALL what() const _NOEXCEPT override
		{	// return pointer to message string
		return ("bad_weak_ptr");
		}
	};

	// CLASS _Ref_count_base
class _Ref_count_base
	{	// common code for reference counting
private:
	virtual void _Destroy() _NOEXCEPT = 0;
	virtual void _Delete_this() _NOEXCEPT = 0;

	_Atomic_counter_t _Uses;
	_Atomic_counter_t _Weaks;

protected:
	_Ref_count_base()
		: _Uses(1), _Weaks(1)	// non-atomic initializations
		{	// construct
		}

public:
	virtual ~_Ref_count_base() _NOEXCEPT
		{	// TRANSITION, should be non-virtual
		}

	bool _Incref_nz()
		{	// increment use count if not zero, return true if successful
		for (;;)
			{	// loop until state is known
 #if _USE_INTERLOCKED_REFCOUNTING
			_Atomic_integral_t _Count =
				static_cast<volatile _Atomic_counter_t&>(_Uses);

			if (_Count == 0)
				return (false);

			if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
					reinterpret_cast<volatile long *>(&_Uses),
					_Count + 1, _Count)) == _Count)
				return (true);

 #else /* _USE_INTERLOCKED_REFCOUNTING */
# 868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
			_Atomic_integral_t _Count =
				_Load_atomic_counter(_Uses);

			if (_Count == 0)
				return (false);

			if (_Compare_increment_atomic_counter(_Uses, _Count))
				return (true);
 #endif /* _USE_INTERLOCKED_REFCOUNTING */
# 877 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
			}
		}

	void _Incref()
		{	// increment use count
		_MT_INCR(_Uses);
		}

	void _Incwref()
		{	// increment weak reference count
		_MT_INCR(_Weaks);
		}

	void _Decref()
		{	// decrement use count
		if (_MT_DECR(_Uses) == 0)
			{	// destroy managed resource, decrement weak reference count
			_Destroy();
			_Decwref();
			}
		}

	void _Decwref()
		{	// decrement weak reference count
		if (_MT_DECR(_Weaks) == 0)
			{
			_Delete_this();
			}
		}

	long _Use_count() const _NOEXCEPT
		{	// return use count
		return (_Get_atomic_count(_Uses));
		}

	virtual void * _Get_deleter(const type_info&) const _NOEXCEPT
		{	// return address of deleter object
		return (nullptr);
		}
	};

	// CLASS TEMPLATE _Ref_count
template<class _Ty>
	class _Ref_count
		: public _Ref_count_base
	{	// handle reference counting for pointer without deleter
public:
	explicit _Ref_count(_Ty * _Px)
		: _Ref_count_base(), _Ptr(_Px)
		{	// construct
		}

private:
	virtual void _Destroy() _NOEXCEPT override
		{	// destroy managed resource
		delete _Ptr;
		}

	virtual void _Delete_this() _NOEXCEPT override
		{	// destroy self
		delete this;
		}

	_Ty * _Ptr;
	};

	// CLASS TEMPLATE _Ref_count_resource
template<class _Resource,
	class _Dx>
	class _Ref_count_resource
		: public _Ref_count_base
	{	// handle reference counting for object with deleter
public:
	_Ref_count_resource(_Resource _Px, _Dx _Dt)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _STD move(_Dt), _Px)
		{	// construct
		}

	virtual void * _Get_deleter(const type_info& _Typeid) const _NOEXCEPT override
		{	// return address of deleter object
#if _HAS_STATIC_RTTI
		if (_Typeid == typeid(_Dx))
			{
			return (const_cast<_Dx *>(_STD addressof(_Mypair._Get_first())));
			}
#else /* _HAS_STATIC_RTTI */
# 963 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
		(void)_Typeid;
#endif /* _HAS_STATIC_RTTI */
# 965 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		return (nullptr);
		}

private:
	virtual void _Destroy() _NOEXCEPT override
		{	// destroy managed resource
		_Mypair._Get_first()(_Mypair._Get_second());
		}

	virtual void _Delete_this() _NOEXCEPT override
		{	// destroy self
		delete this;
		}

	_Compressed_pair<_Dx, _Resource> _Mypair;
	};

	// CLASS TEMPLATE _Ref_count_resource_alloc
template<class _Resource,
	class _Dx,
	class _Alloc>
	class _Ref_count_resource_alloc
		: public _Ref_count_base
	{	// handle reference counting for object with deleter and allocator
public:
	_Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _STD move(_Dt),
			_One_then_variadic_args_t(), _Ax, _Px)
		{	// construct
		}

	virtual void * _Get_deleter(const type_info& _Typeid) const _NOEXCEPT override
		{	// return address of deleter object
#if _HAS_STATIC_RTTI
		if (_Typeid == typeid(_Dx))
			{
			return (const_cast<_Dx *>(_STD addressof(_Mypair._Get_first())));
			}
#else /* _HAS_STATIC_RTTI */
# 1005 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
		(void)_Typeid;
#endif /* _HAS_STATIC_RTTI */
# 1007 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

		return (nullptr);
		}

private:
	using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

	virtual void _Destroy() _NOEXCEPT override
		{	// destroy managed resource
		_Mypair._Get_first()(_Mypair._Get_second()._Get_second());
		}

	virtual void _Delete_this() _NOEXCEPT override
		{	// destroy self
		_Myalty _Al = _Mypair._Get_second()._Get_first();
		allocator_traits<_Myalty>::destroy(_Al, this);
		_Deallocate_plain(_Al, this);
		}

	_Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
	};

	// DECLARATIONS
template<class _Ty>
	struct default_delete;

template<class _Ty,
	class _Dx = default_delete<_Ty>>
	class unique_ptr;

template<class _Ty>
	class shared_ptr;

template<class _Ty>
	class weak_ptr;

template<class _Yty,
	class = void>
	struct _Can_enable_shared
		: false_type
	{	// detect unambiguous and accessible inheritance from enable_shared_from_this
	};

template<class _Yty>
	struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
		: is_convertible<remove_cv_t<_Yty> *, typename _Yty::_Esft_type *>::type
	{	// is_convertible is necessary to verify unambiguous inheritance
	};

template<class _Other,
	class _Yty>
	void _Enable_shared_from_this1(const shared_ptr<_Other>& _This, _Yty * _Ptr, true_type)
	{	// enable shared_from_this
	if (_Ptr && _Ptr->_Wptr.expired())
		{
		_Ptr->_Wptr = shared_ptr<remove_cv_t<_Yty>>(_This, const_cast<remove_cv_t<_Yty> *>(_Ptr));
		}
	}

template<class _Other,
	class _Yty>
	void _Enable_shared_from_this1(const shared_ptr<_Other>&, _Yty *, false_type)
	{	// don't enable shared_from_this
	}

template<class _Other,
	class _Yty>
	void _Enable_shared_from_this(const shared_ptr<_Other>& _This, _Yty * _Ptr)
	{	// possibly enable shared_from_this
	_Enable_shared_from_this1(_This, _Ptr, _Conjunction_t<
		negation<is_array<_Other>>,
		negation<is_volatile<_Yty>>,
		_Can_enable_shared<_Yty>>{});
	}

	// CLASS TEMPLATE _Ptr_base
template<class _Ty>
	class _Ptr_base
	{	// base class for shared_ptr and weak_ptr
public:
	using element_type = remove_extent_t<_Ty>;

	_NODISCARD long use_count() const _NOEXCEPT
		{	// return use count
		return (_Rep ? _Rep->_Use_count() : 0);
		}

	template<class _Ty2>
		_NODISCARD bool owner_before(const _Ptr_base<_Ty2>& _Right) const _NOEXCEPT
		{	// compare addresses of manager objects
		return (_Rep < _Right._Rep);
		}

	_Ptr_base(const _Ptr_base&) = delete;
	_Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
	_NODISCARD element_type * get() const _NOEXCEPT
		{	// return pointer to resource
		return (_Ptr);
		}

	constexpr _Ptr_base() _NOEXCEPT = default;

	~_Ptr_base() = default;

	template<class _Ty2>
		void _Move_construct_from(_Ptr_base<_Ty2>&& _Right)
		{	// implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
		_Ptr = _Right._Ptr;
		_Rep = _Right._Rep;

		_Right._Ptr = nullptr;
		_Right._Rep = nullptr;
		}

	template<class _Ty2>
		void _Copy_construct_from(const shared_ptr<_Ty2>& _Other)
		{	// implement shared_ptr's (converting) copy ctor
		if (_Other._Rep)
			{
			_Other._Rep->_Incref();
			}

		_Ptr = _Other._Ptr;
		_Rep = _Other._Rep;
		}

	template<class _Ty2>
		void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type * _Px)
		{	// implement shared_ptr's aliasing ctor
		if (_Other._Rep)
			{
			_Other._Rep->_Incref();
			}

		_Ptr = _Px;
		_Rep = _Other._Rep;
		}

	template<class _Ty0>
		friend class weak_ptr;	// specifically, weak_ptr::lock()

	template<class _Ty2>
		bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other)
		{	// implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()
		if (_Other._Rep && _Other._Rep->_Incref_nz())
			{
			_Ptr = _Other._Ptr;
			_Rep = _Other._Rep;
			return (true);
			}

		return (false);
		}

	void _Decref()
		{	// decrement reference count
		if (_Rep)
			{
			_Rep->_Decref();
			}
		}

	void _Swap(_Ptr_base& _Right) _NOEXCEPT
		{	// swap pointers
		_STD swap(_Ptr, _Right._Ptr);
		_STD swap(_Rep, _Right._Rep);
		}

	void _Set_ptr_rep(element_type * _Other_ptr, _Ref_count_base * _Other_rep)
		{	// take new resource
		_Ptr = _Other_ptr;
		_Rep = _Other_rep;
		}

	template<class _Ty2>
		void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other)
		{	// implement weak_ptr's ctors
		if (_Other._Rep)
			{
			_Other._Rep->_Incwref();
			}

		_Ptr = _Other._Ptr;
		_Rep = _Other._Rep;
		}

	void _Decwref()
		{	// decrement weak reference count
		if (_Rep)
			{
			_Rep->_Decwref();
			}
		}

private:
	element_type * _Ptr{nullptr};
	_Ref_count_base * _Rep{nullptr};

	template<class _Ty0>
		friend class _Ptr_base;

#if _HAS_STATIC_RTTI
	template<class _Dx,
		class _Ty0>
		friend _Dx * get_deleter(const shared_ptr<_Ty0>& _Sx) _NOEXCEPT;
#endif /* _HAS_STATIC_RTTI */
# 1215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
	};

	// TYPE TRAIT _Can_scalar_delete
template<class _Yty,
	class = void>
	struct _Can_scalar_delete
		: false_type
	{};
struct _Can_scalar_delete_unique_type
	{	// TRANSITION, C1XX
	};
template<class _Yty>
	struct _Can_scalar_delete<_Yty, void_t<_Can_scalar_delete_unique_type, decltype(delete _STD declval<_Yty *>())>>
		: true_type
	{};

	// TYPE TRAIT _Can_array_delete
template<class _Yty,
	class = void>
	struct _Can_array_delete
		: false_type
	{};
struct _Can_array_delete_unique_type
	{	// TRANSITION, C1XX
	};
template<class _Yty>
	struct _Can_array_delete<_Yty, void_t<_Can_array_delete_unique_type, decltype(delete[] _STD declval<_Yty *>())>>
		: true_type
	{};

	// TYPE TRAIT _Can_call_function_object
template<class _Fx,
	class _Arg,
	class = void>
	struct _Can_call_function_object
		: false_type
	{};
struct _Can_call_function_object_unique_type
	{	// TRANSITION, C1XX
	};
template<class _Fx,
	class _Arg>
	struct _Can_call_function_object<_Fx, _Arg, void_t<_Can_call_function_object_unique_type,
		decltype(_STD declval<_Fx>()(_STD declval<_Arg>()))>>
		: true_type
	{};

	// TYPE TRAIT _SP_convertible
template<class _Yty,
	class _Ty>
	struct _SP_convertible
		: is_convertible<_Yty *, _Ty *>::type
	{};
template<class _Yty,
	class _Uty>
	struct _SP_convertible<_Yty, _Uty[]>
		: is_convertible<_Yty(*)[], _Uty(*)[]>::type
	{};
template<class _Yty,
	class _Uty,
	size_t _Ext>
	struct _SP_convertible<_Yty, _Uty[_Ext]>
		: is_convertible<_Yty(*)[_Ext], _Uty(*)[_Ext]>::type
	{};

	// TYPE TRAIT _SP_pointer_compatible
template<class _Yty,
	class _Ty>
	struct _SP_pointer_compatible
		: is_convertible<_Yty *, _Ty *>::type
	{	// N4659 [util.smartptr.shared]/5 "a pointer type Y* is said to be compatible with a pointer type T* "
		// "when either Y* is convertible to T* ..."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};

	// CLASS TEMPLATE shared_ptr
template<class _Ty>
	class shared_ptr
		: public _Ptr_base<_Ty>
	{	// class for reference counted resource management
private:
	using _Mybase = _Ptr_base<_Ty>;

public:
	using typename _Mybase::element_type;

#if _HAS_CXX17
	using weak_type = weak_ptr<_Ty>;
#endif /* _HAS_CXX17 */
# 1327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

	constexpr shared_ptr() _NOEXCEPT
		{	// construct empty shared_ptr
		}

	constexpr shared_ptr(nullptr_t) _NOEXCEPT
		{	// construct empty shared_ptr
		}

	template<class _Ux,
		enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		explicit shared_ptr(_Ux * _Px)
		{	// construct shared_ptr object that owns _Px
		_Setp(_Px, is_array<_Ty>{});
		}

	template<class _Ux,
		class _Dx,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, _Ux *&>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		shared_ptr(_Ux * _Px, _Dx _Dt)
		{	// construct with _Px, deleter
		_Setpd(_Px, _STD move(_Dt));
		}

	template<class _Ux,
		class _Dx,
		class _Alloc,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, _Ux *&>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		shared_ptr(_Ux * _Px, _Dx _Dt, _Alloc _Ax)
		{	// construct with _Px, deleter, allocator
		_Setpda(_Px, _STD move(_Dt), _Ax);
		}

	template<class _Dx,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, nullptr_t&>
		>, int> = 0>
		shared_ptr(nullptr_t, _Dx _Dt)
		{	// construct with nullptr, deleter
		_Setpd(nullptr, _STD move(_Dt));
		}

	template<class _Dx,
		class _Alloc,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, nullptr_t&>
		>, int> = 0>
		shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
		{	// construct with nullptr, deleter, allocator
		_Setpda(nullptr, _STD move(_Dt), _Ax);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Right, element_type * _Px) _NOEXCEPT
		{	// construct shared_ptr object that aliases _Right
		this->_Alias_construct_from(_Right, _Px);
		}

	shared_ptr(const shared_ptr& _Other) _NOEXCEPT
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Copy_construct_from(_Other);
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		shared_ptr(const shared_ptr<_Ty2>& _Other) _NOEXCEPT
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Copy_construct_from(_Other);
		}

	shared_ptr(shared_ptr&& _Right) _NOEXCEPT
		{	// construct shared_ptr object that takes resource from _Right
		this->_Move_construct_from(_STD move(_Right));
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		shared_ptr(shared_ptr<_Ty2>&& _Right) _NOEXCEPT
		{	// construct shared_ptr object that takes resource from _Right
		this->_Move_construct_from(_STD move(_Right));
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		explicit shared_ptr(const weak_ptr<_Ty2>& _Other)
		{	// construct shared_ptr object that owns resource *_Other
		if (!this->_Construct_from_weak(_Other))
			{
			_THROW(bad_weak_ptr{});
			}
		}

 #if _HAS_AUTO_PTR_ETC
	template<class _Ty2,
		enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0>
		shared_ptr(auto_ptr<_Ty2>&& _Other)
		{	// construct shared_ptr object that owns *_Other.get()
		_Ty2 * _Px = _Other.get();
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
		_Other.release();
		}
 #endif /* _HAS_AUTO_PTR_ETC */
# 1434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

	template<class _Ux,
		class _Dx,
		enable_if_t<conjunction_v<
			_SP_pointer_compatible<_Ux, _Ty>,
			is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type *>
		>, int> = 0>
		shared_ptr(unique_ptr<_Ux, _Dx>&& _Other)
		{	// construct from unique_ptr
		using _Fancy_t = typename unique_ptr<_Ux, _Dx>::pointer;
		using _Raw_t = typename unique_ptr<_Ux, _Dx>::element_type *;
		using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(_STD ref(_Other.get_deleter())), _Dx>;

		const _Fancy_t _Fancy = _Other.get();

		if (_Fancy)
			{
			const _Raw_t _Raw = _Fancy;
			const auto _Rx = new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _Other.get_deleter());
			_Set_ptr_rep_and_enable_shared(_Raw, _Rx);
			_Other.release();
			}
		}

	~shared_ptr() _NOEXCEPT
		{	// release resource
		this->_Decref();
		}

	shared_ptr& operator=(const shared_ptr& _Right) _NOEXCEPT
		{	// assign shared ownership of resource owned by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) _NOEXCEPT
		{	// assign shared ownership of resource owned by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	shared_ptr& operator=(shared_ptr&& _Right) _NOEXCEPT
		{	// take resource from _Right
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) _NOEXCEPT
		{	// take resource from _Right
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

 #if _HAS_AUTO_PTR_ETC
	template<class _Ty2>
		shared_ptr& operator=(auto_ptr<_Ty2>&& _Right)
		{	// assign ownership of resource pointed to by _Right
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}
 #endif /* _HAS_AUTO_PTR_ETC */
# 1497 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

	template<class _Ux,
		class _Dx>
		shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right)
		{	// move from unique_ptr
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

	void swap(shared_ptr& _Other) _NOEXCEPT
		{	// swap pointers
		this->_Swap(_Other);
		}

	void reset() _NOEXCEPT
		{	// release resource and convert to empty shared_ptr object
		shared_ptr().swap(*this);
		}

	template<class _Ux>
		void reset(_Ux * _Px)
		{	// release, take ownership of _Px
		shared_ptr(_Px).swap(*this);
		}

	template<class _Ux,
		class _Dx>
		void reset(_Ux * _Px, _Dx _Dt)
		{	// release, take ownership of _Px, with deleter _Dt
		shared_ptr(_Px, _Dt).swap(*this);
		}

	template<class _Ux,
		class _Dx,
		class _Alloc>
		void reset(_Ux * _Px, _Dx _Dt, _Alloc _Ax)
		{	// release, take ownership of _Px, with deleter _Dt, allocator _Ax
		shared_ptr(_Px, _Dt, _Ax).swap(*this);
		}

	using _Mybase::get;

	template<class _Ty2 = _Ty,
		enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
		_NODISCARD _Ty2& operator*() const _NOEXCEPT
		{	// return reference to resource
		return (*get());
		}

	template<class _Ty2 = _Ty,
		enable_if_t<!is_array_v<_Ty2>, int> = 0>
		_NODISCARD _Ty2 * operator->() const _NOEXCEPT
		{	// return pointer to resource
		return (get());
		}

	template<class _Ty2 = _Ty,
		class _Elem = element_type,
		enable_if_t<is_array_v<_Ty2>, int> = 0>
		_NODISCARD _Elem& operator[](ptrdiff_t _Idx) const
		{	// subscript
		return (get()[_Idx]);
		}

	_NODISCARD _CXX17_DEPRECATE_SHARED_PTR_UNIQUE bool unique() const _NOEXCEPT
		{	// return true if no other shared_ptr object owns this resource
		return (this->use_count() == 1);
		}

	explicit operator bool() const _NOEXCEPT
		{	// test if shared_ptr object owns a resource
		return (get() != nullptr);
		}

private:
	template<class _Ux>
		void _Setp(_Ux * _Px, true_type)
		{	// take ownership of _Px
		_Setpd(_Px, default_delete<_Ux[]>{});
		}

	template<class _Ux>
		void _Setp(_Ux * _Px, false_type)
		{	// take ownership of _Px
		_TRY_BEGIN	// allocate control block and set
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));
		_CATCH_ALL	// allocation failed, delete resource
		delete _Px;
		_RERAISE;
		_CATCH_END
		}

	template<class _UxptrOrNullptr,
		class _Dx>
		void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt)
		{	// take ownership of _Px, deleter _Dt
		_TRY_BEGIN	// allocate control block and set
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Px, _STD move(_Dt)));
		_CATCH_ALL	// allocation failed, delete resource
		_Dt(_Px);
		_RERAISE;
		_CATCH_END
		}

	template<class _UxptrOrNullptr,
		class _Dx,
		class _Alloc>
		void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax)
		{	// take ownership of _Px, deleter _Dt, allocator _Ax
		using _Refd = _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>;
		using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refd>;
		using _Alref_traits = allocator_traits<_Alref_alloc>;
		_Alref_alloc _Alref(_Ax);

		_TRY_BEGIN	// allocate control block and set
		const auto _Pfancy = _Alref_traits::allocate(_Alref, 1);
		_Refd * const _Pref = _Unfancy(_Pfancy);
			_TRY_BEGIN
			_Alref_traits::construct(_Alref, _Pref, _Px, _STD move(_Dt), _Ax);
			_Set_ptr_rep_and_enable_shared(_Px, _Pref);
			_CATCH_ALL
			_Alref_traits::deallocate(_Alref, _Pfancy, 1);
			_RERAISE;
			_CATCH_END
		_CATCH_ALL	// allocation failed, delete resource
		_Dt(_Px);
		_RERAISE;
		_CATCH_END
		}

	template<class _Ty0,
		class... _Types>
		friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

	template<class _Ty0,
		class _Alloc,
		class... _Types>
		friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

	template<class _Ux>
		void _Set_ptr_rep_and_enable_shared(_Ux * _Px, _Ref_count_base * _Rx)
		{	// take ownership of _Px
		this->_Set_ptr_rep(_Px, _Rx);
		_Enable_shared_from_this(*this, _Px);
		}

	void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base * _Rx)
		{	// take ownership of nullptr
		this->_Set_ptr_rep(nullptr, _Rx);
		}
	};

#if _HAS_DEDUCTION_GUIDES
template<class _Ty>
	shared_ptr(weak_ptr<_Ty>) -> shared_ptr<_Ty>;

template<class _Ty,
	class _Dx>
	shared_ptr(unique_ptr<_Ty, _Dx>) -> shared_ptr<_Ty>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 1657 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

template<class _Ty1,
	class _Ty2>
	_NODISCARD bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) _NOEXCEPT
	{
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) _NOEXCEPT
	{
	return (_Left.get() != _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) _NOEXCEPT
	{
	return (_Left.get() < _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) _NOEXCEPT
	{
	return (_Left.get() >= _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) _NOEXCEPT
	{
	return (_Left.get() > _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) _NOEXCEPT
	{
	return (_Left.get() <= _Right.get());
	}

template<class _Ty>
	_NODISCARD bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) _NOEXCEPT
	{
	return (_Left.get() == nullptr);
	}

template<class _Ty>
	_NODISCARD bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) _NOEXCEPT
	{
	return (nullptr == _Right.get());
	}

template<class _Ty>
	_NODISCARD bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) _NOEXCEPT
	{
	return (_Left.get() != nullptr);
	}

template<class _Ty>
	_NODISCARD bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) _NOEXCEPT
	{
	return (nullptr != _Right.get());
	}

template<class _Ty>
	_NODISCARD bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) _NOEXCEPT
	{
	return (_Left.get() < static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	_NODISCARD bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) _NOEXCEPT
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) < _Right.get());
	}

template<class _Ty>
	_NODISCARD bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) _NOEXCEPT
	{
	return (_Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	_NODISCARD bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) _NOEXCEPT
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) >= _Right.get());
	}

template<class _Ty>
	_NODISCARD bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) _NOEXCEPT
	{
	return (_Left.get() > static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	_NODISCARD bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) _NOEXCEPT
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) > _Right.get());
	}

template<class _Ty>
	_NODISCARD bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) _NOEXCEPT
	{
	return (_Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	_NODISCARD bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) _NOEXCEPT
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) <= _Right.get());
	}

template<class _Elem,
	class _Traits,
	class _Ty>
	basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px)
	{	// write contained pointer to stream
	return (_Out << _Px.get());
	}

template<class _Ty>
	void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) _NOEXCEPT
	{	// swap _Left and _Right shared_ptrs
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) _NOEXCEPT
	{	// static_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) _NOEXCEPT
	{	// const_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

template<class _Ty1,
	class _Ty2>
	_NODISCARD shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) _NOEXCEPT
	{	// reinterpret_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

#ifdef _CPPRTTI
template<class _Ty1,
	class _Ty2>
	_NODISCARD shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) _NOEXCEPT
	{	// dynamic_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());

	if (_Ptr)
		{
		return (shared_ptr<_Ty1>(_Other, _Ptr));
		}

	return (shared_ptr<_Ty1>());
	}
#else /* _CPPRTTI */
# 1825 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>&) _NOEXCEPT = delete;	// requires /GR option
#endif /* _CPPRTTI */
# 1829 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

#if _HAS_STATIC_RTTI
template<class _Dx,
	class _Ty>
	_NODISCARD _Dx * get_deleter(const shared_ptr<_Ty>& _Sx) _NOEXCEPT
	{	// return pointer to shared_ptr's deleter object if its type is _Dx
	if (_Sx._Rep)
		{
		return (static_cast<_Dx *>(_Sx._Rep->_Get_deleter(typeid(_Dx))));
		}

	return (nullptr);
	}
#else /* _HAS_STATIC_RTTI */
# 1843 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
template<class _Dx,
	class _Ty>
	_Dx * get_deleter(const shared_ptr<_Ty>&) _NOEXCEPT = delete;	// requires static RTTI
#endif /* _HAS_STATIC_RTTI */
# 1847 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

	// CLASS TEMPLATE _Ref_count_obj
template<class _Ty>
	class _Ref_count_obj
		: public _Ref_count_base
	{	// handle reference counting for object in control block, no allocator
public:
	template<class... _Types>
		explicit _Ref_count_obj(_Types&&... _Args)
		: _Ref_count_base()
		{	// construct from argument list
		::new (static_cast<void *>(&_Storage)) _Ty(_STD forward<_Types>(_Args)...);
		}

	_Ty * _Getptr()
		{	// get pointer
		return (reinterpret_cast<_Ty *>(&_Storage));
		}

private:
	virtual void _Destroy() _NOEXCEPT override
		{	// destroy managed resource
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this() _NOEXCEPT override
		{	// destroy self
		delete this;
		}

	aligned_union_t<1, _Ty> _Storage;
	};

	// CLASS TEMPLATE _Ref_count_obj_alloc
template<class _Ty,
	class _Alloc>
	class _Ref_count_obj_alloc
		: public _Ref_count_base
	{	// handle reference counting for object in control block, allocator
public:
	template<class... _Types>
		explicit _Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg)
		{	// construct from argument list, allocator
		::new (static_cast<void *>(&_Mypair._Get_second())) _Ty(_STD forward<_Types>(_Args)...);
		}

	_Ty * _Getptr()
		{	// get pointer
		return (reinterpret_cast<_Ty *>(&_Mypair._Get_second()));
		}

private:
	using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc>;
	using _Mystoragety = aligned_union_t<1, _Ty>;

	virtual void _Destroy() _NOEXCEPT override
		{	// destroy managed resource
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this() _NOEXCEPT override
		{	// destroy self
		_Myalty _Al = _Mypair._Get_first();
		allocator_traits<_Myalty>::destroy(_Al, this);
		_Deallocate_plain(_Al, this);
		}

	_Compressed_pair<_Myalty, _Mystoragety> _Mypair;
	};

	// FUNCTION TEMPLATE make_shared
template<class _Ty,
	class... _Types>
	_NODISCARD inline shared_ptr<_Ty> make_shared(_Types&&... _Args)
	{	// make a shared_ptr
	const auto _Rx = new _Ref_count_obj<_Ty>(_STD forward<_Types>(_Args)...);

	shared_ptr<_Ty> _Ret;
	_Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Rx);
	return (_Ret);
	}

	// FUNCTION TEMPLATE allocate_shared
template<class _Ty,
	class _Alloc,
	class... _Types>
	_NODISCARD inline shared_ptr<_Ty> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args)
	{	// make a shared_ptr
	using _Refoa = _Ref_count_obj_alloc<_Ty, _Alloc>;
	using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refoa>;
	using _Alref_traits = allocator_traits<_Alref_alloc>;
	_Alref_alloc _Alref(_Al_arg);

	const auto _Rx = _Alref_traits::allocate(_Alref, 1);

	_TRY_BEGIN
		_Alref_traits::construct(_Alref, _Unfancy(_Rx), _Al_arg, _STD forward<_Types>(_Args)...);
	_CATCH_ALL
		_Alref_traits::deallocate(_Alref, _Rx, 1);
	_RERAISE;
	_CATCH_END

	shared_ptr<_Ty> _Ret;
	_Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Unfancy(_Rx));
	return (_Ret);
	}

	// CLASS TEMPLATE weak_ptr
template<class _Ty>
	class weak_ptr
		: public _Ptr_base<_Ty>
	{	// class for pointer to reference counted resource
public:
	constexpr weak_ptr() _NOEXCEPT
		{	// construct empty weak_ptr object
		}

	weak_ptr(const weak_ptr& _Other) _NOEXCEPT
		{	// construct weak_ptr object for resource pointed to by _Other
		this->_Weakly_construct_from(_Other);
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		weak_ptr(const shared_ptr<_Ty2>& _Other) _NOEXCEPT
		{	// construct weak_ptr object for resource owned by _Other
		this->_Weakly_construct_from(_Other);
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		weak_ptr(const weak_ptr<_Ty2>& _Other) _NOEXCEPT
		{	// construct weak_ptr object for resource pointed to by _Other
		this->_Weakly_construct_from(_Other.lock());
		}

	weak_ptr(weak_ptr&& _Other) _NOEXCEPT
		{	// move construct from _Other
		this->_Move_construct_from(_STD move(_Other));
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		weak_ptr(weak_ptr<_Ty2>&& _Other) _NOEXCEPT
		{	// move construct from _Other
		this->_Weakly_construct_from(_Other.lock());
		_Other.reset();
		}

	~weak_ptr() _NOEXCEPT
		{	// release resource
		this->_Decwref();
		}

	weak_ptr& operator=(const weak_ptr& _Right) _NOEXCEPT
		{	// assign from _Right
		weak_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) _NOEXCEPT
		{	// assign from _Right
		weak_ptr(_Right).swap(*this);
		return (*this);
		}

	weak_ptr& operator=(weak_ptr&& _Right) _NOEXCEPT
		{	// move assign from _Right
		weak_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) _NOEXCEPT
		{	// move assign from _Right
		weak_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) _NOEXCEPT
		{	// assign from _Right
		weak_ptr(_Right).swap(*this);
		return (*this);
		}

	void reset() _NOEXCEPT
		{	// release resource, convert to null weak_ptr object
		weak_ptr().swap(*this);
		}

	void swap(weak_ptr& _Other) _NOEXCEPT
		{	// swap pointers
		this->_Swap(_Other);
		}

	_NODISCARD bool expired() const _NOEXCEPT
		{	// return true if resource no longer exists
		return (this->use_count() == 0);
		}

	_NODISCARD shared_ptr<_Ty> lock() const _NOEXCEPT
		{	// convert to shared_ptr
		shared_ptr<_Ty> _Ret;
		(void) _Ret._Construct_from_weak(*this);
		return (_Ret);
		}
	};

#if _HAS_DEDUCTION_GUIDES
template<class _Ty>
	weak_ptr(shared_ptr<_Ty>) -> weak_ptr<_Ty>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 2062 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

template<class _Ty>
	void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) _NOEXCEPT
	{	// swap contents of _Left and _Right
	_Left.swap(_Right);
	}

	// CLASS TEMPLATE enable_shared_from_this
template<class _Ty>
	class enable_shared_from_this
	{	// provide member functions that create shared_ptr to this
public:
	using _Esft_type = enable_shared_from_this;

	_NODISCARD shared_ptr<_Ty> shared_from_this()
		{	// return shared_ptr
		return (shared_ptr<_Ty>(_Wptr));
		}

	_NODISCARD shared_ptr<const _Ty> shared_from_this() const
		{	// return shared_ptr
		return (shared_ptr<const _Ty>(_Wptr));
		}

	_NODISCARD weak_ptr<_Ty> weak_from_this() _NOEXCEPT
		{	// return weak_ptr
		return (_Wptr);
		}

	_NODISCARD weak_ptr<const _Ty> weak_from_this() const _NOEXCEPT
		{	// return weak_ptr
		return (_Wptr);
		}

protected:
	constexpr enable_shared_from_this() _NOEXCEPT
		: _Wptr()
		{	// construct
		}

	enable_shared_from_this(const enable_shared_from_this&) _NOEXCEPT
		: _Wptr()
		{	// construct (must value-initialize _Wptr)
		}

	enable_shared_from_this& operator=(const enable_shared_from_this&) _NOEXCEPT
		{	// assign (must not change _Wptr)
		return (*this);
		}

	~enable_shared_from_this() = default;

private:
	template<class _Other,
		class _Yty>
		friend void _Enable_shared_from_this1(const shared_ptr<_Other>& _This, _Yty * _Ptr, true_type);

	mutable weak_ptr<_Ty> _Wptr;
	};


	// CLASS TEMPLATE unique_ptr AND HELPERS

	// STRUCT TEMPLATE default_delete
template<class _Ty>
	struct default_delete
	{	// default deleter for unique_ptr
	constexpr default_delete() _NOEXCEPT = default;

	template<class _Ty2,
		enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0>
		default_delete(const default_delete<_Ty2>&) _NOEXCEPT
		{	// construct from another default_delete
		}

	void operator()(_Ty * _Ptr) const _NOEXCEPT
		{	// delete a pointer
		static_assert(0 < sizeof (_Ty),
			"can't delete an incomplete type");
		delete _Ptr;
		}
	};

template<class _Ty>
	struct default_delete<_Ty[]>
	{	// default deleter for unique_ptr to array of unknown size
	constexpr default_delete() _NOEXCEPT = default;

	template<class _Uty,
		enable_if_t<is_convertible_v<_Uty(*)[], _Ty(*)[]>, int> = 0>
		default_delete(const default_delete<_Uty[]>&) _NOEXCEPT
		{	// construct from another default_delete
		}

	template<class _Uty,
		enable_if_t<is_convertible_v<_Uty(*)[], _Ty(*)[]>, int> = 0>
		void operator()(_Uty * _Ptr) const _NOEXCEPT
		{	// delete a pointer
		static_assert(0 < sizeof (_Uty),
			"can't delete an incomplete type");
		delete[] _Ptr;
		}
	};

		// STRUCT TEMPLATE _Get_deleter_pointer_type
template<class _Ty,
	class _Dx_noref,
	class = void>
	struct _Get_deleter_pointer_type
	{	// provide fallback
	typedef _Ty * type;
	};

template<class _Ty,
	class _Dx_noref>
	struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>>
	{	// get _Dx_noref::pointer
	typedef typename _Dx_noref::pointer type;
	};

	// CLASS TEMPLATE _Unique_ptr_base
template<class _Ty,
	class _Dx>
	class _Unique_ptr_base
	{	// stores pointer and deleter
public:
	typedef remove_reference_t<_Dx> _Dx_noref;
	typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

	template<class _Ptr2,
		class _Dx2>
		_Unique_ptr_base(_Ptr2 _Ptr, _Dx2&& _Dt)
		: _Mypair(_One_then_variadic_args_t(), _STD forward<_Dx2>(_Dt), _Ptr)
		{	// construct with compatible pointer and deleter
		}

	template<class _Ptr2>
		constexpr _Unique_ptr_base(_Ptr2 _Ptr)
		: _Mypair(_Zero_then_variadic_args_t(), _Ptr)
		{	// construct with compatible pointer
		}

	_NODISCARD _Dx& get_deleter() _NOEXCEPT
		{	// return reference to deleter
		return (_Mypair._Get_first());
		}

	_NODISCARD const _Dx& get_deleter() const _NOEXCEPT
		{	// return const reference to deleter
		return (_Mypair._Get_first());
		}

	pointer& _Myptr() _NOEXCEPT
		{	// return reference to pointer
		return (_Mypair._Get_second());
		}

	const pointer& _Myptr() const _NOEXCEPT
		{	// return const reference to pointer
		return (_Mypair._Get_second());
		}

	_Compressed_pair<_Dx, pointer> _Mypair;
	};

template<class _Dx2>
	using _Unique_ptr_enable_default_t = enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>,
		is_default_constructible<_Dx2>>, int>;

	// CLASS TEMPLATE unique_ptr SCALAR
template<class _Ty,
	class _Dx>	// = default_delete<_Ty>
	class unique_ptr
		: public _Unique_ptr_base<_Ty, _Dx>
	{	// non-copyable pointer to an object
public:
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	using _Mybase::get_deleter;

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr() _NOEXCEPT
			: _Mybase(pointer())
		{	// default construct
		}

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr(nullptr_t) _NOEXCEPT
			: _Mybase(pointer())
		{	// null pointer construct
		}

	unique_ptr& operator=(nullptr_t) _NOEXCEPT
		{	// assign a null pointer
		reset();
		return (*this);
		}

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		explicit unique_ptr(pointer _Ptr) _NOEXCEPT
			: _Mybase(_Ptr)
		{	// construct with pointer
		}

	template<class _Dx2 = _Dx,
		enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
		unique_ptr(pointer _Ptr, const _Dx& _Dt) _NOEXCEPT
			: _Mybase(_Ptr, _Dt)
		{	// construct with pointer and (maybe const) deleter&
		}

	template<class _Dx2 = _Dx,
		enable_if_t<conjunction_v<negation<is_reference<_Dx2>>,
			is_constructible<_Dx2, _Dx2>>, int> = 0>
		unique_ptr(pointer _Ptr, _Dx&& _Dt) _NOEXCEPT
			: _Mybase(_Ptr, _STD move(_Dt))
		{	// construct by moving deleter
		}

	template<class _Dx2 = _Dx,
		enable_if_t<conjunction_v<is_reference<_Dx2>,
			is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
		unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

	unique_ptr(unique_ptr&& _Right) _NOEXCEPT
		: _Mybase(_Right.release(),
			_STD forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	template<class _Ty2,
		class _Dx2,
		enable_if_t<conjunction_v<negation<is_array<_Ty2>>,
			is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
			conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>
		>, int> = 0>
		unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) _NOEXCEPT
			: _Mybase(_Right.release(),
				_STD forward<_Dx2>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

 #if _HAS_AUTO_PTR_ETC
	template<class _Ty2,
		enable_if_t<conjunction_v<is_convertible<_Ty2 *, _Ty *>,
			is_same<_Dx, default_delete<_Ty>>>, int> = 0>
		unique_ptr(auto_ptr<_Ty2>&& _Right) _NOEXCEPT
			: _Mybase(_Right.release())
		{	// construct by moving _Right
		}
 #endif /* _HAS_AUTO_PTR_ETC */
# 2319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

	template<class _Ty2,
		class _Dx2,
		enable_if_t<conjunction_v<negation<is_array<_Ty2>>,
			is_assignable<_Dx&, _Dx2>,
			is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>
		>, int> = 0>
		unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) _NOEXCEPT
		{	// assign by moving _Right
		reset(_Right.release());
		this->get_deleter() = _STD forward<_Dx2>(_Right.get_deleter());
		return (*this);
		}

	unique_ptr& operator=(unique_ptr&& _Right) _NOEXCEPT
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, do the move
			reset(_Right.release());
			this->get_deleter() = _STD forward<_Dx>(_Right.get_deleter());
			}
		return (*this);
		}

	void swap(unique_ptr& _Right) _NOEXCEPT
		{	// swap elements
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}

	~unique_ptr() _NOEXCEPT
		{	// destroy the object
		if (get() != pointer())
			{
			this->get_deleter()(get());
			}
		}

	_NODISCARD add_lvalue_reference_t<_Ty> operator*() const
		{	// return reference to object
		return (*get());
		}

	_NODISCARD pointer operator->() const _NOEXCEPT
		{	// return pointer to class object
		return (this->_Myptr());
		}

	_NODISCARD pointer get() const _NOEXCEPT
		{	// return pointer to object
		return (this->_Myptr());
		}

	explicit operator bool() const _NOEXCEPT
		{	// test for non-null pointer
		return (get() != pointer());
		}

	pointer release() _NOEXCEPT
		{	// yield ownership of pointer
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}

	void reset(pointer _Ptr = pointer()) _NOEXCEPT
		{	// establish new pointer
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			{
			this->get_deleter()(_Old);
			}
		}

	unique_ptr(const unique_ptr&) = delete;
	unique_ptr& operator=(const unique_ptr&) = delete;
	};

	// CLASS TEMPLATE unique_ptr ARRAY
template<class _Ty,
	class _Dx>
	class unique_ptr<_Ty[], _Dx>
		: public _Unique_ptr_base<_Ty, _Dx>
	{	// non-copyable pointer to an array object
public:
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	using _Mybase::get_deleter;

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr() _NOEXCEPT
			: _Mybase(pointer())
		{	// default construct
		}

	template<class _Uty,
		class _Is_nullptr = is_same<_Uty, nullptr_t>>
		using _Enable_ctor_reset = enable_if_t<
			is_same_v<_Uty, pointer>
			|| _Is_nullptr::value
			|| (is_same_v<pointer, element_type *>
			&& is_pointer_v<_Uty>
			&& is_convertible_v<
				remove_pointer_t<_Uty>(*)[],
				element_type(*)[]
			>)>;

	template<class _Uty,
		class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0,
		class = _Enable_ctor_reset<_Uty>>
		explicit unique_ptr(_Uty _Ptr) _NOEXCEPT
			: _Mybase(_Ptr)
		{	// construct with pointer
		}

	template<class _Uty,
		class _Dx2 = _Dx,
		enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
		class = _Enable_ctor_reset<_Uty>>
		unique_ptr(_Uty _Ptr, const _Dx& _Dt) _NOEXCEPT
			: _Mybase(_Ptr, _Dt)
		{	// construct with pointer and (maybe const) deleter&
		}

	template<class _Uty,
		class _Dx2 = _Dx,
		enable_if_t<conjunction_v<negation<is_reference<_Dx2>>,
			is_constructible<_Dx2, _Dx2>>, int> = 0,
		class = _Enable_ctor_reset<_Uty>>
		unique_ptr(_Uty _Ptr, _Dx&& _Dt) _NOEXCEPT
			: _Mybase(_Ptr, _STD move(_Dt))
		{	// construct by moving deleter
		}

	template<class _Uty,
		class _Dx2 = _Dx,
		enable_if_t<conjunction_v<is_reference<_Dx2>,
			is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
		unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

	unique_ptr(unique_ptr&& _Right) _NOEXCEPT
		: _Mybase(_Right.release(),
			_STD forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	unique_ptr& operator=(unique_ptr&& _Right) _NOEXCEPT
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, do the swap
			reset(_Right.release());
			this->get_deleter() = _STD move(_Right.get_deleter());
			}
		return (*this);
		}

	template<class _Uty,
		class _Ex,
		bool _More,
		class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
		class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
		using _Enable_conversion = enable_if_t<
			is_array_v<_Uty>
			&& is_same_v<pointer, element_type *>
			&& is_same_v<_UP_pointer, _UP_element_type *>
			&& is_convertible_v<_UP_element_type(*)[], element_type(*)[]>
			&& _More>;

	template<class _Uty,
		class _Ex,
		class = _Enable_conversion<_Uty, _Ex,
			is_reference_v<_Dx>
			? is_same_v<_Ex, _Dx>
			: is_convertible_v<_Ex, _Dx>>>
		unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) _NOEXCEPT
			: _Mybase(_Right.release(),
				_STD forward<_Ex>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	template<class _Uty,
		class _Ex,
		class = _Enable_conversion<_Uty, _Ex,
			is_assignable_v<_Dx&, _Ex>>>
		unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) _NOEXCEPT
		{	// assign by moving _Right
		reset(_Right.release());
		this->get_deleter() = _STD forward<_Ex>(_Right.get_deleter());
		return (*this);
		}

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr(nullptr_t) _NOEXCEPT
			: _Mybase(pointer())
		{	// null pointer construct
		}

	unique_ptr& operator=(nullptr_t) _NOEXCEPT
		{	// assign a null pointer
		reset();
		return (*this);
		}

	void reset(nullptr_t = nullptr) _NOEXCEPT
		{	// establish new null pointer
		reset(pointer());
		}

	void swap(unique_ptr& _Right) _NOEXCEPT
		{	// swap elements
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}

	~unique_ptr() _NOEXCEPT
		{	// destroy the object
		_Delete();
		}

	_NODISCARD _Ty& operator[](size_t _Idx) const
		{	// return reference to object
		return (get()[_Idx]);
		}

	_NODISCARD pointer get() const _NOEXCEPT
		{	// return pointer to object
		return (this->_Myptr());
		}

	explicit operator bool() const _NOEXCEPT
		{	// test for non-null pointer
		return (get() != pointer());
		}

	pointer release() _NOEXCEPT
		{	// yield ownership of pointer
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}

	template<class _Uty,
		class = _Enable_ctor_reset<_Uty, false_type>>
		void reset(_Uty _Ptr) _NOEXCEPT
		{	// establish new pointer
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			{
			this->get_deleter()(_Old);
			}
		}

	unique_ptr(const unique_ptr&) = delete;
	unique_ptr& operator=(const unique_ptr&) = delete;

private:
	void _Delete()
		{	// delete the pointer
		if (get() != pointer())
			{
			this->get_deleter()(get());
			}
		}
	};


	// FUNCTION TEMPLATE make_unique
template<class _Ty,
	class... _Types,
	enable_if_t<!is_array_v<_Ty>, int> = 0>
	_NODISCARD inline unique_ptr<_Ty> make_unique(_Types&&... _Args)
	{	// make a unique_ptr
	return (unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...)));
	}

template<class _Ty,
	enable_if_t<is_array_v<_Ty> && extent<_Ty>::value == 0, int> = 0>	// TRANSITION, VSO#459080 (fixed)
	_NODISCARD inline unique_ptr<_Ty> make_unique(size_t _Size)
	{	// make a unique_ptr
	typedef remove_extent_t<_Ty> _Elem;
	return (unique_ptr<_Ty>(new _Elem[_Size]()));
	}

template<class _Ty,
	class... _Types,
	enable_if_t<extent<_Ty>::value != 0, int> = 0>	// TRANSITION, VSO#459080 (fixed)
	void make_unique(_Types&&...) = delete;


	// FUNCTION TEMPLATE _Make_unique_alloc
template<class _Alloc>
	struct _Allocator_deleter
	{
	_Alloc _Al;

	using pointer = typename allocator_traits<_Alloc>::pointer;
	void operator()(pointer _Ptr) _NOEXCEPT
		{	// delete the pointer
		allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_Ptr));
		_Al.deallocate(_Ptr, 1);
		}
	};

template<class _Alloc>
	using _Unique_ptr_alloc = unique_ptr<typename _Alloc::value_type, _Allocator_deleter<_Alloc>>;

template<class _Alloc,
	class... _Args>
	_Unique_ptr_alloc<_Alloc> _Make_unique_alloc(_Alloc& _Al, _Args&&... _Vals)
	{	// construct an object with an allocator and return it owned by a unique_ptr
	auto _Ptr = _Al.allocate(1);
	_TRY_BEGIN
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Ptr), _STD forward<_Args>(_Vals)...);
	_CATCH_ALL
		_Al.deallocate(_Ptr, 1);
	_RERAISE;
	_CATCH_END

	return (_Unique_ptr_alloc<_Alloc>(_Ptr, _Allocator_deleter<_Alloc>{_Al}));
	}

template<class _Ty,
	class _Dx,
	enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
	void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) _NOEXCEPT
	{	// swap _Left with _Right
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	_NODISCARD bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left equals _Right
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	_NODISCARD bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left doesn't equal _Right
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	_NODISCARD bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left precedes _Right
	typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
	typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
	typedef common_type_t<_Ptr1, _Ptr2> _Common;
	return (less<_Common>()(_Left.get(), _Right.get()));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	_NODISCARD bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left doesn't precede _Right
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	_NODISCARD bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Right precedes _Left
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	_NODISCARD bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Right doesn't precede _Left
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) _NOEXCEPT
	{	// test if unique_ptr == nullptr
	return (!_Left);
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) _NOEXCEPT
	{	// test if nullptr == unique_ptr
	return (!_Right);
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) _NOEXCEPT
	{	// test if unique_ptr != nullptr
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator!=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) _NOEXCEPT
	{	// test if nullptr != unique_ptr
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr < nullptr
	typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
	return (less<_Ptr>()(_Left.get(), _Right));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr < unique_ptr
	typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
	return (less<_Ptr>()(_Left, _Right.get()));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr >= nullptr
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr >= unique_ptr
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr > nullptr
	return (_Right < _Left);
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr > unique_ptr
	return (_Right < _Left);
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr <= nullptr
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Dx>
	_NODISCARD bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr <= unique_ptr
	return (!(_Right < _Left));
	}

		// GARBAGE COLLECTION
enum class pointer_safety {	// return codes for get_pointer_safety
	relaxed,
	preferred,
	strict
	};

inline void declare_reachable(void *)
	{	// increment pointer reachable count
	}

template<class _Ty> inline
	_Ty * undeclare_reachable(_Ty * _Ptr)
	{	// decrement pointer reachable count
	return (_Ptr);
	}

inline void declare_no_pointers(char *, size_t)
	{	// declare region to be pointer free
	}

inline void undeclare_no_pointers(char *, size_t)
	{	// undeclare region to be pointer free
	}

inline pointer_safety get_pointer_safety() _NOEXCEPT
	{	// get pointer safety status
	return (pointer_safety::relaxed);
	}

		// STRUCT TEMPLATE owner_less
template<class _Ty = void>
	struct owner_less;	// not defined

template<class _Ty>
	struct owner_less<shared_ptr<_Ty>>
	{	// functor for owner_before
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef shared_ptr<_Ty> first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef shared_ptr<_Ty> second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;

	_NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	_NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	_NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

template<class _Ty>
	struct owner_less<weak_ptr<_Ty>>
	{	// functor for owner_before
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef weak_ptr<_Ty> first_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef weak_ptr<_Ty> second_argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef bool result_type;

	_NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	_NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	_NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

template<>
	struct owner_less<void>
	{	// functor for owner_before
	using is_transparent = int;

	template<class _Ty,
		class _Uty>
		_NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		_NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		_NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		_NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const _NOEXCEPT
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

	// STRUCT TEMPLATE SPECIALIZATION hash
template<class _Ty,
	class _Dx>
	struct hash<unique_ptr<_Ty, _Dx>>
		: _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
			is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>>
	{	// hash functor
	static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval)
			_NOEXCEPT_COND(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) // strengthened
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get()));
		}
	};

template<class _Ty>
	struct hash<shared_ptr<_Ty>>
	{	// hash functor
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef shared_ptr<_Ty> argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const shared_ptr<_Ty>& _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<typename shared_ptr<_Ty>::element_type *>()(_Keyval.get()));
		}
	};

		// FUNCTION align
inline void * align(size_t _Bound, size_t _Size, void *& _Ptr, size_t& _Space) _NOEXCEPT
	{	// try to carve out _Size bytes on boundary _Bound
	size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
	if (_Off != 0)
		{
		_Off = _Bound - _Off;	// number of bytes to skip
		}

	if (_Space < _Off || _Space - _Off < _Size)
		{
		return (0);
		}

	// enough room, update
	_Ptr = static_cast<char *>(_Ptr) + _Off;
	_Space -= _Off;
	return (_Ptr);
	}



		/* SPIN LOCKS */
_EXTERN_C
_CRTIMP2_PURE void __cdecl _Lock_shared_ptr_spin_lock();
_CRTIMP2_PURE void __cdecl _Unlock_shared_ptr_spin_lock();
_END_EXTERN_C

		// WRAP SPIN-LOCK
struct _Shared_ptr_spin_lock
	{	// class to manage a spin lock for shared_ptr atomic operations
	_Shared_ptr_spin_lock()
		{	// lock the spin lock
		_Lock_shared_ptr_spin_lock();
		}

	~_Shared_ptr_spin_lock() _NOEXCEPT
		{	// unlock the spin lock
		_Unlock_shared_ptr_spin_lock();
		}
	};

template<class _Ty>
	_NODISCARD inline bool atomic_is_lock_free(const shared_ptr<_Ty> *)
	{	// return true if atomic operations on shared_ptr<_Ty> are lock-free
	return (false);
	}

template<class _Ty>
	_NODISCARD inline shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> * _Ptr,
		memory_order)
	{	// load *_Ptr atomically
	_Shared_ptr_spin_lock _Lock;
	shared_ptr<_Ty> _Result = *_Ptr;
	return (_Result);
	}

template<class _Ty>
	_NODISCARD inline shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> * _Ptr)
	{	// load *_Ptr atomically
	return (_STD atomic_load_explicit(_Ptr, memory_order_seq_cst));
	}

template<class _Ty> inline
	void atomic_store_explicit(shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other,
		memory_order)
	{	// store _Other to *_Ptr atomically
	_Shared_ptr_spin_lock _Lock;
	_Ptr->swap(_Other);
	}

template<class _Ty> inline
	void atomic_store(shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other)
	{	// store _Other to *_Ptr atomically
	_STD atomic_store_explicit(_Ptr, _STD move(_Other), memory_order_seq_cst);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_exchange_explicit(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other,
		memory_order)
	{	// copy _Other to *_Ptr and return previous value of *_Ptr atomically
	_Shared_ptr_spin_lock _Lock;
	_Ptr->swap(_Other);
	return (_Other);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_exchange(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other)
	{	// copy _Other to *_Ptr and return previous value of *_Ptr atomically
	return (_STD atomic_exchange_explicit(_Ptr, _STD move(_Other), memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_weak_explicit(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp, shared_ptr<_Ty> _Value,
		memory_order, memory_order)
	{	// atomically compare and exchange
	shared_ptr<_Ty> _Old_exp;	// destroyed outside spin lock
	_Shared_ptr_spin_lock _Lock;
	bool _Success = _Ptr->get() == _Exp->get()
		&& !_Ptr->owner_before(*_Exp)
		&& !_Exp->owner_before(*_Ptr);
	if (_Success)
		_Ptr->swap(_Value);
	else
		{	// match failed
		_Exp->swap(_Old_exp);
		*_Exp = *_Ptr;
		}
	return (_Success);
	}

template<class _Ty> inline
	bool atomic_compare_exchange_weak(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp,
			shared_ptr<_Ty> _Value)
	{	// atomically compare and exchange
	return (_STD atomic_compare_exchange_weak_explicit(_Ptr, _Exp, _STD move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_strong_explicit(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp, shared_ptr<_Ty> _Value,
		memory_order, memory_order)
	{	// atomically compare and exchange
	return (_STD atomic_compare_exchange_weak_explicit(_Ptr, _Exp, _STD move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_strong(
	shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp,
		shared_ptr<_Ty> _Value)
	{	// atomically compare and exchange
	return (_STD atomic_compare_exchange_strong_explicit(_Ptr, _Exp, _STD move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
using _STD allocate_shared;
using _STD bad_weak_ptr;
using _STD const_pointer_cast;
using _STD dynamic_pointer_cast;
using _STD enable_shared_from_this;
using _STD get_deleter;
using _STD make_shared;
using _STD shared_ptr;
using _STD static_pointer_cast;
using _STD swap;
using _STD weak_ptr;
}
#endif /* _HAS_TR1_NAMESPACE */
# 3095 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 3101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3
#endif /* _MEMORY_ */
# 3102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\memory" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 7 "ice.cpp" 2
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 7 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 1 3
// string standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
#ifndef _STRING_
#define _STRING_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <istream>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
#if 0 /* expanded by -frewrite-includes */
#include <xstring_insert.h>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring_insert.h" 1 3
// xstring_insert.h internal header
// Copyright (c) Microsoft Corporation. All rights reserved.
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 4 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring_insert.h" 3
#ifndef _XSTRING_INSERT_H
#define _XSTRING_INSERT_H
#ifndef RC_INVOKED

#if 0 /* expanded by -frewrite-includes */
#include <ostream>
#endif /* expanded by -frewrite-includes */
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring_insert.h" 3
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring_insert.h" 3

#pragma pack(push,_CRT_PACKING)
#pragma warning(push,_STL_WARNING_LEVEL)
#pragma warning(disable: _STL_DISABLED_WARNINGS)
#pragma push_macro("new")
#undef new

_STD_BEGIN

template<class _Elem,
	class _Traits,
	class _SizeT> inline
	basic_ostream<_Elem, _Traits>& _Insert_string(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const _Elem * const _Data, const _SizeT _Size)
	{	// insert a character-type sequence into _Ostr as if through a basic_string copy
	ios_base::iostate _State = ios_base::goodbit;
	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size
		? 0 : static_cast<_SizeT>(_Ostr.width()) - _Size;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert characters
		_TRY_IO_BEGIN
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		_CATCH_IO_(_Ostr)
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

_STD_END

#pragma pop_macro("new")
#pragma warning(pop)
#pragma pack(pop)
#endif /* RC_INVOKED */
# 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring_insert.h" 3
#endif /* _XSTRING_INSERT_H */
# 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\xstring_insert.h" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 2 3

#if _HAS_CXX17
 #if 0 /* expanded by -frewrite-includes */
#include <xpolymorphic_allocator.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
#endif /* _HAS_CXX17 */
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// basic_string INSERTERS AND EXTRACTORS
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// extract a string
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	// state okay, extract characters
		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);
		_Str.erase();

		_TRY_IO_BEGIN
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	// whitespace, quit
			else
				{	// add character to string
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		_CATCH_IO_(_Istr)
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	// get characters into string, discard delimiter
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	// state okay, extract characters
		_TRY_IO_BEGIN
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	// got a delimiter, discard it and quit
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	// string too large, quit
				_State |= ios_base::failbit;
				break;
				}
			else
				{	// got a character, add it to string
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		_CATCH_IO_(_Istr)
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// get characters into string, discard newline
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// extract a string
	return (_STD move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	// get characters into string, discard delimiter
	return (getline(_STD move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// get characters into string, discard newline
	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// insert a string
	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));
	}

		// sto* NARROW CONVERSIONS

inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert string to int
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert string to long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert string to unsigned long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	unsigned long _Ans = _CSTD strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert string to long long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	long long _Ans = _CSTD strtoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert string to unsigned long long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	unsigned long long _Ans = _CSTD strtoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	// convert string to float
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	float _Ans = _CSTD strtof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	// convert string to double
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	double _Ans = _CSTD strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	// convert string to long double
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	long double _Ans = _CSTD strtold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		// sto* WIDE CONVERSIONS
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert wstring to int
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	long _Ans = _CSTD wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert wstring to long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	long _Ans = _CSTD wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert wstring to unsigned long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	unsigned long _Ans = _CSTD wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert wstring to long long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	long long _Ans = _CSTD wcstoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	// convert wstring to unsigned long long
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	unsigned long long _Ans = _CSTD wcstoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	// convert wstring to float
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	float _Ans = _CSTD wcstof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	// convert wstring to double
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	double _Ans = _CSTD wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	// convert wstring to long double
	int& _Errno_ref = errno;	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	long double _Ans = _CSTD wcstold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if (_Errno_ref == ERANGE)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		// HELPERS FOR to_string AND to_wstring
template<class _Elem,
	class _UTy> inline
	_Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal)
	{	// format _UVal into buffer *ending at* _RNext
	static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");

#ifdef _WIN64
	auto _UVal_trunc = _UVal;
#else /* ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv */
# 471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

#pragma warning(push)
#pragma warning(disable: 4127)	// conditional expression is constant
	if (sizeof(_UTy) > 4)
		{	// For 64-bit numbers, work in chunks to avoid 64-bit divisions.
		while (_UVal > 0xFFFFFFFFU)
			{
			auto _UVal_chunk = static_cast<_Uint32t>(_UVal % 1000000000);
			_UVal /= 1000000000;

			for (int _Idx = 0; _Idx != 9; ++_Idx)
				{
				*--_RNext = '0' + _UVal_chunk % 10;
				_UVal_chunk /= 10;
				}
			}
		}
#pragma warning(pop)

	auto _UVal_trunc = static_cast<_Uint32t>(_UVal);
#endif /* _WIN64 */
# 492 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

	do
		{
		*--_RNext = '0' + _UVal_trunc % 10;
		_UVal_trunc /= 10;
		}
	while (_UVal_trunc != 0);
	return (_RNext);
	}

template<class _Elem,
	class _Ty> inline
	basic_string<_Elem> _Integral_to_string(const _Ty _Val)
	{	// convert _Val to string
	static_assert(is_integral_v<_Ty>, "_Ty must be integral");
	using _UTy = make_unsigned_t<_Ty>;
	_Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
	_Elem* const _Buff_end = _STD end(_Buff);
	_Elem* _RNext = _Buff_end;
	auto _UVal = static_cast<_UTy>(_Val);
	if (_Val < 0)
		{
		_RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
		*--_RNext = '-';
		}
	else
		_RNext = _UIntegral_to_buff(_RNext, _UVal);

	return (basic_string<_Elem>(_RNext, _Buff_end));
	}

template<class _Ty> inline
	string _Floating_to_string(const char *_Fmt, _Ty _Val)
	{	// convert _Val to string
	static_assert(is_floating_point_v<_Ty>,
		"_Ty must be floating point");

	int _Len = _CSTD _scprintf(_Fmt, _Val);
	string _Str(_Len + 1, '\0');
	_CSTD sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}

template<class _Ty> inline
	wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	// convert _Val to wstring
	static_assert(is_floating_point_v<_Ty>,
		"_Ty must be floating point");

	int _Len = _CSTD _scwprintf(_Fmt, _Val);
	wstring _Str(_Len + 1, L'\0');
	_CSTD swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}

#undef _TO_STRING_BUF_SIZE

		// to_string NARROW CONVERSIONS
_NODISCARD inline string to_string(int _Val)
	{	// convert int to string
	return (_Integral_to_string<char>(_Val));
	}

_NODISCARD inline string to_string(unsigned int _Val)
	{	// convert unsigned int to string
	return (_Integral_to_string<char>(_Val));
	}

_NODISCARD inline string to_string(long _Val)
	{	// convert long to string
	return (_Integral_to_string<char>(_Val));
	}

_NODISCARD inline string to_string(unsigned long _Val)
	{	// convert unsigned long to string
	return (_Integral_to_string<char>(_Val));
	}

_NODISCARD inline string to_string(long long _Val)
	{	// convert long long to string
	return (_Integral_to_string<char>(_Val));
	}

_NODISCARD inline string to_string(unsigned long long _Val)
	{	// convert unsigned long long to string
	return (_Integral_to_string<char>(_Val));
	}

_NODISCARD inline string to_string(float _Val)
	{	// convert float to string
	return (_Floating_to_string("%f", _Val));
	}

_NODISCARD inline string to_string(double _Val)
	{	// convert double to string
	return (_Floating_to_string("%f", _Val));
	}

_NODISCARD inline string to_string(long double _Val)
	{	// convert long double to string
	return (_Floating_to_string("%Lf", _Val));
	}

		// to_wstring WIDE CONVERSIONS
_NODISCARD inline wstring to_wstring(int _Val)
	{	// convert int to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

_NODISCARD inline wstring to_wstring(unsigned int _Val)
	{	// convert unsigned int to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

_NODISCARD inline wstring to_wstring(long _Val)
	{	// convert long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

_NODISCARD inline wstring to_wstring(unsigned long _Val)
	{	// convert unsigned long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

_NODISCARD inline wstring to_wstring(long long _Val)
	{	// convert long long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

_NODISCARD inline wstring to_wstring(unsigned long long _Val)
	{	// convert unsigned long long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

_NODISCARD inline wstring to_wstring(float _Val)
	{	// convert float to wstring
	return (_Floating_to_wstring(L"%f", _Val));
	}

_NODISCARD inline wstring to_wstring(double _Val)
	{	// convert double to wstring
	return (_Floating_to_wstring(L"%f", _Val));
	}

_NODISCARD inline wstring to_wstring(long double _Val)
	{	// convert long double to wstring
	return (_Floating_to_wstring(L"%Lf", _Val));
	}

	// basic_string LITERALS
#ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wuser-defined-literals"
#endif /* __clang__ */
# 648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

#pragma warning(push)
#pragma warning(disable: 4455)	// literal suffix identifiers that do not start with an underscore are reserved

inline namespace literals {
inline namespace string_literals {
_NODISCARD inline string operator "" s(const char *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (string(_Str, _Len));
	}

_NODISCARD inline wstring operator "" s(const wchar_t *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (wstring(_Str, _Len));
	}

_NODISCARD inline u16string operator "" s(const char16_t *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (u16string(_Str, _Len));
	}

_NODISCARD inline u32string operator "" s(const char32_t *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (u32string(_Str, _Len));
	}
}	// inline namespace string_literals
}	// inline namespace literals

#pragma warning(pop)

#ifdef __clang__
 #pragma clang diagnostic pop
#endif /* __clang__ */
# 681 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

#if _HAS_CXX17
namespace pmr {
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	using basic_string = _STD basic_string<_Elem, _Traits, polymorphic_allocator<_Elem>>;

using string = basic_string<char>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
using wstring = basic_string<wchar_t>;
} // namespace pmr
#endif /* _HAS_CXX17 */
# 694 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 701 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3
#endif /* _STRING_ */
# 702 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\string" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 8 "ice.cpp" 2
#if 0 /* expanded by -frewrite-includes */
#include <utility>
#endif /* expanded by -frewrite-includes */
# 8 "ice.cpp"
# 9 "ice.cpp"
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 9 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 1 3
// vector standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
#ifndef _VECTOR_
#define _VECTOR_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <xmemory>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdexcept>
#endif /* expanded by -frewrite-includes */
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

#if _HAS_CXX17
 #if 0 /* expanded by -frewrite-includes */
#include <xpolymorphic_allocator.h>
#endif /* expanded by -frewrite-includes */
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
#endif /* _HAS_CXX17 */
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// CLASS TEMPLATE _Vector_const_iterator
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator_base
	{	// iterator for nonmutable vector
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Myvec::value_type;
	using difference_type = typename _Myvec::difference_type;
	using pointer = typename _Myvec::const_pointer;
	using reference = const value_type&;
	using _Tptr = typename _Myvec::pointer;

	_Vector_const_iterator()
		: _Ptr()
		{	// construct with null pointer
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	// construct with pointer _Parg
		this->_Adopt(_Pvector);
		}

	using _Unchecked_type = pointer;

	_NODISCARD reference operator*() const
		{	// return designated object
 #if _ITERATOR_DEBUG_LEVEL == 2
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == _Tptr()
			|| _Ptr < _Mycont->_Myfirst
			|| _Mycont->_Mylast <= _Ptr)
			{	// report error
			_DEBUG_ERROR("vector iterator not dereferencable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		_SCL_SECURE_VALIDATE(_Mycont != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		_Analysis_assume_(_Ptr != _Tptr());

		return (*_Ptr);
		}

	_NODISCARD pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Vector_const_iterator& operator++()
		{	// preincrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr
			|| _Mycont->_Mylast <= _Ptr)
			{	// report error
			_DEBUG_ERROR("vector iterator not incrementable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		_SCL_SECURE_VALIDATE(_Mycont != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		++_Ptr;
		return (*this);
		}

	_Vector_const_iterator operator++(int)
		{	// postincrement
		_Vector_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vector_const_iterator& operator--()
		{	// predecrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr
			|| _Ptr <= _Mycont->_Myfirst)
			{	// report error
			_DEBUG_ERROR("vector iterator not decrementable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		_SCL_SECURE_VALIDATE(_Mycont != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst < _Ptr);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		--_Ptr;
		return (*this);
		}

	_Vector_const_iterator operator--(int)
		{	// postdecrement
		_Vector_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vector_const_iterator& operator+=(difference_type _Off)
		{	// increment by integer
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
			if (_Mycont == 0
				|| _Ptr + _Off < _Mycont->_Myfirst
				|| _Mycont->_Mylast < _Ptr + _Off)
				{
				_DEBUG_ERROR("vector iterator + offset out of range");
				}
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
			_SCL_SECURE_VALIDATE(_Mycont != 0);
			_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr + _Off
				&& _Ptr + _Off <= _Mycont->_Mylast);
			}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		_Ptr += _Off;
		return (*this);
		}

	_NODISCARD _Vector_const_iterator operator+(difference_type _Off) const
		{	// return this + integer
		_Vector_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vector_const_iterator& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _Vector_const_iterator operator-(difference_type _Off) const
		{	// return this - integer
		_Vector_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const _Vector_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	_NODISCARD reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD bool operator==(const _Vector_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	_NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD bool operator<(const _Vector_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	_NODISCARD bool operator>(const _Vector_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD bool operator<=(const _Vector_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD bool operator>=(const _Vector_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

 #if _ITERATOR_DEBUG_LEVEL == 2
	void _Compat(const _Vector_const_iterator& _Right) const
		{	// test for compatible iterator pair
		if (this->_Getcont() != _Right._Getcont())
			{
			_DEBUG_ERROR("vector iterators incompatible");
			}
		}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Compat(const _Vector_const_iterator& _Right) const
		{	// test for compatible iterator pair
		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
		}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 238 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Compat(const _Vector_const_iterator&) const
		{	// test for compatible iterator pair
		}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

	_Tptr _Ptr;	// pointer to element in vector
	};

template<class _Myvec>
	_NODISCARD inline _Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec>& _Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
		const typename _Vector_const_iterator<_Myvec>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
	_Iter._Ptr = _Const_cast(_Right);
	return (_Iter);
	}

template<class _Myvec> inline
	typename _Vector_const_iterator<_Myvec>::_Unchecked_type _Unchecked(
		const _Vector_const_iterator<_Myvec>& _Iter)
	{	// make an unchecked iterator
	return (_Iter._Ptr);
	}

		// CLASS TEMPLATE _Vector_iterator
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	// iterator for mutable vector
public:
	using _Mybase = _Vector_const_iterator<_Myvec>;
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Myvec::value_type;
	using difference_type = typename _Myvec::difference_type;
	using pointer = typename _Myvec::pointer;
	using reference = value_type&;

	_Vector_iterator()
		{	// construct with null vector pointer
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	// construct with pointer _Parg
		}

	using _Unchecked_type = pointer;

	_NODISCARD reference operator*() const
		{	// return designated object
		return ((reference)**(_Mybase *)this);
		}

	_NODISCARD pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Vector_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Vector_iterator operator++(int)
		{	// postincrement
		_Vector_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vector_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Vector_iterator operator--(int)
		{	// postdecrement
		_Vector_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vector_iterator& operator+=(difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_NODISCARD _Vector_iterator operator+(difference_type _Off) const
		{	// return this + integer
		_Vector_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vector_iterator& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _Vector_iterator operator-(difference_type _Off) const
		{	// return this - integer
		_Vector_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	_NODISCARD reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Myvec>
	_NODISCARD inline _Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec>& _Rechecked(_Vector_iterator<_Myvec>& _Iter,
		const typename _Vector_iterator<_Myvec>::_Unchecked_type _Right)
	{	// reset from unchecked iterator
	_Iter._Ptr = _Right;
	return (_Iter);
	}

template<class _Myvec> inline
	typename _Vector_iterator<_Myvec>::_Unchecked_type _Unchecked(
		const _Vector_iterator<_Myvec>& _Iter)
	{	// make an unchecked iterator
	return (_Iter._Ptr);
	}

		// vector TYPE WRAPPERS
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	// wraps types needed by iterators
	using value_type = _Value_type;
	using size_type = _Size_type;
	using difference_type = _Difference_type;
	using pointer = _Pointer;
	using const_pointer = _Const_pointer;
	};

template<class _Ty,
	class _Alloc>
	struct _Vec_base_types
	{	// types needed for a container base
	using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
	using _Alty_traits = allocator_traits<_Alty>;

	using _Val_types = conditional_t<_Is_simple_alloc_v<_Alty>,
		_Simple_types<_Ty>,
		_Vec_iter_types<_Ty,
			typename _Alty_traits::size_type,
			typename _Alty_traits::difference_type,
			typename _Alty_traits::pointer,
			typename _Alty_traits::const_pointer,
			_Ty&,
			const _Ty&>>;
	};

		// CLASS TEMPLATE _Vector_val
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	// base class for vector to hold data
public:
	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	_Vector_val()
		: _Myfirst(),
		_Mylast(),
		_Myend()
		{	// initialize values
		}

	pointer _Myfirst;	// pointer to beginning of array
	pointer _Mylast;	// pointer to current end of sequence
	pointer _Myend;	// pointer to end of array
	};

		// CLASS TEMPLATE _Vector_alloc
template<class _Alloc_types>
	class _Vector_alloc
	{	// base class for vector to hold allocator
public:
	using _Alty = typename _Alloc_types::_Alty;
	using _Alty_traits = typename _Alloc_types::_Alty_traits;
	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Val_types = typename _Alloc_types::_Val_types;

	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;

	using iterator = _Vector_iterator<_Vector_val<_Val_types>>;
	using const_iterator = _Vector_const_iterator<_Vector_val<_Val_types>>;

 #if _ITERATOR_DEBUG_LEVEL == 0
	_Vector_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<decay_t<_Any_alloc>, _Vector_alloc>>>
		_Vector_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			_STD forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		_Pocca(_Getal(), _Al);
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		_Pocma(_Getal(), _Al);
		}

 #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
# 492 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	_Vector_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<decay_t<_Any_alloc>, _Vector_alloc>>>
		_Vector_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			_STD forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		_Alloc_proxy();
		}

	~_Vector_alloc() _NOEXCEPT
		{	// destroy proxy
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocca(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_move_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocma(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Alloc_proxy()
		{	// construct proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = _STD addressof(_Get_data());
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
		_Deallocate_plain(_Proxy_allocator, _Myproxy());
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() _NOEXCEPT
		{	// return reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const _NOEXCEPT
		{	// return const reference to _Myproxy
		return (_Get_data()._Myproxy);
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 580 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

	void _Orphan_all()
		{	// orphan all iterators
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Vector_alloc& _Right)
		{	// swap all iterators
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() _NOEXCEPT
		{	// return reference to allocator
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const _NOEXCEPT
		{	// return const reference to allocator
		return (_Mypair._Get_first());
		}

	_Vector_val<_Val_types>& _Get_data() _NOEXCEPT
		{	// return reference to _Vector_val
		return (_Mypair._Get_second());
		}

	const _Vector_val<_Val_types>& _Get_data() const _NOEXCEPT
		{	// return const reference to _Vector_val
		return (_Mypair._Get_second());
		}

	pointer& _Myfirst() _NOEXCEPT
		{	// return reference to _Myfirst
		return (_Get_data()._Myfirst);
		}

	const pointer& _Myfirst() const _NOEXCEPT
		{	// return const reference to _Myfirst
		return (_Get_data()._Myfirst);
		}

	pointer& _Mylast() _NOEXCEPT
		{	// return reference to _Mylast
		return (_Get_data()._Mylast);
		}

	const pointer& _Mylast() const _NOEXCEPT
		{	// return const reference to _Mylast
		return (_Get_data()._Mylast);
		}

	pointer& _Myend() _NOEXCEPT
		{	// return reference to _Myend
		return (_Get_data()._Myend);
		}

	const pointer& _Myend() const _NOEXCEPT
		{	// return const reference to _Myend
		return (_Get_data()._Myend);
		}

private:
	_Compressed_pair<_Alty, _Vector_val<_Val_types>> _Mypair;
	};

		// FUNCTION TEMPLATE _Unfancy_maybe_null
template<class _Ptrty> inline
	auto _Unfancy_maybe_null(_Ptrty _Ptr)
	{	// converts from a (potentially null) fancy pointer to a plain pointer
	return (_Ptr ? _STD addressof(*_Ptr) : nullptr);
	}

template<class _Ty> inline
	_Ty * _Unfancy_maybe_null(_Ty * _Ptr)
	{	// do nothing for plain pointers
	return (_Ptr);
	}

		// CLASS TEMPLATE vector
template<class _Ty,
	class _Alloc = allocator<_Ty>>
	class vector
		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>
	{	// varying size array of values
private:
	using _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>;
	using _Alty = typename _Mybase::_Alty;
	using _Alty_traits = typename _Mybase::_Alty_traits;

public:
	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Ty, typename _Alloc::value_type>,
		_MISMATCHED_ALLOCATOR_MESSAGE("vector<T, Allocator>", "T"));

	using value_type = _Ty;
	using allocator_type = _Alloc;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = _Ty&;
	using const_reference = const _Ty&;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;
	using reverse_iterator = _STD reverse_iterator<iterator>;
	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

	vector() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
		: _Mybase()
		{	// construct empty vector
		}

	explicit vector(const _Alloc& _Al) _NOEXCEPT
		: _Mybase(_Al)
		{	// construct empty vector, allocator
		}

	explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Count * _Ty(), optional allocator
		if (_Buy(_Count))
			{	// nonzero, fill it
			_TRY_BEGIN
			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);
			_CATCH_ALL
			_Tidy();
			_RERAISE;
			_CATCH_END
			}
		}

	vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Count * _Val, optional allocator
		if (_Buy(_Count))
			{	// nonzero, fill it
			_TRY_BEGIN
			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Val);
			_CATCH_ALL
			_Tidy();
			_RERAISE;
			_CATCH_END
			}
		}

private:
	template<class _Iter>
		void _Range_construct_or_tidy(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// initialize with [_First, _Last), avoid leaking, input iterators
		_TRY_BEGIN
		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);	// performance note: emplace_back()'s strong guarantee is unnecessary here
			}
		_CATCH_ALL
		_Tidy();
		_RERAISE;
		_CATCH_END
		}

	template<class _Iter>
		void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag)
		{	// initialize with [_First, _Last), avoid leaking, forward iterators
		if (_Buy(_Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)))))
			{	// nonzero, fill it
			_TRY_BEGIN
			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			_CATCH_ALL
			_Tidy();
			_RERAISE;
			_CATCH_END
			}
		}

public:
	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from [_First, _Last) with optional allocator
		_DEBUG_RANGE(_First, _Last);
		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});
		}

	vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from initializer_list, optional allocator
		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
		}

	vector(const vector& _Right)
		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct by copying _Right
		if (_Buy(_Right.size()))
			{	// nonzero, fill it
			_TRY_BEGIN
			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
			_CATCH_ALL
			_Tidy();
			_RERAISE;
			_CATCH_END
			}
		}

	vector(const vector& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct by copying _Right, allocator
		if (_Buy(_Right.size()))
			{	// nonzero, fill it
			_TRY_BEGIN
			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
			_CATCH_ALL
			_Tidy();
			_RERAISE;
			_CATCH_END
			}
		}

private:
	void _Move_from(vector&& _Right, true_type) _NOEXCEPT
		{	// move from _Right, stealing its contents
		this->_Swap_all(_Right);

		this->_Myfirst() = _Right._Myfirst();
		this->_Mylast() = _Right._Mylast();
		this->_Myend() = _Right._Myend();

		_Right._Myfirst() = pointer();
		_Right._Mylast() = pointer();
		_Right._Myend() = pointer();
		}

	void _Move_from(vector&& _Right, false_type)
		{	// move from _Right, possibly moving its contents
		if (this->_Getal() == _Right._Getal())
			{
			_Move_from(_STD move(_Right), true_type{});
			}
		else if (_Buy(_Right.size()))
			{	// nonzero, fill it
			this->_Mylast() = _Umove(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
			}
		}

public:
	vector(vector&& _Right) _NOEXCEPT
		: _Mybase(_STD move(_Right._Getal()))
		{	// construct by moving _Right
		_Move_from(_STD move(_Right), true_type{});
		}

	vector(vector&& _Right, const _Alloc& _Al)
		_NOEXCEPT_COND(_Alty_traits::is_always_equal::value) // strengthened
		: _Mybase(_Al)
		{	// construct by moving _Right, allocator
		if /* constexpr */ (_Alty_traits::is_always_equal::value)
			{
			_Move_from(_STD move(_Right), true_type{});
			}
		else
			{
#pragma warning(push) // TRANSITION, if constexpr
#pragma warning(disable: 4297) // function assumed not to throw an exception but does
			_TRY_BEGIN
			_Move_from(_STD move(_Right), false_type{});
			_CATCH_ALL
			_Tidy();
			_RERAISE;
			_CATCH_END
#pragma warning(pop)
			}
		}

private:
	void _Move_assign_from(vector&& _Right, true_type) _NOEXCEPT
		{	// move from _Right, stealing its contents
		_Move_from(_STD move(_Right), true_type{});
		}

	void _Move_assign_from(vector&& _Right, false_type)
		{	// move from _Right, possibly moving its contents
		if (this->_Getal() == _Right._Getal())
			{
			_Move_from(_STD move(_Right), true_type{});
			return;
			}

		const pointer _First = _Right._Myfirst();
		const pointer _Last = _Right._Mylast();
		const size_type _Newsize = _Right.size();

		this->_Orphan_all();

		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			if (this->_Myfirst() != pointer())
				{	// destroy and deallocate old array
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
				}

			_Buy(_Newcapacity);

			this->_Mylast() = _Umove(_First, _Last, this->_Myfirst());
			}
		else if (_Newsize > _Oldsize)
			{
			const pointer _Mid = _First + _Oldsize;
			_Move_unchecked(_First, _Mid, this->_Myfirst());
			this->_Mylast() = _Umove(_Mid, _Last, this->_Mylast());
			}
		else
			{
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Move_unchecked(_First, _Last, this->_Myfirst());
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

public:
	vector& operator=(vector&& _Right)
		_NOEXCEPT_COND(_Always_equal_after_move<_Alty>)
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	// conditional expression is constant
			if (_Always_equal_after_move<_Alty>
				|| this->_Getal() == _Right._Getal())
				{	// will steal _Right's contents (also, POCMA non-equal must reload array)
				_Tidy();
				}
#pragma warning(pop)
			this->_Move_alloc(_Right._Getal());
			_Move_assign_from(_STD move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});
			}
		return (*this);
		}

	~vector() _NOEXCEPT
		{	// destroy the object
		_Tidy();
		}

private:
	template<class... _Valty>
		void _Emplace_back_with_unused_capacity(_Valty&&... _Val)
		{	// insert by perfectly forwarding into element at end, provide strong guarantee
			// pre: _Has_unused_capacity()
		_Alty_traits::construct(this->_Getal(), _Unfancy(this->_Mylast()), _STD forward<_Valty>(_Val)...);
		_Orphan_range(this->_Mylast(), this->_Mylast());
		++this->_Mylast();
		}

public:
	template<class... _Valty>
		decltype(auto) emplace_back(_Valty&&... _Val)
		{	// insert by perfectly forwarding into element at end, provide strong guarantee
		if (_Has_unused_capacity())
			{
			_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
			}
		else
			{	// reallocate
			const size_type _Oldsize = size();

			if (_Oldsize == max_size())
				{
				_Xlength();
				}

			const size_type _Newsize = _Oldsize + 1;
			const size_type _Newcapacity = _Calculate_growth(_Newsize);
			bool _Emplaced = false;
			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			_Alty& _Al = this->_Getal();

			_TRY_BEGIN
			_Alty_traits::construct(_Al, _Unfancy(_Newvec + _Oldsize), _STD forward<_Valty>(_Val)...);
			_Emplaced = true;
			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
			_CATCH_ALL
			if (_Emplaced)
				{
				_Alty_traits::destroy(_Al, _Unfancy(_Newvec + _Oldsize));
				}

			_Al.deallocate(_Newvec, _Newcapacity);
			_RERAISE;
			_CATCH_END

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}

#if _HAS_CXX17
		return (this->_Mylast()[-1]);
#endif /* _HAS_CXX17 */
# 987 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		}

	void push_back(const _Ty& _Val)
		{	// insert element at end, provide strong guarantee
		emplace_back(_Val);
		}

	void push_back(_Ty&& _Val)
		{	// insert by moving into element at end, provide strong guarantee
		emplace_back(_STD move(_Val));
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	// insert by perfectly forwarding _Val at _Where
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Where._Getcont() != _STD addressof(this->_Get_data())
			|| _Where._Ptr < this->_Myfirst()
			|| this->_Mylast() < _Where._Ptr)
			{
			_DEBUG_ERROR("vector emplace iterator outside range");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1010 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		const size_type _Whereoff = _Where._Ptr - this->_Myfirst();
		const bool _At_back = _Where._Ptr == this->_Mylast();
		_Alty& _Al = this->_Getal();

		if (!_Has_unused_capacity())
			{	// reallocate
			const size_type _Oldsize = size();

			if (_Oldsize == max_size())
				{
				_Xlength();
				}

			const size_type _Newsize = _Oldsize + 1;
			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Constructed_last = _Newvec + _Whereoff + 1;
			pointer _Constructed_first = _Constructed_last;

			_TRY_BEGIN
			_Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
			_Constructed_first = _Newvec + _Whereoff;

			if (_At_back)
				{	// provide strong guarantee
				_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
				}
			else
				{	// provide basic guarantee
				_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
				_Constructed_first = _Newvec;
				_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + 1);
				}
			_CATCH_ALL
			_Destroy(_Constructed_first, _Constructed_last);
			_Al.deallocate(_Newvec, _Newcapacity);
			_RERAISE;
			_CATCH_END

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else if (_At_back)
			{	// provide strong guarantee
			_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
			}
		else
			{
			_Ty _Obj(_STD forward<_Valty>(_Val)...);	// handle aliasing
			// after constructing _Obj, provide basic guarantee
			const pointer _Oldlast = this->_Mylast();
			_Orphan_range(_Where._Ptr, _Oldlast);
			_Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));
			++this->_Mylast();
			_Move_backward_unchecked(_Where._Ptr, _Oldlast - 1, _Oldlast);
			*_Where._Ptr = _STD move(_Obj);
			}

		return (begin() + _Whereoff);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	// insert _Val at _Where
		return (emplace(_Where, _Val));
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	// insert by moving _Val at _Where
		return (emplace(_Where, _STD move(_Val)));
		}

	iterator insert(const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Where._Getcont() != _STD addressof(this->_Get_data())
			|| _Where._Ptr < this->_Myfirst()
			|| this->_Mylast() < _Where._Ptr)
			{
			_DEBUG_ERROR("vector insert iterator outside range");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1092 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		const size_type _Whereoff = _Where._Ptr - this->_Myfirst();
		const bool _One_at_back = _Count == 1 && _Where._Ptr == this->_Mylast();

		if (_Count == 0)
			{	// nothing to do, avoid invalidating iterators
			}
		else if (_Count > _Unused_capacity())
			{	// reallocate
			const size_type _Oldsize = size();

			if (_Count > max_size() - _Oldsize)
				{
				_Xlength();
				}

			const size_type _Newsize = _Oldsize + _Count;
			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
			pointer _Constructed_first = _Constructed_last;

			_TRY_BEGIN
			_Ufill(_Newvec + _Whereoff, _Count, _Val);
			_Constructed_first = _Newvec + _Whereoff;

			if (_One_at_back)
				{	// provide strong guarantee
				_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
				}
			else
				{	// provide basic guarantee
				_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
				_Constructed_first = _Newvec;
				_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + _Count);
				}
			_CATCH_ALL
			_Destroy(_Constructed_first, _Constructed_last);
			this->_Getal().deallocate(_Newvec, _Newcapacity);
			_RERAISE;
			_CATCH_END

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else if (_One_at_back)
			{	// provide strong guarantee
			_Emplace_back_with_unused_capacity(_Val);
			}
		else
			{	// provide basic guarantee
			const _Ty _Tmp = _Val;	// handle aliasing
			const pointer _Oldlast = this->_Mylast();
			const size_type _Affected_elements = _Oldlast - _Where._Ptr;
			_Orphan_range(_Where._Ptr, _Oldlast);

			if (_Count > _Affected_elements)
				{	// new stuff spills off end
				this->_Mylast() = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
				this->_Mylast() = _Umove(_Where._Ptr, _Oldlast, this->_Mylast());
				_Fill_unchecked(_Where._Ptr, _Oldlast, _Tmp);
				}
			else
				{	// new stuff can all be assigned
				this->_Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
				_Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
				_Fill_unchecked(_Where._Ptr, _Where._Ptr + _Count, _Tmp);
				}
			}

		return (begin() + _Whereoff);
		}

private:
	template<class _Iter>
		void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		if (_First == _Last)
			{
			return;	// nothing to do, avoid invalidating iterators
			}

		const size_type _Whereoff = _Where._Ptr - this->_Myfirst();
		const size_type _Oldsize = size();

		// For one-at-back, provide strong guarantee.
		// Otherwise, provide basic guarantee (despite N4659 26.3.11.5 [vector.modifiers]/1).
		// Performance note: except for one-at-back, emplace_back()'s strong guarantee is unnecessary here.

		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);
			}

		_Orphan_range(this->_Myfirst() + _Whereoff, this->_Myfirst() + _Oldsize);

		_Rotate_unchecked(this->_Myfirst() + _Whereoff, this->_Myfirst() + _Oldsize, this->_Mylast());
		}

	template<class _Iter>
		void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators
		const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
		const size_type _Whereoff = _Where._Ptr - this->_Myfirst();
		const bool _One_at_back = _Count == 1 && _Where._Ptr == this->_Mylast();

		if (_Count == 0)
			{	// nothing to do, avoid invalidating iterators
			}
		else if (_Count > _Unused_capacity())
			{	// reallocate
			const size_type _Oldsize = size();

			if (_Count > max_size() - _Oldsize)
				{
				_Xlength();
				}

			const size_type _Newsize = _Oldsize + _Count;
			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
			pointer _Constructed_first = _Constructed_last;

			_TRY_BEGIN
			_Ucopy(_First, _Last, _Newvec + _Whereoff);
			_Constructed_first = _Newvec + _Whereoff;

			if (_One_at_back)
				{	// provide strong guarantee
				_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
				}
			else
				{	// provide basic guarantee
				_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
				_Constructed_first = _Newvec;
				_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + _Count);
				}
			_CATCH_ALL
			_Destroy(_Constructed_first, _Constructed_last);
			this->_Getal().deallocate(_Newvec, _Newcapacity);
			_RERAISE;
			_CATCH_END

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else
			{	// Attempt to provide the strong guarantee for EmplaceConstructible failure.
				// If we encounter copy/move construction/assignment failure, provide the basic guarantee.
				// (For one-at-back, this provides the strong guarantee.)

			const pointer _Oldlast = this->_Mylast();
			const size_type _Affected_elements = _Oldlast - _Where._Ptr;

			if (_Count < _Affected_elements)
				{	// some affected elements must be assigned
				this->_Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
				_Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
				_Destroy(_Where._Ptr, _Where._Ptr + _Count);

				_TRY_BEGIN
				_Ucopy(_First, _Last, _Where._Ptr);
				_CATCH_ALL
				// glue the broken pieces back together

					_TRY_BEGIN
					_Umove(_Where._Ptr + _Count, _Where._Ptr + 2 * _Count, _Where._Ptr);
					_CATCH_ALL
					// vaporize the detached piece
					_Orphan_range(_Where._Ptr, _Oldlast);
					_Destroy(_Where._Ptr + _Count, this->_Mylast());
					this->_Mylast() = _Where._Ptr;
					_RERAISE;
					_CATCH_END

					_Move_unchecked(_Where._Ptr + 2 * _Count, this->_Mylast(), _Where._Ptr + _Count);
					_Destroy(_Oldlast, this->_Mylast());
					this->_Mylast() = _Oldlast;
				_RERAISE;
				_CATCH_END
				}
			else
				{	// affected elements don't overlap before/after
				const pointer _Relocated = _Where._Ptr + _Count;
				this->_Mylast() = _Umove(_Where._Ptr, _Oldlast, _Relocated);
				_Destroy(_Where._Ptr, _Oldlast);

				_TRY_BEGIN
				_Ucopy(_First, _Last, _Where._Ptr);
				_CATCH_ALL
				// glue the broken pieces back together

					_TRY_BEGIN
					_Umove(_Relocated, this->_Mylast(), _Where._Ptr);
					_CATCH_ALL
					// vaporize the detached piece
					_Orphan_range(_Where._Ptr, _Oldlast);
					_Destroy(_Relocated, this->_Mylast());
					this->_Mylast() = _Where._Ptr;
					_RERAISE;
					_CATCH_END

					_Destroy(_Relocated, this->_Mylast());
					this->_Mylast() = _Oldlast;
				_RERAISE;
				_CATCH_END
				}

			_Orphan_range(_Where._Ptr, _Oldlast);
			}
		}

public:
	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Where._Getcont() != _STD addressof(this->_Get_data())
			|| _Where._Ptr < this->_Myfirst()
			|| this->_Mylast() < _Where._Ptr)
			{
			_DEBUG_ERROR("vector insert iterator outside range");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1318 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		_DEBUG_RANGE(_First, _Last);

		const size_type _Whereoff = _Where._Ptr - this->_Myfirst();
		_Insert_range(_Where, _Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});
		return (begin() + _Whereoff);
		}

	iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist)
		{	// insert initializer_list at _Where
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val)
		{	// assign _Newsize * _Val
		this->_Orphan_all();

		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			if (this->_Myfirst() != pointer())
				{	// destroy and deallocate old array
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
				}

			_Buy(_Newcapacity);

			this->_Mylast() = _Ufill(this->_Myfirst(), _Newsize, _Val);
			}
		else if (_Newsize > _Oldsize)
			{
			_Fill_unchecked(this->_Myfirst(), this->_Mylast(), _Val);
			this->_Mylast() = _Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);
			}
		else
			{
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Fill_unchecked(this->_Myfirst(), _Newlast, _Val);
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

private:
	template<class _Iter>
		void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// assign [_First, _Last), input iterators
		this->_Orphan_all();

		pointer _Next = this->_Myfirst();

		for (; _First != _Last && _Next != this->_Mylast(); ++_First, (void)++_Next)
			{
			*_Next = *_First;
			}

		// Code size optimization: we've exhausted only the source, only the dest, or both.
		// If we've exhausted only the source: we Trim, then Append does nothing.
		// If we've exhausted only the dest: Trim does nothing, then we Append.
		// If we've exhausted both: Trim does nothing, then Append does nothing.

		// Trim.
		_Destroy(_Next, this->_Mylast());
		this->_Mylast() = _Next;

		// Append.
		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);	// performance note: emplace_back()'s strong guarantee is unnecessary here
			}
		}

	template<class _Iter>
		void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag)
		{	// assign [_First, _Last), forward iterators
		const size_type _Newsize = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

		this->_Orphan_all();

		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			if (this->_Myfirst() != pointer())
				{	// destroy and deallocate old array
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
				}

			_Buy(_Newcapacity);

			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			}
		else if (_Newsize > _Oldsize)
			{
			const _Iter _Mid = _STD next(_First, _Oldsize);	// performance note: traversing [_First, _Mid) twice
			_Copy_unchecked(_First, _Mid, this->_Myfirst());
			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());
			}
		else
			{
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Copy_unchecked(_First, _Last, this->_Myfirst());
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

public:
	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});
		}

	void assign(initializer_list<_Ty> _Ilist)
		{	// assign initializer_list
		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
		}

	vector& operator=(const vector& _Right)
		{	// assign _Right
		if (this != _STD addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	// conditional expression is constant
			if (_Alty_traits::propagate_on_container_copy_assignment::value
				&& this->_Getal() != _Right._Getal())
				{	// reload array
				_Tidy();
				}
#pragma warning(pop)

			this->_Copy_alloc(_Right._Getal());

			assign(_Right._Myfirst(), _Right._Mylast());
			}

		return (*this);
		}

	vector& operator=(initializer_list<_Ty> _Ilist)
		{	// assign initializer_list
		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
		return (*this);
		}

private:
	template<class _Lambda>
		void _Resize(const size_type _Newsize, _Lambda _Udefault_or_fill)
		{	// trim or append elements, provide strong guarantee
		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Appended_first = _Newvec + _Oldsize;
			pointer _Appended_last = _Appended_first;

			_TRY_BEGIN
			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);
			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
			_CATCH_ALL
			_Destroy(_Appended_first, _Appended_last);
			this->_Getal().deallocate(_Newvec, _Newcapacity);
			_RERAISE;
			_CATCH_END

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else if (_Newsize > _Oldsize)
			{	// append
			const pointer _Oldlast = this->_Mylast();
			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
			_Orphan_range(_Oldlast, _Oldlast);
			}
		else if (_Newsize == _Oldsize)
			{	// nothing to do, avoid invalidating iterators
			}
		else
			{	// trim
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Orphan_range(_Newlast, this->_Mylast());
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

public:
	void resize(_CRT_GUARDOVERFLOW const size_type _Newsize)
		{	// trim or append value-initialized elements, provide strong guarantee
		auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
			{
			return (_Udefault(_Dest, _Count));
			};

		_Resize(_Newsize, _Lambda_default);
		}

	void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val)
		{	// trim or append copies of _Val, provide strong guarantee
		auto _Lambda_fill = [this, &_Val](pointer _Dest, const size_type _Count)
			{
			return (_Ufill(_Dest, _Count, _Val));
			};

		_Resize(_Newsize, _Lambda_fill);
		}

private:
	void _Reallocate_exactly(const size_type _Newcapacity)
		{	// set capacity to _Newcapacity (without geometric growth), provide strong guarantee
		const size_type _Size = size();

		const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

		_TRY_BEGIN
		_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
		_CATCH_ALL
		this->_Getal().deallocate(_Newvec, _Newcapacity);
		_RERAISE;
		_CATCH_END

		_Change_array(_Newvec, _Size, _Newcapacity);
		}

public:
	void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity)
		{	// increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
		if (_Newcapacity > capacity())
			{	// something to do (reserve() never shrinks)
			if (_Newcapacity > max_size())
				{
				_Xlength();
				}

			_Reallocate_exactly(_Newcapacity);
			}
		}

	void shrink_to_fit()
		{	// reduce capacity to size, provide strong guarantee
		if (_Has_unused_capacity())
			{	// something to do
			if (empty())
				{
				_Tidy();
				}
			else
				{
				_Reallocate_exactly(size());
				}
			}
		}

	void pop_back()
		{	// erase element at end
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (empty())
			{
			_DEBUG_ERROR("vector empty before pop");
			}

		_Orphan_range(this->_Mylast() - 1, this->_Mylast());
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		_Alty_traits::destroy(this->_Getal(), _Unfancy(this->_Mylast() - 1));
		--this->_Mylast();
		}

	iterator erase(const_iterator _Where)
		{	// erase element at _Where
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Where._Getcont() != _STD addressof(this->_Get_data())
			|| _Where._Ptr < this->_Myfirst()
			|| this->_Mylast() <= _Where._Ptr)
			{
			_DEBUG_ERROR("vector erase iterator outside range");
			}

		_Orphan_range(_Where._Ptr, this->_Mylast());
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1628 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		_Move_unchecked(_Where._Ptr + 1, this->_Mylast(), _Where._Ptr);
		_Alty_traits::destroy(this->_Getal(), _Unfancy(this->_Mylast() - 1));
		--this->_Mylast();
		return (iterator(_Where._Ptr, _STD addressof(this->_Get_data())));
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	// erase [_First, _Last)
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_First._Getcont() != _STD addressof(this->_Get_data())
			|| _Last._Getcont() != _STD addressof(this->_Get_data())
			|| _First._Ptr < this->_Myfirst()
			|| _Last._Ptr < _First._Ptr
			|| this->_Mylast() < _Last._Ptr)
			{
			_DEBUG_ERROR("vector erase iterator outside range");
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 1647 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		if (_First._Ptr != _Last._Ptr)
			{	// something to do, invalidate iterators
			_Orphan_range(_First._Ptr, this->_Mylast());
			const pointer _Newlast = _Move_unchecked(_Last._Ptr, this->_Mylast(), _First._Ptr);
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}

		return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));
		}

	void clear() _NOEXCEPT
		{	// erase all
		this->_Orphan_all();
		_Destroy(this->_Myfirst(), this->_Mylast());
		this->_Mylast() = this->_Myfirst();
		}

	void swap(vector& _Right) _NOEXCEPT // Strengthened
		{	// exchange contents with _Right
		if (this != _STD addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
			_Swap_adl(this->_Mylast(), _Right._Mylast());
			_Swap_adl(this->_Myend(), _Right._Myend());
			}
		}

	_NODISCARD _Ty * data() _NOEXCEPT
		{	// return address of first element
		return (_Unfancy_maybe_null(this->_Myfirst()));
		}

	_NODISCARD const _Ty * data() const _NOEXCEPT
		{	// return address of first element
		return (_Unfancy_maybe_null(this->_Myfirst()));
		}

	_NODISCARD iterator begin() _NOEXCEPT
		{	// return iterator for beginning of mutable sequence
		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
		}

	_NODISCARD const_iterator begin() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
		}

	_NODISCARD iterator end() _NOEXCEPT
		{	// return iterator for end of mutable sequence
		return (iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
		}

	_NODISCARD const_iterator end() const _NOEXCEPT
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
		}

	_NODISCARD reverse_iterator rbegin() _NOEXCEPT
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	_NODISCARD const_reverse_iterator rbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	_NODISCARD reverse_iterator rend() _NOEXCEPT
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	_NODISCARD const_reverse_iterator rend() const _NOEXCEPT
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	_NODISCARD const_iterator cbegin() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	_NODISCARD const_iterator cend() const _NOEXCEPT
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	_NODISCARD const_reverse_iterator crbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	_NODISCARD const_reverse_iterator crend() const _NOEXCEPT
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	pointer _Unchecked_begin() _NOEXCEPT
		{	// return pointer for beginning of mutable sequence
		return (this->_Myfirst());
		}

	const_pointer _Unchecked_begin() const _NOEXCEPT
		{	// return pointer for beginning of nonmutable sequence
		return (this->_Myfirst());
		}

	pointer _Unchecked_end() _NOEXCEPT
		{	// return pointer for end of mutable sequence
		return (this->_Mylast());
		}

	const_pointer _Unchecked_end() const _NOEXCEPT
		{	// return pointer for end of nonmutable sequence
		return (this->_Mylast());
		}

	_NODISCARD bool empty() const _NOEXCEPT
		{	// test if sequence is empty
		return (this->_Myfirst() == this->_Mylast());
		}

	_NODISCARD size_type size() const _NOEXCEPT
		{	// return length of sequence
		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));
		}

	_NODISCARD size_type max_size() const _NOEXCEPT
		{	// return maximum possible length of sequence
		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),
			_Alty_traits::max_size(this->_Getal())));
		}

	_NODISCARD size_type capacity() const _NOEXCEPT
		{	// return current length of allocated storage
		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));
		}

private:
	size_type _Unused_capacity() const _NOEXCEPT
		{	// micro-optimization for capacity() - size()
		return (static_cast<size_type>(this->_Myend() - this->_Mylast()));
		}

	bool _Has_unused_capacity() const _NOEXCEPT
		{	// micro-optimization for capacity() != size()
		return (this->_Myend() != this->_Mylast());
		}

public:
	_NODISCARD _Ty& operator[](const size_type _Pos)
		{	// subscript mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (size() <= _Pos)
			{	// report error
			_DEBUG_ERROR("vector subscript out of range");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1809 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1811 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (this->_Myfirst()[_Pos]);
		}

	_NODISCARD const _Ty& operator[](const size_type _Pos) const
		{	// subscript nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (size() <= _Pos)
			{	// report error
			_DEBUG_ERROR("vector subscript out of range");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1823 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1825 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (this->_Myfirst()[_Pos]);
		}

	_NODISCARD _Ty& at(const size_type _Pos)
		{	// subscript mutable sequence with checking
		if (size() <= _Pos)
			{
			_Xrange();
			}

		return (this->_Myfirst()[_Pos]);
		}

	_NODISCARD const _Ty& at(const size_type _Pos) const
		{	// subscript nonmutable sequence with checking
		if (size() <= _Pos)
			{
			_Xrange();
			}

		return (this->_Myfirst()[_Pos]);
		}

	_NODISCARD _Ty& front()
		{	// return first element of mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (empty())
			{	// report error
			_DEBUG_ERROR("front() called on empty vector");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1857 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE_RANGE(!empty());
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1859 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (*this->_Myfirst());
		}

	_NODISCARD const _Ty& front() const
		{	// return first element of nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (empty())
			{	// report error
			_DEBUG_ERROR("front() called on empty vector");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1871 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE_RANGE(!empty());
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (*this->_Myfirst());
		}

	_NODISCARD _Ty& back()
		{	// return last element of mutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (empty())
			{	// report error
			_DEBUG_ERROR("back() called on empty vector");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1885 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE_RANGE(!empty());
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1887 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (this->_Mylast()[-1]);
		}

	_NODISCARD const _Ty& back() const
		{	// return last element of nonmutable sequence
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (empty())
			{	// report error
			_DEBUG_ERROR("back() called on empty vector");
			}
 #elif _ITERATOR_DEBUG_LEVEL == 1
# 1899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE_RANGE(!empty());
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 1901 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (this->_Mylast()[-1]);
		}

	_NODISCARD allocator_type get_allocator() const _NOEXCEPT
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Getal()));
		}

private:
	pointer _Udefault(pointer _Dest, const size_type _Count)
		{	// fill raw _Dest with _Count value-initialized objects, using allocator
		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));
		}

	pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val)
		{	// fill raw _Dest with _Count copies of _Val, using allocator
		return (_Uninitialized_fill_n(_Dest, _Count, _Val, this->_Getal()));
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest)
		{	// copy [_First, _Last) to raw _Dest, using allocator
		return (_Uninitialized_copy(_First, _Last, _Dest, this->_Getal()));
		}

	pointer _Umove(pointer _First, pointer _Last, pointer _Dest)
		{	// move [_First, _Last) to raw _Dest, using allocator
		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));
		}

	void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type)
		{	// move [_First, _Last) to raw _Dest, using allocator
		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());
		}

	void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, false_type)
		{	// copy [_First, _Last) to raw _Dest, using allocator
		_Uninitialized_copy(_First, _Last, _Dest, this->_Getal());
		}

	void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest)
		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator
		_Umove_if_noexcept1(_First, _Last, _Dest,
			_Disjunction_t<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>{});
		}

	void _Destroy(pointer _First, pointer _Last)
		{	// destroy [_First, _Last) using allocator
		_Destroy_range(_First, _Last, this->_Getal());
		}

	size_type _Calculate_growth(const size_type _Newsize) const
		{	// given _Oldcapacity and _Newsize, calculate geometric growth
		const size_type _Oldcapacity = capacity();

		if (_Oldcapacity > max_size() - _Oldcapacity / 2)
			{
			return (_Newsize);	// geometric growth would overflow
			}

		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

		if (_Geometric < _Newsize)
			{
			return (_Newsize);	// geometric growth would be insufficient
			}

		return (_Geometric);	// geometric growth is sufficient
		}

	bool _Buy(const size_type _Newcapacity)
		{	// allocate array with _Newcapacity elements
		this->_Myfirst() = pointer();
		this->_Mylast() = pointer();
		this->_Myend() = pointer();

		if (_Newcapacity == 0)
			{
			return (false);
			}

		if (_Newcapacity > max_size())
			{
			_Xlength();
			}

		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);
		this->_Mylast() = this->_Myfirst();
		this->_Myend() = this->_Myfirst() + _Newcapacity;

		return (true);
		}

	void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity)
		{	// orphan all iterators, discard old array, acquire new array
		this->_Orphan_all();

		if (this->_Myfirst() != pointer())
			{	// destroy and deallocate old array
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(), capacity());
			}

		this->_Myfirst() = _Newvec;
		this->_Mylast() = _Newvec + _Newsize;
		this->_Myend() = _Newvec + _Newcapacity;
		}

	void _Tidy()
		{	// free all storage
		this->_Orphan_all();

		if (this->_Myfirst() != pointer())
			{	// destroy and deallocate old array
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(), capacity());

			this->_Myfirst() = pointer();
			this->_Mylast() = pointer();
			this->_Myend() = pointer();
			}
		}

	[[noreturn]] static void _Xlength()
		{	// report a length_error
		_Xlength_error("vector<T> too long");
		}

	[[noreturn]] static void _Xrange()
		{	// report an out_of_range error
		_Xout_of_range("invalid vector<T> subscript");
		}

 #if _ITERATOR_DEBUG_LEVEL == 2
	void _Orphan_range(pointer _First, pointer _Last) const
		{	// orphan iterators within specified (inclusive) range
		_Lockit _Lock(_LOCK_DEBUG);

		const_iterator ** _Pnext = reinterpret_cast<const_iterator **>(this->_Getpfirst());

		if (_Pnext)
			{
			while (*_Pnext)
				{
				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)
					{	// skip the iterator
					_Pnext = reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());
					}
				else
					{	// orphan the iterator
					(*_Pnext)->_Clrcont();
					*_Pnext = *reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());
					}
				}
			}
		}
 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 2059 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Orphan_range(pointer, pointer) const
		{	// orphan iterators within specified (inclusive) range
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 2063 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	};

#if _HAS_DEDUCTION_GUIDES
template<class _Iter,
	class _Alloc = allocator<_Iter_value_t<_Iter>>,
	enable_if_t<conjunction_v<
		_Is_iterator<_Iter>,
		_Is_allocator<_Alloc>
	>, int> = 0>
	vector(_Iter, _Iter, _Alloc = _Alloc())
		-> vector<_Iter_value_t<_Iter>, _Alloc>;
#endif /* _HAS_DEDUCTION_GUIDES */
# 2075 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) _NOEXCEPT // Strengthened
	{	// swap _Left and _Right vectors
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc>
	_NODISCARD inline bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test for vector equality
	return (_Left.size() == _Right.size()
		&& _STD equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc>
	_NODISCARD inline bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test for vector inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc>
	_NODISCARD inline bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left < _Right for vectors
	return (_STD lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc>
	_NODISCARD inline bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left > _Right for vectors
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc>
	_NODISCARD inline bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left <= _Right for vectors
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc>
	_NODISCARD inline bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left >= _Right for vectors
	return (!(_Left < _Right));
	}

		// CLASS TEMPLATE vector<bool, Alloc> AND FRIENDS
using _Vbase = unsigned int;	// word type for vector<bool> representation
constexpr int _VBITS = 8 * sizeof (_Vbase);	// at least CHAR_BITS bits per word

template<class _Alloc0>
	struct _Wrap_alloc
	{	// TRANSITION, ABI compat, preserves symbol names of vector<bool>::iterator
	using _Alloc = _Alloc0;
	};

		// CLASS _Vb_iter_base
template<class _Alvbase_wrapped>
	class _Vb_iter_base
		: public _Iterator_base
	{	// store information common to reference and iterators
public:
	using _Alvbase = typename _Alvbase_wrapped::_Alloc;
	using _Sizet = typename allocator_traits<_Alvbase>::size_type;
	using _Difft = typename allocator_traits<_Alvbase>::difference_type;
	using _Mycont = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	// construct with null pointer
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	// construct with offset and pointer
		this->_Adopt(_Mypvbool);
		}

	void _Advance(_Sizet _Off)
		{	// advance iterator by _Off
		_Myoff += _Off;
		_Myptr += _Myoff / _VBITS;
		_Myoff %= _VBITS;
		}

	int _Valid(_Sizet _Inc) const
		{	// test for valid incremented offset
 #if _ITERATOR_DEBUG_LEVEL == 2
		const auto _Cont = static_cast<const _Mycont *>(this->_Getcont());
		_Sizet _Mysize = _Cont->_Mysize;

		_Inc += _Myoff;
		_Inc += static_cast<_Sizet>(_VBITS * (_Myptr - _Cont->_Myvec.data()));
		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 2184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		(void)_Inc;
		return (-1);
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 2187 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		// CLASS _Vb_reference
template<class _Alvbase_wrapped>
	class _Vb_reference
		: public _Vb_iter_base<_Alvbase_wrapped>
	{	// reference to a bit within a base word
	using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

	_Vb_reference() _NOEXCEPT
		{	// construct with null pointer (private)
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	// construct with base
		}

	_Vb_reference& operator=(const _Vb_reference& _Right) _NOEXCEPT
		{	// assign _Vb_reference _Right to bit
		return (*this = bool(_Right));
		}

	_Vb_reference& operator=(bool _Val) _NOEXCEPT
		{	// assign _Val to bit
		if (_Val)
			*const_cast<_Vbase *>(_Getptr()) |= _Mask();
		else
			*const_cast<_Vbase *>(_Getptr()) &= ~_Mask();
		return (*this);
		}

	void flip() _NOEXCEPT
		{	// toggle the bit
		*const_cast<_Vbase *>(_Getptr()) ^= _Mask();
		}

	operator bool() const _NOEXCEPT
		{	// test if bit is set
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	// get pointer to base word
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (this->_Getcont() == 0
			|| this->_Myptr == 0
			|| 0 <= this->_Valid(0))
			{	// report error
			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 2245 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Myptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(this->_Valid(0) < 0);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 2248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	// convert offset to mask
		return (static_cast<_Vbase>(1) << this->_Myoff);
		}
	};

template<class _Alvbase_wrapped> inline
	void swap(_Vb_reference<_Alvbase_wrapped> _Left, _Vb_reference<_Alvbase_wrapped> _Right) _NOEXCEPT
	{	// swap _Left and _Right vector<bool> elements
	bool _Val = _Left;	// NOT _STD swap
	_Left = _Right;
	_Right = _Val;
	}

		// CLASS _Vb_const_iterator
template<class _Alvbase_wrapped>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alvbase_wrapped>
	{	// iterator for nonmutable vector<bool>
private:
	using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
	using _Size_type = typename _Mybase::_Sizet;

public:
	using _Reft = _Vb_reference<_Alvbase_wrapped>;
	using const_reference = bool;

	using iterator_category = random_access_iterator_tag;
	using value_type = bool;
	using difference_type = typename _Mybase::_Difft;
	using pointer = const_reference *;
	using reference = const_reference;

	_Vb_const_iterator()
		{	// construct with null reference
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	// construct with offset and pointer
		}

	_NODISCARD const_reference operator*() const
		{	// return (reference to) designated object
		return (_Reft(*this));
		}

	_Vb_const_iterator& operator++()
		{	// preincrement
		_Inc();
		return (*this);
		}

	_Vb_const_iterator operator++(int)
		{	// postincrement
		_Vb_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vb_const_iterator& operator--()
		{	// predecrement
		_Dec();
		return (*this);
		}

	_Vb_const_iterator operator--(int)
		{	// postdecrement
		_Vb_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vb_const_iterator& operator+=(difference_type _Off)
		{	// increment by integer
		if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off))
			{	/* add negative increment */
			this->_Myoff += _Off;
			this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	/* add non-negative increment */
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_NODISCARD _Vb_const_iterator operator+(difference_type _Off) const
		{	// return this + integer
		_Vb_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vb_const_iterator& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _Vb_const_iterator operator-(difference_type _Off) const
		{	// return this - integer
		_Vb_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const _Vb_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
			+ static_cast<difference_type>(this->_Myoff)
			- static_cast<difference_type>(_Right._Myoff));
		}

	_NODISCARD const_reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	_NODISCARD bool operator==(const _Vb_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	_NODISCARD bool operator!=(const _Vb_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_NODISCARD bool operator<(const _Vb_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| (this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff));
		}

	_NODISCARD bool operator>(const _Vb_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	_NODISCARD bool operator<=(const _Vb_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	_NODISCARD bool operator>=(const _Vb_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

 #if _ITERATOR_DEBUG_LEVEL == 2
	void _Compat(const _Vb_const_iterator& _Right) const
		{	// test for compatible iterator pair
		if (this->_Getcont() != _Right._Getcont())
			{
			_DEBUG_ERROR("vector<bool> iterators incompatible");
			}
		}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 2418 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Compat(const _Vb_const_iterator& _Right) const
		{	// test for compatible iterator pair
		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
		}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Compat(const _Vb_const_iterator&) const
		{	// test for compatible iterator pair
		}
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 2428 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

	void _Dec()
		{	// decrement bit position
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	// move to previous word
 #if _ITERATOR_DEBUG_LEVEL == 2
			if (this->_Getcont() == 0 || 0 < this->_Valid(static_cast<_Size_type>(-1)))
				{	// report error
				_DEBUG_ERROR("vector<bool> iterator not decrementable");
				}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 2442 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
			_SCL_SECURE_VALIDATE_RANGE(this->_Valid(static_cast<_Size_type>(-1)) <= 0);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 2445 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	// increment bit position
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	// move to next word
 #if _ITERATOR_DEBUG_LEVEL == 2
			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
				{	// report error
				_DEBUG_ERROR("vector<bool> iterator not incrementable");
				}

 #elif _ITERATOR_DEBUG_LEVEL == 1
# 2464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
			_SCL_SECURE_VALIDATE_RANGE(this->_Valid(1) <= 0);
 #endif /* _ITERATOR_DEBUG_LEVEL */
# 2467 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alvbase_wrapped>
	_NODISCARD _Vb_const_iterator<_Alvbase_wrapped> operator+(
		typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off,
		_Vb_const_iterator<_Alvbase_wrapped> _Right)
		{	// return _Right + integer
		return (_Right += _Off);
		}

template<class _Alvbase_wrapped>
	struct _Is_checked_helper<_Vb_const_iterator<_Alvbase_wrapped>>
		: public true_type
	{	// mark _Vb_const_iterator as checked
	};

	// CLASS _Vb_iterator
template<class _Alvbase_wrapped>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alvbase_wrapped>
	{	// iterator for mutable vector<bool>
public:
	using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;

	using _Reft = _Vb_reference<_Alvbase_wrapped>;
	using const_reference = bool;

	using iterator_category = random_access_iterator_tag;
	using value_type = bool;
	using difference_type = typename _Mybase::difference_type;
	using pointer = _Reft *;
	using reference = _Reft;

	_Vb_iterator()
		{	// construct with null reference
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	// construct with offset and pointer
		}

	_NODISCARD reference operator*() const
		{	// return (reference to) designated object
		return (_Reft(*this));
		}

	_Vb_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Vb_iterator operator++(int)
		{	// postincrement
		_Vb_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vb_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Vb_iterator operator--(int)
		{	// postdecrement
		_Vb_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vb_iterator& operator+=(difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_NODISCARD _Vb_iterator operator+(difference_type _Off) const
		{	// return this + integer
		_Vb_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vb_iterator& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_NODISCARD _Vb_iterator operator-(difference_type _Off) const
		{	// return this - integer
		_Vb_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	_NODISCARD difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	_NODISCARD reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Alvbase_wrapped>
	_NODISCARD inline _Vb_iterator<_Alvbase_wrapped> operator+(
		typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off,
		_Vb_iterator<_Alvbase_wrapped> _Right)
		{	// return _Right + integer
		return (_Right += _Off);
		}

template<class _Alvbase_wrapped>
	struct _Is_checked_helper<_Vb_iterator<_Alvbase_wrapped>>
		: public true_type
	{	// mark _Vb_iterator as checked
	};

		// CLASS TEMPLATE _Vb_val
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	// base class for vector<bool> to hold data
public:
	using _Alproxy = _Rebind_alloc_t<_Alloc, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Alvbase = _Rebind_alloc_t<_Alloc, _Vbase>;
	using _Alvbase_traits = allocator_traits<_Alvbase>;
	using _Vectype = vector<_Vbase, _Alvbase>;
	using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
	using size_type = typename _Alvbase_traits::size_type;

	_Vb_val() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Vectype>)
		: _Myvec()
		{	// construct empty vector
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Alloc& _Al) _NOEXCEPT_COND(is_nothrow_constructible_v<_Vectype, _Alvbase>)
		: _Myvec(static_cast<_Alvbase>(_Al))
		{	// construct empty vector, allocator
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(size_type _Count, const bool& _Val)
		: _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0))
		{	// construct _Count * _Val elements
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
		: _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al))
		{	// construct _Count * _Val elements with allocator _Al
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	// copy construct
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)),
			_Mysize(_Right._Mysize)
		{	// copy construct, allocator
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right) _NOEXCEPT_COND(is_nothrow_move_constructible_v<_Vectype>)
		: _Myvec(_STD move(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	// move construct
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		_NOEXCEPT_COND(is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
		: _Myvec(_STD move(_Right._Myvec), static_cast<_Alvbase>(_Al)),
			_Mysize(_Right._Mysize)
		{	// move construct, allocator
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() _NOEXCEPT
		{	// destroy proxy
		_Free_proxy();
		}

 #if _ITERATOR_DEBUG_LEVEL == 0
	void _Alloc_proxy()
		{	// do nothing
		}

	void _Free_proxy()
		{	// do nothing
		}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2681 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Alloc_proxy()
		{	// allocate a proxy
		_Alproxy _Proxy_allocator(_Myvec._Getal());
		this->_Myproxy = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Myvec._Getal());
		this->_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, this->_Myproxy);
		_Deallocate_plain(_Proxy_allocator, this->_Myproxy);
		this->_Myproxy = 0;
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
# 2698 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

	static size_type _Nw(size_type _Count)
		{	// return number of base words from number of bits
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	// base vector of words
	size_type _Mysize;	// current length of sequence
	};

		// CLASS vector<bool>
template<class _Alloc>
	class vector<bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	// varying size array of bits
public:
	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<bool, typename _Alloc::value_type>,
		_MISMATCHED_ALLOCATOR_MESSAGE("vector<bool, Allocator>", "bool"));

	using _Mybase = _Vb_val<_Alloc>;
	using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
	using _Alvbase = typename _Mybase::_Alvbase;
	using _Alvbase_traits = typename _Mybase::_Alvbase_traits;

	using size_type = typename _Alvbase_traits::size_type;
	using difference_type = typename _Alvbase_traits::difference_type;
	using allocator_type = _Alloc;

	using reference = _Vb_reference<_Alvbase_wrapped>;
	using const_reference = bool;
	using value_type = bool;

	using _Reft = reference;
	using iterator = _Vb_iterator<_Alvbase_wrapped>;
	using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

	using pointer = iterator;
	using const_pointer = const_iterator;
	using reverse_iterator = _STD reverse_iterator<iterator>;
	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

	static const int _VBITS = _STD _VBITS;
	enum {_EEN_VBITS = _VBITS};	// helper for expression evaluator

	vector() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Mybase>) // strengthened
		: _Mybase()
		{	// construct empty vector
		}

	explicit vector(const _Alloc& _Al)
		_NOEXCEPT_COND(is_nothrow_constructible_v<_Mybase, const _Alloc&>) // strengthened
		: _Mybase(_Al)
		{	// construct empty vector, allocator
		}

	explicit vector(_CRT_GUARDOVERFLOW size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, false, _Al)
		{	// construct from _Count * false, optional allocator
		_Trim(_Count);
		}

	vector(_CRT_GUARDOVERFLOW size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, _Val, _Al)
		{	// construct from _Count * _Val, optional allocator
		_Trim(_Count);
		}

	vector(const vector& _Right)
		: _Mybase(_Right)
		{	// construct by copying _Right
		}

	vector(const vector& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	// construct by copying _Right, allocator
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from [_First, _Last), optional allocator
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	// initialize from [_First, _Last), input iterators
		insert(begin(), _First, _Last);
		}

	vector(vector&& _Right)
		_NOEXCEPT_COND(is_nothrow_move_constructible_v<_Mybase>) // strengthened
		: _Mybase(_STD move(_Right))
		{	// move construct by moving _Right
		this->_Swap_all(_Right);
		}

	vector(vector&& _Right, const _Alloc& _Al)
		_NOEXCEPT_COND(is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
		: _Mybase(_STD move(_Right), _Al)
		{	// move construct by moving _Right, allocator
		const bool _Swap_iterators = _Alvbase_traits::is_always_equal::value
			|| this->_Myvec._Getal() == _Right._Myvec._Getal();
		if (_Swap_iterators)
			{
			this->_Swap_all(_Right);
			}
		}

	vector& operator=(vector&& _Right)
		_NOEXCEPT_COND(is_nothrow_move_assignable_v<_Mybase>) // strengthened
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, assign it
			clear();

			const bool _Reload = _Alvbase_traits::propagate_on_container_move_assignment::value
				&& !_Alvbase_traits::is_always_equal::value
				&& this->_Myvec._Getal() != _Right._Myvec._Getal();

			if (_Reload)
				{
				this->_Free_proxy();
				}

			this->_Myvec = _STD move(_Right._Myvec);

			if (_Reload)
				{
				this->_Alloc_proxy();
				}

			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;

			const bool _Swap_iterators = _Alvbase_traits::is_always_equal::value
				|| this->_Myvec._Getal() == _Right._Myvec._Getal();
			if (_Swap_iterators)
				{
				this->_Swap_all(_Right);
				}
			}
		return (*this);
		}

	template<class... _Valty>
		decltype(auto) emplace_back(_Valty&&... _Val)
		{	// insert bool at end
		bool _Tmp(_STD forward<_Valty>(_Val)...);
		push_back(_Tmp);

#if _HAS_CXX17
		return (back());
#endif /* _HAS_CXX17 */
# 2853 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	// insert bool at _Where
		bool _Tmp(_STD forward<_Valty>(_Val)...);
		return (insert(_Where, _Tmp));
		}

	vector(initializer_list<bool> _Ilist,
			const _Alloc& _Al = allocator_type())
		: _Mybase(0, false, _Al)
		{	// construct from initializer_list
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	vector& operator=(initializer_list<bool> _Ilist)
		{	// assign initializer_list
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(initializer_list<bool> _Ilist)
		{	// assign initializer_list
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
			initializer_list<bool> _Ilist)
		{	// insert initializer_list
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() _NOEXCEPT
		{	// destroy the object
		}

	vector& operator=(const vector& _Right)
		{	// assign from _Right
		if (this != _STD addressof(_Right))
			{	// different, assign it
			this->_Orphan_all();

			const bool _Reload = _Alvbase_traits::propagate_on_container_copy_assignment::value
				&& this->_Myvec._Getal() != _Right._Myvec._Getal();

			if (_Reload)
				{
				this->_Free_proxy();
				}

			this->_Myvec = _Right._Myvec;

			if (_Reload)
				{
				this->_Alloc_proxy();
				}

			this->_Mysize = _Right._Mysize;
			}

		return (*this);
		}

	void reserve(_CRT_GUARDOVERFLOW size_type _Count)
		{	// determine new minimum length of allocated storage
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	_NODISCARD size_type capacity() const _NOEXCEPT
		{	// return current length of allocated storage
		return (this->_Myvec.capacity() * _VBITS);
		}

	_NODISCARD iterator begin() _NOEXCEPT
		{	// return iterator for beginning of mutable sequence
		return (iterator(this->_Myvec.data(), this));
		}

	_NODISCARD const_iterator begin() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(this->_Myvec.data(), this));
		}

	_NODISCARD iterator end() _NOEXCEPT
		{	// return iterator for end of mutable sequence
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	_NODISCARD const_iterator end() const _NOEXCEPT
		{	// return iterator for end of nonmutable sequence
		const_iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	_NODISCARD const_iterator cbegin() const _NOEXCEPT
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	_NODISCARD const_iterator cend() const _NOEXCEPT
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	_NODISCARD const_reverse_iterator crbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	_NODISCARD const_reverse_iterator crend() const _NOEXCEPT
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	void shrink_to_fit()
		{	// reduce capacity
		if (this->_Myvec.capacity() != this->_Myvec.size())
			{	// worth shrinking, do it
			this->_Orphan_all();
			this->_Myvec.shrink_to_fit();
			}
		}

	iterator _Make_iter(const_iterator _Where)
		{	// make iterator from const_iterator
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	_NODISCARD reverse_iterator rbegin() _NOEXCEPT
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	_NODISCARD const_reverse_iterator rbegin() const _NOEXCEPT
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	_NODISCARD reverse_iterator rend() _NOEXCEPT
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	_NODISCARD const_reverse_iterator rend() const _NOEXCEPT
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	void resize(_CRT_GUARDOVERFLOW size_type _Newsize, bool _Val = false)
		{	// determine new length, padding with _Val elements as needed
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	_NODISCARD size_type size() const _NOEXCEPT
		{	// return length of sequence
		return (this->_Mysize);
		}

	_NODISCARD size_type max_size() const _NOEXCEPT
		{	// return maximum possible length of sequence
		const size_type _Diff_max = static_cast<size_type>((numeric_limits<difference_type>::max)());
		const size_type _Ints_max = this->_Myvec.max_size();
		if (_Ints_max > _Diff_max / _VBITS)
			{	// max_size bound by difference_type limits
			return (_Diff_max);
			}

		// max_size bound by underlying storage limits
		return (_Ints_max * _VBITS);
		}

	_NODISCARD bool empty() const _NOEXCEPT
		{	// test if sequence is empty
		return (size() == 0);
		}

	_NODISCARD allocator_type get_allocator() const _NOEXCEPT
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Myvec.get_allocator()));
		}

	_NODISCARD const_reference at(size_type _Off) const
		{	// subscript nonmutable sequence with checking
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	_NODISCARD reference at(size_type _Off)
		{	// subscript mutable sequence with checking
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	_NODISCARD const_reference operator[](size_type _Off) const
		{	// subscript nonmutable sequence
		const_iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	_NODISCARD reference operator[](size_type _Off)
		{	// subscript mutable sequence
		iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	_NODISCARD reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	_NODISCARD const_reference front() const
		{	// return first element of nonmutable sequence
		return (*begin());
		}

	_NODISCARD reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	_NODISCARD const_reference back() const
		{	// return last element of nonmutable sequence
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	// insert element at end
		insert(end(), _Val);
		}

	void pop_back()
		{	// erase element at end
		erase(end() - 1);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last), input iterators
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(_CRT_GUARDOVERFLOW size_type _Count, const bool& _Val)
		{	// assign _Count * _Val
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	// insert _Val at _Where
		return (_Insert_n(_Where, static_cast<size_type>(1), _Val));
		}

	iterator insert(const_iterator _Where, _CRT_GUARDOVERFLOW size_type _Count,
		const bool& _Val)
		{	// insert _Count * _Val at _Where
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
		size_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, (void)++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators
		_DEBUG_RANGE(_First, _Last);
		size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
		size_type _Off = _Insert_x(_Where, _Count);
		_Copy_unchecked(_Unchecked(_First), _Unchecked(_Last), begin() + _Off);
		}

	iterator erase(const_iterator _Where_arg)
		{	// erase element at _Where
		iterator _Where = _Make_iter(_Where_arg);
		size_type _Off = _Where - begin();

 #if _ITERATOR_DEBUG_LEVEL == 2
		if (end() <= _Where)
			{
			_DEBUG_ERROR("vector<bool> erase iterator outside range");
			}

		_STD copy(_Where + 1, end(), _Where);
		_Orphan_range(_Off, this->_Mysize);

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
		_STD copy(_Where + 1, end(), _Where);
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	// erase [_First, _Last)
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		size_type _Off = _First - begin();

		if (_First != _Last)
			{	// worth doing, copy down over hole
 #if _ITERATOR_DEBUG_LEVEL == 2
			if (_Last < _First || end() < _Last)
				{
				_DEBUG_ERROR("vector<bool> erase iterator outside range");
				}

			iterator _Next = _STD copy(_Last, end(), _First);
			size_type _Newsize = _Next - begin();
			_Orphan_range(_Newsize, this->_Mysize);
			_Trim(_Newsize);

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
			iterator _Next = _STD copy(_Last, end(), _First);
			_Trim(_Next - begin());
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
			}
		return (begin() + _Off);
		}

	void clear() _NOEXCEPT
		{	// erase all elements
		erase(begin(), end());
		}

	void flip() _NOEXCEPT
		{	// toggle all elements
		for (auto& _Elem : this->_Myvec)
			{
			_Elem = ~_Elem;
			}

		_Trim(this->_Mysize);
		}

	void swap(vector& _Right) _NOEXCEPT // Strengthened
		{	// exchange contents with _Right
		if (this != _STD addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			_STD swap(this->_Mysize, _Right._Mysize);
			}
		}

	static void swap(reference _Left, reference _Right) _NOEXCEPT
		{	// swap _Left and _Right vector<bool> elements
		bool _Val = _Left;	// NOT _STD swap
		_Left = _Right;
		_Right = _Val;
		}

	friend hash<vector<bool, _Alloc>>;

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	// insert _Count * _Val at _Where
		size_type _Off = _Insert_x(_Where, _Count);
		_STD fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		return (begin() + _Off);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	// make room to insert _Count elements at _Where
		size_type _Off = _Where - begin();

 #if _ITERATOR_DEBUG_LEVEL == 2
		if (end() < _Where)
			{
			_DEBUG_ERROR("vector<bool> insert iterator outside range");
			}

		bool _Realloc = capacity() - size() < _Count;
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	// result too long
		else
			{	// worth doing
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				this->_Mysize += _Count;
			else
				{	// make room and copy down suffix
				iterator _Oldend = end();
				this->_Mysize += _Count;
				_STD copy_backward(begin() + _Off, _Oldend, end());
				}

 #if _ITERATOR_DEBUG_LEVEL == 2
			_Orphan_range(_Realloc ? 0 : _Off, this->_Mysize);
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
			}
		return (_Off);
		}

 #if _ITERATOR_DEBUG_LEVEL == 2
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	// orphan iterators within specified (inclusive) range
		_Lockit _Lock(_LOCK_DEBUG);
		auto _Base = const_cast<_Vbase *>(this->_Myvec.data());

		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				{	// test offset from beginning of vector
				size_type _Off = static_cast<size_type>(_VBITS * ((*_Pnext)->_Myptr - _Base))
					+ (*_Pnext)->_Myoff;
				if (_Off < _Offlo || _Offhi < _Off)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	// orphan the iterator
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
	void _Orphan_range(size_type, size_type) const
		{	// orphan iterators within specified (inclusive) range
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
# 3315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

	void _Trim(size_type _Size)
		{	// trim base vector to exact length in bits
		if (max_size() < _Size)
			_Xlen();	// result too long
		size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + _Words,
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
		}

	[[noreturn]] void _Xlen() const
		{	// report a length_error
		_Xlength_error("vector<bool> too long");
		}

	[[noreturn]] void _Xran() const
		{	// report an out_of_range error
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc>
	_NODISCARD inline bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	// test for vector equality
	return (_Left.size() == _Right.size()
		&& _STD equal(_Left._Myvec.begin(), _Left._Myvec.end(),
			_Right._Myvec.begin()));
	}

template<class _Alloc>
	_NODISCARD inline bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	// test for vector inequality
	return (!(_Left == _Right));
	}

	// STRUCT TEMPLATE SPECIALIZATION hash
template<class _Alloc>
	struct hash<vector<bool, _Alloc>>
	{	// hash functor
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef vector<bool, _Alloc> argument_type;
	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

	_NODISCARD size_t operator()(const vector<bool, _Alloc>& _Keyval) const _NOEXCEPT
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size()));
		}
	};

#if _HAS_CXX17
namespace pmr {
template<class _Ty>
	using vector = _STD vector<_Ty, polymorphic_allocator<_Ty>>;
} // namespace pmr
#endif /* _HAS_CXX17 */
# 3377 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
_STD_END

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 3383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3
#endif /* _VECTOR_ */
# 3384 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\vector" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 10 "ice.cpp" 2

#if 0 /* expanded by -frewrite-includes */
#include <iostream>
#endif /* expanded by -frewrite-includes */
# 11 "ice.cpp"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 1 3
// iostream standard header
#if 0 /* expanded by -frewrite-includes */
#pragma once
#endif /* expanded by -frewrite-includes */
# 3 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3
#ifndef _IOSTREAM_
#define _IOSTREAM_
#ifndef RC_INVOKED
#if 0 /* expanded by -frewrite-includes */
#include <istream>
#endif /* expanded by -frewrite-includes */
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 #pragma push_macro("new")
 #undef new
_STD_BEGIN
  #ifdef _M_CEE_PURE
__PURE_APPDOMAIN_GLOBAL extern istream cin, *_Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern ostream cout, *_Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern ostream cerr, *_Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream clog, *_Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern wistream wcin, *_Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream wcout, *_Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream wcerr, *_Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream wclog, *_Ptr_wclog;

  #else /* _M_CEE_PURE */
# 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3
		// OBJECTS
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT istream cin, *_Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT ostream cout, *_Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT ostream cerr, *_Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT ostream clog, *_Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT wistream wcin, *_Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT wostream wcout, *_Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT wostream wcerr, *_Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2_IMPORT wostream wclog, *_Ptr_wclog;

		// CLASS _Winit
class _CRTIMP2_PURE_IMPORT _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() _NOEXCEPT;
private:
	__PURE_APPDOMAIN_GLOBAL static int _Init_cnt;
	};
  #endif /* _M_CEE_PURE */
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3
_STD_END
 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3
#endif /* _IOSTREAM_ */
# 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\include\\iostream" 3

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
# 12 "ice.cpp" 2

using std::begin;
using std::end;

namespace huffman {

// NOTE(nicole): these types assume an ASCII encoding

template <class Iter>
std::array<int, 128> frequency_list(Iter const first, Iter const last) {
  auto ret = std::array<int, 128>();

  /*
  for (auto it = first; it != last; ++it) {
    ret.at(*it) += 1;
  }
  */
  std::for_each(first, last,
      [&ret] (char c) { ret.at(*it) += 1; });

  return ret;
}

class codebook {
  struct node {
    int frequency;

    node(int freq): frequency(freq) {}
  };

  using node_ptr = std::unique_ptr<node const>;

  struct leaf final : node {
    char key;

    leaf(int freq, char key): node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs) :
      node(lhs->frequency + rhs->frequency),
      lhs(std::move(lhs)),
      rhs(std::move(rhs)) {}
  };

  node_ptr top_;

public:
  template <class Iter>
  codebook(Iter const first, Iter const last) {
    auto freq = frequency_list(first, last);

    auto lst = std::vector<std::unique_ptr<node const>>();

    {
      int c = 0;
      for (auto f : freq) {
        if (f > 0) {
          lst.emplace_back(new leaf(f, char(c)));
        }
        ++c;
      }
    }
  }
};

class encoded_string {
};

}

int main() {
  std::string s = "Hello, world!";
  auto book = huffman::codebook(begin(s), end(s));
}
